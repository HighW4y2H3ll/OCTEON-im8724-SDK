<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Octeon Software Development Kit: OCTEON Bootloader</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="bootloader">OCTEON Bootloader </a></h1><p>The OCTEON SDK uses version 2013.07 of the opensource U-boot bootloader.</p>
<p>The version included has been modified to support multicore OCTEON processors. The 'bootoct' command has been added, which supports the booting of an OCTEON executive application, and the 'bootoctlinux' has been added to boot a Linux kernel. More information about U-boot is available on the U-boot project page at <a href="http://www.denx.de/wiki/U-Boot">http://www.denx.de/wiki/U-Boot</a> and in the directory sdk/docs/u-boot. Also see the README file included with U-Boot as well as the documentation in the U-Boot doc directory.</p>
<ul>
<li><a class="el" href="bootloader.html#usage">Usage</a></li>
<li><a class="el" href="bootloader.html#octeon_specific">OCTEON specific added functionality</a></li>
<li><a class="el" href="bootloader.html#memory_map">Memory map and TLB usage</a></li>
<li><a class="el" href="bootloader.html#boot_process">Boot process description</a></li>
<li><a class="el" href="bootloader.html#building_u-boot">Building u-boot</a></li>
<li><a class="el" href="bootloader.html#updating_u-boot">Updating u-boot on an evaluation board</a></li>
<li><a class="el" href="bootloader.html#board_support">Supporting new boards (porting)</a></li>
<li><a class="el" href="bootloader.html#se_api">Simple Executive API</a></li>
<li><a class="el" href="bootloader.html#limitations">Limitations</a></li>
<li><a class="el" href="bootloader.html#serial_config">serial_config</a></li>
<li><a class="el" href="bootloader.html#console_config">console_config</a></li>
<li><a class="el" href="bootloader.html#u-boot_applications">u-boot_applications</a></li>
</ul>
<h2><a class="anchor" id="usage">
Usage</a></h2>
<p>The bootloader supports loading multiple application images on subsets of cores. The applications are started when the application that runs on core 0 is loaded, so this application should be loaded last.</p>
<p>On the simulator, the bootloader is automatically invoked by the 'oct-sim' script, which should be used to run the simulator. Boot commands and application arguments are passed to the bootloader through an environment file using the '-envfile' option on the oct-sim script.</p>
<p>On hardware the bootloader provides an interactive prompt for setting environment variables and issuing commands.</p>
<p>The 'bootoct' command has been added to support the multicore OCTEON executive environment. The stack and heap sizes are configurable at runtime, and are controlled by providing arguments to the bootoct command. The bootoct command usage is:</p>
<div class="fragment"><pre class="fragment">
bootoct [ elf_address [stack=stack_size] [heap=heap_size] [coremask=mask_to_run | numcores=core_cnt_to_run] [forceboot] [debug] [break] [endbootargs] [app_name] [app_args ...]
    elf-address:    address of ELF image to load. defaults to $(loadaddr). If 0, default load address used.
    stack:          size of stack in bytes.  Default is 1 megabyte
    heap:           size of heap in bytes.   Default is 3 megabytes
    coremask:       mask of cores to run on.  Anded with coremask_override
                    environment variable to ensure only working cores are used.
                    In a multi-node configuration the coremask for each
                    node should be separated by a comma.  For example, to use
                    four cores on node 0 and 8 cores on node 1 the coremask
                    value should be set to 0xf,0xff.
    numcores:       number of cores to run on.  Runs on specified number of
                    cores, taking into account the coremask_override.  On a
                    multi-node configuration, the number of cores for nodes 0
                    and 1 are separated by a comma.  For example, to use 4 cores
                    on node 0 and 8 cores on node 1 the parameter would be 4,8.
    skipcores:      only meaningful with numcores.  Skips this many cores
                    (starting from 0) when loading the numcores cores.  For
                    example, setting skipcores to 1 will skip core 0.
                    and load the application starting at the next available core.
                    On a multi-node configuration the number of cores to skip
                    for each node is separated by a comma like the numcores
                    parameter.
    debug:          if present, bootloader passes debug flag to application which will cause
                    the application to stop at a breakpoint on startup.
    break:          if present, exit program when control-c is received on the console.
    forceboot:      if set, boots application even if core 0 is not in mask
    endbootargs:    if set, bootloader does not process any further arguments and only passes
                    the arguments that follow to the application.  If not set, the application
                    gets the entire commnad line as arguments.
    app name:       U-boot has no way of knowing the name of the application so this must be the first argument.

</pre></div><p>The 'bootoctlinux' command has been added to support booting the Linux kernel. The bootoctlinux command usage is:</p>
<div class="fragment"><pre class="fragment">
bootoctlinux elf_address [coremask=mask_to_run | numcores=core_cnt_to_run] [forceboot] [skipcores=core_cnt_to_skip] [namedblock=name] [endbootargs] [...]
    elf_address:    address of ELF image to load. If 0, default load address
                    is  used.
    coremask:       mask of cores to run on.  Anded with coremask_override environment
                    variable to ensure only working cores are used.
                    On a multi-node configuration the coremask for each node
                    should be separated by a comma.  For example, to run 4 cores
                    on node 0 and 8 cores on node 1 the coremask should be set
                    to 0xf,0xff.
    numcores:       number of cores to run on.  Runs on specified number of
                    cores, taking into account the coremask_override.  On a
                    multi-node configuration the number of cores for each node
                    is separated by a comma.  For example, to run 4 cores on
                    node 0 and 8 cores on node 1 the parameter would be 4,8.
    skipcores:      only meaningful with numcores.  Skips this many cores
                    (starting from 0) when loading the numcores cores.  For
                    example, setting skipcores to 1 will skip core 0.
                    and load the application starting at the next available core.
                    On a multi-node configuration the number of cores to skip
                    for each node should be separated by a comma like the
                    numcores parameter.
    forceboot:      if set, boots application even if core 0 is not in mask
    namedblock      specifies a named block to load the kernel
    endbootargs:    if set, bootloader does not process any further arguments and only passes
                    the arguments that follow to the application.  If not set, the application
                    gets the entire commnad line as arguments.

</pre></div><p>The 'bootoctelf' command has been added to support booting the ELF images such as VxWorks images. The ELF entry point is branched to from the bootloader, so the ELF image must contain all its own startup code. This is intented for use with other operating systems. The OCTEON SDK does not produce any ELF images suitable for use with this command. The bootoct command usage is:</p>
<div class="fragment"><pre class="fragment">
bootoctelf elf_address mem_size [coremask=mask_to_run] [forceboot]
    elf_address:    address of ELF image to load. If 0, default load address is
                    used.
    mem_size:       amount of memory to reserve for ELF file.  Starts at ELF
                    entry point rounded down to 1 MByte alignment.
                    No memory allocated if not specified.  (Program will not
                    coexist with simple executive applications or Linux if memory
                    is not allocated properly.

    coremask:       mask of cores to run on.  Anded with coremask_override
                    environment variable to ensure only working cores are used.
                    Note: Most ELF files are only suitable for booting on a
                    single core.
                    On a multi-node configuration the coremask values are
                    separated by a comma for each node.  For example, on a
                    two-node 78xx system the coremask value might be
                    0xf,0xff to run 4 cores on node 0 and 8 cores on node 1.
    forceboot:      if set, boots application even if core 0 is not in mask
    numcores        number of cores to run on.  Runs on specified number of
                    cores, taking into account the coremask_override.  In
                    a multi-node setup a comma should be used to specify the
                    number of cores to use on each node.  For example, to use
                    4 cores on node 0 and 8 cores on node 1 the parameter should
                    be 4,8.
    skipcores       only meaningful with numcores.  Skips this many cores
                    (starting from 0) when loading the numcores cores.
                    For example, setting skipcores to 1 will skip core 0
                    and load the application starting at the next available core.
                    On a dual-node configuration the number of cores to skip
                    for each node should be separated by a comma.

</pre></div><p>Starting in 2.1, the 'octreginfo' command has been added to print out all of the CP0 registers as well as any TLB entries in use. It is a subset of the oct-remote-core utility. It currently takes no parameters.</p>
<p>The tlv_eeprom command allows you to read and optionally set various parameters stored in the board serial EEPROM.</p>
<div class="fragment"><pre class="fragment">
tlv_eeprom [display|set|delete|help]
tlv_eeprom display
       - display contents of eeprom data structures
tlv_eeprom set
       - set contents of eeprom data structures, values in hex or decimal
       set clock &lt;ddr_clock in Mhz&gt; &lt;cpu_ref_clock in Mhz * 8&gt; &lt;dfa_ref_cloc
k in Mhz * 8&gt; &lt;spi_clock in Mhz&gt; (CN3XXX/CN5XXX)
       set board &lt;board type&gt; &lt;major rev&gt; &lt;minor rev&gt;  &lt;serial string&gt;
       set mac    &lt;mac base x:x:x:x:x:x&gt; &lt;mac addr count&gt;
       set voltmult &lt;voltage in millivolts&gt; &lt;cpu multiplier&gt; (CN3XXX/CN5XXX)
       set volt &lt;core voltage in millivolts&gt; (CN6XXX/CNF7XXX/CN7XXX)
       set mult &lt;cpu multiplier&gt; &lt;IO multiplier&gt; (CN6XXX/CNF7XXX/CN7XXX)
       set ddrclock &lt;ddr clock Hz&gt; (CN6XXX/CNF7XXX/CN7XXX)
       set ddrverbose &lt;verbosity&gt; Sets the DDR verbosity during DDR 
           initialization, 0 for none.
             bit 0: DDR verbose output
             bit 1: DDR trace output
             bit 2: DDR debug output
       set capability [coremask_override]
tlv_eeprom delete &lt;tuple addr&gt;
       - deletes tuple at address and compacts any following tuples.

Chip types have been deprecated, and can no longer be set.

(use tlv_eeprom help for list of board types)

</pre></div><p>The namedalloc command allocates a named block of memory. It also sets the environment variables named_block_addr and named_block_size to the address and size of the last allocated block. The namedfree command is used to free blocks allocated with namedalloc and namedprint will print all named blocks.</p>
<div class="fragment"><pre class="fragment">
namedalloc name size [address]
    - Allocate a named bootmem block with a given name and size at an
      optional fixed address.  Sets environment variables named_block_addr,
      named_block_size to address and size of block allocated.

namedfree name
    - Free a named bootmem block_address

namedprint
    - Print list of named bootmem blocks
</pre></div><p>Starting in 2.1, the 'flush_l2c', 'flush_dcache' and 'inv_icache' commands have been added. These flush the L2 cache, data cache and invalidate the instruction cache respectively. None of these commands take any parameters.</p>
<p>Starting in 2.1, the octwd command can start and stop watchdog timer support within U-Boot. By default the watchdog is disabled unless the enable_watchdog environment variable is set.</p>
<div class="fragment"><pre class="fragment">
octwd - Starts the OCTEON watchdog

Usage:
octwd Usage:
octwd start [timeout in ms] - initializes and starts the watchdog
octwd stop                  - disables the watchdog timer
</pre></div><p>Starting in 2.1, the 'sata' command has been added with initial support for Silicon Image PCIe SATA controllers. Sata can now be used in commands like fatls and ext2load just like ide and usb can be used. NOTE: This command requires that SATA support is enabled and compiled for a particular board. It may not be available on all boards.</p>
<div class="fragment"><pre class="fragment">
sata - SATA sub system

Usage:
sata init - init SATA sub system
sata info - show available SATA devices
sata device [dev] - show or set current device
sata part [dev] - print partition table
sata read addr blk# cnt
sata write addr blk# cnt
</pre></div><h3>Simulator specific usage</h3>
<p>To change the arguments provided to the bootoct command during simulator, an alternate u-boot environment file that specifies an alternate default boot command needs to be created. Multiple commands can be specified, with a semicolon (;) used as a separator. To change the stack and heap sizes, an environment file with the following content should be created:</p>
<div class="fragment"><pre class="fragment">
bootcmd=bootoct 0x10000000 stack=0x34500 heap=0x567800
</pre></div><p>This file is then passed to the bootloader by passing the filename with the oct-sim option '-envfile=env_file_name. Please refer to the simulator documentation for more information on oct-sim and simulator options. The 'application-args' example shows how to pass arguments to applications as well as how to specify different stack and heap sizes. The oct-sim script accepts arguments for stack/heap sizes as well as application arguments, and creates the environment file on the fly. Please see the simulator documentation and the 'application-args' example for more information.</p>
<p>To run multiple applications the other application ELF files must be loaded into the boot bus (0x10000000 - 0x1fffffff) with the -ld option, and the corresponding bootoct command must be added to the environment file. For example, the following command and environment file will load app1 on cores 0-3, and app2 on cores 4-7:</p>
<div class="fragment"><pre class="fragment">
oct-sim app1 -ld0x11000000:app2 -quiet -noperf -numcores=8 -envfile=myenv
</pre></div><p>The 'myenv' file should contain: </p>
<div class="fragment"><pre class="fragment">
bootcmd=bootoct 0x11000000 coremask=0xf0;bootoct 0x10000000 coremask=0xf
</pre></div><p>The bootloader boots the loaded application(s) when core 0 is in the coremask of loaded application. This means that when loading multiple application images the image running on core 0 must be loaded last.</p>
<h3>Remote boot mode </h3>
<p>OCTEON supports booting over PCI with the help of a PCI host or over EJTAG. The board must be configured to be a PCI target and to be in PCI boot mode for PCI boot. For EJTAG remote boot, the OCTEON must _not_ be in PCI boot mode. In PCI boot mode no cores come out of reset when the chip is reset. The procedure is as follows:</p>
<ul>
<li>Host program configures DRAM controller on OCTEON</li>
<li>Host program copies bootloader to DRAM</li>
<li>Host program configures MIO local memory block to be at reset vector, and copies instructions to branch to the bootloader image in DRAM to the local memory.</li>
<li>Host program takes core 0 out of reset. Core 0 fetches instructions from the reset vector - these are supplied from the MIO local memory block, no memory is required on the boot bus.</li>
<li>The instructions in this local memory jump to the bootloader image already present in OCTEON DRAM, and the bootloader boots from that location.</li>
</ul>
<p>The 'oct-remote-boot' program in the host/remote-utils directory implements the host portion of the PCI boot process. The u-boot image determines that it is booting from RAM, and changes its behavior as follows:</p>
<ul>
<li>the bootloader skips DRAM controller setup.</li>
</ul>
<h3>Networking support (DHCP, TFTP) </h3>
<p>U-boot supports DHCP and TFTP using OCTEON's GMX, MIX, BGX interfaces. These features require properly configured TFTP and DHCP servers to be available. The network interface to use for networking is selected by the ethact environment variable. The ethact environment variable is initialized to the value of the ethprime environment variable first. The ethact environment variable is not persistent whereas the ethprime environment variable is.</p>
<p>If the environment variable "netsingle" is set then DHCP will not attempt to go to the next interface if the first interface fails.</p>
<p>Relevant commands:</p>
<ul>
<li>dhcp: Use this command to get an IP address, netmask, server address, boot file, and boot command. The boot file is automatically loaded via tftp unless the 'autoload' environment variable is set to 'n'. The boot command is put into the 'NetOurBootCommand' environment variable. Note that the boot command is not a standard DHCP field, see below for details.</li>
</ul>
<p>The NetOurBootCommand feature is not enabled by default. In order to enable it, a board configuration file must define the following three options:</p>
<p>CONFIG_BOOTP_VENDOREX - enable vendor specific extensions CONFIG_BOOTP_VENDOREX_OPTIONS - enable vendor specific options CONFIG_OCTEON_NET_OUR_BOOT_COMMAND - enables option 224</p>
<ul>
<li>cdp: Use this command to get an IP address and netmask vis Cisco Discover Protocol.</li>
<li>tftpboot: This command loads the requested file via the tftp protocol. This command will use the default load address (loadaddr) and the filename in the bootfile environment variable if not arguments are specified. This command expects the ipaddr, netmask, and serverip environment variables to be set.</li>
<li>ping: Transmits an ICMP echo request. Note that u-boot only listens for networking traffic when it is expecting some, so u-boot will not respond to pings.</li>
<li>nfs: This command loads the specified file via the NFS protocol.</li>
</ul>
<h4>MDIO Support </h4>
<p>It is possible to access PHY registers for reading and writing inside U-Boot. The mdio command supports both clause 22 and clause 45.</p>
<p>For example, to read clause 45 register 0x1e.0xe000 on the phy connected to octeth0 the following command will work: </p>
<div class="fragment"><pre class="fragment">
mdio read octeth0 0x1e.0xe000
</pre></div><p> For a clause 22 register the command would be something like: </p>
<div class="fragment"><pre class="fragment">
mdio read octeth0 0x1e
</pre></div><p> The mdio command also supports ranges. For example, to read 16 registers the following command will work: </p>
<div class="fragment"><pre class="fragment">
mdio read octeth0 1.0x0-0x10
</pre></div><h4>Autobooting a TFTP loaded image </h4>
<p>Set the 'bootcmd' environment variable to the boot command that should be run. The following code will set the boot command to boot the loaded simple executive program on 4 cores. </p>
<div class="fragment"><pre class="fragment">
 setenv bootcmd 'dhcp;bootoct $(loadaddr) numcores=4'
 saveenv
</pre></div><p> The following code will use the boot command provided by DHCP to boot the image. </p>
<div class="fragment"><pre class="fragment">
 setenv bootcmd 'dhcp;run $(NetOurBootCommand)'
 saveenv
</pre></div><h4>Boot command via DHCP </h4>
<p>DHCP does not have a standard option field for returning a boot command. We use option number 224 to return the boot command to u-boot. The following configuration file snippet configures the ISC dhcp server to return the boot command. Change the IP addresses and netmasks as appropriate for your network. </p>
<div class="fragment"><pre class="fragment">
option octeon-boot-command code 224 = string;

subnet 192.168.2.0 netmask 255.255.255.0 {
  range 192.168.2.100 192.168.2.200;
  option octeon-boot-command "bootoct $(loadaddr) numcores=4";
  filename "octeon_boot_file";
  server-name "192.168.2.1";
  next-server 192.168.2.1;
}
</pre></div><h3>Application considerations </h3>
<p>The bootloader supports loading multiple applications on subsets of cores. This is primarily useful for running a simple executive application and Linux at the same time. It is recommended that a single simple executive image be run on all cores, and that the application handle core dependent processing if necessary. Additionally, the following should be kept in mind:</p>
<ul>
<li>global (and static) data is copied for each core, unless it is read only. If large amounts of data are compiled in to the application, make it 'const' (readonly) if possible. This allows one copy of the data to be shared by all cores.</li>
</ul>
<h2><a class="anchor" id="octeon_specific">
OCTEON specific added functionality</a></h2>
<h3>Named bootmem blocks </h3>
<p>The bootloader uses the bootmem allocator to allocate physical memory for its own use, and passes the bootmem <a class="el" href="structdescriptor.html">descriptor</a> to the application so that the application can manage the memory remaining after application loading. Named bootmem blocks are memory blocks allocated with the bootmem allocator that have names associated with them in table in the bootmem <a class="el" href="structdescriptor.html">descriptor</a>. This allows the bootloader to allocate memory blocks for various purposes assign names that the application can use to reference them. For example, named bootmem blocks could be used to have the bootloader load a DFA graph from a compact flash card into a named block and then have the application load the graph from that block.</p>
<p>Three new bootloader commands have been added to support this functionality. (Executive functions have also been added - see the executive documentation for more information.)</p>
<ul>
<li>namedalloc &lt;block_name&gt; &lt;block_size&gt; [block_address]<ul>
<li>This command allocates a named block of a given name and size at an optional address. If the name or memory block is not available, this command fails. The environment variables named_block_addr and named_block_size are set when allocation is successful, and can be used other commands.</li>
</ul>
</li>
<li>namedfree &lt;block_name&gt;<ul>
<li>Frees block with supplied name name.</li>
</ul>
</li>
<li>namedprint<ul>
<li>Prints a list of current named blocks.</li>
</ul>
</li>
</ul>
<h3>Support for Gzip Compressed Images</h3>
<p>The bootloader has a command <b>unzip</b> for uncompressing Gzipped images from memory. The unzip command can read its input from fixed address. Output is written to a specific address. It is the user's responsibility to make sure the output region is large enough. The command syntax is:</p>
<div class="fragment"><pre class="fragment">
    unzip srcaddr dstaddr [dstsize]
</pre></div><h3>Environment variables</h3>
<p>A number of special environment variables have been added (or usage modified) to make u-boot more configurable. These variables are stored in the u-boot environment (typically in flash), and are updated using the setenv and savenv commands.</p>
<p><b> Special note on environment variable expansion for compound commands: </b> U-boot expands all environment variables in a command (compound or not) before any of the commands are executed. This means that a compound command like:</p>
<div class="fragment"><pre class="fragment">
dhcp;tftp 0x20000000 elf.bin;bootoct $(fileaddr)
</pre></div><p>will not work becuase the fileaddr environment variable is expanded before the tftp command runs and sets it. A command like this should be written in one of the following ways:</p>
<div class="fragment"><pre class="fragment">
dhcp;tftp 0x20000000 elf.bin;bootoct 0x20000000
dhcp;tftp;bootoct $(loadaddr)
</pre></div><p> The first example uses a fixed address for both the tftp and bootoct command. The second uses the default load address for the tftp, and then specifies the default load address to the bootoct command.</p>
<ul>
<li><b>baudrate</b> Controls the baudrate of the console uart</li>
<li><b>boardname</b> Name of the board. This is set automatically.</li>
<li><b>board_revision</b> Revision number of the board. This is required for the ebb7800, ebb7804 and the tb7600 board with pass 1.0 CN7800 or pass 1.0 CN7600 devices since otherwise there is no way to determine the board revision.</li>
<li><b>console_uart</b> Selects which uart (0 or 1) to use for the console. This is passed to simple executive applications which will use the same uart for the console. Defaults to 0. Changes to this variable take effect immediately (as of SDK 1.6.0)</li>
<li><b>coremask_override</b> This defines the working cores for the OCTEON on the board. This is primarily used for engineering samples, as production parts have this set in silicon, and this variable reflects that value.</li>
<li><b>disable_cf_dma</b> If defined (any value), DMA will not be used for the compactflash interface.</li>
<li><b>disable_dfm</b> If defined (any value) the DFM module will not be initialized. This may result in traps in Simple Executive applications.</li>
<li><b>disable_l2_index_aliasing</b> If defined (any value), L2 Cache index aliasing is disabled.</li>
<li><b>disable_mmc</b> If defined (any value) then MMC devices will not be initialized.</li>
<li><b>disable_nand</b> If defined (any value) then NAND flash will not be initialized.</li>
<li><b>disable_networking</b> If defined (any value), no OCTEON network support is enabled in the bootloader. This has no effect on applications.</li>
<li><b>disable_spi</b> If defined (any value), all SPI interfaces are ignored by the blootloader. This has no effect on applications.</li>
<li><b>disable_spi_ixf18201</b> If defined (any value), all SPI interfaces connected to a IXF18201 are disabled. This does not affect the SPI4000.</li>
<li><b>disable_usb_scan</b> Disables USB initialization and scanning during boot-up. USB can be started later via the usb command.</li>
<li><b>ddr_clock_hertz</b> Overrides the DDR clock stored in the EEPROM.</li>
<li><b>ddr_narrow</b> Force the DDR interface to be 'narrow'. Most OCTEONs support 2 DDR interface widths, and this forces the chip to use the narrower of the two.</li>
<li><b>ddr_ref_hertz</b> Overrides the DDR reference clock.</li>
<li><b>ddr_safe</b> (must be yes) If set to 'yes', then more conservative DDR2 timings are used.</li>
<li><b>disable_spi</b> Disables SPI interface initialization and support.</li>
<li><b>ddr_trace_init</b> Turns on tracing of all DDR operations during initialization.</li>
<li><b>ddr_verbose</b> If set to 'yes', then detailed DDR2 configuration information is displayed at boot. This variable _must_ be set for other ddr controller environment variables to be checked. Please refer to the dram controller initialization code for details on which parameters can be adjusted with environment variables.</li>
<li><b>dram_size_mbytes</b> Forces U-Boot to override the amount of memory detected and used.</li>
<li><b>download_baudrate</b> Controls the baudrate for downloads when using the loadb command. This allows different baudrates to be used for console and downloading.</li>
<li><b>enable_spi_ixf18201</b> - If defined (any value) then boards that support a SPI IXF18201 interface will initialize it even if disable_spi is also set. This is used for the NICPro2 board which disables this by default.</li>
<li><b>enable_spi_eeprom</b> - Enables the SPI connected EEPROM on EBB6100 evaluation boards, otherwise the SLIC interfaces are enabled.</li>
<li><b>enable_usb_ehci_clock</b> - Initializes the USB clock and runs the BIST test if disable_usb_scan is set, otherwise the USB clock and BIST test will not be run.</li>
<li><b>enable_watchdog</b> - Enables the hardware watchdog timer if set. Also see the watchdog_timeout environment variable.</li>
<li><b>ethact</b> Current active Ethernet interface. Note that this is NOT persistent, use ethprime instead to save.</li>
<li><b>ethprime</b> First Ethernet interface to use for ethact. This is persistent.</li>
<li><b>fileaddr</b> Address that a file/image was loaded at using the loadb, fatload, ext2load, or tftp commands.</li>
<li><b>icache_prefetch_disable</b> Disable instruction cache prefetching support for Linux and simple executive applications.</li>
<li><b>limit_dram_mbytes</b> Limits the DRAM size to the specified number of MBytes. This is useful for testing small memory configurations on boards that have move memory. Both the bootloader and any loaded apps are affected by this limit.</li>
<li><b>limit_l2_ways</b> Limits the L2 to the specified number of ways (associations) when defined. Valid values are between 1 and (num_ways - 1).</li>
<li><b>loadaddr</b> Indicates the current default load address for load commands. This is set at boot time based on the memory allocated by the octeon_reserved_mem_load* variables. If the reserved memory for loading is disabled, then this variable will keep its value across boots. (New in SDK 1.6.0) NOTE: If memory is reserved for loading, this variable should not be changed directly - the reserved memory for loading should be adjusted instead. If no memory is reserved for loading, then and only then should this variable be directly changed.</li>
<li><b>mmc_max_freq</b> This will override the maximum frequency supported by the MMC device in Hz.</li>
<li><b>mmc_voltages</b> This is used to override the supported voltages reported to the MMC card. Do not set this.</li>
<li><b>mtdids</b> This environment variable defines the mapping from u-boot device names to linux kernel device names. This allows the same 'mtdparts' definition to be shared between Linux and u-boot even if different device names are used. This environment variable must be of the form "&lt;u-boot_name&gt;=&lt;linux_name&gt;,&lt;u-boot_name&gt;=&lt;linux_name&gt;,...". The Linux names are used in the mtdparts environment variable, allowing this environment variable to be passed directly to Linux. For OCTEON boards, nand devices are named "nandX", where X is a digit. (The first NAND device is nand0.) <div class="fragment"><pre class="fragment">
mtdids=&lt;idmap&gt;[,&lt;idmap&gt;,...]

&lt;idmap&gt;    := &lt;dev-id&gt;=&lt;mtd-id&gt;
&lt;dev-id&gt;   := 'octeon_nand'&lt;dev-num&gt;|'nor'&lt;dev-num&gt;
&lt;dev-num&gt;  := mtd device number, 0...
&lt;mtd-id&gt;   := unique device tag used by linux kernel to find mtd device (mtd-&gt;name)
</pre></div></li>
<li><b>mtdparts</b> This environment defines the MTD partitioning of flash devices, and is meant to be shared with the Linux kernel. As such, it has "mtdparts=" as the beginning of the expected value of the variable, so that  can be passed on the Linux command line and have the expected form. This environment uses the Linux device names defined in the mtdids variable. <div class="fragment"><pre class="fragment">
mtdparts=mtdparts=&lt;mtd-def&gt;[;&lt;mtd-def&gt;...]

&lt;mtd-def&gt;  := &lt;mtd-id&gt;:&lt;part-def&gt;[,&lt;part-def&gt;...]
&lt;mtd-id&gt;   := unique device tag used by linux kernel to find mtd device (mtd-&gt;name)
&lt;part-def&gt; := &lt;size&gt;[@&lt;offset&gt;][&lt;name&gt;][&lt;ro-flag&gt;]
&lt;size&gt;     := standard linux memsize OR '-' to denote all remaining space
&lt;offset&gt;   := partition start offset within the device
&lt;name&gt;     := '(' NAME ')'
&lt;ro-flag&gt;  := when set to 'ro' makes partition read-only (not used, passed to kernel)
</pre></div></li>
<li><b>named_block_addr</b> Set to the address of the last named block allocated with the namedalloc command.</li>
<li><b>named_block_size</b> Set to the size of the last named block allocated with the namedalloc command.</li>
<li><b>nand_ecc_mode</b> Overrides the ECC mode for NAND flash. Currently soft_bch, soft and none are supported.</li>
<li><b>nand_ecc_size</b> specifies how many bytes per block of ECC to provide if nand_ecc_mode is soft_bch.</li>
<li><b>no_mark_private_data</b> If defined (any value), the bootloader will not mark the private data for simple executive applications as special for use with the syncws instruction.</li>
<li><b>octeon_debug_nand</b> Set to display a lot of debugging information when performing NAND flash operations.</li>
<li><b>octeon_failsafe_mode</b> Set to 1 if running in failsafe mode, otherwise set to 0.</li>
<li><b>octeon_load_app_hi</b> If defined (any value), the bootloader will preferentially allocate memory from the DDR1 ranged (0x410000000 - 0x420000000) when loading simple executive applications.</li>
<li><b>octeon_mmc_ddr</b> Set to 1 to enable double data rate or 0 to disable. Enabled if not set.</li>
<li><b>octeon_ram_mode</b> Set to 1 if U-Boot was booted out of RAM, otherwise set to 0.</li>
<li><b>octeon_reserved_mem_linux_base</b> Base address for linux reserved memory. The octeon_reserved_mem_linux_size variable must be set for this to take effect.</li>
<li><b>octeon_reserved_mem_linux_size</b> Size of memory reserved for linux image in bytes. This reserved memory block ensures that no allocations conflict with the range required by Linux before the kernel is loaded. This is freed when a linux image is loaded, or when the application starts if a linux image is not loaded. If set to 0, this region is not reserved. If not set, compile time defaults are used for size and address.</li>
<li><b>octeon_reserved_mem_load_base</b> Base address of bootloader reserved memory. The octeon_reserved_mem_load_size variable must be set for this to take effect.</li>
<li><b>octeon_reserved_mem_load_size</b> Specifies the size (in bytes) of the memory reserved for the loading of applications by the bootloader. This defaults to 0x100000 - 0x1000000 (for SDK 1.6.0 and earlier) (default for SDK 1.7.0 will to auto placement based on memory size), and is used for temporary storage of the ELF files when loaded off of compact flash or tftp. This memory is freed when the application is booted. If set to 0, this region is not reserved. If not set, compile time defaults are used for size and address.</li>
<li><b>octeon_stage3_bootloader</b> Specifies the filename of the stage 3 bootloader when booting from eMMC.</li>
<li><b>octeon_stage3_devname</b> Specifies the name of the device to load the bootloader from. Typically this will be "mmc".</li>
<li><b>octeon_stage3_devno</b> Specifies the device number used for loading the stage 3 bootloader when booting from eMMC or NAND.</li>
<li><b>octeon_stage3_failsafe_bootloader</b> Specifies the filename of the stage 3 failsafe bootloader.</li>
<li><b>octeon_stage3_load_addr</b> Specifies the address where the stage 3 bootloader will be loaded in memory and executed from.</li>
<li><b>octeon_usb_tune</b> This sets a couple of tuning parameters that might help with several boards and chips if EHCI timeout errors occur.</li>
<li><b>pci_console_active</b> If defined (any value), the PCI console mode is active. (See PCI console section in PCI target documentation for more detail on PCI console.) Note that the output of U-Boot will hang after the output buffer fills if no PCI console is connected.</li>
<li><b>pci_console_count</b> Specifies the number of PCI console channels.</li>
<li><b>pci_console_size</b> Specifies PCI console buffer size in bytes.</li>
<li><b>pcieX:Y_lanes</b> Specifies the number of PCIe lanes for QLM X, node Y.</li>
<li><b>pcieX:Y_mode</b> Specifies the PCIe mode for QLM X, node Y. Value can be ep or rc.</li>
<li><b>pcieX_Y_gen</b> Specifies the PCIe generation for QLM X, node Y. Value can be 1, 2 or 3.</li>
<li><b>prompt</b> Overrides the default prompt. Note that a space is always appended.</li>
<li><b>qlmX:Y_mode</b> Specifies the mode the QLM should operate in. This is used for numerous CN78XX based boards. X specifies the QLM number and Y specifies the node number. Valid modes are: none, sgmii, xaui, dxaui, rxaui, ila, ilk, xlaui, xfi, 10G_KR, 40G_KR, pcie. Many of these can take an optional parameter specifying that there is no PHY. For example, qlm6:0_mode=xlaui,no_phy.</li>
<li><b>stderr</b> Sets the stderr destinations. Currently "serial", "pci" and "serial,pci" are supported. Note: if pci is selected then U-Boot will stop and wait for the PCI console to connect once the output buffer is full.</li>
<li><b>stdin</b> Sets the stdin sources. Currently "serial", "pci" and "bootoct" are supported. Multiple inputs can be selected, separated by a comma, for example, "serial,pci".</li>
<li><b>stdout</b> Sets the stdout destinations. Currently "serial", "pci" and "serial,pci" are supported. Note: if pci is selected then U-Boot will stop and wait for the PCI console to connect once the output buffer is full.</li>
<li><b>usb_host_port</b> Select which OCTEON USB port to use for devices with more than one USB port, such as CN68XX. Port numbering starts at 0.</li>
<li><b>vcs8488_preemph</b> Set this to the hex value to override the PHYXS_TYPE_CTRL (PHY XS XAUI TX Pre-emphasis control) register on the Vitesse VCS8488 PHY.</li>
<li><b>vcs8488_rxeq</b> Set this to the hex value to verride the PHYXS_RXEQ_CTRL (PHY XS XAUI RX Equalization Control) register on the Vitesse VCS8488 PHY.</li>
<li><b>vcs8488_txdrvctrl1</b> Set this to the hex value to override the PMA_TXOUTCTRL1 register on the Vitesse VCS8488 PHY.</li>
<li><b>vcs8488_txdrvctrl2</b> Set this to the hex value to override the PMA_TXOUTCTRL2 register on the Vitesse VCS8488 PHY.</li>
<li><b>watchdog_enable</b> Set this to enable watchdog support. By default watchdog support is disabled.</li>
<li><b>watchdog_timeout</b> Sets the watchdog timeout in ms. The maximum is 5000ms. NOTE: enable_watchdog must also be set.</li>
</ul>
<h4>Erasing the environment </h4>
<p>Sometimes it is desirable to erase the entire environment. The 'eraseenv' command has been added to facilitate this. Note that this only works when the environment is stored in NOR flash.</p>
<h4>Environment stored in eMMC or a filesystem </h4>
<p>U-Boot now supports loading the environment from eMMC or a file. When configured to do this the saveenv command will work as it did before. One difference, however, is that the environment is loaded very late in the boot process after eMMC or USB has been enabled so environment variables that affect processes early in the boot process will have no effect.</p>
<h2><a class="anchor" id="memory_map">
Memory map and TLB usage</a></h2>
<h3>Physical memory map </h3>
<p>The OCTEON physical memory addressing is as follows (Please see the hardware manual for more information.): </p>
<div class="fragment"><pre class="fragment">
DDR0: 0x0 0000 0000 to 0x0 0FFF FFFF	(low  256 Megabytes)
DDR1: 0x4 1000 0000 to 0x4 1FFF FFFF	(next 256 Megabytes)
DDR2: 0x0 2000 0000 to 0x3 FFFF FFFF	(next 15.5 Gigabytes)
</pre></div><h3>Bootloader and OCTEON executive physical memory usage </h3>
<p>The bootloader uses the address range from 0x0 to 0xFFFFF (low 1 megabyte) for boot time initialization and exception vectors, debugger stub and debugger state. The low 1 MByte remains in use after the applications are running. U-boot allocates a named bootmem block (__uboot_code_data) for its code and data. This memory may be freed by the application after the application has started. This memory is required for some operations, such as GDB over the UART, and the 'bootoct' linux command. If either of these features is used, the bootloader memory must not be freed.</p>
<p>U-boot creates a global free memory list and allocator (bootmem_alloc*) that it uses to allocate memory for applications as well as some internal uses (network packet buffers, PCI console buffers.)This memory is managed by the bootmem allocator in <a class="el" href="cvmx-bootmem_8c.html" title="Simple allocate only memory allocator.">cvmx-bootmem.c</a>. The applications and operating systems should use this allocator to allocate physical memory.</p>
<h4>Boot time reserved memory </h4>
<p>The bootloader creates two special reserved memory blocks that are used at boot time to set aside memory for loading application/OS images and the Linux kernel. When loading an application from somewhere other than the bootflash (network, compactflash, etc.) there must be room in memory for the ELF image, as well as room for the ELF data to be loaded into the memory locations that it will run from. While it is being loaded, there will be two copies of the ELF data in memory: one copy in the ELF image(file) itself, and one where the bootloader is copying it to run from. Simple executive applications use the TLB for virtual memory mappings, so they do not require a particular physical location in memory. The load reserved area must be set aside to ensure that the loading of (potentially several) applications does not interfere with the load area, and also that the loading of later applications will not overwrite a previously loaded one. Linux and other OSes are linked at a specific physical address. The Linux reserved block keeps this specific physical range available even if other allocations (for example, loading a simple executive application) is done before it. The Linux reserved block is typically only required if Linux is used along with simple executive applications.</p>
<h5>Default reserved block locations </h5>
<h6>SDK 1.6.X and earlier:</h6>
<ul>
<li>The image loading block is from address 0x100000 - 0x1000000</li>
<li>The linux reserved block is from address 0x1000000 - 0x9000000</li>
</ul>
<h6>SDK 1.7.X and SDK 1.9.X:</h6>
<ul>
<li>The image loading block is allocated at the base of the DDR2 DRAM segment if there is enough memory, or at the top available DRAM in the DDR0 segment. It is sized based on the amount of available memory.</li>
<li>The linux reserved block is allocated at 0x100000 and is sized based on the amount of available memory.</li>
</ul>
<h6>SDK 2.0.X onwards:</h6>
<ul>
<li>Bootloader reserves memory to put its code and data. This is no longer below 1MByte. It is recommended not to remove this memory, some applications might not work.</li>
<li>The image loading block is allocated at the base of the DDR2 DRAM segment if there is enough memory, or at the top available DRAM in the DDR0 segment. It is sized based on the amount of available memory.</li>
<li>The linux reserved block is allocated at 0x100000 and is sized based on the amount of available memory.</li>
</ul>
<h5>Configuring boot time reserved memory. </h5>
<p>The load reserved block base address and size is contolled by the <b>octeon_reserved_mem_load_base</b> and <b>octeon_reserved_mem_load_size</b> environment variables. If these variables are not set, the defaults listed above are used. If they are set (both must be set), then the block is allocated at the specified address and the specified size. If octeon_reserved_mem_load_size is 0, no memory will be reserved. When this block is allocated, the 'loadaddr' environment variable is set to the base address of this block for use in u-boot commands.</p>
<p>The linux reserved block base address and size is contolled by the <b>octeon_reserved_mem_linux_base</b> and <b>octeon_reserved_mem_linux_size</b> environment variables. This region is not needed if Linux is not used, and will not be reserved if octeon_reserved_mem_linux_size is 0. This reserved memory is primarily useful for systems that load simple executive and linux images at the same time on different cores.</p>
<p>The default values will work for many configurations, but some (and in particular systems with small amounts of memory) will need these values to be tailored to the specific requirements of the system being designed.</p>
<h3>Bootloader and OCTEON executive virtual memory usage </h3>
<p>Starting in SDK 2.0, U-Boot uses the TLB and runs from virtual address 0xC0000000. This allows a single u-boot binary to be used for failsafe, normal, and remote boot. This also allows a single u-boot binary to be burned at different addresses in flash.</p>
<p>Before starting a simple executive application, the bootloader sets up the TLB mappings required by the application. This includes setting up TLB mappings for code, data, stack, heap, and CVMX_SHARED variables. These mappings are set up in virtual address range 0x1000 0000 to 0x1fff ffff. This address range is used since it does not conflict with any 1-1 mappings. The executive uses 1-1 mappings (virtual and physical addresses the same) to avoid the need to use XKPHYS addressing modes, which requires setting bit 63 of the address to access a physical address. These 1-1 mappings are setup by the application.</p>
<h2><a class="anchor" id="boot_process">
Boot process description</a></h2>
<p>The bootloader has been modified to support booting and starting OCTEON executive based applications on multiple cores. This section outlines the boot process from power on to the start of the application. (Limitations of the simulation environment will be noted.)</p>
<ul>
<li>When the OCTEON is powered on, core 0 starts execution at the reset vector, 0x1fc00000. This address is on the OCTEON boot bus, and on a typical board flash storage will be present at this address. The other cores remain held in reset.</li>
<li>u-boot starts executing from flash (or the movable boot bus region in the case of remote boot.)</li>
<li>If running on OCTEON II or later and the L2 cache is large enough, the U-Boot image is copied from flash to the L2 cache to speed up execution.</li>
<li>u-boot configures a TLB entry to map its virtual address to the physical address it is running from. It adjusts the boot bus mappings to align its flash address as required for the TLB mappings (if booting from flash).</li>
<li>u-boot determines if it is booting from cache, flash or DRAM.</li>
<li>u-boot starts executing code, initializes the UART, and configures the DRAM controller to allow DRAM to be used (only in the non-remote boot case). (Note: the simulator does not simulate the DRAM controller, so this step is skipped.) In order to speed boot times, oct-sim by default disables the simulator performance modeling of the flash memory.</li>
<li>u-boot relocates itself to DRAM, and continues executing from DRAM.</li>
<li>u-boot executes the default command if present - for the simulator this is the 'bootoct' command. On hardware the bootloader displays a prompt on uart 0.</li>
</ul>
<h3>Outline of simple executive application startup: </h3>
<ul>
<li>bootoct reads an OCTEON executive application ELF file the specified address (defaults to ). The ELF file is parsed, and loaded into memory, including copying the data segments for all cores that will run this application. Memory for each core's stack and heap is also allocated.</li>
<li>bootoct also creates a table in memory with an entry for each core that describes the application specific initialization that it needs to perform. This includes the TLB mappings required, application entry point, stack address/size, heap address/size.</li>
<li>when core 0 is ready to start the other cores, it takes them out of reset, at which point they start execution from flash at the reset exception vector. Based on their non-zero core number, after performing the necessary per-core initialization, they jump to dram and process the table set up by core 0. When core 0 takes the other cores out of reset it also processes its own table entry. Core 0 also resets its cycle counter when it takes the other cores out of reset so that its cycle counter will be similar to the other cores' cycle counters.</li>
<li>when the processing of the table is complete, each core sets some register state for the application, and does an ERET (return from exception) to the application entry point. The address of the table entry for the core is included in one of the registers.</li>
<li>the stack, heap, and argc/argv are set for the application by init code called from crt0</li>
<li>if the application is linked against the libcvmx.a library, the <a class="el" href="cvmx-app-init_8c.html#ab9da50b364dc78df8130c0712bdc24d3" title="Main entry point for all simple executive based programs.">__cvmx_app_init()</a> routine is called to initialize the simple exec. All cores are synchronized at this time so they will start <a class="el" href="cvmx-app-init-linux_8c.html#ac0f2228420376f4db7e1274f2b41667c" title="Main entrypoint of the application.">main()</a> at the same time.</li>
<li>all cores enter <a class="el" href="cvmx-app-init-linux_8c.html#ac0f2228420376f4db7e1274f2b41667c" title="Main entrypoint of the application.">main()</a> at close to the same time.</li>
</ul>
<h2><a class="anchor" id="MMC_boot_process">
MMC boot process</a></h2>
<p>Booting out of MMC is either a two or three stage process depending on the size of the bootloader. In the case of the CN61XX or CN71XX this will likely be a three stage process since the L2 cache is smaller than the bootloader.</p>
<p>When the boot bus address line 8 is pulled up by a 10K resistor the OCTEON processor will begin executing on-chip ROM code. This ROM code will initialize the MMC or SD device (added in CN61XX pass 1.1) and then load the first 8K at the beginning of the device into the L2 cache at address 0x81000000 and begin executing it.</p>
<p>While previously the stage 1 bootloader only loaded the stage 2 bootloader to address 0x81004000 which required a text address of 0xc0000000, the latest version automatically detects if it is linked at 0xC0000000 or 0xC0004000. If linked at 0xC0000000 it uses a trampoline to overwrite itself with the stage 2 bootloader. This allows it to boot directly into a stage 3 bootloader on devices where the L2 cache is larger than the bootloader binary.</p>
<p>The stage 1 bootloader will re-initialize the MMC or SD device and then look for a stage 2 bootloader. It first checks for a bootable FAT16 or FAT32 partition for a file named OCTBOOT2.BIN or OCTBOOT2.BAK. If found, it loads the file into the L2 cache beginning at address 0x81000000 and branches to the beginning of the code. If it cannot find that file then it attempts to load the stage 2 bootloader starting at the 8K offset from the MMC device. If the failsafe GPIO is set then the FAT filesystem files will be skipped.</p>
<p>Since the partition table is embedded in the stage 1 bootloader it is possible to hard-code a DOS partition table entry into it by modifying start.S.</p>
<p>The FAT partition must be marked as bootable by FDISK and must have a valid logial block address. The stage 1 bootloader ignores the old cylinder, head, sector entry.</p>
<p>A tool has been created in order to update the stage 1 and stage 2 bootloaders called write_stage1 under bootloader/tools. This will overwrite the stage 1 and stage 2 bootloaders and will preserve the partition table. Before using write_stage1 run make in the bootloader/tools directory.</p>
<p>It is safe to use the Linux fdisk tool in order to partition the MMC or SD device. NOTE: make sure that none of the partitions include the first 8K or the space required for the stage 2 bootloader if that is also installed after the stage 1 bootloader. Generally this is not a problem with fdisk since the minimum starting block is typically 2048, reserving the first 1MB. If an older version of fdisk is used type the 'u' command to change the units from C/H/S to LBA sectors. Older versions of fdisk also will default to using a smaller starting sector. If this is the case, set the starting sector to 2048 for the first partition.</p>
<p>Use the 'a' command in fdisk to mark the FAT partition as bootable. NOTE: do not use a FAT12 partition. FAT12 is not supported.</p>
<p>The provided stage 2 bootloader is generic and uses the TLV information on the board to detect the board type in order to initialize the DRAM. It provides minimal functionality in order to load a stage 3 bootloader so that it can fit entirely within the L2 cache. If the stage 3 bootloader is corrupted or not present it is possible to use the loady or loadb command to load the stage 3 bootloader over the serial port. In minicom, loady is the preferred method and uses y-modem.</p>
<p>The stage 3 bootloader is typically stored on a filesystem on the MMC device. To load and execute the stage 3 bootloader the following commands should be executed:</p>
<div class="fragment"><pre class="fragment">
fatload mmc 0 0x81000000 u-boot-octeon_stage3_name.bin
go 0x81000000
</pre></div><p>Alternatively, the following command may be used:</p>
<div class="fragment"><pre class="fragment">
bootstage3
</pre></div><h2><a class="anchor" id="SPI_boot_process">
SPI boot process</a></h2>
<p>The SPI boot process consists of on-chip ROM loading the first 8K from the SPI EEPROM or flash device.</p>
<p>A three stage boot process is used, similar to how eMMC is booted.</p>
<p>The stage 1 bootloader named spi-boot.bin is written to the very beginning of the SPI NOR flash. This bootloader will scan the SPI NOR for a stage 2 bootloader and load it to address 0x81000000 using a trampoline to overwrite itself. The stage 2 bootloader should be marked as a stage 2 bootloader in the header and it should be installed on a page-sized boundary starting at offset 0x10000.</p>
<p>The stage 2 bootloader, which must be small enough to fit in L2 cache will initialize DRAM then search for and load the stage 3 bootloader to address 0x81000000 and execute it. Two copies of the stage 3 bootloader are supported and the second copy will be loaded unless the failsafe GPIO setting is set.</p>
<p>The stage 3 bootloader should be located after the stage 2 bootloader and reside on a 64K boundary.</p>
<h2><a class="anchor" id="Octeon_III_NAND_boot_process">
Octeon III NAND boot process</a></h2>
<p>The Octeon CN70XX supports NAND with a new hardware BCH engine to handle multi-bit NAND ECC. Unlike previous Octeon models, however, the boot process must start with either a SPI EEPROM or a SPI NOR. The SPI EEPROM must be a minimum of 32K with a 64K device being recommended.</p>
<p>The NAND boot process consist of several stages. Octeon will read the first 8K out of the SPI EEPROM and begin execution. Since the NAND bootloader requires more than 8K, the first stage looks for and loads the NAND stage 1.5 bootloader immediately following the SPI stage 1 bootloader.</p>
<p>The stage 1.5 bootloader begins scanning the NAND device looking for a valid bootloader starting at the beginning of the NAND device. Bad and corrupt blocks are automatically skipped and the ECC is applied to each page read. Once the stage 2 bootloader is loaded into memory a trampoline is used to begin execution at address 0x81000000 to start the stage 2 bootloader.</p>
<p>The stage 2 bootloader initializes DRAM and searches for and loads the final stage 3 bootloader into memory and transfers execution to it.</p>
<p>Unlike earlier Octeon devices, the new stage 1.5 bootloader is fully compatible with the ECC and layout used by both U-Boot and Linux.</p>
<p>The stage 1 and 1.5 bootloader code is contained under bootloader/nand2-boot. By default it is configured to execute out of a SPI EEPROM and not a SPI NOR flash since that is most likely what customers will use. If a SPI NOR device is used, for example on the SFF7000 board, then spi-config.h will need to be modified to define CONFIG_SPI_NOR and comment out the define for CONFIG_SPI_EEPROM_M95XXX.</p>
<p>Running make will build both the stage 1 and stage 1.5 bootloaders and create a file called spi-combined.bin which contains both bootloaders.</p>
<p>With a SPI EEPROM the following commands will update the stage 1 and 1.5 bootloaders:</p>
<div class="fragment"><pre class="fragment">
# tftp 0 spi-combined.bin
# spieeprom write $(fileaddr) 0 $(filesize)
</pre></div><p>If a SPI NOR flash is used then the following commands should be used:</p>
<div class="fragment"><pre class="fragment">
# tftp 0 spi-combined.bin
# sf probe
# sf update $(fileaddr) 0 $(filesize)
</pre></div><p>The stage 2 and final stage bootloaders can be written using the bootloaderupdate command as follows:</p>
<div class="fragment"><pre class="fragment">
# tftp 0 u-boot-octeon_generic_nand2_stage2.bin
# bootloaderupdate nand
# tftp 0 u-boot-octeon_board.bin
# bootloaderupdate nand
</pre></div><p>If there are any problems the nand commands can be used:</p>
<div class="fragment"><pre class="fragment">
# tftp 0 u-boot-octeon_generic_nand2_stage2.bin
# nand erase 0 $(filesize)
# nand write $(fileaddr) 0 $(filesize)
# tftp 0 u-boot-octeon_boardname.bin
# nand erase 0x100000 $(filesize)
# nand write $(fileaddr) 0x100000 $(filesize)
</pre></div><h2><a class="anchor" id="modifting_mmc_stage1">
Modifying the stage 1 eMMC bootloader</a></h2>
<p>Most of the configurable parameters for the stage 1 bootloader can be found in bootloader/emmc-boot/stage1/config.h.</p>
<ul>
<li><b>UART_PORT</b> UART port number</li>
<li><b>UART_BAUD_RATE</b> baud rate to initialize the UART to</li>
<li><b>STAGE1_START_STRING</b> string displayed just before executing any C code</li>
<li><b>STAGE1_BOOTLOADER_SIZE</b> Do not change this.</li>
<li><b>STAGE2_DRAM_LOAD_ADDR</b> Starting address to load the stage 2 bootloader</li>
<li><b>STAGE2_START_ADDRESS</b> Address to begin executing in the stage 2 bootloader</li>
<li><b>STAGE2_DRAM_SIZE</b> Amount of memory used for the stage 2 bootloader. NOTE: The stage 1 bootloader does not verify if the stage 2 bootloader exceeds this size.</li>
<li><b>STAGE_2_FILENAME</b> File name to use for the stage to bootloader. The file name must be 11 characters in length. For a normal 8.3 DOS filename, pad the 8 character part out with spaces then add the three letter extension. Use upper-case characters.</li>
</ul>
<ul>
<li><b>STAGE2_BACKUP_FILENAME</b> Backup file name to use if the primary stage 2 bootloader fails.</li>
<li><b>STAGE2_ENV_FILENAME</b> Environment filename loaded into memory. Not currently supported.</li>
<li><b>STAGE1_VALIDATE_STAGE2_CRC</b> Define this to verify the stage 2 bootloader CRC.</li>
<li><b>MMC_MAX_WIDTH</b> Maximum width of MMC device supported</li>
<li><b>MMC_SET_BLOCKLEN</b> Sets the block length before read operations. Not needed and not compatible with some MMC devices.</li>
<li><b>STAGE1_RESET_MMC</b> Define this to reset the MMC device before executing the stage 2 bootloader.</li>
<li><b>STAGE_2_LAST_FAILSAFE</b> Define this to search for a stage 2 bootloader immediately following the stage 1 bootloader at the beginning of the MMC device if no stage 2 bootloader is found in a FAT partition.</li>
<li><b>STAGE_2_LAST_FAILSAFE_START_SECTOR</b> Starting sector to use for loading the stage 2 bootloader.</li>
<li><b>MAX_FAT_RETRIES</b> Maximum number of retries to load a stage 2 bootloader from the FAT filesystem. This should be a multiple of four. First it tries to load the standard stage 2 using the primary FAT table, then it tries the backup stage 2 with the primary FAT table. Next it tries the primary and backup stage 2 bootloaders using the backup FAT table before switching back to the primary FAT table.</li>
<li><b>MMC_MIN_SPEED</b> Minimum speed when starting MMC negotiation. This must not exceed 400KHz.</li>
<li><b>MMC_MAX_SPEED</b> Maximum speed for the MMC bus. It is best not to exceed 20MHz for external MMC cards although it has been tested at speeds up to 52MHz.</li>
</ul>
<h2><a class="anchor" id="Environment">
Variable When Booting via MMC/SD</a></h2>
<p>It is now possible for the stage 1 bootloader to load the environment variables for the stage 2 bootloader. In order to do this, issue the following commands to save the environment variables:</p>
<div class="fragment"><pre class="fragment">
env export -c -s 0x1000 0x20000000
fatwrite mmc 0 0x20000000 octboot2.env 0x1000
</pre></div><h2><a class="anchor" id="building_u-boot">
Building u-boot</a></h2>
<p>To rebuild u-boot for the ebb6800 board, run the following commands in the u-boot directory: </p>
<div class="fragment"><pre class="fragment">
$ make distclean
$ make octeon_ebb6800_config
$ make
</pre></div><p> The 'octeon_ebb6800_config' target only needs to be made once. The file 'u-boot-octeon_ebb6800.bin' is the binary image of the bootloader, suitable for burning to the boot flash on the board. The process is same for other evaluation boards - only the configuration and file names are different.</p>
<p>To rebuild for the simulator, the 'octeon_sim_config' configuration target needs to be made, and the 'u-boot-octeon_sim.bin' produced. Copy the built bootloader to $OCTEON_ROOT/target/bin directory.</p>
<h2>Building bootloader without USB Support</h2>
<p>The bootloader is now capable of recognizing USB devices connected to the board. It can also load applications from USB devices to memory. The USB support is enabled by default in the bootloader. To disable USB support in bootloader for an EBB6100 board, look for CONFIG_OCTEON_USB_OCTEON2 in include/configs/octeon_ebh6100.h file and disable all the macros as per the comments in the file. Then re-build the bootloader using the following commands: </p>
<div class="fragment"><pre class="fragment">
$ vi include/configs/octeon_ebb6100.h  // make the changes and save
$ make clean
$ make octeon_ebb6100_config
$ make
</pre></div><p>Follow the instructions mentioned in <a class="el" href="bootloader.html#updating_u-boot">Updating u-boot on an evaluation board</a> to update this newly built bootloader.</p>
<h2><a class="anchor" id="updating_u-boot">
Updating u-boot on an evaluation board</a></h2>
<p>There are two bootloader images burned into the flash on OCTEON evaluation boards - failsafe and normal. The failsafe image is programmed by Cavium before the board is shipped and should not be updated in the field. The failsafe image provides a means to recover from a failed bootloader update. The board is shipped with the current normal bootloader image, and this image is field upgradable. NOTE: From SDK-2.0.X release onwards, same bootloader image is used in failsafe and normal mode.</p>
<h3>To upgrade the bootloader with NOR FLASH</h3>
<p><b>To upgrade bootloader from SDK-1.8.X or SDK-1.9.X release to SDK-2.0.X release</b></p>
<ul>
<li>Load the new bootloader to the address  from compactflash, usb, network, etc.</li>
<li>Find the size of the new bootloader by invoking, for example on ebb6300 board <div class="fragment"><pre class="fragment">  Octeon ebb6300# printenv filesize
  filesize=DA480
</pre></div></li>
</ul>
<p>Round the size up to the nearest 0x10000 bytes and pass it to uboot_flash_size environment variable. </p>
<div class="fragment"><pre class="fragment">  setenv uboot_flash_size 0xe0000
</pre></div><ul>
<li>burn the new image with the command: <div class="fragment"><pre class="fragment">  run bootloader_flash_update; reset
  saveenv; reset
</pre></div></li>
</ul>
<p><b>To upgrade bootloader from SDK-2.X.X to modified version </b></p>
<ul>
<li>Load the new bootloader to the address  from compactflash, usb, network, etc.</li>
<li>burn the new image with the command: <div class="fragment"><pre class="fragment">    bootloaderupdate
</pre></div> This command reads the bootloader image from DRAM (previously loaded via TFTP, compact flash, SD card or usb) and burns it onto the flash location the executable is built at. This command burns the bootloader to the first available sector aligned segment on the flash, if the flash location the executable is built at is used by failsafe bootloader. This removes the limit on the size of the bootloader. Both failsafe and normal bootloader images have an embedded header that describes the image and which is used by this command to relocate the image. Because of this embedded header in the image, the failsafe bootloader is incompatible with the previously released bootloaders (SDK-1.9.X and older).</li>
</ul>
<p>To force the bootloader to be updated in NAND use the following command: </p>
<div class="fragment"><pre class="fragment">    bootloaderupdate nand
</pre></div><p>To force the bootloader to be updated in SPI use the following command: </p>
<div class="fragment"><pre class="fragment">    bootloaderupdate spi
</pre></div><ul>
<li>reset the board. The new bootloader should boot.</li>
</ul>
<h3>Updating a SPI bootloader</h3>
<p>There are three components to the SPI bootloader: (1) Stage 1 bootloader, typically named spi-boot.bin (2) Stage 2 bootloader, typically named u-boot-octeon_generic_spi_stage2.bin or u-boot-octeon_generic_cn70xx_spi_stage2.bin (3) Stage 3 bootloader</p>
<p>If the L2 cache is large enough, for example on the CN73XX and CN78XX then the stage 2 bootloader is not required.</p>
<p>To write the stage 1 bootloader use the following commands: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"># tftp 0 spi-combined.bin</span>
<span class="preprocessor"># bootloaderupdate spi</span>
</pre></div><p>or alternatively: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"># sf probe</span>
<span class="preprocessor"># sf update $(fileaddr) 0 $(filesize)</span>
</pre></div><p>Currently only a single copy of the stage 2 bootloader is supported by the SPI stage 1 bootloader. A future release will add support for both a failsafe as well as a normal bootloader. If a stage 2 and stage 3 bootloader are used, the stage 2 bootloader supports both a failsafe and standard stage 3 bootloader.</p>
<p>The stage 2 bootloader is typically installed at offset 0x10000 (64K) in the SPI NOR and the environment is typically stored at offset 0xe000 (56K) in the SPI NOR. If a stage 3 bootloader is installed, the failsafe will be installed at the next 64K boundary after the stage 2 bootloader.</p>
<p>To write the failsafe and standard stage 2 bootloaders use the following commands: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"># tftp 0 u-boot-octeon_generic_cn70xx_spi_stage2.bin</span>
<span class="preprocessor"># bootloaderupdate spi</span>
</pre></div><p>Alternatively, if for some reason that should fail:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"># sf update $(fileaddr) 0x10000 $(filesize)</span>
</pre></div><p>Two copies of the stage 3 bootloader are also supported for both a failsafe and non-failsafe.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"># tftp 0 u-boot-octeon_boardname.bin</span>
<span class="preprocessor"># bootloaderupdate spi</span>
</pre></div><p>Or alternatively: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"># sf update $(fileaddr) 0x100000 $(filesize)</span>
<span class="preprocessor"># sf update $(fileaddr) 0x280000 $(filesize)</span>
</pre></div><p>The last offsets shown, 0x100000 and 0x280000 must be such that they do not overwrite the stage 2 bootloaders. Any starting offsets should be rounded up to the next 64K offset.</p>
<p>There is also some initial support for the bootloaderupdate command but this support has not been thoroughly tested and may contain bugs. To use the bootloaderupdate command use the following commands:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"># tftp 0 u-boot-octeon_generic_spi_stage2.bin</span>
<span class="preprocessor"></span><span class="preprocessor"># bootloaderupdate spi</span>
<span class="preprocessor"></span><span class="preprocessor"># tftp 0 u-boot-octeon_boardname.bin</span>
<span class="preprocessor"># bootloaderupdate spi</span>
</pre></div><p>The bootloaderupdate command will automatically detect if the bootloader is a stage 1, stage 2 or stage 3 bootloader.</p>
<p>If there are problems then the sf erase command can be used then the bootloaderupdate command should work properly, or if not, the bootloader can be updated manually.</p>
<h3>Old style (SDK 1.9.X and older) bootloader updates </h3>
<p>To upgrade the bootloader:</p>
<ul>
<li>put the new bootloader image onto a compact flash card, insert the card into the OCTEON board, and turn the board on.</li>
<li>load the image into dram with the command: <div class="fragment"><pre class="fragment">     fatload ide 0 $(loadaddr) image-filename
</pre></div></li>
<li>burn the new image with the command: <div class="fragment"><pre class="fragment">    run bootloader_flash_update
</pre></div> Since the failsafe bootloader is not field upgraded, this method may be required when using the failsafe image. This method can be used to write u-boot images with the header (new in 1.9), as the header is embedded in the binary image.</li>
</ul>
<p>Note: The size of the bootloader exceeds the default flash size when the bootloader is built with USB support or PCI support, adjust uboot_flash_size before invoking 'run bootloader_flash_update', as mentioned below: </p>
<div class="fragment"><pre class="fragment">    fatload ide 0 $(loadaddr) image-file
    setenv uboot_flash_size 0x90000
    run bootloader_flash_update
</pre></div><p> Always make sure the value of uboot_flash_size returned by the present bootloader is greater than the size of the bootloader that is being updated. And also make sure the size of the bootloader passed to 'uboot_flash_size' is rounded to the next 0x10000 bytes.</p>
<h3>Recovering from a failed bootloader update </h3>
<p>The failsafe bootloader image is not modified when updating the normal bootloader image. If the normal image update fails, the failsafe bootloader can be used to update the normal bootloader image. The following instructions apply to the CN38XX-EVB-NIC4 board only. To use the failsafe bootloader image to update the normal image:</p>
<ul>
<li>flip switch 1 on the SW9 on Rev 4 boards (SW8 on rev 3 boards) switch pack to 'off'. This is GPIO 0, and an LED should come on indicating that the GPIO line is now high. (The switch polarity is reversed.)</li>
<li>reset the board. The failsafe bootloader image should now boot. The bootloader prompt should identify itself as the failsafe bootloader.</li>
<li>follow the directions in the section above describing the bootloader update</li>
<li>power board off, return switch 1 of the SW9 on Rev 4 boards (SW8 on rev 3 boards) switch pack to 'on', and turn the board on. The new bootloader image should now boot.</li>
</ul>
<h3>To upgrade the bootloader with SPI NOR FLASH</h3>
<p>The SPI boot process requires a multi-stage boot process, either two or three stages depending on the size of the L2 cache of the Octeon processor.</p>
<p>Currently only CN70XX/CN71XX requires a three-stage boot process.</p>
<p>The first stage is a file called </p>
<div class="fragment"><pre class="fragment"> spi-boot.bin 
</pre></div><p> . This file looks for a valid stage 2 bootloader starting at offset 0x10000 (64KB) and loads it into the L2 cache at address 0x81000000 and transfers control to the stage 2 bootloader. For CN73XX, CN78XX and CNF75XX the stage 2 bootloader is the final stage. For CN70XX, however, due to limitations of the L2 cache size, a stage 2 bootloader is typically required.</p>
<p>If the board has a TLV EEPROM then the generic SPI stage 2 bootloader can be used, otherwise a custom stage 2 bootloader for that particular board is required.</p>
<p>The stage 2 bootloader will initialize DDR memory then load a stage 3 bootloader into memory and transfer control to the stage 3 bootloader. If the SPI nor is large enough there may be both a failsafe and a standard stage 3 bootloader. In this case, the failsafe GPIO (typically 0) is checked to see if the standard or failsafe bootloader should be loaded and control is transferred to that bootloader.</p>
<h4>Upgrading the SPI bootloaders</h4>
<p>. The bootloaderupdate command has been enhanced in order to support SPI NOR. The command will automatically detect which bootloader is to be installed and will install it at the appropriate location in the SPI NOR. The stage 1 bootloader is always installed at offset 0 and the stage 2 is typically installed at offset 0x10000 (64K).</p>
<p>To update the stage 1 bootloader use either tftp, fatload or some other command to load the spi-boot.bin file into memory then issue the following command:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"># bootloaderupdate spi</span>
</pre></div><p>If the board lacks parallel NOR flash then the "spi" parameter may be ommitted.</p>
<p>To update the stage 2 bootloader for a three-stage boot process the same command may be used. To update the failsafe stage 3 bootloader, use the following command:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"># bootloaderupdate spi failsafe</span>
</pre></div><p>Updating the non-failsafe stage 3 bootloader uses the following command, where the "spi" paramter may be ommitted if the board lacks a parallel NOR flash.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"># bootloaderupdate spi</span>
</pre></div><p>The bootloaderupdate command will issue a warning if the new bootloader is larger than the old bootloader causing it to overwrite the beginning of the next bootloader. For example, if the new stage 2 bootloader is bigger than the previous one, it may be required to update the stage 3 failsafe and normal bootloader. Similarly, if the new stage 3 failsafe bootloader overwrites the standard bootloader it will be required that the standard bootloader also be updated.</p>
<p>Currently the stage 1 bootloader lacks support for supporting a standard and failsafe stage 2 or final stage bootloader. Future releases of this SDK will add this capability.</p>
<p>Since this will require a larger stage 1 bootloader, the stage 1 will be broken down into two parts. The first 56-60K should always be reserved for the stage 1 bootloader in the SPI NOR flash, leaving 4-8K for environment variables to be stored before the stage 2 bootloader.</p>
<h2><a class="anchor" id="board_support">
Supporting new boards (porting)</a></h2>
<p>It is very straightforward to add support for a new board to u-boot. Hacking an existing board configuration will cause problems, as the board type is used in many places to determine how things should be configured. The following is an outline of how to add support for a new board to u-boot.</p>
<ul>
<li>Add new board type to <a class="el" href="cvmx-app-init_8h.html" title="Header file for simple executive application initialization.">cvmx-app-init.h</a>. This should be added to the CVMX_BOARD_TYPE_CUST_PRIVATE_* section. This range is reserved for private use by customers, so the standard SDK will never use this range.</li>
<li>Add board config file to u-boot/include/configs. Start out by copying an existing configuration. Update prompt string, dram timing, and other configuration settings that differ from the source of the copy.</li>
<li>add board directory to u-boot/board/octeon directory. Again, start out by copying/renaming an existing configuration. Be sure to update setting of board type in these files, and to remove any code that doesn't apply to the new board.</li>
<li>add config targets to u-boot/boards.cfg.</li>
<li>add new board memory configuration to u-boot/arch/mips/cpu/lib_octeon_shared.c</li>
<li>add board specific configuration to <a class="el" href="cvmx-helper-board_8c.html" title="Helper functions to abstract board specific data about network ports from the rest...">cvmx-helper-board.c</a>. U-boot, the simple executive, and Linux all use this file to get board specific configuration information.</li>
</ul>
<p>Cavium evaluation boards have some features (MCU and PAL for controlling clocks and voltages ) that provide flexible configuration that are usually not present on production boards. The values that are determined from these should be hard coded for boards that do not have them. Also, all OCTEON evaluation boards have a TWSI eeprom that stores board specific information such as serial number and MAC addresses. If this eeprom is missing from production boards then other means will need to be used to store this information.</p>
<h2><a class="anchor" id="se_api">
Simple Executive API</a></h2>
<p>Support has been added to support a Simple Executive API for SE applications to allow simple executive applications to read U-Boot environment variables as well as simple file I/O. The file I/O should be limited to small files that are 64K or smaller due to the fact that there is an internal 64K bounce buffer used in U-Boot. File write operations beyond 64K are not supported and read operations will become increasingly slow since each read past 64K will require re-reading the entire file up to that point. For example, reading a 256K file will cause the bootloader to read 64K, then 128K, then 192K then 256K. See the uboot-seapi example program on its use. Note that most bootloaders have this option disabled.</p>
<p>To enable this API for SE applications, define CONFIG_OCTEON_SE_NAPI in the board's configuration .h file under include/configs.</p>
<h2><a class="anchor" id="limitations">
Limitations</a></h2>
<ul>
<li>U-boot is a 32 bit application, meaning pointers are 32 bits. This restricts what addresses U-boot can run from and what memory it has easy access to. Several assembly routines have been added to allow access to hardware units, such as the UART.</li>
</ul>
<ul>
<li>OCTEON executive applications do not support returning to the bootloader on application completion.</li>
</ul>
<h2><a class="anchor" id="serial_config">
serial_config</a></h2>
<p>The u-boot 'loadb' command supports serial download using the kermit protocol, although it only supports a limited subset of the protocol. The following options should be set in the .kermrc file for use with u-boot:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">set</span> modem type none
<span class="keyword">set</span> line /dev/ttyUSB0  #Change <span class="keyword">this</span> to match the serial device
<span class="keyword">set</span> speed 115200
<span class="preprocessor">#set speed 460800   # Many USB serial adapters support 460800</span>
<span class="preprocessor"></span><span class="keyword">set</span> streaming off
<span class="keyword">set</span> prefixing all
<span class="keyword">set</span> flow xon/xoff
<span class="keyword">set</span> carrier-watch off
robust

Many USB serial adapters support 460800 bps, so <span class="keyword">this</span> can be a very quick
way to load small files.  This is especially useful during early board
bringup when the UART may be the only way to load code.  Serial download
along with a failsafe bootloader can greatly speed up bootloader
development on <span class="keyword">new</span> boards.
</pre></div><h2><a class="anchor" id="console_config">
console_config</a></h2>
<p>The u-boot console supports multiple consoles being active simultaneously on boards that support PCI or PCIE target support. By default, the PCI console will be active for stdin only. This is due to the fact that stdout will block if no PCI console is connected.</p>
<p>To enable the PCI console output, at any time use the following commands:</p>
<div class="fragment"><pre class="fragment">setenv stdin serial,pci,bootoct
setenv stdout serial,pci
setenv stderr serial,pci
</pre></div><p>This enables output to be sent to both the serial console and the pci console. For output to the pci console only, remove serial.</p>
<p>stdin by default supports serial, pci, and bootoct. bootoct is used by a number of utilities like oct-pci-bootcmd, oct-pci-load and several others. It is an alternate method of entering commands that will likely go away in the near future in favor of the PCI console.</p>
<h2><a class="anchor" id="u-boot_applications">
u-boot_applications</a></h2>
<p>U-Boot supports native applications which are binaries that are able to call a number of exported functions. This support has been added to the OCTEON U-Boot but there are a number of differences in the way that it works. Most of these differences are hidden from both the user and the developer.</p>
<p>For one thing, U-Boot applications run in virtual memory like U-Boot itself. Unlike U-Boot, however, the memory address space is different.</p>
<p>When the go command is used to start a native application, the go command first checks to see if the special U-Boot native application header is present or not. The header contains information such as the virtual address where the application starts and the start and end addresses of the various segments.</p>
<p>If it is found then it will attempt to allocate memory, first from memory normally unavailable to 32-bit applications if possible. A named block named "u-boot-app" is used.</p>
<p>The go command figures out the amount of space needed to hold the entire application including its BSS segment and rounds it up to a page size where the entire application will fit in either one or two pages. If, for example, an application is 17,992 bytes then two 16K pages will be used and 32K will be allocated.</p>
<p>Next the memory is mapped to the virtual address specified in the header which is typically 0xD0000000. Note that the starting virtual address must not cross a page boundary and it must not overlap with U-Boot. Currently addresses in the range of 0xC0100000 through DFFFF000 are supported though the default address of 0xD0000000 provides the least chance of any issues.</p>
<p>The application, up until the bss segment, is copied into the virtual memory and the bss segment is initialized to zero.</p>
<p>Several fields in the application header are filled in by U-Boot to help assist the application.</p>
<p>Normally the application would start to search for a special signature for the native API starting at the stack pointer. Since this is limited to 3MB it may not cover the heap and find the data structure. Due to this, the address of the data structure is copied into the application header and the starting search location is set to this address.</p>
<p>There are also version fields, both for the application and the bootloader to support backward and forward compatibility.</p>
<p>After the application returns control back to U-Boot the virtual to physical mapping is removed and the memory block is freed.</p>
<p>All of this support is handled under the covers so it should be transparent to both the U-Boot user and the application developer. The only other thing to be aware of is that like U-Boot memory addresses are not physical addresses.</p>
<p>Memory allocated using malloc will be allocated from U-Boot's heap which is typically initialized to have 12MB available. Similarly, the application inherits U-Boot's stack. The cvmx_bootmem allocation routines are safe to use but should be freed before exiting.</p>
<p>Before exiting it is imparative that U-Boot not have any pointers or references to memory locations within the app since as soon as it exits the virtual mapping will disappear. This should make it easy to discover if any crashes are caused due to this.</p>
<p>All applications should use the mips-octeon.lds linker script found in the examples/api and examples/standalone directories. They also must use the crt0.S file in examples/api as well since this contains all of the header and support code. The examples/api/octeon.c file provides several library files that are missing due to architectural specific versions of memcmp, memset, memcpy, hw_watchdog_reset, get_tbclk and crc32.</p>
<p>In order to enable the native API support add </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#define CONFIG_API</span>
</pre></div><p> to the board configuration header file.</p>
<p>Currently it is only enabled in the simulator and the Embedded Planet EP6300C board. This may be enabled in additional boards in the future. In order to use it with the demo application use the following command:</p>
<div class="fragment"><pre class="fragment">oct-sim examples/api/demo.bin -noperf -uart0=1234 -quiet
</pre></div><p>Then telnet to port 1234. Press return immediately to prevent it from automatically starting the application then type:</p>
<div class="fragment"><pre class="fragment">go 0x10000000
</pre></div><p>This will start the demo application. Failure to press ENTER early enough will cause U-Boot to crash since demo.bin is not compatible with simple exec.</p>
<p>If support is added to a board the command to start the application is:</p>
<div class="fragment"><pre class="fragment">go $(fileaddr)
</pre></div><p>Do not specify the virtual address in the go command. The virtual address will be automatically calculated from the header. </p>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Oct 2017 for Octeon Software Development Kit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
