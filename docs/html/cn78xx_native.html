<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Octeon Software Development Kit: CN7XXX native api reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="cn78xx_native">CN7XXX native api reference </a></h1><p>Here CN7XXX means, CN78XX, CN73XX, CNF75XX that use OCTEON III packet IO blocks.</p>
<ul>
<li><a class="el" href="cn78xx_native.html#cn78_pk_xmit">Packet transmission</a></li>
<li><a class="el" href="cn78xx_native.html#cn78_pdesc">Packet Descriptor Danipulation</a></li>
<li><a class="el" href="cn78xx_native.html#cn78_bp">Backpressure</a></li>
<li><a class="el" href="cn78xx_native.html#cn78_fpa">CN78XX-specific FPA3 API details</a></li>
<li><a class="el" href="cn78xx_native.html#cn78_multinode">Multi-node data-types</a></li>
<li><a class="el" href="cn78xx_native.html#cn78_pki">CN78XX-specific packet input (PKI) details</a></li>
<li><a class="el" href="cn78xx_native.html#cn78_new_apis">Using PKI New APIS for 78xx</a></li>
<li><a class="el" href="cn78xx_native.html#cn78_multinode">Multi-node data-types</a></li>
</ul>
<h2><a class="anchor" id="cn78_pk_xmit">
Packet transmission</a></h2>
<p>In the CN7XXX series, packet transmission is controlled by the structure cvmx_pko3_pdesc_t. In contrast with the previous cvmx_pko_command_t structure, the pdesc is a dynamic stack where additional operands can be pushed for operation by the PKO. These commands can include pointers to packet fragments, gather lists, crc specifications, memory write/modify operations, and the traditional transmission complete work queue notifications.</p>
<p>The following sections describe a new API that is designed to take full advantage of the CN7XXX PKO (a.k.a. PKO3) based on cvmx_pko3_pdesc_t.</p>
<p>The memory space for the cvmx_pko3_pdesc_t structure is provided by the application. In most cases this space can be simply allocated as an automatic variable on the stack of the function that uses the following API. In some advanced use cases however, the pdesc_t object may be contained in an auxiliary data structure and persist across multiple iterations of the main packet processing loop. For example, an application that is designed to reassemble fragmented IP packets might declare a pdesc_t as one of the information element in its packet reassembly hash table, so that each pdesc_t represents an original IP packet while it is being reassembled.</p>
<p>The pdesc_t may be initialized in one of two ways: (a) if the packet being processed has been received by the application via the SSO and PKI from one of the network interfaces, the native WQE structure may be converted to a pdesc_t by calling <a class="el" href="cvmx-pko3_8c.html#ae205a7e1cc1c184c856f55422e03cab1" title="Create a packet descriptor from WQE.">cvmx_pko3_pdesc_from_wqe()</a>.</p>
<p>If, on contrast an application needs to *create* a packet to be transmitted, or build a packet from another source that is not represented by a WQE, it should first call <a class="el" href="cvmx-pko3_8c.html#a2457d75d2ef80e23c4b574b9227aeba4" title="Initialize packet descriptor.">cvmx_pko3_pdesc_init()</a> that will create an *empty* packet <a class="el" href="structdescriptor.html">descriptor</a> that would be subsequently *filled with buffers using the <a class="el" href="cvmx-pko3_8c.html#a376824b8c7e601d244771a5a683b1ecd" title="Append a packet segment to a packet descriptor.">cvmx_pko3_pdesc_buf_append()</a> function.</p>
<p>In either case, the pdesc_t may be augmented with additional PKO-specific meta-data, such as a method the PKO should use to notify the application of a succesful packet transmission etc.</p>
<p>Once the packet <a class="el" href="structdescriptor.html">descriptor</a> is *complete*, it can be transmitted to an egress port using the <a class="el" href="cvmx-pko3_8c.html#a0716acbac44ccac16e283a1c95229c25" title="Send a packet in a desciptor to an output port via an output queue.">cvmx_pko3_pdesc_transmit()</a> function.</p>
<p>After <a class="el" href="cvmx-pko3_8c.html#a0716acbac44ccac16e283a1c95229c25" title="Send a packet in a desciptor to an output port via an output queue.">cvmx_pko3_pdesc_transmit()</a> returns, the pdesc_t structure can be re-used by the application to store a new packet (by calling <a class="el" href="cvmx-pko3_8c.html#ae205a7e1cc1c184c856f55422e03cab1" title="Create a packet descriptor from WQE.">cvmx_pko3_pdesc_from_wqe()</a> or <a class="el" href="cvmx-pko3_8c.html#a2457d75d2ef80e23c4b574b9227aeba4" title="Initialize packet descriptor.">cvmx_pko3_pdesc_init()</a> again). The buffers that are contained in a 'pdesc' should not be accessed by the application after calling <a class="el" href="cvmx-pko3_8c.html#a0716acbac44ccac16e283a1c95229c25" title="Send a packet in a desciptor to an output port via an output queue.">cvmx_pko3_pdesc_transmit()</a> in any way if the PKO has been instructed to *free* the packet buffers on completion. If the PKO has been programmed not to free the buffers, the 'pdesc' can be re-used by sending the exact same packet to a different destination port. The data in the buffers must not be modified after calling <a class="el" href="cvmx-pko3_8c.html#a0716acbac44ccac16e283a1c95229c25" title="Send a packet in a desciptor to an output port via an output queue.">cvmx_pko3_pdesc_transmit()</a> because the buffers may have not yet been consumed, and any modification could effect the prior packet.</p>
<p>For example, never call <a class="el" href="cvmx-pko3_8c.html#a39ce8fe04684ac95179df6b301db8405" title="Prepend a data segment to the packet descriptor.">cvmx_pko3_pdesc_hdr_push()</a> or <a class="el" href="cvmx-pko3_8c.html#aff344df78201ecb32c062817fa8a1923" title="Remove some bytes from start of packet.">cvmx_pko3_pdesc_hdr_pop()</a> on a pdesc_t following its transmission, but only after the pdesc_t has been re-initialized to be empty or from a WQE.</p>
<h2><a class="anchor" id="cn78_pdesc">
Packet Descriptor Danipulation</a></h2>
<p>The 7XXX no longer has a hardware FAU unit, however the PKO now has an atomic memory operation capability, allowing it to perform most of the same functionality. In order to decrement a counter after transmission, add the following call before <a class="el" href="cvmx-pko3_8c.html#a0716acbac44ccac16e283a1c95229c25" title="Send a packet in a desciptor to an output port via an output queue.">cvmx_pko3_pdesc_transmit()</a>:</p>
<p><a class="el" href="cvmx-pko3_8h.html#a4744d965a3d8597dfdb1b43200af24be" title="Request atomic memory decrement at transmission completion.">cvmx_pko3_pdesc_notify_decrement(cvmx_pko3_pdesc_t *pdesc, volatile uint64_t *p_counter)</a>;</p>
<p>WQE notification is handled via the <a class="el" href="cvmx-pko3_8c.html#ad94338f36d2bc14ba5ab8f1403374b78" title="Add a Work Entry for packet transmission notification.">cvmx_pko3_pdesc_notify_wqe()</a> call, however note the WQE format is in the 7XXX specific format. Unlike other commands, only 1 WQE notification can be added per PKO operation.</p>
<p>For a typical packet processing application, to make a packet received from an ingress port via the PKI, SSO in the form of a WQE, call <a class="el" href="cvmx-pko3_8c.html#ae205a7e1cc1c184c856f55422e03cab1" title="Create a packet descriptor from WQE.">cvmx_pko3_pdesc_from_wqe()</a> to quickly convert the input packet to pdesc_t and make it ready for transmission. Following <a class="el" href="cvmx-pko3_8c.html#ae205a7e1cc1c184c856f55422e03cab1" title="Create a packet descriptor from WQE.">cvmx_pko3_pdesc_from_wqe()</a> one may call <a class="el" href="cvmx-helper-util_8c.html#a3178b90be403d7078fb5643c9af08ae8" title="Free Work Queue Entry memory.">cvmx_wqe_free()</a> immediately, or at any later time, since all the data and meta-data for the packet has been saved in pdesc_t.</p>
<p>If a received packet headers need to be modified, the prescribed method of modifying a packet header is made available with 'cvmx_pko3_pdesc_hdr_pop()' that will extract a packet header from the packet and save it in caller-provided buffer, and remove that header from the packet (hence extending its headroom). A new header can be prependend to the packet by calling <a class="el" href="cvmx-pko3_8c.html#a39ce8fe04684ac95179df6b301db8405" title="Prepend a data segment to the packet descriptor.">cvmx_pko3_pdesc_hdr_push()</a>.</p>
<p>For example, to forward a packet at Layer-2 between two different VLANs, the application would need to first remove the L2 header from the packet using <a class="el" href="cvmx-pko3_8c.html#aff344df78201ecb32c062817fa8a1923" title="Remove some bytes from start of packet.">cvmx_pko3_pdesc_hdr_pop()</a>, modify its VLAN tag and any other Layer-2 header fields, and the call <a class="el" href="cvmx-pko3_8c.html#a39ce8fe04684ac95179df6b301db8405" title="Prepend a data segment to the packet descriptor.">cvmx_pko3_pdesc_hdr_push()</a> to prepend a new Layer-2 header to the packet. Note that the new Layer-2 header may be of a different size than the original header, as would be in the case of a MAC-in-MAC tunneling application.</p>
<p>For a simpler Layer-2 forwarding application that does not modify the headers, but needs to inspect the header contents for making a forwarding or learning operation, it may use <a class="el" href="cvmx-pko3_8c.html#ace567085ed7bd14851fadd574b4ecf4a" title="Peek into some header field of a packet.">cvmx_pko3_pdesc_hdr_peek()</a> to get a copy of the Layer-2 header without modifying the packet contents.</p>
<h2><a class="anchor" id="cn78_bp">
Backpressure</a></h2>
<p>The 78XX uses hardware counters called AURAs to control backpressure, RED and drop thresholds. You may enable flow control on per-aura basis by calling <a class="el" href="cvmx-fpa3_8h.html#a337ec66f47a47d906272e4017bcb8931" title="Configure the QoS parameters of an FPA3 AURA.">cvmx_fpa3_setup_aura_qos()</a>, with the thresholds you wish to use. For example, for an aura attached to a shared pool with 800 buffers you could specify <a class="el" href="cvmx-fpa3_8h.html#a337ec66f47a47d906272e4017bcb8931" title="Configure the QoS parameters of an FPA3 AURA.">cvmx_fpa3_setup_aura_qos()</a>. Which would configure the specified aura to pass all packets when at least 200 buffers were free, send backpressure notification when 100 buffers are free, and to drop all packets when only 50 buffers are free. The auras should be considered on a per-style basis, in such a way that a single style consuming too many resources will be throttled gracefully while all other traffic is continue.</p>
<h2><a class="anchor" id="cn78_fpa">
CN78XX-specific FPA3 API details</a></h2>
<p>One major difference between the 2 chip generations is the existence of auras. For 78xx boards in legacy mode, any references to pools are expected to target auras, and any devices which in the past would require pools for their memory will now instead use an aura id in place. Pool 0 will be disabled, so that any misconfigured aura accesses will fail on the simulator. There are new helper api calls to make pool/aura configuration easier:</p>
<p><a class="el" href="cvmx-fpa_8c.html#ae101ddc4b8ed14298c2a67f6448ca642" title="Create a combination of an AURA and a POOL.">cvmx_fpa3_setup_aura_and_pool()</a> will allocate and set up a single aura with a backing pool of given size. The aura id is returned, and the api will attempt to reserve the specified aura id unless given -1, in which case aura ids will be allocated dynamically. If buffers == NULL then memory will be allocated automatically. The backing pool number will be reserved dynamically, and the 'num_blocks' argument is used both for the actual number of buffers that populate the pool, and the allocation buffer limit that will be assigned to the aura.</p>
<p><a class="el" href="cvmx-fpa_8c.html#a7f1f6975c26dd01c6b7128cc0d60b5ee" title="Attach an AURA to an existing POOL.">cvmx_fpa3_set_aura_for_pool()</a> is used to attach auras to an existing pool, which can be created and filled with buffers using <a class="el" href="cvmx-fpa_8c.html#accf7ec65305f00b6caafa616330f9066" title="Create an FPA POOL and fill it up with buffers.">cvmx_fpa3_setup_fill_pool()</a>, or by calling <a class="el" href="cvmx-fpa3_8h.html#abd9d1d0c121c5b502f80c13791d77461" title="Get the FPA3 POOL underneath FPA3 AURA, containing all its buffers.">cvmx_fpa3_aura_to_pool()</a> that will return the id of the pool that is baking the specified aura. The 'num_blocks argument to <a class="el" href="cvmx-fpa_8c.html#a7f1f6975c26dd01c6b7128cc0d60b5ee" title="Attach an AURA to an existing POOL.">cvmx_fpa3_set_aura_for_pool()</a> is used to limit the number of buffers that can be consumed through the new aura, and should be less than or equal to the number of buffers contained in the backing pool it is associated with. The 'block_size argument is only used to verify that the backing pool was created with the same buffer size that the application expects with this new aura, to avoid unpredictable behavior.</p>
<p>An end user should rarely attempt to reserve a specific pool id on 78xx, as the handle given to all I/O blocks, and used to allocate buffers is an aura.</p>
<p>Beyond initialization and shutdown the only occasion the pool id should be used is when attaching an additional aura to an already configured pool.</p>
<p>One of the key changes in cn78xx is that the new Buffer Link Pointer no longer includes the "Back" field, which is used on older chip to indicate the distance from the start of data to the beginning of the buffer in cache lines. For this reason, the only method that can be relied on at all times for the FPA to locate the beginning of a buffer to free, is to use the native alignment mode, where the buffer start is always aligned to the buffer size for a given POOL. Other alignment modes of the FPA can only be expected to work if the 1ST_SKIP and NEXT_SKIP values in PKI (as well as the distance to start of data in any software-generated packet) are always less then cache line size. Taking advantage of this restriction is highly discouraged.</p>
<h2><a class="anchor" id="cn78_pki">
CN78XX-specific packet input (PKI) details</a></h2>
<p>PKI can be broken down in 7 major areas, where backward compatibilty needs to be addressed</p>
<ul>
<li><a class="el" href="cn78xx_native.html#pki_if_cfg">Interface/Port Configuration</a></li>
<li><a class="el" href="cn78xx_native.html#wqe_and_pb_pools">WQE and packet buffer pools</a></li>
<li><a class="el" href="cn78xx_native.html#wqe_fields">WQE fields</a></li>
<li><a class="el" href="cn78xx_native.html#qos_and_queue_prio">QOS and QUEUE PRIORITIES</a></li>
<li><a class="el" href="cn78xx_native.html#pkt_sched">Packet Scheduling</a></li>
<li><a class="el" href="cn78xx_native.html#pki_red_and_bp">PKI RED and backpressure</a></li>
<li><a class="el" href="cn78xx_native.html#pki_cfg">Steps to configure PKI</a></li>
</ul>
<h3><a class="anchor" id="pki_if_cfg">
Interface/Port Configuration</a></h3>
<p>Software in previous chips controls the per port (interface/index) configuration for packet input block through provisioning the pkind registers. In 78xx port configuration is controlled via style registers. pkind configuration registers only control few aspect of port. To configure the port, a style needs to be assigned to the port first and after that configuration can be controlled through that style register.</p>
<p>To keep backward compatibility, SE library be default assigns style = pkind for that port. "cvmx_pip_config_port" supports the backward compatibility for many fields. Some fields that are not supported are qos and group watchers, portadd_en and different tagging mechanism for different protocols.</p>
<h3><a class="anchor" id="wqe_and_pb_pools">
WQE and packet buffer pools</a></h3>
<p>In older chips pacwqe and packet data could reside in separate pools. Packet data buffers were hardwired to come from pool 0.</p>
<p>78xx Support-- 78xx has concept of auras and any aura can be assigned to buffer the packet data.</p>
<p>To keep backward compatibilty all the packet data from all interface/ports are still buffered in aura0. By default SDK supports NO_WPTR mode where wqe entry uses same buffer as packet data and is appended to first packet buffer. Older chips supported 2 mode for packet buffering.</p>
<p>a) WQE and packet data reside in different buffers which comes from different fpa pools. wqe buffers contains wqe <a class="el" href="structdescriptor.html">descriptor</a> and 12 words of packet data. 78xx support --- In 78xx this mode to keep wqe entry and packet data in different buffers can be chosen by calling api "cvmx_helper_pki_set_wqe_mode". Note that buffers for wqe still comes from the same packet pool. There is no need to configure WQE buffer pool. You may want to increase the size of packet pool since now wqe buffers comes from there. Take note that this may increase the memory footprint. Also WQE buffer only contains first few words 5-8 depending on wqe_header_size chosen in configuration. If application need first few words of packet data to be in WQE, they will need to copy them themselves. Also notice that WQE entry now has minimum of 5 words compare to 4 words before.</p>
<p>b) WQE_NOPTR: WQE and packet data share the same buffer, where 4 WQE WORDS are appended in front of packet data.</p>
<p>78xx support -- This is default mode in 78xx where wqe is appended in front of the first packet data buffer. 78XX has minimum 5 words and there is a word after that for next_ptr field for linked buffers. next_ptr field is there even for packets which needs only 1 buffer.</p>
<h3><a class="anchor" id="wqe_fields">
WQE fields</a></h3>
<p>WQE structure has been almost completely modified in 78xx. If software is accessing the fields of it directly, it needs to modify the code to use accessor functions. Unused fields are not supported.</p>
<h3><a class="anchor" id="pkt_sched">
Packet Scheduling</a></h3>
<p>In older chips by default SE software sends packets to 8 different qos queues. There are no separate qos queues in 78xx, sso groups can be used as qos queues within.</p>
<p>78xx support: In backward compatible mode by default all packets from all interfaces/ports go to sso group 0.</p>
<h3><a class="anchor" id="qos_and_queue_prio">
QOS and QUEUE PRIORITIES</a></h3>
<p>In older chips sso could prioritize scheduling of work based on QOS queues0-7, in 78xx prioritization is based on groups. Each group can be prioritized between priorities 0-7. 78xx has 256 groups which are configured in software, so that lowest 3 bits of group denotes priority and remaining 5 bits represent a group which limits group numbers to 32 in backward compatible mode. 68xx had many ways to configure QoS which are outlined below 1) per port QoS queue and group -- It could be configured through PIP_PRT_CFGX register by calling API <a class="el" href="cvmx-pip_8h.html#a3ea0a3b94e416a0050898d5ce2d80d13" title="Configure an ethernet input port.">cvmx_pip_config_port()</a> which now have support for 78xx 2) QoS watchers -- software will reserve pcam entries 0-7 for qos watcher 0-7. In 78xx qos is controlled via sso groups so there is no separate control for qos. 3) priority table -- user need to config qpg table where grp = grp &lt;&lt; 3 | qos, padd, bpid per port/channel are not supported in backward compatible mode. user need to setup qpg_base by calling cvmx_pki_write_style_cfg 4) bit selector -- can be achieved by programming pcam entries</p>
<h3><a class="anchor" id="pki_red_and_bp">
PKI RED and backpressure</a></h3>
<p>RED is applied per aura, since in backward compatible mode all the packets goes to aura 0 RED can't be applied on per port/interface basis. Back Pressure- There are no per port back pressure counters in 78xx, back pressure is applied per aura. Since all the packets goes to same aura in backward compatible mode, backpressure can't be applied on per interface/port.</p>
<h2><a class="anchor" id="cn78_new_apis">
Using PKI New APIS for 78xx</a></h2>
<h3><a class="anchor" id="pki_cfg">
Steps to configure PKI</a></h3>
<p>1) On power on PKI is initialized to default parameters by software which assigns packet pool 0, sso group 0 and 1:1 pkind:style mapping. It then enables PKI to send/receive traffic.</p>
<p>To modify default parameters call</p>
<ul>
<li><a class="el" href="cvmx-helper-pki_8h.html#a10681935ee4cf3d56545d24292a4a32b">cvmx_helper_pki_set_dflt_pool(int node, int pool, int buffer_size, int buffer_count)</a></li>
</ul>
<ul>
<li><a class="el" href="cvmx-helper-pki_8h.html#a5cda35d41d1b26e61a8179f3b47b09c0">cvmx_helper_pki_set_dflt_aura(int node, int aura, int pool, int buffer_count)</a></li>
</ul>
<ul>
<li><a class="el" href="cvmx-helper-pki_8h.html#a3da9c807aadc02b95703e2a2ed677a6a">cvmx_helper_pki_set_dflt_pool_buffer(int node, int buffer_count)</a></li>
</ul>
<ul>
<li><a class="el" href="cvmx-helper-pki_8h.html#a258515ff580963c97534e5fe989b4697">cvmx_helper_pki_set_dflt_aura_buffer(int node, int buffer_count)</a></li>
</ul>
<ul>
<li><a class="el" href="cvmx-helper-pki_8h.html#a2d62b42873a83dc77039026ecc287a1a">cvmx_helper_pki_set_dflt_pkind_map(int node, int pkind, int style)</a></li>
</ul>
<ul>
<li><a class="el" href="cvmx-helper-pki_8h.html#a5eebebda361ed5c87bba109bf2c1fa51">cvmx_helper_pki_get_dflt_style(int node, struct cvmx_pki_style_config *style_cfg)</a></li>
</ul>
<ul>
<li><a class="el" href="cvmx-helper-pki_8h.html#a7773b6fe29b61cc7f1b5d5b939f065f1">cvmx_helper_pki_set_dflt_style(int node, struct cvmx_pki_style_config *style_cfg)</a></li>
</ul>
<p>To disable PKI default initialization call</p>
<ul>
<li><a class="el" href="cvmx-helper-pki_8h.html#af4aa68a69fe64abfbeb4904f245847a7">cvmx_helper_pki_no_dflt_init(int node)</a></li>
</ul>
<p>2) Configure/Modify PKI global parameters(if needed) by calling</p>
<ul>
<li><a class="el" href="cvmx-pki_8h.html#a6826d2ba257bf5c1a80e61c23016b7af" title="This function reads global configuration of PKI block.">cvmx_pki_read_global_config(int node, struct cvmx_pki_global_config *gbl_cfg)</a></li>
</ul>
<ul>
<li><a class="el" href="cvmx-pki_8h.html#a5338c761d00be6e06e57d4dd4e97ff49" title="This function writes global configuration of PKI into hw.">cvmx_pki_write_global_config(int node, struct cvmx_pki_global_config *gbl_cfg)</a></li>
</ul>
<ul>
<li>struct <a class="el" href="structcvmx__pki__global__config.html">cvmx_pki_global_config</a> contains all PKI global parameters which can be modified.</li>
</ul>
<p>3) Configure scheduling resources of interface/ports by calling api <a class="el" href="cvmx-helper-pki_8h.html#a3f2c0c4fda7390a4e7fb8ad280c16e66" title="This function sets up scheduling parameters (pool, aura, sso group etc) of an interface...">cvmx_helper_pki_init_interface(const int xiface, struct cvmx_pki_intf_schd *intfsch, struct cvmx_pki_global_schd *gblsch)</a></p>
<p>OR</p>
<p><a class="el" href="cvmx-helper-pki_8h.html#abffd668147b18397cdd1a43b4ff4649f" title="This function sets up scheduling parameters (pool, aura, sso group etc) of an ipd...">cvmx_helper_pki_init_port(int ipd_port, struct cvmx_pki_prt_schd *prtsch)</a></p>
<p>4) Modify port related parameter (if needed)) by calling <a class="el" href="cvmx-helper-pki_8h.html#ad6ad4195e1306276a8fd73b35c7e395c" title="This function gets all the PKI parameters related to that particular port from hardware...">cvmx_pki_get_port_config(int ipd_port, struct cvmx_pki_port_config *port_cfg)</a></p>
<p><a class="el" href="cvmx-helper-pki_8h.html#a1e96f7a2752913ea16bb5cd91f22493a" title="This function sets all the PKI parameters related to that particular port in hardware...">cvmx_pki_set_port_config(int ipd_port, struct cvmx_pki_port_config *port_cfg)</a></p>
<p>If only flow profile related parameters need to be modified and many ports are sharing same profile, parameters can be modified by calling <a class="el" href="cvmx-pki_8h.html#aede3b4678e60760ad0a21b2209ef5bb7" title="This function reads parameters associated with style in hardware.">cvmx_pki_read_style_config(int node, int style, uint64_t cluster_mask, struct cvmx_pki_style_config *style_cfg)</a></p>
<p><a class="el" href="cvmx-pki_8h.html#aede3b4678e60760ad0a21b2209ef5bb7" title="This function reads parameters associated with style in hardware.">cvmx_pki_read_style_config(int node, int style, uint64_t cluster_mask,struct cvmx_pki_style_config *style_cfg)</a></p>
<p>5) Install pcam entries (if needed) by calling cvmx_helper_pki_install_pcam_entry(int node, uint64_t cluster_mask, struct cvmx_pki_pcam_input input, struct cvmx_pki_pcam_action action)</p>
<p>6) Enable RED and/or backpressure (if needed) using:</p>
<p>cvmx_helper_pki_map_aura_chl_bpid(int node, uint16_t aura, uint16_t bpid, uint16_t chl_map[], uint16_t chl_cnt)</p>
<p>cvmx_helper_setup_aura_qos(int node, int aura, bool ena_red, bool ena_drop, uint64_t pass_thresh, uint64_t drop_thresh, bool ena_bp, uint64_t bp_thresh) follow the code/example in passthrough-pktio.c</p>
<p>7) Enable PKI to start processing packets by calling <a class="el" href="cvmx-helper-pki_8h.html#aab092dfe6850faf486d741ae67a24006" title="This function Enabled the PKI hardware to start accepting/processing packets.">cvmx_helper_pki_enable(int node)</a></p>
<h2><a class="anchor" id="cn78_multinode">
Multi-node data-types</a></h2>
<ul>
<li>SSO XGRP = (node &lt;&lt; 8) | lgrp == (node &lt;&lt; 8) | group &lt;&lt; 3 | qos</li>
<li>PKO ipd_port = (node &lt;&lt; 12) | chan_e</li>
<li>PKO: xqueue = (node &lt;&lt; 10) | dq</li>
<li>XIFACE = node &lt;&lt; 5 | local_iface</li>
</ul>
<p>Multinode mode on the cn78xx is implemented in 2 ways:</p>
<ul>
<li>Compatibility mode where all calls are assumed to target current node hardware<ul>
<li>Not all functionality is supported in compatibility mode, application instances are limited to a single node's cores, though communication can cross node boundaries via named-block memory.</li>
</ul>
</li>
<li>Native mode where calls take a target node argument.<ul>
<li>Limitations exist, while packets can be transmitted on any node's port by any core, packet reception and get_work is restricted to the local node (though add_work can be sent across node boundaries, work can only be received by a node's cores).</li>
</ul>
</li>
</ul>
<p>Loading executables on multiple nodes:</p>
<ul>
<li>bootoct has been modified to support multiple nodes on 78xx, the command takes additional arguments as follows: bootoct [addr] -nodemask=[nodemask to run on, ie 0x3 for nodes 0 and 1] -coremask=[coremask on node0],[coremask on node1]</li>
</ul>
<p>Execution on all nodes/cores will be suspended until node0/core0 has been booted, so coremask 0x1 must be specified last. </p>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Oct 2017 for Octeon Software Development Kit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
