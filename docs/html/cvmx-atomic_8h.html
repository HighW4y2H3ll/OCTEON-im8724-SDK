<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Octeon Software Development Kit: cvmx-atomic.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cvmx-atomic.h File Reference</h1>
<p>This file provides atomic operations.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="cvmx-asm_8h_source.html">cvmx-asm.h</a>&quot;</code><br/>
<div class="dynheader">
Include dependency graph for cvmx-atomic.h:</div>
<div class="dynsection">
<div class="center"><img src="cvmx-atomic_8h__incl.png" border="0" usemap="#cvmx-atomic_8h_map" alt=""/></div>
<map name="cvmx-atomic_8h_map" id="cvmx-atomic_8h">
<area shape="rect" id="node3" href="cvmx-asm_8h.html" title="This is file defines ASM primitives for the executive." alt="" coords="15,83,119,112"/></map>
</div>
<div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dynsection">
<div class="center"><img src="cvmx-atomic_8h__dep__incl.png" border="0" usemap="#cvmx-atomic_8hdep_map" alt=""/></div>
<map name="cvmx-atomic_8hdep_map" id="cvmx-atomic_8hdep">
<area shape="rect" id="node3" href="cvmx-app-init-linux_8c.html" title="Simple executive application initialization for Linux user space." alt="" coords="312,83,475,112"/><area shape="rect" id="node5" href="cvmx-cmd-queue_8h.html" title="Support functions for managing command queues used for various hardware blocks." alt="" coords="499,83,653,112"/><area shape="rect" id="node51" href="cvmx-error3_8c.html" title="Interface to the Octeon 78xx extended error status." alt="" coords="1465,83,1583,112"/><area shape="rect" id="node53" href="cvmx-interrupt_8c.html" title="Interface to the Mips interrupts." alt="" coords="1607,83,1743,112"/><area shape="rect" id="node55" href="cvmx-mbox_8c.html" title="Encapsulation of OCTEON mailbox interrupts." alt="" coords="1767,83,1881,112"/><area shape="rect" id="node57" href="cvmx-pki-resources_8c.html" title="PKI Support." alt="" coords="1905,83,2071,112"/><area shape="rect" id="node59" href="cvmx-pko3_8h.html" title="cvmx&#45;pko3.h" alt="" coords="1335,83,1441,112"/><area shape="rect" id="node75" href="cvmx-profiler_8c.html" title="Interface to event profiler." alt="" coords="2095,83,2217,112"/><area shape="rect" id="node77" href="cvmx-rwlock_8h.html" title="This file provides reader/writer locks." alt="" coords="2241,83,2359,112"/><area shape="rect" id="node79" href="cvmx-srio_8c.html" title="Interface to SRIO." alt="" coords="2383,83,2481,112"/><area shape="rect" id="node7" href="cvmx-bch_8c.html" title="Interface to the CN70XX, CN78XX hardware BCH engine." alt="" coords="373,160,475,189"/><area shape="rect" id="node9" href="cvmx-cmd-queue_8c.html" title="Support functions for managing command queues used for various hardware blocks." alt="" coords="499,160,653,189"/><area shape="rect" id="node11" href="cvmx-dma-engine_8c.html" title="Interface to the PCI / PCIe DMA engines." alt="" coords="677,160,835,189"/><area shape="rect" id="node13" href="cvmx-hfa_8c.html" title="Support library for the CN63XX, CN68XX hardware HFA engine." alt="" coords="5,160,104,189"/><area shape="rect" id="node15" href="cvmx-hwpko_8h.html" title="Interface to the hardware Packet Output unit." alt="" coords="859,160,976,189"/><area shape="rect" id="node47" href="cvmx-raid_8c.html" title="Interface to RAID block." alt="" coords="128,160,229,189"/><area shape="rect" id="node49" href="cvmx-zip_8c.html" title="Source file for the zip (deflate) block." alt="" coords="253,160,349,189"/><area shape="rect" id="node17" href="cvmx-helper-errata_8c.html" title="Fixes and workaround for Octeon chip errata." alt="" coords="35,237,200,267"/><area shape="rect" id="node19" href="cvmx-helper-ilk_8c.html" title="Functions for ILK initialization, configuration, and monitoring." alt="" coords="224,237,360,267"/><area shape="rect" id="node21" href="cvmx-helper-npi_8c.html" title="Functions for NPI initialization, configuration, and monitoring." alt="" coords="384,237,525,267"/><area shape="rect" id="node23" href="cvmx-helper-pko_8c.html" title="Helper Functions for the PKO." alt="" coords="549,237,696,267"/><area shape="rect" id="node25" href="cvmx-helper-rgmii_8c.html" title="Functions for RGMII/GMII/MII initialization, configuration, and monitoring." alt="" coords="720,237,875,267"/><area shape="rect" id="node27" href="cvmx-helper-util_8c.html" title="Small helper utilities." alt="" coords="899,237,1043,267"/><area shape="rect" id="node29" href="cvmx-ilk_8c.html" title="Support library for the ILK." alt="" coords="1067,237,1157,267"/><area shape="rect" id="node31" href="cvmx-pko_8h.html" title="cvmx&#45;pko.h" alt="" coords="1181,237,1280,267"/><area shape="rect" id="node43" href="cvmx-pko3_8c.html" title="cvmx&#45;pko3.c" alt="" coords="1421,237,1528,267"/><area shape="rect" id="node45" href="cvmx-spi_8c.html" title="Support library for the SPI." alt="" coords="1304,237,1397,267"/><area shape="rect" id="node33" href="cvmx-config-init_8c.html" title="cvmx&#45;config&#45;init.c" alt="" coords="933,315,1077,344"/><area shape="rect" id="node35" href="cvmx-helper-fpa_8c.html" title="Helper functions for FPA setup." alt="" coords="1101,315,1245,344"/><area shape="rect" id="node37" href="cvmx-helper_8c.html" title="Helper functions for common, but complicated tasks." alt="" coords="1392,315,1509,344"/><area shape="rect" id="node39" href="cvmx-pko_8c.html" title="Support library for the hardware Packet Output unit." alt="" coords="1269,315,1368,344"/><area shape="rect" id="node41" href="cvmx-pko3-compat_8c.html" title="cvmx&#45;pko3&#45;compat.c" alt="" coords="1533,315,1699,344"/><area shape="rect" id="node61" href="cvmx-app-init_8c.html" title="Main entry point for all simple executive based programs." alt="" coords="1653,160,1781,189"/><area shape="rect" id="node63" href="cvmx-helper-pko3_8c.html" title="cvmx&#45;helper&#45;pko3.c" alt="" coords="1805,160,1960,189"/><area shape="rect" id="node67" href="cvmx-lap_8c.html" title="Support library for the LAP." alt="" coords="1000,160,1096,189"/><area shape="rect" id="node70" href="cvmx-pko3-queue_8c.html" title="cvmx&#45;pko3&#45;queue.c" alt="" coords="1120,160,1275,189"/><area shape="rect" id="node72" href="cvmx-pko3-resources_8c.html" title="PKO resources." alt="" coords="1299,160,1477,189"/></map>
</div>

<p><a href="cvmx-atomic_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-atomic_8h.html#ad637de201109f338688d35f4c40f7894">cvmx_atomic_add32_nosync</a> (int32_t *ptr, int32_t incr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically adds a signed value to a 32 bit (aligned) memory location.  <a href="#ad637de201109f338688d35f4c40f7894"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-atomic_8h.html#a226d03216f99f4902c523214c9cc2ff8">cvmx_atomic_add32</a> (int32_t *ptr, int32_t incr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically adds a signed value to a 32 bit (aligned) memory location.  <a href="#a226d03216f99f4902c523214c9cc2ff8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-atomic_8h.html#a3425368e55465016bdc2ffab87ce193d">cvmx_atomic_set32</a> (int32_t *ptr, int32_t value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically sets a 32 bit (aligned) memory location to a value.  <a href="#a3425368e55465016bdc2ffab87ce193d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-atomic_8h.html#aa7b1ca9f0e98057920d2718b8956c3f1">cvmx_atomic_get32</a> (int32_t *ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current value of a 32 bit (aligned) memory location.  <a href="#aa7b1ca9f0e98057920d2718b8956c3f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-atomic_8h.html#a136f6a13f111afd1e6e085b7da7f3b25">cvmx_atomic_add64_nosync</a> (int64_t *ptr, int64_t incr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically adds a signed value to a 64 bit (aligned) memory location.  <a href="#a136f6a13f111afd1e6e085b7da7f3b25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-atomic_8h.html#a844232114ff475f27b7527534fc086a5">cvmx_atomic_add64</a> (int64_t *ptr, int64_t incr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically adds a signed value to a 64 bit (aligned) memory location.  <a href="#a844232114ff475f27b7527534fc086a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-atomic_8h.html#a0bffa06176a6d60b51e6b418add7b8a9">cvmx_atomic_set64</a> (int64_t *ptr, int64_t value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically sets a 64 bit (aligned) memory location to a value.  <a href="#a0bffa06176a6d60b51e6b418add7b8a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-atomic_8h.html#a45b8c1487940ecd78eaa4798ab21d2ff">cvmx_atomic_get64</a> (int64_t *ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current value of a 64 bit (aligned) memory location.  <a href="#a45b8c1487940ecd78eaa4798ab21d2ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-atomic_8h.html#ab4371a433f9e65123d7c3032011f9302">cvmx_atomic_compare_and_store32_nosync</a> (uint32_t *ptr, uint32_t old_val, uint32_t new_val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically compares the old value with the value at ptr, and if they match, stores new_val to ptr.  <a href="#ab4371a433f9e65123d7c3032011f9302"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-atomic_8h.html#a2cc2a03fa87ea299014a88b86da4ac3d">cvmx_atomic_compare_and_store32</a> (uint32_t *ptr, uint32_t old_val, uint32_t new_val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically compares the old value with the value at ptr, and if they match, stores new_val to ptr.  <a href="#a2cc2a03fa87ea299014a88b86da4ac3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-atomic_8h.html#ade1f3eddc797f6fbe35395190b8d3cef">cvmx_atomic_compare_and_store64_nosync</a> (uint64_t *ptr, uint64_t old_val, uint64_t new_val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically compares the old value with the value at ptr, and if they match, stores new_val to ptr.  <a href="#ade1f3eddc797f6fbe35395190b8d3cef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-atomic_8h.html#a9aa93efa06c486b86224ab7f600e8d67">cvmx_atomic_compare_and_store64</a> (uint64_t *ptr, uint64_t old_val, uint64_t new_val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically compares the old value with the value at ptr, and if they match, stores new_val to ptr.  <a href="#a9aa93efa06c486b86224ab7f600e8d67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-atomic_8h.html#a90c188af9576165639f961d9851524fe">cvmx_atomic_fetch_and_add64_nosync</a> (int64_t *ptr, int64_t incr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically adds a signed value to a 64 bit (aligned) memory location, and returns previous value.  <a href="#a90c188af9576165639f961d9851524fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-atomic_8h.html#a5435e1c89e5941540bd28e649b93b07d">cvmx_atomic_fetch_and_add64</a> (int64_t *ptr, int64_t incr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically adds a signed value to a 64 bit (aligned) memory location, and returns previous value.  <a href="#a5435e1c89e5941540bd28e649b93b07d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-atomic_8h.html#ad4b8c717c22d2f81e01a5d6c0ec13d02">cvmx_atomic_fetch_and_add32_nosync</a> (int32_t *ptr, int32_t incr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically adds a signed value to a 32 bit (aligned) memory location, and returns previous value.  <a href="#ad4b8c717c22d2f81e01a5d6c0ec13d02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-atomic_8h.html#a787b1e2651f6947b4d04fcc535453a00">cvmx_atomic_fetch_and_add32</a> (int32_t *ptr, int32_t incr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically adds a signed value to a 32 bit (aligned) memory location, and returns previous value.  <a href="#a787b1e2651f6947b4d04fcc535453a00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-atomic_8h.html#aaf432080dfadc4e2632b5a3aeb34a6ef">cvmx_atomic_fetch_and_bset64_nosync</a> (uint64_t *ptr, uint64_t mask)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically set bits in a 64 bit (aligned) memory location, and returns previous value.  <a href="#aaf432080dfadc4e2632b5a3aeb34a6ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-atomic_8h.html#a6b91f8d6be8f977c4b9f8f79be46a63e">cvmx_atomic_fetch_and_bset32_nosync</a> (uint32_t *ptr, uint32_t mask)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically set bits in a 32 bit (aligned) memory location, and returns previous value.  <a href="#a6b91f8d6be8f977c4b9f8f79be46a63e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-atomic_8h.html#a61677c4e502c30a2a87d687ec7722607">cvmx_atomic_fetch_and_bclr64_nosync</a> (uint64_t *ptr, uint64_t mask)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically clear bits in a 64 bit (aligned) memory location, and returns previous value.  <a href="#a61677c4e502c30a2a87d687ec7722607"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-atomic_8h.html#a00247062731044569233a068d3e4a39b">cvmx_atomic_fetch_and_bclr32_nosync</a> (uint32_t *ptr, uint32_t mask)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically clear bits in a 32 bit (aligned) memory location, and returns previous value.  <a href="#a00247062731044569233a068d3e4a39b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-atomic_8h.html#a160826daefbf1ae58e7dde53abea353b">cvmx_atomic_swap64_nosync</a> (uint64_t *ptr, uint64_t new_val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically swaps value in 64 bit (aligned) memory location, and returns previous value.  <a href="#a160826daefbf1ae58e7dde53abea353b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-atomic_8h.html#a31afe877d35e69d269fb29bcb63e84e4">cvmx_atomic_swap32_nosync</a> (uint32_t *ptr, uint32_t new_val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomically swaps value in 32 bit (aligned) memory location, and returns previous value.  <a href="#a31afe877d35e69d269fb29bcb63e84e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-atomic_8h.html#aee74f90d5ef5110b778fefe76cd03429">cvmx_atomic_get128</a> (void *ptr, int64_t *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current value of a 128 bit (aligned) memory location.  <a href="#aee74f90d5ef5110b778fefe76cd03429"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This file provides atomic operations. </p>
<hr/>
<dl class="rcs"><dt><b>Revision</b></dt><dd>142870 </dd></dl>
<hr/>
 <hr/><h2>Function Documentation</h2>
<a class="anchor" id="a226d03216f99f4902c523214c9cc2ff8"></a><!-- doxytag: member="cvmx&#45;atomic.h::cvmx_atomic_add32" ref="a226d03216f99f4902c523214c9cc2ff8" args="(int32_t *ptr, int32_t incr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_atomic_add32 </td>
          <td>(</td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>incr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomically adds a signed value to a 32 bit (aligned) memory location. </p>
<p>Memory access ordering is enforced before/after the atomic operation, so no additional 'sync' instructions are required.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>address in memory to add incr to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>incr</em>&nbsp;</td><td>amount to increment memory location by (signed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad637de201109f338688d35f4c40f7894"></a><!-- doxytag: member="cvmx&#45;atomic.h::cvmx_atomic_add32_nosync" ref="ad637de201109f338688d35f4c40f7894" args="(int32_t *ptr, int32_t incr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_atomic_add32_nosync </td>
          <td>(</td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>incr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomically adds a signed value to a 32 bit (aligned) memory location. </p>
<p>This version does not perform 'sync' operations to enforce memory operations. This should only be used when there are no memory operation ordering constraints. (This should NOT be used for reference counting - use the standard version instead.)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>address in memory to add incr to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>incr</em>&nbsp;</td><td>amount to increment memory location by (signed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a844232114ff475f27b7527534fc086a5"></a><!-- doxytag: member="cvmx&#45;atomic.h::cvmx_atomic_add64" ref="a844232114ff475f27b7527534fc086a5" args="(int64_t *ptr, int64_t incr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_atomic_add64 </td>
          <td>(</td>
          <td class="paramtype">int64_t *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>incr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomically adds a signed value to a 64 bit (aligned) memory location. </p>
<p>Memory access ordering is enforced before/after the atomic operation, so no additional 'sync' instructions are required.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>address in memory to add incr to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>incr</em>&nbsp;</td><td>amount to increment memory location by (signed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a136f6a13f111afd1e6e085b7da7f3b25"></a><!-- doxytag: member="cvmx&#45;atomic.h::cvmx_atomic_add64_nosync" ref="a136f6a13f111afd1e6e085b7da7f3b25" args="(int64_t *ptr, int64_t incr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_atomic_add64_nosync </td>
          <td>(</td>
          <td class="paramtype">int64_t *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>incr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomically adds a signed value to a 64 bit (aligned) memory location. </p>
<p>This version does not perform 'sync' operations to enforce memory operations. This should only be used when there are no memory operation ordering constraints. (This should NOT be used for reference counting - use the standard version instead.)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>address in memory to add incr to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>incr</em>&nbsp;</td><td>amount to increment memory location by (signed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2cc2a03fa87ea299014a88b86da4ac3d"></a><!-- doxytag: member="cvmx&#45;atomic.h::cvmx_atomic_compare_and_store32" ref="a2cc2a03fa87ea299014a88b86da4ac3d" args="(uint32_t *ptr, uint32_t old_val, uint32_t new_val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t cvmx_atomic_compare_and_store32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>old_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>new_val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomically compares the old value with the value at ptr, and if they match, stores new_val to ptr. </p>
<p>If *ptr and old don't match, function returns failure immediately. If *ptr and old match, function spins until *ptr updated to new atomically, or until *ptr and old no longer match</p>
<p>Does memory synchronization that is required to use this as a locking primitive.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 on success (match and store) 0 on no match </dd></dl>

</div>
</div>
<a class="anchor" id="ab4371a433f9e65123d7c3032011f9302"></a><!-- doxytag: member="cvmx&#45;atomic.h::cvmx_atomic_compare_and_store32_nosync" ref="ab4371a433f9e65123d7c3032011f9302" args="(uint32_t *ptr, uint32_t old_val, uint32_t new_val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t cvmx_atomic_compare_and_store32_nosync </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>old_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>new_val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomically compares the old value with the value at ptr, and if they match, stores new_val to ptr. </p>
<p>If *ptr and old don't match, function returns failure immediately. If *ptr and old match, function spins until *ptr updated to new atomically, or until *ptr and old no longer match</p>
<p>Does no memory synchronization.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 on success (match and store) 0 on no match </dd></dl>

</div>
</div>
<a class="anchor" id="a9aa93efa06c486b86224ab7f600e8d67"></a><!-- doxytag: member="cvmx&#45;atomic.h::cvmx_atomic_compare_and_store64" ref="a9aa93efa06c486b86224ab7f600e8d67" args="(uint64_t *ptr, uint64_t old_val, uint64_t new_val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t cvmx_atomic_compare_and_store64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>old_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>new_val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomically compares the old value with the value at ptr, and if they match, stores new_val to ptr. </p>
<p>If *ptr and old don't match, function returns failure immediately. If *ptr and old match, function spins until *ptr updated to new atomically, or until *ptr and old no longer match</p>
<p>Does memory synchronization that is required to use this as a locking primitive.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 on success (match and store) 0 on no match </dd></dl>

</div>
</div>
<a class="anchor" id="ade1f3eddc797f6fbe35395190b8d3cef"></a><!-- doxytag: member="cvmx&#45;atomic.h::cvmx_atomic_compare_and_store64_nosync" ref="ade1f3eddc797f6fbe35395190b8d3cef" args="(uint64_t *ptr, uint64_t old_val, uint64_t new_val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t cvmx_atomic_compare_and_store64_nosync </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>old_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>new_val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomically compares the old value with the value at ptr, and if they match, stores new_val to ptr. </p>
<p>If *ptr and old don't match, function returns failure immediately. If *ptr and old match, function spins until *ptr updated to new atomically, or until *ptr and old no longer match</p>
<p>Does no memory synchronization.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 on success (match and store) 0 on no match </dd></dl>

</div>
</div>
<a class="anchor" id="a787b1e2651f6947b4d04fcc535453a00"></a><!-- doxytag: member="cvmx&#45;atomic.h::cvmx_atomic_fetch_and_add32" ref="a787b1e2651f6947b4d04fcc535453a00" args="(int32_t *ptr, int32_t incr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t cvmx_atomic_fetch_and_add32 </td>
          <td>(</td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>incr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomically adds a signed value to a 32 bit (aligned) memory location, and returns previous value. </p>
<p>Memory access ordering is enforced before/after the atomic operation, so no additional 'sync' instructions are required.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>address in memory to add incr to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>incr</em>&nbsp;</td><td>amount to increment memory location by (signed)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value of memory location before increment </dd></dl>

</div>
</div>
<a class="anchor" id="ad4b8c717c22d2f81e01a5d6c0ec13d02"></a><!-- doxytag: member="cvmx&#45;atomic.h::cvmx_atomic_fetch_and_add32_nosync" ref="ad4b8c717c22d2f81e01a5d6c0ec13d02" args="(int32_t *ptr, int32_t incr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t cvmx_atomic_fetch_and_add32_nosync </td>
          <td>(</td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>incr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomically adds a signed value to a 32 bit (aligned) memory location, and returns previous value. </p>
<p>This version does not perform 'sync' operations to enforce memory operations. This should only be used when there are no memory operation ordering constraints. (This should NOT be used for reference counting - use the standard version instead.)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>address in memory to add incr to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>incr</em>&nbsp;</td><td>amount to increment memory location by (signed)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value of memory location before increment </dd></dl>

</div>
</div>
<a class="anchor" id="a5435e1c89e5941540bd28e649b93b07d"></a><!-- doxytag: member="cvmx&#45;atomic.h::cvmx_atomic_fetch_and_add64" ref="a5435e1c89e5941540bd28e649b93b07d" args="(int64_t *ptr, int64_t incr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int64_t cvmx_atomic_fetch_and_add64 </td>
          <td>(</td>
          <td class="paramtype">int64_t *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>incr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomically adds a signed value to a 64 bit (aligned) memory location, and returns previous value. </p>
<p>Memory access ordering is enforced before/after the atomic operation, so no additional 'sync' instructions are required.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>address in memory to add incr to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>incr</em>&nbsp;</td><td>amount to increment memory location by (signed)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value of memory location before increment </dd></dl>

</div>
</div>
<a class="anchor" id="a90c188af9576165639f961d9851524fe"></a><!-- doxytag: member="cvmx&#45;atomic.h::cvmx_atomic_fetch_and_add64_nosync" ref="a90c188af9576165639f961d9851524fe" args="(int64_t *ptr, int64_t incr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int64_t cvmx_atomic_fetch_and_add64_nosync </td>
          <td>(</td>
          <td class="paramtype">int64_t *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>incr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomically adds a signed value to a 64 bit (aligned) memory location, and returns previous value. </p>
<p>This version does not perform 'sync' operations to enforce memory operations. This should only be used when there are no memory operation ordering constraints. (This should NOT be used for reference counting - use the standard version instead.)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>address in memory to add incr to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>incr</em>&nbsp;</td><td>amount to increment memory location by (signed)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value of memory location before increment </dd></dl>

</div>
</div>
<a class="anchor" id="a00247062731044569233a068d3e4a39b"></a><!-- doxytag: member="cvmx&#45;atomic.h::cvmx_atomic_fetch_and_bclr32_nosync" ref="a00247062731044569233a068d3e4a39b" args="(uint32_t *ptr, uint32_t mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t cvmx_atomic_fetch_and_bclr32_nosync </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomically clear bits in a 32 bit (aligned) memory location, and returns previous value. </p>
<p>This version does not perform 'sync' operations to enforce memory operations. This should only be used when there are no memory operation ordering constraints.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>address in memory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>mask of bits to clear</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value of memory location before clearing bits </dd></dl>

</div>
</div>
<a class="anchor" id="a61677c4e502c30a2a87d687ec7722607"></a><!-- doxytag: member="cvmx&#45;atomic.h::cvmx_atomic_fetch_and_bclr64_nosync" ref="a61677c4e502c30a2a87d687ec7722607" args="(uint64_t *ptr, uint64_t mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t cvmx_atomic_fetch_and_bclr64_nosync </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomically clear bits in a 64 bit (aligned) memory location, and returns previous value. </p>
<p>This version does not perform 'sync' operations to enforce memory operations. This should only be used when there are no memory operation ordering constraints.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>address in memory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>mask of bits to clear</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value of memory location before clearing bits </dd></dl>

</div>
</div>
<a class="anchor" id="a6b91f8d6be8f977c4b9f8f79be46a63e"></a><!-- doxytag: member="cvmx&#45;atomic.h::cvmx_atomic_fetch_and_bset32_nosync" ref="a6b91f8d6be8f977c4b9f8f79be46a63e" args="(uint32_t *ptr, uint32_t mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t cvmx_atomic_fetch_and_bset32_nosync </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomically set bits in a 32 bit (aligned) memory location, and returns previous value. </p>
<p>This version does not perform 'sync' operations to enforce memory operations. This should only be used when there are no memory operation ordering constraints.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>address in memory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>mask of bits to set</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value of memory location before setting bits </dd></dl>

</div>
</div>
<a class="anchor" id="aaf432080dfadc4e2632b5a3aeb34a6ef"></a><!-- doxytag: member="cvmx&#45;atomic.h::cvmx_atomic_fetch_and_bset64_nosync" ref="aaf432080dfadc4e2632b5a3aeb34a6ef" args="(uint64_t *ptr, uint64_t mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t cvmx_atomic_fetch_and_bset64_nosync </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomically set bits in a 64 bit (aligned) memory location, and returns previous value. </p>
<p>This version does not perform 'sync' operations to enforce memory operations. This should only be used when there are no memory operation ordering constraints.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>address in memory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>mask of bits to set</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value of memory location before setting bits </dd></dl>

</div>
</div>
<a class="anchor" id="aee74f90d5ef5110b778fefe76cd03429"></a><!-- doxytag: member="cvmx&#45;atomic.h::cvmx_atomic_get128" ref="aee74f90d5ef5110b778fefe76cd03429" args="(void *ptr, int64_t *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int cvmx_atomic_get128 </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the current value of a 128 bit (aligned) memory location. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Address of memory to get  [out] data An array of two 64-bit words to hold the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error </dd></dl>

</div>
</div>
<a class="anchor" id="aa7b1ca9f0e98057920d2718b8956c3f1"></a><!-- doxytag: member="cvmx&#45;atomic.h::cvmx_atomic_get32" ref="aa7b1ca9f0e98057920d2718b8956c3f1" args="(int32_t *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t cvmx_atomic_get32 </td>
          <td>(</td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the current value of a 32 bit (aligned) memory location. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Address of memory to get </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value of the memory </dd></dl>

</div>
</div>
<a class="anchor" id="a45b8c1487940ecd78eaa4798ab21d2ff"></a><!-- doxytag: member="cvmx&#45;atomic.h::cvmx_atomic_get64" ref="a45b8c1487940ecd78eaa4798ab21d2ff" args="(int64_t *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int64_t cvmx_atomic_get64 </td>
          <td>(</td>
          <td class="paramtype">int64_t *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the current value of a 64 bit (aligned) memory location. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>Address of memory to get </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value of the memory </dd></dl>

</div>
</div>
<a class="anchor" id="a3425368e55465016bdc2ffab87ce193d"></a><!-- doxytag: member="cvmx&#45;atomic.h::cvmx_atomic_set32" ref="a3425368e55465016bdc2ffab87ce193d" args="(int32_t *ptr, int32_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_atomic_set32 </td>
          <td>(</td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomically sets a 32 bit (aligned) memory location to a value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>address of memory to set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value to set memory location to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0bffa06176a6d60b51e6b418add7b8a9"></a><!-- doxytag: member="cvmx&#45;atomic.h::cvmx_atomic_set64" ref="a0bffa06176a6d60b51e6b418add7b8a9" args="(int64_t *ptr, int64_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_atomic_set64 </td>
          <td>(</td>
          <td class="paramtype">int64_t *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomically sets a 64 bit (aligned) memory location to a value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>address of memory to set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>value to set memory location to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a31afe877d35e69d269fb29bcb63e84e4"></a><!-- doxytag: member="cvmx&#45;atomic.h::cvmx_atomic_swap32_nosync" ref="a31afe877d35e69d269fb29bcb63e84e4" args="(uint32_t *ptr, uint32_t new_val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t cvmx_atomic_swap32_nosync </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>new_val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomically swaps value in 32 bit (aligned) memory location, and returns previous value. </p>
<p>This version does not perform 'sync' operations to enforce memory operations. This should only be used when there are no memory operation ordering constraints.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>address in memory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_val</em>&nbsp;</td><td>new value to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value of memory location before swap operation </dd></dl>

</div>
</div>
<a class="anchor" id="a160826daefbf1ae58e7dde53abea353b"></a><!-- doxytag: member="cvmx&#45;atomic.h::cvmx_atomic_swap64_nosync" ref="a160826daefbf1ae58e7dde53abea353b" args="(uint64_t *ptr, uint64_t new_val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t cvmx_atomic_swap64_nosync </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>new_val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomically swaps value in 64 bit (aligned) memory location, and returns previous value. </p>
<p>This version does not perform 'sync' operations to enforce memory operations. This should only be used when there are no memory operation ordering constraints.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>address in memory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_val</em>&nbsp;</td><td>new value to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value of memory location before swap operation </dd></dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Oct 2017 for Octeon Software Development Kit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
