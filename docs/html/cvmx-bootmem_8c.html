<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Octeon Software Development Kit: cvmx-bootmem.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cvmx-bootmem.c File Reference</h1>
<p>Simple allocate only memory allocator.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="cvmx_8h_source.html">cvmx.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cvmx-bootmem_8h_source.html">cvmx-bootmem.h</a>&quot;</code><br/>
<div class="dynheader">
Include dependency graph for cvmx-bootmem.c:</div>
<div class="dynsection">
<div class="center"><img src="cvmx-bootmem_8c__incl.png" border="0" usemap="#cvmx-bootmem_8c_map" alt=""/></div>
<map name="cvmx-bootmem_8c_map" id="cvmx-bootmem_8c">
<area shape="rect" id="node3" href="cvmx_8h.html" title="Main Octeon executive header file (This should be the second header file included..." alt="" coords="1220,83,1289,112"/><area shape="rect" id="node113" href="cvmx-bootmem_8h.html" title="Simple allocate only memory allocator." alt="" coords="1313,83,1455,112"/><area shape="rect" id="node5" href="cvmx-platform_8h.html" title="This file is resposible for including all system dependent headers for the cvmx&#45;*..." alt="" coords="541,237,675,267"/><area shape="rect" id="node27" href="cvmx-access_8h.html" title="Function prototypes for accessing memory and CSRs on Octeon." alt="" coords="395,237,517,267"/><area shape="rect" id="node29" href="cvmx-address_8h.html" title="Typedefs and defines for working with Octeon physical addresses." alt="" coords="21,237,149,267"/><area shape="rect" id="node32" href="cvmx-asm_8h.html" title="This is file defines ASM primitives for the executive." alt="" coords="941,392,1045,421"/><area shape="rect" id="node34" href="cvmx-packet_8h.html" title="Packet buffer defines." alt="" coords="1328,160,1451,189"/><area shape="rect" id="node36" href="cvmx-warn_8h.html" title="Functions for warning users about errors and such." alt="" coords="1475,160,1584,189"/><area shape="rect" id="node38" href="cvmx-sysinfo_8h.html" title="This module provides system/board information obtained by the bootloader." alt="" coords="831,160,953,189"/><area shape="rect" id="node48" href="octeon-model_8h.html" title="File defining different Octeon model IDs and macros to compare them." alt="" coords="1608,160,1736,189"/><area shape="rect" id="node50" href="cvmx-csr_8h.html" title="Configuration and status register (CSR) address and type definitions for Octoen." alt="" coords="1085,160,1181,189"/><area shape="rect" id="node91" href="cvmx-utils_8h.html" title="Small utility functions and macros to ease programming of Octeon." alt="" coords="204,237,308,267"/><area shape="rect" id="node94" href="cvmx-clock_8h.html" title="Interface to Core, IO and DDR Clock." alt="" coords="1760,160,1869,189"/><area shape="rect" id="node97" href="octeon-feature_8h.html" title="File defining checks for different Octeon features." alt="" coords="1893,160,2032,189"/><area shape="rect" id="node99" href="cvmx-fpa_8h.html" title="Interface to the hardware Free Pool Allocator." alt="" coords="1205,160,1304,189"/><area shape="rect" id="node7" href="cvmx-abi_8h.html" title="This file defines macros for use in determining the current calling ABI." alt="" coords="5,315,101,344"/><area shape="rect" id="node40" href="cvmx-app-init_8h.html" title="Header file for simple executive application initialization." alt="" coords="879,237,1007,267"/><area shape="rect" id="node42" href="cvmx-coremask_8h.html" title="Module to support operations on bitmap of cores." alt="" coords="869,315,1011,344"/><area shape="rect" id="node53" href="cvmx-csr-enums_8h.html" title="Definitions for enumerations used with Octeon CSRs." alt="" coords="1085,237,1232,267"/><area shape="rect" id="node55" href="cvmx-csr-typedefs_8h.html" title="Configuration and status register (CSR) address and type definitions for Octeon." alt="" coords="2273,237,2436,267"/><area shape="rect" id="node57" href="cvmx-agl-defs_8h.html" title="cvmx&#45;agl&#45;defs.h" alt="" coords="2051,315,2181,344"/><area shape="rect" id="node59" href="cvmx-ase-defs_8h.html" title="cvmx&#45;ase&#45;defs.h" alt="" coords="2205,315,2341,344"/><area shape="rect" id="node61" href="cvmx-asxx-defs_8h.html" title="cvmx&#45;asxx&#45;defs.h" alt="" coords="2365,315,2507,344"/><area shape="rect" id="node63" href="cvmx-asx0-defs_8h.html" title="cvmx&#45;asx0&#45;defs.h" alt="" coords="2531,315,2672,344"/><area shape="rect" id="node65" href="cvmx-bbp-defs_8h.html" title="cvmx&#45;bbp&#45;defs.h" alt="" coords="2696,315,2832,344"/><area shape="rect" id="node67" href="cvmx-bbxa-defs_8h.html" title="cvmx&#45;bbxa&#45;defs.h" alt="" coords="2856,315,3000,344"/><area shape="rect" id="node69" href="cvmx-bbxbx-defs_8h.html" title="cvmx&#45;bbxbx&#45;defs.h" alt="" coords="3024,315,3176,344"/><area shape="rect" id="node71" href="cvmx-bbxc-defs_8h.html" title="cvmx&#45;bbxc&#45;defs.h" alt="" coords="3200,315,3344,344"/><area shape="rect" id="node73" href="cvmx-bch-defs_8h.html" title="cvmx&#45;bch&#45;defs.h" alt="" coords="3368,315,3504,344"/><area shape="rect" id="node75" href="cvmx-bgxx-defs_8h.html" title="cvmx&#45;bgxx&#45;defs.h" alt="" coords="3528,315,3672,344"/><area shape="rect" id="node77" href="cvmx-bts-defs_8h.html" title="cvmx&#45;bts&#45;defs.h" alt="" coords="1085,315,1219,344"/><area shape="rect" id="node79" href="cvmx-ciu2-defs_8h.html" title="cvmx&#45;ciu2&#45;defs.h" alt="" coords="1243,315,1381,344"/><area shape="rect" id="node81" href="cvmx-ciu3-defs_8h.html" title="cvmx&#45;ciu3&#45;defs.h" alt="" coords="1405,315,1544,344"/><area shape="rect" id="node83" href="cvmx-ciu-defs_8h.html" title="cvmx&#45;ciu&#45;defs.h" alt="" coords="1568,315,1699,344"/><area shape="rect" id="node85" href="cvmx-cprix-defs_8h.html" title="cvmx&#45;cprix&#45;defs.h" alt="" coords="1723,315,1867,344"/><area shape="rect" id="node87" href="cvmx-dbg-defs_8h.html" title="cvmx&#45;dbg&#45;defs.h" alt="" coords="1891,315,2027,344"/><area shape="rect" id="node89" href="cvmx-fpa-defs_8h.html" title="cvmx&#45;fpa&#45;defs.h" alt="" coords="3696,315,3829,344"/><area shape="rect" id="node101" href="cvmx-scratch_8h.html" title="This file provides support for the processor local scratch memory." alt="" coords="3853,315,3981,344"/><area shape="rect" id="node105" href="cvmx-fpa1_8h.html" title="Interface to the hardware Free Pool Allocator on Octeon chips." alt="" coords="3725,237,3832,267"/><area shape="rect" id="node109" href="cvmx-fpa3_8h.html" title="Interface to the CN78XX Free Pool Allocator, a.k.a." alt="" coords="3595,237,3701,267"/></map>
</div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#afa99ec4acc4ecb2dc3c2d05da15d0e3f">MAX</a>(a, b)&nbsp;&nbsp;&nbsp;(((a) &gt; (b)) ? (a) : (b))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a3acffbd305ee72dcd4593c0d8af64a4f">MIN</a>(a, b)&nbsp;&nbsp;&nbsp;(((a) &lt; (b)) ? (a) : (b))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#ab17db1ce34837b8a3249c6f0942fa8b1">ALIGN_ADDR_UP</a>(addr, align)&nbsp;&nbsp;&nbsp;(((addr) + (~(align))) &amp; (align))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a702b0dd1ac75146dd5ef8d96a5150588">SIZEOF_FIELD</a>(<a class="el" href="cvmx-coremask_8c.html#a7cc33a7fd56e1ab82f778fe3f0e88c25">s</a>, field)&nbsp;&nbsp;&nbsp;sizeof(((<a class="el" href="cvmx-coremask_8c.html#a7cc33a7fd56e1ab82f778fe3f0e88c25">s</a> *)NULL)-&gt;field)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This macro returns the size of a member of a structure.  <a href="#a702b0dd1ac75146dd5ef8d96a5150588"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a6244953e59857e1fb70d2a1d6fffa777">CVMX_BOOTMEM_DESC_GET_FIELD</a>(field)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This macro returns a member of the <a class="el" href="structcvmx__bootmem__desc__t.html">cvmx_bootmem_desc_t</a> structure.  <a href="#a6244953e59857e1fb70d2a1d6fffa777"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#ae360408beadc56e7ffbe1d304a01bcc2">CVMX_BOOTMEM_DESC_SET_FIELD</a>(field, value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This macro writes a member of the <a class="el" href="structcvmx__bootmem__desc__t.html">cvmx_bootmem_desc_t</a> structure.  <a href="#ae360408beadc56e7ffbe1d304a01bcc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a9211a9cb1caa384ba3bb5d0e3b51da15">CVMX_BOOTMEM_NAMED_GET_FIELD</a>(addr, field)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This macro returns a member of the cvmx_bootmem_named_block_desc_t structure.  <a href="#a9211a9cb1caa384ba3bb5d0e3b51da15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#aca3f388ddd7a97a5d7d6f5f6137f610f">CVMX_BOOTMEM_NAMED_SET_FIELD</a>(addr, field, value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This macro writes a member of the cvmx_bootmem_named_block_desc_t structure.  <a href="#aca3f388ddd7a97a5d7d6f5f6137f610f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a7f468deaeb0346f1c48954d83f249cf2">NEXT_OFFSET</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#abdce06ea1b6219f79ac1736d1a026cb3">SIZE_OFFSET</a>&nbsp;&nbsp;&nbsp;8</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#ac0f9bb757d8c4dee2d4b18f746344a45">__cvmx_bootmem_desc_get</a> (uint64_t base, int offset, int size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is the implementation of the get macros defined for individual structure members.  <a href="#ac0f9bb757d8c4dee2d4b18f746344a45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a16833fd49e5596ddbba511f3e97ce229">__cvmx_bootmem_desc_set</a> (uint64_t base, int offset, int size, uint64_t value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is the implementation of the set macros defined for individual structure members.  <a href="#a16833fd49e5596ddbba511f3e97ce229"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a9bdb25592a8c3cad87ee3e3dea8c82f8">__cvmx_bootmem_get_lock_addr</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function returns the address of the bootmem <a class="el" href="structdescriptor.html">descriptor</a> lock.  <a href="#a9bdb25592a8c3cad87ee3e3dea8c82f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a85a7ac7ecbbe74b3f50963092f6fdf68">CVMX_BOOTMEM_NAMED_GET_NAME</a> (uint64_t addr, char *str, int len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function retrieves the string name of a named block.  <a href="#a85a7ac7ecbbe74b3f50963092f6fdf68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a92d59ea9b1f4ae15525d78f3532b0c09">CVMX_BOOTMEM_NAMED_SET_NAME</a> (uint64_t addr, const char *str, int len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function stores the string name of a named block.  <a href="#a92d59ea9b1f4ae15525d78f3532b0c09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a8a637d2d1f7133c6580eabb45d293af6">cvmx_bootmem_phy_set_size</a> (uint64_t addr, uint64_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a6da5cc54f511c92be1baef638521eed8">cvmx_bootmem_phy_set_next</a> (uint64_t addr, uint64_t next)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#ab90819eb90220b954fed262e46a279bb">cvmx_bootmem_phy_get_size</a> (uint64_t addr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a28bd9cdef6cae1525cb2bafc034a86cb">cvmx_bootmem_phy_get_next</a> (uint64_t addr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#aeb2521d10a8d7ffd0c8901232af8d009">__cvmx_bootmem_check_version</a> (int exact_match)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the version information on the bootmem <a class="el" href="structdescriptor.html">descriptor</a>.  <a href="#aeb2521d10a8d7ffd0c8901232af8d009"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a419488e4547b963537a01b1749b0654b">__cvmx_bootmem_lock</a> (uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the low level bootmem <a class="el" href="structdescriptor.html">descriptor</a> lock.  <a href="#a419488e4547b963537a01b1749b0654b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#aaa7de3aa0ff1b8aee96f377e28aa315a">__cvmx_bootmem_unlock</a> (uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release the low level bootmem <a class="el" href="structdescriptor.html">descriptor</a> lock.  <a href="#aaa7de3aa0ff1b8aee96f377e28aa315a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a3d8e0c4a5865eb3b6e319c24c295d7f6">__cvmx_validate_mem_range</a> (uint64_t *min_addr_ptr, uint64_t *max_addr_ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#ace5afa0dca0a8460e4c4f927da72a22d">cvmx_bootmem_phy_alloc_range</a> (uint64_t size, uint64_t alignment, uint64_t min_addr, uint64_t max_addr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a5f1db600138f2c00bc9e34e15a585e60">cvmx_bootmem_alloc_range</a> (uint64_t size, uint64_t alignment, uint64_t min_addr, uint64_t max_addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of memory from the free list that was passed to the application by the bootloader within a specified address range.  <a href="#a5f1db600138f2c00bc9e34e15a585e60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#af537b32e203533f1c02137b2c9c7cbdf">EXPORT_SYMBOL</a> (cvmx_bootmem_alloc_range)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a1aeeabcff132e8b9152bf5fa69068b87">cvmx_bootmem_alloc_address</a> (uint64_t size, uint64_t address, uint64_t alignment)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of memory from the free list that was passed to the application by the bootloader at a specific address.  <a href="#a1aeeabcff132e8b9152bf5fa69068b87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a918fa07da4cdfaf9e8c09edd9eacf027">cvmx_bootmem_alloc_node</a> (uint64_t node, uint64_t size, uint64_t alignment)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of memory from the free list that was passed to the application by the bootloader from a specific node.  <a href="#a918fa07da4cdfaf9e8c09edd9eacf027"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#aad42377e67e844646a53e5b2ed9fdcce">EXPORT_SYMBOL</a> (cvmx_bootmem_alloc_node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a4295ccfec5aeb9b415c92fbbb1f5873e">cvmx_bootmem_alloc</a> (uint64_t size, uint64_t alignment)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of memory from the free list that was passed to the application by the bootloader.  <a href="#a4295ccfec5aeb9b415c92fbbb1f5873e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#ab68096d5b3fd193c9d08dab9110af45f">EXPORT_SYMBOL</a> (cvmx_bootmem_alloc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a287cdc81b2cc4249792c199242096b32">cvmx_bootmem_alloc_named_range_once</a> (uint64_t size, uint64_t min_addr, uint64_t max_addr, uint64_t align, const char *name, void(*init)(void *))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate if needed a block of memory from a specific range of the free list that was passed to the application by the bootloader, and assign it a name in the global named block table.  <a href="#a287cdc81b2cc4249792c199242096b32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a85fbabe6a04ac971b7d7611a0d7fddbf">EXPORT_SYMBOL</a> (cvmx_bootmem_alloc_named_range_once)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#ad4d863b8a85601d6f2d9e62428a1a29c">cvmx_bootmem_alloc_named_range_flags</a> (uint64_t size, uint64_t min_addr, uint64_t max_addr, uint64_t align, const char *name, uint32_t flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a9e6982b83394b6e740b938ed540d3cb1">cvmx_bootmem_alloc_named_range</a> (uint64_t size, uint64_t min_addr, uint64_t max_addr, uint64_t align, const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of memory from a specific range of the free list that was passed to the application by the bootloader, and assign it a name in the global named block table.  <a href="#a9e6982b83394b6e740b938ed540d3cb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a30d21e76d1041d8ffbc92858e4008379">cvmx_bootmem_alloc_named_address</a> (uint64_t size, uint64_t address, const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of memory from the free list that was passed to the application by the bootloader, and assign it a name in the global named block table.  <a href="#a30d21e76d1041d8ffbc92858e4008379"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#ab787a63a038bd4e79d3b80f832b361f9">cvmx_bootmem_alloc_named</a> (uint64_t size, uint64_t alignment, const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of memory from the free list that was passed to the application by the bootloader, and assign it a name in the global named block table.  <a href="#ab787a63a038bd4e79d3b80f832b361f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a88c92a0277cfce15ae750bd32e66ed0a">cvmx_bootmem_alloc_named_flags</a> (uint64_t size, uint64_t alignment, const char *name, uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of memory from the free list that was passed to the application by the bootloader, and assign it a name in the global named block table.  <a href="#a88c92a0277cfce15ae750bd32e66ed0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a23f7f64bfd97df4d95ae8c935f2302ac">EXPORT_SYMBOL</a> (cvmx_bootmem_alloc_named_flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#aad826d085ebf8a452e6120be2579c8bb">cvmx_bootmem_free_named</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees a previously allocated named bootmem block.  <a href="#aad826d085ebf8a452e6120be2579c8bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a312de4edda8e63091737f6bd0ed2201d">EXPORT_SYMBOL</a> (cvmx_bootmem_free_named)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <br class="typebreak"/>
<a class="el" href="structcvmx__bootmem__named__block__desc.html">cvmx_bootmem_named_block_desc_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a52c7783f31f4ec239effb1493cf26ca3">__cvmx_bootmem_find_named_block_flags</a> (const char *name, uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a named block with flags.  <a href="#a52c7783f31f4ec239effb1493cf26ca3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <br class="typebreak"/>
<a class="el" href="structcvmx__bootmem__named__block__desc.html">cvmx_bootmem_named_block_desc_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a91ab83d95ecdc1fce1a0d32d09aaab9b">cvmx_bootmem_find_named_block</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds a named bootmem block by name.  <a href="#a91ab83d95ecdc1fce1a0d32d09aaab9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a0ac92506e2e37f06355b6be5888f84b2">EXPORT_SYMBOL</a> (cvmx_bootmem_find_named_block)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a307ac29a8eda478a2c7b7f88fb29ba14">cvmx_bootmem_print_named</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints out the list of named blocks that have been allocated along with their addresses and sizes.  <a href="#a307ac29a8eda478a2c7b7f88fb29ba14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#acdcc9ba322d4fc16a8a1099b59445901">cvmx_bootmem_init</a> (uint64_t mem_desc_addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the boot alloc memory structures.  <a href="#acdcc9ba322d4fc16a8a1099b59445901"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a6b2363b2a5328771ab156f8081fbc53b">cvmx_bootmem_available_mem</a> (uint64_t min_block_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size of available memory in bytes, only counting blocks that are at least as big as the minimum block size.  <a href="#a6b2363b2a5328771ab156f8081fbc53b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a05957d11119b4bd7b75623a209043fa2">cvmx_bootmem_phy_alloc</a> (uint64_t req_size, uint64_t address_min, uint64_t address_max, uint64_t alignment, uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates a block of physical memory from the free list, at (optional) requested address and alignment.  <a href="#a05957d11119b4bd7b75623a209043fa2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a4e0316bb1cdb654122be084dce233757">__cvmx_bootmem_phy_free</a> (uint64_t phy_addr, uint64_t size, uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees a block to the bootmem allocator list.  <a href="#a4e0316bb1cdb654122be084dce233757"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#aacc63c0743db73855b502bf0fdd9f0c4">cvmx_bootmem_phy_list_print</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints the list of available memory.  <a href="#aacc63c0743db73855b502bf0fdd9f0c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a4d5b3fa2c531740d9ff3adef43fba6c9">cvmx_bootmem_phy_available_mem</a> (uint64_t min_block_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size of available memory in bytes, only counting blocks that are at least as big as the minimum block size.  <a href="#a4d5b3fa2c531740d9ff3adef43fba6c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a3275ade53d91556abc9d46247211fca4">cvmx_bootmem_phy_named_block_find</a> (const char *name, uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds a named memory block by name.  <a href="#a3275ade53d91556abc9d46247211fca4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a7457209ef2001be22938846c4c3f114b">cvmx_bootmem_phy_named_block_free</a> (const char *name, uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees a named block.  <a href="#a7457209ef2001be22938846c4c3f114b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a33a73dcc74933f5701804d0b51129ba6">cvmx_bootmem_phy_named_block_alloc</a> (uint64_t size, uint64_t min_addr, uint64_t max_addr, uint64_t alignment, const char *name, uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates a named block of physical memory from the free list, at (optional) requested address and alignment.  <a href="#a33a73dcc74933f5701804d0b51129ba6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a0588c4ceaf1b0e2f8c432911bc44b473">cvmx_bootmem_phy_named_block_print</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints the list of currently allocated named blocks.  <a href="#a0588c4ceaf1b0e2f8c432911bc44b473"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a38b5caabc1a679454ef07c9cf66c63c8">cvmx_bootmem_phy_mem_list_init</a> (uint64_t mem_size, uint32_t low_reserved_bytes, <a class="el" href="structcvmx__bootmem__desc__t.html">cvmx_bootmem_desc_t</a> *desc_buffer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function initializes the free memory list used by cvmx_bootmem.  <a href="#a38b5caabc1a679454ef07c9cf66c63c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a11218b1c21d4b0144d03ba8d42ab9179">cvmx_bootmem_phy_mem_list_init_multi</a> (uint8_t node_mask, uint32_t mem_sizes[], uint32_t low_reserved_bytes, <a class="el" href="structcvmx__bootmem__desc__t.html">cvmx_bootmem_desc_t</a> *desc_buffer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function initializes the free memory list used by cvmx_bootmem.  <a href="#a11218b1c21d4b0144d03ba8d42ab9179"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#acf313732820de4a5b08256b087212248">cvmx_bootmem_reserve_memory</a> (uint64_t start_addr, uint64_t size, const char *name, uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate all free memory starting at the start address.  <a href="#acf313732820de4a5b08256b087212248"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#aeb7a12587438b8e735032074a2b2b0a5">cvmx_bootmem_lock</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locks the bootmem allocator.  <a href="#aeb7a12587438b8e735032074a2b2b0a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#ae4e803936d44fb5d31bc52451fe27321">cvmx_bootmem_unlock</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlocks the bootmem allocator.  <a href="#ae4e803936d44fb5d31bc52451fe27321"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a034e3f5bd429e2e0fd58cb3d4fd3fd16">__cvmx_phys_addr_to_ptr</a> (uint64_t phys, int size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal use.  <a href="#a034e3f5bd429e2e0fd58cb3d4fd3fd16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#ae8b6ba700574be9b74e7a6ac7ed07bca">__cvmx_bootmem_internal_get_desc_ptr</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal use function to get the current <a class="el" href="structdescriptor.html">descriptor</a> pointer.  <a href="#ae8b6ba700574be9b74e7a6ac7ed07bca"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static CVMX_SHARED uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8c.html#a2de9f2b56f3cadd9486fdf9af858fffe">cvmx_bootmem_desc_addr</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the physical location of a <a class="el" href="structcvmx__bootmem__desc__t.html">cvmx_bootmem_desc_t</a> structure in Octeon's memory.  <a href="#a2de9f2b56f3cadd9486fdf9af858fffe"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Simple allocate only memory allocator. </p>
<p>Used to allocate memory at application start time.</p>
<hr/>
<dl class="rcs"><dt><b>Revision</b></dt><dd>156174 </dd></dl>
<hr/>
 <hr/><h2>Define Documentation</h2>
<a class="anchor" id="ab17db1ce34837b8a3249c6f0942fa8b1"></a><!-- doxytag: member="cvmx&#45;bootmem.c::ALIGN_ADDR_UP" ref="ab17db1ce34837b8a3249c6f0942fa8b1" args="(addr, align)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ALIGN_ADDR_UP</td>
          <td>(</td>
          <td class="paramtype">addr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">align&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(((addr) + (~(align))) &amp; (align))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6244953e59857e1fb70d2a1d6fffa777"></a><!-- doxytag: member="cvmx&#45;bootmem.c::CVMX_BOOTMEM_DESC_GET_FIELD" ref="a6244953e59857e1fb70d2a1d6fffa777" args="(field)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CVMX_BOOTMEM_DESC_GET_FIELD</td>
          <td>(</td>
          <td class="paramtype">field&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="cvmx-bootmem_8c.html#ac0f9bb757d8c4dee2d4b18f746344a45" title="This function is the implementation of the get macros defined for individual structure...">__cvmx_bootmem_desc_get</a>(<a class="code" href="cvmx-bootmem_8c.html#a2de9f2b56f3cadd9486fdf9af858fffe" title="This is the physical location of a cvmx_bootmem_desc_t structure in Octeon&amp;#39;s...">cvmx_bootmem_desc_addr</a>,         \
        offsetof(<a class="code" href="structcvmx__bootmem__desc__t.html">cvmx_bootmem_desc_t</a>, field),           \
        <a class="code" href="cvmx-bootmem_8c.html#a702b0dd1ac75146dd5ef8d96a5150588" title="This macro returns the size of a member of a structure.">SIZEOF_FIELD</a>(<a class="code" href="structcvmx__bootmem__desc__t.html">cvmx_bootmem_desc_t</a>, field))
</pre></div>
<p>This macro returns a member of the <a class="el" href="structcvmx__bootmem__desc__t.html">cvmx_bootmem_desc_t</a> structure. </p>
<p>These members can't be directly addressed as they might be in memory not directly reachable. In the case where bootmem is compiled with LINUX_HOST, the structure itself might be located on a remote Octeon. The argument "field" is the member name of the <a class="el" href="structcvmx__bootmem__desc__t.html">cvmx_bootmem_desc_t</a> to read. Regardless of the type of the field, the return type is always a uint64_t. </p>

</div>
</div>
<a class="anchor" id="ae360408beadc56e7ffbe1d304a01bcc2"></a><!-- doxytag: member="cvmx&#45;bootmem.c::CVMX_BOOTMEM_DESC_SET_FIELD" ref="ae360408beadc56e7ffbe1d304a01bcc2" args="(field, value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CVMX_BOOTMEM_DESC_SET_FIELD</td>
          <td>(</td>
          <td class="paramtype">field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="cvmx-bootmem_8c.html#a16833fd49e5596ddbba511f3e97ce229" title="This function is the implementation of the set macros defined for individual structure...">__cvmx_bootmem_desc_set</a>(<a class="code" href="cvmx-bootmem_8c.html#a2de9f2b56f3cadd9486fdf9af858fffe" title="This is the physical location of a cvmx_bootmem_desc_t structure in Octeon&amp;#39;s...">cvmx_bootmem_desc_addr</a>,         \
        offsetof(<a class="code" href="structcvmx__bootmem__desc__t.html">cvmx_bootmem_desc_t</a>, field),           \
        <a class="code" href="cvmx-bootmem_8c.html#a702b0dd1ac75146dd5ef8d96a5150588" title="This macro returns the size of a member of a structure.">SIZEOF_FIELD</a>(<a class="code" href="structcvmx__bootmem__desc__t.html">cvmx_bootmem_desc_t</a>, field), value)
</pre></div>
<p>This macro writes a member of the <a class="el" href="structcvmx__bootmem__desc__t.html">cvmx_bootmem_desc_t</a> structure. </p>
<p>These members can't be directly addressed as they might be in memory not directly reachable. In the case where bootmem is compiled with LINUX_HOST, the structure itself might be located on a remote Octeon. The argument "field" is the member name of the <a class="el" href="structcvmx__bootmem__desc__t.html">cvmx_bootmem_desc_t</a> to write. </p>

</div>
</div>
<a class="anchor" id="a9211a9cb1caa384ba3bb5d0e3b51da15"></a><!-- doxytag: member="cvmx&#45;bootmem.c::CVMX_BOOTMEM_NAMED_GET_FIELD" ref="a9211a9cb1caa384ba3bb5d0e3b51da15" args="(addr, field)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CVMX_BOOTMEM_NAMED_GET_FIELD</td>
          <td>(</td>
          <td class="paramtype">addr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">field&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="cvmx-bootmem_8c.html#ac0f9bb757d8c4dee2d4b18f746344a45" title="This function is the implementation of the get macros defined for individual structure...">__cvmx_bootmem_desc_get</a>(addr,                   \
        offsetof(<a class="code" href="structcvmx__bootmem__named__block__desc.html">cvmx_bootmem_named_block_desc_t</a>, field),   \
        <a class="code" href="cvmx-bootmem_8c.html#a702b0dd1ac75146dd5ef8d96a5150588" title="This macro returns the size of a member of a structure.">SIZEOF_FIELD</a>(<a class="code" href="structcvmx__bootmem__named__block__desc.html">cvmx_bootmem_named_block_desc_t</a>, field))
</pre></div>
<p>This macro returns a member of the cvmx_bootmem_named_block_desc_t structure. </p>
<p>These members can't be directly addressed as they might be in memory not directly reachable. In the case where bootmem is compiled with LINUX_HOST, the structure itself might be located on a remote Octeon. The argument "field" is the member name of the cvmx_bootmem_named_block_desc_t to read. Regardless of the type of the field, the return type is always a uint64_t. The "addr" parameter is the physical address of the structure. </p>

</div>
</div>
<a class="anchor" id="aca3f388ddd7a97a5d7d6f5f6137f610f"></a><!-- doxytag: member="cvmx&#45;bootmem.c::CVMX_BOOTMEM_NAMED_SET_FIELD" ref="aca3f388ddd7a97a5d7d6f5f6137f610f" args="(addr, field, value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CVMX_BOOTMEM_NAMED_SET_FIELD</td>
          <td>(</td>
          <td class="paramtype">addr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="cvmx-bootmem_8c.html#a16833fd49e5596ddbba511f3e97ce229" title="This function is the implementation of the set macros defined for individual structure...">__cvmx_bootmem_desc_set</a>(addr,                   \
        offsetof(<a class="code" href="structcvmx__bootmem__named__block__desc.html">cvmx_bootmem_named_block_desc_t</a>, field),   \
        <a class="code" href="cvmx-bootmem_8c.html#a702b0dd1ac75146dd5ef8d96a5150588" title="This macro returns the size of a member of a structure.">SIZEOF_FIELD</a>(<a class="code" href="structcvmx__bootmem__named__block__desc.html">cvmx_bootmem_named_block_desc_t</a>, field), value)
</pre></div>
<p>This macro writes a member of the cvmx_bootmem_named_block_desc_t structure. </p>
<p>These members can't be directly addressed as they might be in memory not directly reachable. In the case where bootmem is compiled with LINUX_HOST, the structure itself might be located on a remote Octeon. The argument "field" is the member name of the cvmx_bootmem_named_block_desc_t to write. The "addr" parameter is the physical address of the structure. </p>

</div>
</div>
<a class="anchor" id="afa99ec4acc4ecb2dc3c2d05da15d0e3f"></a><!-- doxytag: member="cvmx&#45;bootmem.c::MAX" ref="afa99ec4acc4ecb2dc3c2d05da15d0e3f" args="(a, b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX</td>
          <td>(</td>
          <td class="paramtype">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">b&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(((a) &gt; (b)) ? (a) : (b))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3acffbd305ee72dcd4593c0d8af64a4f"></a><!-- doxytag: member="cvmx&#45;bootmem.c::MIN" ref="a3acffbd305ee72dcd4593c0d8af64a4f" args="(a, b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIN</td>
          <td>(</td>
          <td class="paramtype">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">b&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(((a) &lt; (b)) ? (a) : (b))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7f468deaeb0346f1c48954d83f249cf2"></a><!-- doxytag: member="cvmx&#45;bootmem.c::NEXT_OFFSET" ref="a7f468deaeb0346f1c48954d83f249cf2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NEXT_OFFSET&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abdce06ea1b6219f79ac1736d1a026cb3"></a><!-- doxytag: member="cvmx&#45;bootmem.c::SIZE_OFFSET" ref="abdce06ea1b6219f79ac1736d1a026cb3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIZE_OFFSET&nbsp;&nbsp;&nbsp;8</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a702b0dd1ac75146dd5ef8d96a5150588"></a><!-- doxytag: member="cvmx&#45;bootmem.c::SIZEOF_FIELD" ref="a702b0dd1ac75146dd5ef8d96a5150588" args="(s, field)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIZEOF_FIELD</td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cvmx-coremask_8c.html#a7cc33a7fd56e1ab82f778fe3f0e88c25">s</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">field&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;sizeof(((<a class="el" href="cvmx-coremask_8c.html#a7cc33a7fd56e1ab82f778fe3f0e88c25">s</a> *)NULL)-&gt;field)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This macro returns the size of a member of a structure. </p>
<p>Logically it is the same as "sizeof(s::field)" in C++, but C lacks the "::" operator. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aeb2521d10a8d7ffd0c8901232af8d009"></a><!-- doxytag: member="cvmx&#45;bootmem.c::__cvmx_bootmem_check_version" ref="aeb2521d10a8d7ffd0c8901232af8d009" args="(int exact_match)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int __cvmx_bootmem_check_version </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>exact_match</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check the version information on the bootmem <a class="el" href="structdescriptor.html">descriptor</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>exact_match</em>&nbsp;</td><td>Exact major version to check against. A zero means check that the version supports named blocks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Zero if the version is correct. Negative if the version is incorrect. Failures also cause a message to be displayed. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0f9bb757d8c4dee2d4b18f746344a45"></a><!-- doxytag: member="cvmx&#45;bootmem.c::__cvmx_bootmem_desc_get" ref="ac0f9bb757d8c4dee2d4b18f746344a45" args="(uint64_t base, int offset, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t __cvmx_bootmem_desc_get </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function is the implementation of the get macros defined for individual structure members. </p>
<p>The argument are generated by the macros inorder to read only the needed memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>base</em>&nbsp;</td><td>64bit physical address of the complete structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>Offset from the beginning of the structure to the member being accessed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the structure member.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value of the structure member promoted into a uint64_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a16833fd49e5596ddbba511f3e97ce229"></a><!-- doxytag: member="cvmx&#45;bootmem.c::__cvmx_bootmem_desc_set" ref="a16833fd49e5596ddbba511f3e97ce229" args="(uint64_t base, int offset, int size, uint64_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void __cvmx_bootmem_desc_set </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function is the implementation of the set macros defined for individual structure members. </p>
<p>The argument are generated by the macros in order to write only the needed memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>base</em>&nbsp;</td><td>64bit physical address of the complete structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>Offset from the beginning of the structure to the member being accessed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the structure member. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value to write into the structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a52c7783f31f4ec239effb1493cf26ca3"></a><!-- doxytag: member="cvmx&#45;bootmem.c::__cvmx_bootmem_find_named_block_flags" ref="a52c7783f31f4ec239effb1493cf26ca3" args="(const char *name, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structcvmx__bootmem__named__block__desc.html">cvmx_bootmem_named_block_desc_t</a>* __cvmx_bootmem_find_named_block_flags </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find a named block with flags. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>is the block name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>indicates the need to use locking during search </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to named block <a class="el" href="structdescriptor.html">descriptor</a></dd></dl>
<p>Note: this function returns a pointer to a static structure, and is therefore not re-entrant. Making this function re-entrant will break backward compatibility. </p>

</div>
</div>
<a class="anchor" id="a9bdb25592a8c3cad87ee3e3dea8c82f8"></a><!-- doxytag: member="cvmx&#45;bootmem.c::__cvmx_bootmem_get_lock_addr" ref="a9bdb25592a8c3cad87ee3e3dea8c82f8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t __cvmx_bootmem_get_lock_addr </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function returns the address of the bootmem <a class="el" href="structdescriptor.html">descriptor</a> lock. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>64-bit address in KSEG0 of the bootmem <a class="el" href="structdescriptor.html">descriptor</a> block </dd></dl>

</div>
</div>
<a class="anchor" id="ae8b6ba700574be9b74e7a6ac7ed07bca"></a><!-- doxytag: member="cvmx&#45;bootmem.c::__cvmx_bootmem_internal_get_desc_ptr" ref="ae8b6ba700574be9b74e7a6ac7ed07bca" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* __cvmx_bootmem_internal_get_desc_ptr </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal use function to get the current <a class="el" href="structdescriptor.html">descriptor</a> pointer. </p>

</div>
</div>
<a class="anchor" id="a419488e4547b963537a01b1749b0654b"></a><!-- doxytag: member="cvmx&#45;bootmem.c::__cvmx_bootmem_lock" ref="a419488e4547b963537a01b1749b0654b" args="(uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void __cvmx_bootmem_lock </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the low level bootmem <a class="el" href="structdescriptor.html">descriptor</a> lock. </p>
<p>If no locking is specified in the flags, then nothing is done.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>CVMX_BOOTMEM_FLAG_NO_LOCKING means this functions should do nothing. This is used to support nested bootmem calls. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4e0316bb1cdb654122be084dce233757"></a><!-- doxytag: member="cvmx&#45;bootmem.c::__cvmx_bootmem_phy_free" ref="a4e0316bb1cdb654122be084dce233757" args="(uint64_t phy_addr, uint64_t size, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __cvmx_bootmem_phy_free </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>phy_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees a block to the bootmem allocator list. </p>
<p>This must be used with care, as the size provided must match the size of the block that was allocated, or the list will become corrupted.</p>
<p>IMPORTANT: This is only intended to be used as part of named block frees and initial population of the free memory list. *</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>phy_addr</em>&nbsp;</td><td>physical address of block </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>size of block in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>flags for passing options</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 on success, 0 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="aaa7de3aa0ff1b8aee96f377e28aa315a"></a><!-- doxytag: member="cvmx&#45;bootmem.c::__cvmx_bootmem_unlock" ref="aaa7de3aa0ff1b8aee96f377e28aa315a" args="(uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void __cvmx_bootmem_unlock </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release the low level bootmem <a class="el" href="structdescriptor.html">descriptor</a> lock. </p>
<p>If no locking is specified in the flags, then nothing is done.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>CVMX_BOOTMEM_FLAG_NO_LOCKING means this functions should do nothing. This is used to support nested bootmem calls. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a034e3f5bd429e2e0fd58cb3d4fd3fd16"></a><!-- doxytag: member="cvmx&#45;bootmem.c::__cvmx_phys_addr_to_ptr" ref="a034e3f5bd429e2e0fd58cb3d4fd3fd16" args="(uint64_t phys, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* __cvmx_phys_addr_to_ptr </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>phys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal use. </p>
<p>This is userd to get a pointer to a physical address. For linux n32 the physical address in mmaped to a virtual address and the virtual address is returned. For n64 the address is converted to an xkphys address and the xkhpys address is returned. </p>

</div>
</div>
<a class="anchor" id="a3d8e0c4a5865eb3b6e319c24c295d7f6"></a><!-- doxytag: member="cvmx&#45;bootmem.c::__cvmx_validate_mem_range" ref="a3d8e0c4a5865eb3b6e319c24c295d7f6" args="(uint64_t *min_addr_ptr, uint64_t *max_addr_ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int __cvmx_validate_mem_range </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&nbsp;</td>
          <td class="paramname"> <em>min_addr_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&nbsp;</td>
          <td class="paramname"> <em>max_addr_ptr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4295ccfec5aeb9b415c92fbbb1f5873e"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_alloc" ref="a4295ccfec5aeb9b415c92fbbb1f5873e" args="(uint64_t size, uint64_t alignment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cvmx_bootmem_alloc </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>alignment</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a block of memory from the free list that was passed to the application by the bootloader. </p>
<p>This is an allocate-only algorithm, so freeing memory is not possible.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size in bytes of block to allocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alignment</em>&nbsp;</td><td>Alignment required - must be power of 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to block of memory, NULL on error </dd></dl>

</div>
</div>
<a class="anchor" id="a1aeeabcff132e8b9152bf5fa69068b87"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_alloc_address" ref="a1aeeabcff132e8b9152bf5fa69068b87" args="(uint64_t size, uint64_t address, uint64_t alignment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cvmx_bootmem_alloc_address </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>alignment</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a block of memory from the free list that was passed to the application by the bootloader at a specific address. </p>
<p>This is an allocate-only algorithm, so freeing memory is not possible. Allocation will fail if memory cannot be allocated at the specified address.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size in bytes of block to allocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>address</em>&nbsp;</td><td>Physical address to allocate memory at. If this memory is not available, the allocation fails. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alignment</em>&nbsp;</td><td>Alignment required - must be power of 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to block of memory, NULL on error </dd></dl>

</div>
</div>
<a class="anchor" id="ab787a63a038bd4e79d3b80f832b361f9"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_alloc_named" ref="ab787a63a038bd4e79d3b80f832b361f9" args="(uint64_t size, uint64_t alignment, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cvmx_bootmem_alloc_named </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a block of memory from the free list that was passed to the application by the bootloader, and assign it a name in the global named block table. </p>
<p>(part of the cvmx_bootmem_descriptor_t structure) Named blocks can later be freed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size in bytes of block to allocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alignment</em>&nbsp;</td><td>Alignment required - must be power of 2 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of block - must be less than CVMX_BOOTMEM_NAME_LEN bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to block of memory, NULL on error </dd></dl>

</div>
</div>
<a class="anchor" id="a30d21e76d1041d8ffbc92858e4008379"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_alloc_named_address" ref="a30d21e76d1041d8ffbc92858e4008379" args="(uint64_t size, uint64_t address, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cvmx_bootmem_alloc_named_address </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a block of memory from the free list that was passed to the application by the bootloader, and assign it a name in the global named block table. </p>
<p>(part of the cvmx_bootmem_descriptor_t structure) Named blocks can later be freed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size in bytes of block to allocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>address</em>&nbsp;</td><td>Physical address to allocate memory at. If this memory is not available, the allocation fails. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of block - must be less than CVMX_BOOTMEM_NAME_LEN bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to block of memory, NULL on error </dd></dl>

</div>
</div>
<a class="anchor" id="a88c92a0277cfce15ae750bd32e66ed0a"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_alloc_named_flags" ref="a88c92a0277cfce15ae750bd32e66ed0a" args="(uint64_t size, uint64_t alignment, const char *name, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cvmx_bootmem_alloc_named_flags </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a block of memory from the free list that was passed to the application by the bootloader, and assign it a name in the global named block table. </p>
<p>(part of the cvmx_bootmem_descriptor_t structure) Named blocks can later be freed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size in bytes of block to allocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alignment</em>&nbsp;</td><td>Alignment required - must be power of 2 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of block - must be less than CVMX_BOOTMEM_NAME_LEN bytes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags to control options for the allocation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to block of memory, NULL on error </dd></dl>

</div>
</div>
<a class="anchor" id="a9e6982b83394b6e740b938ed540d3cb1"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_alloc_named_range" ref="a9e6982b83394b6e740b938ed540d3cb1" args="(uint64_t size, uint64_t min_addr, uint64_t max_addr, uint64_t align, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cvmx_bootmem_alloc_named_range </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>min_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>max_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a block of memory from a specific range of the free list that was passed to the application by the bootloader, and assign it a name in the global named block table. </p>
<p>(part of the cvmx_bootmem_descriptor_t structure) Named blocks can later be freed. If request cannot be satisfied within the address range specified, NULL is returned</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size in bytes of block to allocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>min_addr</em>&nbsp;</td><td>minimum address of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_addr</em>&nbsp;</td><td>maximum address of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>align</em>&nbsp;</td><td>Alignment of memory to be allocated. (must be a power of 2) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of block - must be less than CVMX_BOOTMEM_NAME_LEN bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to block of memory, NULL on error </dd></dl>

</div>
</div>
<a class="anchor" id="ad4d863b8a85601d6f2d9e62428a1a29c"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_alloc_named_range_flags" ref="ad4d863b8a85601d6f2d9e62428a1a29c" args="(uint64_t size, uint64_t min_addr, uint64_t max_addr, uint64_t align, const char *name, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cvmx_bootmem_alloc_named_range_flags </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>min_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>max_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a287cdc81b2cc4249792c199242096b32"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_alloc_named_range_once" ref="a287cdc81b2cc4249792c199242096b32" args="(uint64_t size, uint64_t min_addr, uint64_t max_addr, uint64_t align, const char *name, void(*init)(void *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cvmx_bootmem_alloc_named_range_once </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>min_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>max_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>init</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate if needed a block of memory from a specific range of the free list that was passed to the application by the bootloader, and assign it a name in the global named block table. </p>
<p>(part of the cvmx_bootmem_descriptor_t structure) Named blocks can later be freed. If the requested name block is already allocated, return the pointer to block of memory. If request cannot be satisfied within the address range specified, NULL is returned</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size in bytes of block to allocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>min_addr</em>&nbsp;</td><td>minimum address of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_addr</em>&nbsp;</td><td>maximum address of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>align</em>&nbsp;</td><td>Alignment of memory to be allocated. (must be a power of 2) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of block - must be less than CVMX_BOOTMEM_NAME_LEN bytes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>init</em>&nbsp;</td><td>Initialization function</td></tr>
  </table>
  </dd>
</dl>
<p>The initialization function is optional, if omitted the named block is initialized to all zeros when it is created, i.e. once.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to block of memory, NULL on error </dd></dl>

</div>
</div>
<a class="anchor" id="a918fa07da4cdfaf9e8c09edd9eacf027"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_alloc_node" ref="a918fa07da4cdfaf9e8c09edd9eacf027" args="(uint64_t node, uint64_t size, uint64_t alignment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cvmx_bootmem_alloc_node </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>alignment</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a block of memory from the free list that was passed to the application by the bootloader from a specific node. </p>
<p>This is an allocate-only algorithm, so freeing memory is not possible.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>The node to allocate memory from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size in bytes of block to allocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alignment</em>&nbsp;</td><td>Alignment required - must be power of 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to block of memory, NULL on error </dd></dl>

</div>
</div>
<a class="anchor" id="a5f1db600138f2c00bc9e34e15a585e60"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_alloc_range" ref="a5f1db600138f2c00bc9e34e15a585e60" args="(uint64_t size, uint64_t alignment, uint64_t min_addr, uint64_t max_addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cvmx_bootmem_alloc_range </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>min_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>max_addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a block of memory from the free list that was passed to the application by the bootloader within a specified address range. </p>
<p>This is an allocate-only algorithm, so freeing memory is not possible. Allocation will fail if memory cannot be allocated in the requested range.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size in bytes of block to allocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>min_addr</em>&nbsp;</td><td>defines the minimum address of the range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_addr</em>&nbsp;</td><td>defines the maximum address of the range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alignment</em>&nbsp;</td><td>Alignment required - must be power of 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to block of memory, NULL on error </dd></dl>

</div>
</div>
<a class="anchor" id="a6b2363b2a5328771ab156f8081fbc53b"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_available_mem" ref="a6b2363b2a5328771ab156f8081fbc53b" args="(uint64_t min_block_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cvmx_bootmem_available_mem </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>min_block_size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the size of available memory in bytes, only counting blocks that are at least as big as the minimum block size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>min_block_size</em>&nbsp;</td><td>Minimum block size to count in total.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes available for allocation that meet the block size requirement </dd></dl>

</div>
</div>
<a class="anchor" id="a91ab83d95ecdc1fce1a0d32d09aaab9b"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_find_named_block" ref="a91ab83d95ecdc1fce1a0d32d09aaab9b" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structcvmx__bootmem__named__block__desc.html">cvmx_bootmem_named_block_desc_t</a>* cvmx_bootmem_find_named_block </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds a named bootmem block by name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of block to free</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to named block <a class="el" href="structdescriptor.html">descriptor</a> on success 0 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="aad826d085ebf8a452e6120be2579c8bb"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_free_named" ref="aad826d085ebf8a452e6120be2579c8bb" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_bootmem_free_named </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees a previously allocated named bootmem block. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of block to free</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on failure, !0 on success </dd></dl>

</div>
</div>
<a class="anchor" id="acdcc9ba322d4fc16a8a1099b59445901"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_init" ref="acdcc9ba322d4fc16a8a1099b59445901" args="(uint64_t mem_desc_addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_bootmem_init </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>mem_desc_addr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the boot alloc memory structures. </p>
<p>This is normally called inside of <a class="el" href="cvmx-access_8h.html#a22c7fb96aa0426a2a74f7ff47c153e64" title="This function performs some default initialization of the Octeon executive.">cvmx_user_app_init()</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mem_desc_addr</em>&nbsp;</td><td>Address of the free memory list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aeb7a12587438b8e735032074a2b2b0a5"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_lock" ref="aeb7a12587438b8e735032074a2b2b0a5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvmx_bootmem_lock </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Locks the bootmem allocator. </p>
<p>This is useful in certain situations where multiple allocations must be made without being interrupted. This should be used with the CVMX_BOOTMEM_FLAG_NO_LOCKING flag. </p>

</div>
</div>
<a class="anchor" id="a85a7ac7ecbbe74b3f50963092f6fdf68"></a><!-- doxytag: member="cvmx&#45;bootmem.c::CVMX_BOOTMEM_NAMED_GET_NAME" ref="a85a7ac7ecbbe74b3f50963092f6fdf68" args="(uint64_t addr, char *str, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void CVMX_BOOTMEM_NAMED_GET_NAME </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function retrieves the string name of a named block. </p>
<p>It is more complicated than a simple memcpy() since the named block <a class="el" href="structdescriptor.html">descriptor</a> may not be directly accessable.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Physical address of the named block <a class="el" href="structdescriptor.html">descriptor</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>String to receive the named block string name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Length of the string buffer, which must match the length stored in the bootmem <a class="el" href="structdescriptor.html">descriptor</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92d59ea9b1f4ae15525d78f3532b0c09"></a><!-- doxytag: member="cvmx&#45;bootmem.c::CVMX_BOOTMEM_NAMED_SET_NAME" ref="a92d59ea9b1f4ae15525d78f3532b0c09" args="(uint64_t addr, const char *str, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVMX_BOOTMEM_NAMED_SET_NAME </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function stores the string name of a named block. </p>
<p>It is more complicated than a simple memcpy() since the named block <a class="el" href="structdescriptor.html">descriptor</a> may not be directly accessable.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Physical address of the named block <a class="el" href="structdescriptor.html">descriptor</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>String to store into the named block string name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Length of the string buffer, which must match the length stored in the bootmem <a class="el" href="structdescriptor.html">descriptor</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a05957d11119b4bd7b75623a209043fa2"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_phy_alloc" ref="a05957d11119b4bd7b75623a209043fa2" args="(uint64_t req_size, uint64_t address_min, uint64_t address_max, uint64_t alignment, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t cvmx_bootmem_phy_alloc </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>req_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>address_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>address_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates a block of physical memory from the free list, at (optional) requested address and alignment. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>req_size</em>&nbsp;</td><td>size of region to allocate. All requests are rounded up to be a multiple CVMX_BOOTMEM_ALIGNMENT_SIZE bytes size</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>address_min</em>&nbsp;</td><td>Minimum address that block can occupy.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>address_max</em>&nbsp;</td><td>Specifies the maximum address_min (inclusive) that the allocation can use.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alignment</em>&nbsp;</td><td>Requested alignment of the block. If this alignment cannot be met, the allocation fails. This must be a power of 2. (Note: Alignment of CVMX_BOOTMEM_ALIGNMENT_SIZE bytes is required, and internally enforced. Requested alignments of less than CVMX_BOOTMEM_ALIGNMENT_SIZE are set to CVMX_BOOTMEM_ALIGNMENT_SIZE.) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags to control options for the allocation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>physical address of block allocated, or -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ace5afa0dca0a8460e4c4f927da72a22d"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_phy_alloc_range" ref="ace5afa0dca0a8460e4c4f927da72a22d" args="(uint64_t size, uint64_t alignment, uint64_t min_addr, uint64_t max_addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cvmx_bootmem_phy_alloc_range </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>min_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>max_addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4d5b3fa2c531740d9ff3adef43fba6c9"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_phy_available_mem" ref="a4d5b3fa2c531740d9ff3adef43fba6c9" args="(uint64_t min_block_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cvmx_bootmem_phy_available_mem </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>min_block_size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the size of available memory in bytes, only counting blocks that are at least as big as the minimum block size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>min_block_size</em>&nbsp;</td><td>Minimum block size to count in total.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes available for allocation that meet the block size requirement </dd></dl>

</div>
</div>
<a class="anchor" id="a28bd9cdef6cae1525cb2bafc034a86cb"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_phy_get_next" ref="a28bd9cdef6cae1525cb2bafc034a86cb" args="(uint64_t addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t cvmx_bootmem_phy_get_next </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>addr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab90819eb90220b954fed262e46a279bb"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_phy_get_size" ref="ab90819eb90220b954fed262e46a279bb" args="(uint64_t addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t cvmx_bootmem_phy_get_size </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>addr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aacc63c0743db73855b502bf0fdd9f0c4"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_phy_list_print" ref="aacc63c0743db73855b502bf0fdd9f0c4" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvmx_bootmem_phy_list_print </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints the list of available memory. </p>

</div>
</div>
<a class="anchor" id="a38b5caabc1a679454ef07c9cf66c63c8"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_phy_mem_list_init" ref="a38b5caabc1a679454ef07c9cf66c63c8" args="(uint64_t mem_size, uint32_t low_reserved_bytes, cvmx_bootmem_desc_t *desc_buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t cvmx_bootmem_phy_mem_list_init </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>mem_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>low_reserved_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvmx__bootmem__desc__t.html">cvmx_bootmem_desc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>desc_buffer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function initializes the free memory list used by cvmx_bootmem. </p>
<p>This must be called before any allocations can be done.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mem_size</em>&nbsp;</td><td>Total memory available, in bytes</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>low_reserved_bytes</em>&nbsp;</td><td>Number of bytes to reserve (leave out of free list) at address 0x0.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>desc_buffer</em>&nbsp;</td><td>Buffer for the bootmem <a class="el" href="structdescriptor.html">descriptor</a>. This must be a 32 bit addressable address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 on success 0 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a11218b1c21d4b0144d03ba8d42ab9179"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_phy_mem_list_init_multi" ref="a11218b1c21d4b0144d03ba8d42ab9179" args="(uint8_t node_mask, uint32_t mem_sizes[], uint32_t low_reserved_bytes, cvmx_bootmem_desc_t *desc_buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t cvmx_bootmem_phy_mem_list_init_multi </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>nodemask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>mem_size</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>low_reserved_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvmx__bootmem__desc__t.html">cvmx_bootmem_desc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>desc_buffer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function initializes the free memory list used by cvmx_bootmem. </p>
<p>This must be called before any allocations can be done.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nodemask</em>&nbsp;</td><td>Nodemask - one bit per node (bit0-&gt;node0, bit1-&gt;node1,...)</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mem_size[]</em>&nbsp;</td><td>Array of memory sizes in MBytes per node ([0]-&gt;node0,...)</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>low_reserved_bytes</em>&nbsp;</td><td>Number of bytes to reserve (leave out of free list) at address 0x0.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>desc_buffer</em>&nbsp;</td><td>Buffer for the bootmem <a class="el" href="structdescriptor.html">descriptor</a>. This must be a 32 bit addressable address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 on success 0 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a33a73dcc74933f5701804d0b51129ba6"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_phy_named_block_alloc" ref="a33a73dcc74933f5701804d0b51129ba6" args="(uint64_t size, uint64_t min_addr, uint64_t max_addr, uint64_t alignment, const char *name, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t cvmx_bootmem_phy_named_block_alloc </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>min_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>max_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates a named block of physical memory from the free list, at (optional) requested address and alignment. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>size of region to allocate. All requests are rounded up to be a multiple CVMX_BOOTMEM_ALIGNMENT_SIZE bytes size</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>min_addr</em>&nbsp;</td><td>Minimum address that block can occupy.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_addr</em>&nbsp;</td><td>Specifies the maximum address_min (inclusive) that the allocation can use.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alignment</em>&nbsp;</td><td>Requested alignment of the block. If this alignment cannot be met, the allocation fails. This must be a power of 2. (Note: Alignment of CVMX_BOOTMEM_ALIGNMENT_SIZE bytes is required, and internally enforced. Requested alignments of less than CVMX_BOOTMEM_ALIGNMENT_SIZE are set to CVMX_BOOTMEM_ALIGNMENT_SIZE.)</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name to assign to named block</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags to control options for the allocation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>physical address of block allocated, or -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a3275ade53d91556abc9d46247211fca4"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_phy_named_block_find" ref="a3275ade53d91556abc9d46247211fca4" args="(const char *name, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cvmx_bootmem_phy_named_block_find </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds a named memory block by name. </p>
<p>Also used for finding an unused entry in the named block table.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of memory block to find. If NULL pointer given, then finds unused <a class="el" href="structdescriptor.html">descriptor</a>, if available.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags to control options for the allocation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Physical address of the memory block <a class="el" href="structdescriptor.html">descriptor</a>, zero if not found. If zero returned when name parameter is NULL, then no memory block descriptors are available. </dd></dl>

</div>
</div>
<a class="anchor" id="a7457209ef2001be22938846c4c3f114b"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_phy_named_block_free" ref="a7457209ef2001be22938846c4c3f114b" args="(const char *name, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_bootmem_phy_named_block_free </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees a named block. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of block to free </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>flags for passing options</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on failure 1 on success </dd></dl>

</div>
</div>
<a class="anchor" id="a0588c4ceaf1b0e2f8c432911bc44b473"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_phy_named_block_print" ref="a0588c4ceaf1b0e2f8c432911bc44b473" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvmx_bootmem_phy_named_block_print </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints the list of currently allocated named blocks. </p>

</div>
</div>
<a class="anchor" id="a6da5cc54f511c92be1baef638521eed8"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_phy_set_next" ref="a6da5cc54f511c92be1baef638521eed8" args="(uint64_t addr, uint64_t next)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_bootmem_phy_set_next </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>next</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8a637d2d1f7133c6580eabb45d293af6"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_phy_set_size" ref="a8a637d2d1f7133c6580eabb45d293af6" args="(uint64_t addr, uint64_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_bootmem_phy_set_size </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a307ac29a8eda478a2c7b7f88fb29ba14"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_print_named" ref="a307ac29a8eda478a2c7b7f88fb29ba14" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvmx_bootmem_print_named </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints out the list of named blocks that have been allocated along with their addresses and sizes. </p>
<p>This is primarily used for debugging purposes </p>

</div>
</div>
<a class="anchor" id="acf313732820de4a5b08256b087212248"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_reserve_memory" ref="acf313732820de4a5b08256b087212248" args="(uint64_t start_addr, uint64_t size, const char *name, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_bootmem_reserve_memory </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>start_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate all free memory starting at the start address. </p>
<p>This is used to prevent any free blocks from later being allocated within the reserved space. Note that any memory allocated with this function cannot be later freed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start_addr</em>&nbsp;</td><td>Starting address to reserve </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size in bytes to reserve starting at start_addr </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name to assign to reserved blocks </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags to use when reserving memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on failure, !0 on success </dd></dl>

</div>
</div>
<a class="anchor" id="ae4e803936d44fb5d31bc52451fe27321"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_unlock" ref="ae4e803936d44fb5d31bc52451fe27321" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvmx_bootmem_unlock </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlocks the bootmem allocator. </p>
<p>This is useful in certain situations where multiple allocations must be made without being interrupted. This should be used with the CVMX_BOOTMEM_FLAG_NO_LOCKING flag. </p>

</div>
</div>
<a class="anchor" id="a0ac92506e2e37f06355b6be5888f84b2"></a><!-- doxytag: member="cvmx&#45;bootmem.c::EXPORT_SYMBOL" ref="a0ac92506e2e37f06355b6be5888f84b2" args="(cvmx_bootmem_find_named_block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL </td>
          <td>(</td>
          <td class="paramtype">cvmx_bootmem_find_named_block&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a312de4edda8e63091737f6bd0ed2201d"></a><!-- doxytag: member="cvmx&#45;bootmem.c::EXPORT_SYMBOL" ref="a312de4edda8e63091737f6bd0ed2201d" args="(cvmx_bootmem_free_named)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL </td>
          <td>(</td>
          <td class="paramtype">cvmx_bootmem_free_named&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a23f7f64bfd97df4d95ae8c935f2302ac"></a><!-- doxytag: member="cvmx&#45;bootmem.c::EXPORT_SYMBOL" ref="a23f7f64bfd97df4d95ae8c935f2302ac" args="(cvmx_bootmem_alloc_named_flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL </td>
          <td>(</td>
          <td class="paramtype">cvmx_bootmem_alloc_named_flags&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a85fbabe6a04ac971b7d7611a0d7fddbf"></a><!-- doxytag: member="cvmx&#45;bootmem.c::EXPORT_SYMBOL" ref="a85fbabe6a04ac971b7d7611a0d7fddbf" args="(cvmx_bootmem_alloc_named_range_once)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL </td>
          <td>(</td>
          <td class="paramtype">cvmx_bootmem_alloc_named_range_once&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab68096d5b3fd193c9d08dab9110af45f"></a><!-- doxytag: member="cvmx&#45;bootmem.c::EXPORT_SYMBOL" ref="ab68096d5b3fd193c9d08dab9110af45f" args="(cvmx_bootmem_alloc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL </td>
          <td>(</td>
          <td class="paramtype">cvmx_bootmem_alloc&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aad42377e67e844646a53e5b2ed9fdcce"></a><!-- doxytag: member="cvmx&#45;bootmem.c::EXPORT_SYMBOL" ref="aad42377e67e844646a53e5b2ed9fdcce" args="(cvmx_bootmem_alloc_node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL </td>
          <td>(</td>
          <td class="paramtype">cvmx_bootmem_alloc_node&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af537b32e203533f1c02137b2c9c7cbdf"></a><!-- doxytag: member="cvmx&#45;bootmem.c::EXPORT_SYMBOL" ref="af537b32e203533f1c02137b2c9c7cbdf" args="(cvmx_bootmem_alloc_range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL </td>
          <td>(</td>
          <td class="paramtype">cvmx_bootmem_alloc_range&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a2de9f2b56f3cadd9486fdf9af858fffe"></a><!-- doxytag: member="cvmx&#45;bootmem.c::cvmx_bootmem_desc_addr" ref="a2de9f2b56f3cadd9486fdf9af858fffe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVMX_SHARED uint64_t <a class="el" href="cvmx-bootmem_8c.html#a2de9f2b56f3cadd9486fdf9af858fffe">cvmx_bootmem_desc_addr</a> = 0<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the physical location of a <a class="el" href="structcvmx__bootmem__desc__t.html">cvmx_bootmem_desc_t</a> structure in Octeon's memory. </p>
<p>Note that dues to addressing limits or runtime environment it might not be possible to create a C pointer to this structure. </p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Oct 2017 for Octeon Software Development Kit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
