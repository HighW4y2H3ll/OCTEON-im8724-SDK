<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Octeon Software Development Kit: cvmx-bootmem.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cvmx-bootmem.h File Reference</h1>
<p>Simple allocate only memory allocator.  
<a href="#_details">More...</a></p>
<div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dynsection">
<div class="center"><img src="cvmx-bootmem_8h__dep__incl.png" border="0" usemap="#cvmx-bootmem_8hdep_map" alt=""/></div>
<map name="cvmx-bootmem_8hdep_map" id="cvmx-bootmem_8hdep">
<area shape="rect" id="node3" href="cvmx-adma_8c.html" title="cvmx&#45;adma.c" alt="" coords="5,83,120,112"/><area shape="rect" id="node5" href="cvmx-app-hotplug_8h.html" title="Header file for the hotplug APIs." alt="" coords="144,83,301,112"/><area shape="rect" id="node9" href="cvmx-app-init-linux_8c.html" title="Simple executive application initialization for Linux user space." alt="" coords="325,83,488,112"/><area shape="rect" id="node11" href="cvmx-app-init_8c.html" title="Main entry point for all simple executive based programs." alt="" coords="512,83,640,112"/><area shape="rect" id="node13" href="cvmx-appcfg-transport_8c.html" title="cvmx&#45;appcfg&#45;transport.c" alt="" coords="664,83,853,112"/><area shape="rect" id="node15" href="cvmx-boot-vector_8c.html" title="cvmx&#45;boot&#45;vector.c" alt="" coords="877,83,1035,112"/><area shape="rect" id="node17" href="cvmx-bootmem_8c.html" title="Simple allocate only memory allocator." alt="" coords="1059,83,1200,112"/><area shape="rect" id="node19" href="cvmx-cmd-queue_8c.html" title="Support functions for managing command queues used for various hardware blocks." alt="" coords="1224,83,1379,112"/><area shape="rect" id="node21" href="cvmx-coredump_8c.html" title="Main Coredump Interface." alt="" coords="1403,83,1547,112"/><area shape="rect" id="node23" href="cvmx-coremask_8c.html" title="Module to support operations on bitmap of cores." alt="" coords="1571,83,1712,112"/><area shape="rect" id="node25" href="cvmx-debug_8c.html" title="cvmx&#45;debug.c" alt="" coords="1736,83,1853,112"/><area shape="rect" id="node27" href="cvmx-dma-engine_8c.html" title="Interface to the PCI / PCIe DMA engines." alt="" coords="1877,83,2035,112"/><area shape="rect" id="node29" href="cvmx-fau-compat_8c.html" title="cvmx&#45;fau&#45;compat.c" alt="" coords="2059,83,2213,112"/><area shape="rect" id="node31" href="cvmx-fau_8c.html" title="cvmx&#45;fau.c" alt="" coords="2237,83,2336,112"/><area shape="rect" id="node33" href="cvmx-fpa_8c.html" title="Support library for the hardware Free Pool Allocator." alt="" coords="2360,83,2459,112"/><area shape="rect" id="node35" href="cvmx-global-resources_8c.html" title="cvmx&#45;global&#45;resources.c" alt="" coords="2483,83,2669,112"/><area shape="rect" id="node37" href="cvmx-helper-board_8c.html" title="Helper functions to abstract board specific data about network ports from the rest..." alt="" coords="2693,83,2853,112"/><area shape="rect" id="node39" href="cvmx-helper-cfg_8c.html" title="Helper Functions for the Configuration Framework." alt="" coords="2877,83,3021,112"/><area shape="rect" id="node41" href="cvmx-helper-fpa_8c.html" title="Helper functions for FPA setup." alt="" coords="3045,83,3189,112"/><area shape="rect" id="node43" href="cvmx-helper-ilk_8c.html" title="Functions for ILK initialization, configuration, and monitoring." alt="" coords="3213,83,3349,112"/><area shape="rect" id="node45" href="cvmx-helper-pko_8c.html" title="Helper Functions for the PKO." alt="" coords="3373,83,3520,112"/><area shape="rect" id="node47" href="cvmx-helper-sfp_8c.html" title="cvmx&#45;helper&#45;sfp.c" alt="" coords="3544,83,3688,112"/><area shape="rect" id="node49" href="cvmx-helper-util_8c.html" title="Small helper utilities." alt="" coords="3712,83,3856,112"/><area shape="rect" id="node51" href="cvmx-helper_8c.html" title="Helper functions for common, but complicated tasks." alt="" coords="3880,83,3997,112"/><area shape="rect" id="node53" href="cvmx-hfa_8c.html" title="Support library for the CN63XX, CN68XX hardware HFA engine." alt="" coords="4028,160,4127,189"/><area shape="rect" id="node55" href="cvmx-hfa_8h.html" title="Interface to the CN63XX, CN68XX hardware HFA engine." alt="" coords="4072,83,4171,112"/><area shape="rect" id="node58" href="cvmx-ipd_8c.html" title="IPD Support." alt="" coords="4195,83,4291,112"/><area shape="rect" id="node60" href="cvmx-l2c_8c.html" title="Implementation of the Level 2 Cache (L2C) control, measurement, and debugging facilities..." alt="" coords="4315,83,4411,112"/><area shape="rect" id="node62" href="cvmx-mgmt-port_8c.html" title="Support functions for managing the MII management port." alt="" coords="4435,83,4587,112"/><area shape="rect" id="node64" href="cvmx-nand_8c.html" title="Interface to the NAND flash controller." alt="" coords="4611,83,4720,112"/><area shape="rect" id="node66" href="cvmx-otrace_8c.html" title="cvmx&#45;otrace implements the SE stub for the runtime tool otrace." alt="" coords="4744,83,4867,112"/><area shape="rect" id="node68" href="cvmx-pcie_8c.html" title="Interface to PCIe as a host(RC) or target(EP)." alt="" coords="4891,83,4995,112"/><area shape="rect" id="node70" href="cvmx-pko-internal-ports-range_8c.html" title="cvmx&#45;pko&#45;internal&#45;ports&#45;range.c" alt="" coords="5019,83,5261,112"/><area shape="rect" id="node72" href="cvmx-pko3-queue_8c.html" title="cvmx&#45;pko3&#45;queue.c" alt="" coords="5285,83,5440,112"/><area shape="rect" id="node74" href="cvmx-pko3-resources_8c.html" title="PKO resources." alt="" coords="5464,83,5643,112"/><area shape="rect" id="node76" href="cvmx-pow_8c.html" title="Interface to the hardware Packet Order / Work unit." alt="" coords="5667,83,5768,112"/><area shape="rect" id="node78" href="cvmx-profiler_8c.html" title="Interface to event profiler." alt="" coords="5792,83,5915,112"/><area shape="rect" id="node80" href="cvmx-qlm_8c.html" title="Helper utilities for qlm." alt="" coords="5939,83,6040,112"/><area shape="rect" id="node82" href="cvmx-raid_8c.html" title="Interface to RAID block." alt="" coords="6064,83,6165,112"/><area shape="rect" id="node84" href="cvmx-shmem_8c.html" title="cvmx&#45;shmem supplies the cross application shared memory implementation" alt="" coords="6189,83,6315,112"/><area shape="rect" id="node86" href="cvmx-tim-atomic_8c.html" title="New lockless timer API, inspired by ODP timer definition." alt="" coords="6339,83,6491,112"/><area shape="rect" id="node88" href="cvmx-tim_8c.html" title="Support library for the hardware work queue timers." alt="" coords="6515,83,6613,112"/><area shape="rect" id="node90" href="cvmx-usb-ehci_8c.html" title="cvmx&#45;usb&#45;ehci.c" alt="" coords="6637,83,6771,112"/><area shape="rect" id="node92" href="octeon-pci-console_8c.html" title="octeon&#45;pci&#45;console.c" alt="" coords="6795,83,6957,112"/><area shape="rect" id="node7" href="cvmx-app-hotplug_8c.html" title="Provides APIs for applications to register for hotplug." alt="" coords="144,160,301,189"/></map>
</div>

<p><a href="cvmx-bootmem_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcvmx__bootmem__block__header__t.html">cvmx_bootmem_block_header_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcvmx__bootmem__named__block__desc.html">cvmx_bootmem_named_block_desc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcvmx__bootmem__desc__t.html">cvmx_bootmem_desc_t</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a5849ce61dadf387c7bf77ea67e955af7">CVMX_BOOTMEM_NAME_LEN</a>&nbsp;&nbsp;&nbsp;128</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a45ec8b3654e1c6afc4007fa87346796a">CVMX_BOOTMEM_NUM_NAMED_BLOCKS</a>&nbsp;&nbsp;&nbsp;64</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a5e2a61282c4ad5fc6c63e387bea9d1e9">CVMX_BOOTMEM_ALIGNMENT_SIZE</a>&nbsp;&nbsp;&nbsp;(16ull)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a71dac52f76a8b8bdf87fffe889b5c7e2">CVMX_BOOTMEM_FLAG_END_ALLOC</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#ada6b32ecac8f6feb01cdb87fb2308398">CVMX_BOOTMEM_FLAG_NO_LOCKING</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a7f6eb53dbda76b0e17246f2f87307bbe">OCTEON_DDR0_BASE</a>&nbsp;&nbsp;&nbsp;(0x0ULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a21813c952484e5ab8e9cbbf327d9ee46">OCTEON_DDR0_SIZE</a>&nbsp;&nbsp;&nbsp;(0x010000000ULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#ae38dfd476e0c8287f600a38ec460567c">OCTEON_DDR1_BASE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#ac95736ea00849dcb901bd957d8e8ee0f">OCTEON_DDR1_SIZE</a>&nbsp;&nbsp;&nbsp;(0x010000000ULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a24a5e1579b028672b4ef0e40f2551c4a">OCTEON_DDR2_BASE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#aaf98d90d2104d5c0ffbb2d28d2f875b0">OCTEON_DDR2_SIZE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#ae986c75c4dcd889f680489339fe67261">OCTEON_MAX_PHY_MEM_SIZE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a6c9a5b459a346173b44d5cb2f07bed56">CVMX_BOOTMEM_DESC_MAJ_VER</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a89b812218bde6471ab2ad30d891375e8">CVMX_BOOTMEM_DESC_MIN_VER</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="structcvmx__bootmem__named__block__desc.html">cvmx_bootmem_named_block_desc</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a487d2ecb767f3a3845907473fe6cc38f">cvmx_bootmem_named_block_desc_t</a></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#acdcc9ba322d4fc16a8a1099b59445901">cvmx_bootmem_init</a> (uint64_t mem_desc_addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the boot alloc memory structures.  <a href="#acdcc9ba322d4fc16a8a1099b59445901"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a4295ccfec5aeb9b415c92fbbb1f5873e">cvmx_bootmem_alloc</a> (uint64_t size, uint64_t alignment)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of memory from the free list that was passed to the application by the bootloader.  <a href="#a4295ccfec5aeb9b415c92fbbb1f5873e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a918fa07da4cdfaf9e8c09edd9eacf027">cvmx_bootmem_alloc_node</a> (uint64_t node, uint64_t size, uint64_t alignment)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of memory from the free list that was passed to the application by the bootloader from a specific node.  <a href="#a918fa07da4cdfaf9e8c09edd9eacf027"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a1aeeabcff132e8b9152bf5fa69068b87">cvmx_bootmem_alloc_address</a> (uint64_t size, uint64_t address, uint64_t alignment)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of memory from the free list that was passed to the application by the bootloader at a specific address.  <a href="#a1aeeabcff132e8b9152bf5fa69068b87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#ae8a84e6ef38c952b26e76f23c148c03d">cvmx_bootmem_alloc_range_flags</a> (uint64_t size, uint64_t alignment, uint64_t min_addr, uint64_t max_addr, uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of memory from the free list that was passed to the application by the bootloader within a specified address range.  <a href="#ae8a84e6ef38c952b26e76f23c148c03d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a5f1db600138f2c00bc9e34e15a585e60">cvmx_bootmem_alloc_range</a> (uint64_t size, uint64_t alignment, uint64_t min_addr, uint64_t max_addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of memory from the free list that was passed to the application by the bootloader within a specified address range.  <a href="#a5f1db600138f2c00bc9e34e15a585e60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#ab787a63a038bd4e79d3b80f832b361f9">cvmx_bootmem_alloc_named</a> (uint64_t size, uint64_t alignment, const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of memory from the free list that was passed to the application by the bootloader, and assign it a name in the global named block table.  <a href="#ab787a63a038bd4e79d3b80f832b361f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a88c92a0277cfce15ae750bd32e66ed0a">cvmx_bootmem_alloc_named_flags</a> (uint64_t size, uint64_t alignment, const char *name, uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of memory from the free list that was passed to the application by the bootloader, and assign it a name in the global named block table.  <a href="#a88c92a0277cfce15ae750bd32e66ed0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a30d21e76d1041d8ffbc92858e4008379">cvmx_bootmem_alloc_named_address</a> (uint64_t size, uint64_t address, const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of memory from the free list that was passed to the application by the bootloader, and assign it a name in the global named block table.  <a href="#a30d21e76d1041d8ffbc92858e4008379"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a9e6982b83394b6e740b938ed540d3cb1">cvmx_bootmem_alloc_named_range</a> (uint64_t size, uint64_t min_addr, uint64_t max_addr, uint64_t align, const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of memory from a specific range of the free list that was passed to the application by the bootloader, and assign it a name in the global named block table.  <a href="#a9e6982b83394b6e740b938ed540d3cb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a287cdc81b2cc4249792c199242096b32">cvmx_bootmem_alloc_named_range_once</a> (uint64_t size, uint64_t min_addr, uint64_t max_addr, uint64_t align, const char *name, void(*init)(void *))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate if needed a block of memory from a specific range of the free list that was passed to the application by the bootloader, and assign it a name in the global named block table.  <a href="#a287cdc81b2cc4249792c199242096b32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#acf313732820de4a5b08256b087212248">cvmx_bootmem_reserve_memory</a> (uint64_t start_addr, uint64_t size, const char *name, uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate all free memory starting at the start address.  <a href="#acf313732820de4a5b08256b087212248"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#aad826d085ebf8a452e6120be2579c8bb">cvmx_bootmem_free_named</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees a previously allocated named bootmem block.  <a href="#aad826d085ebf8a452e6120be2579c8bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <br class="typebreak"/>
<a class="el" href="structcvmx__bootmem__named__block__desc.html">cvmx_bootmem_named_block_desc_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a91ab83d95ecdc1fce1a0d32d09aaab9b">cvmx_bootmem_find_named_block</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds a named bootmem block by name.  <a href="#a91ab83d95ecdc1fce1a0d32d09aaab9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a6b2363b2a5328771ab156f8081fbc53b">cvmx_bootmem_available_mem</a> (uint64_t min_block_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size of available memory in bytes, only counting blocks that are at least as big as the minimum block size.  <a href="#a6b2363b2a5328771ab156f8081fbc53b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a307ac29a8eda478a2c7b7f88fb29ba14">cvmx_bootmem_print_named</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints out the list of named blocks that have been allocated along with their addresses and sizes.  <a href="#a307ac29a8eda478a2c7b7f88fb29ba14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a05957d11119b4bd7b75623a209043fa2">cvmx_bootmem_phy_alloc</a> (uint64_t req_size, uint64_t address_min, uint64_t address_max, uint64_t alignment, uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates a block of physical memory from the free list, at (optional) requested address and alignment.  <a href="#a05957d11119b4bd7b75623a209043fa2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a33a73dcc74933f5701804d0b51129ba6">cvmx_bootmem_phy_named_block_alloc</a> (uint64_t size, uint64_t min_addr, uint64_t max_addr, uint64_t alignment, const char *name, uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates a named block of physical memory from the free list, at (optional) requested address and alignment.  <a href="#a33a73dcc74933f5701804d0b51129ba6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a3275ade53d91556abc9d46247211fca4">cvmx_bootmem_phy_named_block_find</a> (const char *name, uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds a named memory block by name.  <a href="#a3275ade53d91556abc9d46247211fca4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a4d5b3fa2c531740d9ff3adef43fba6c9">cvmx_bootmem_phy_available_mem</a> (uint64_t min_block_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size of available memory in bytes, only counting blocks that are at least as big as the minimum block size.  <a href="#a4d5b3fa2c531740d9ff3adef43fba6c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a7457209ef2001be22938846c4c3f114b">cvmx_bootmem_phy_named_block_free</a> (const char *name, uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees a named block.  <a href="#a7457209ef2001be22938846c4c3f114b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a4e0316bb1cdb654122be084dce233757">__cvmx_bootmem_phy_free</a> (uint64_t phy_addr, uint64_t size, uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees a block to the bootmem allocator list.  <a href="#a4e0316bb1cdb654122be084dce233757"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a0588c4ceaf1b0e2f8c432911bc44b473">cvmx_bootmem_phy_named_block_print</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints the list of currently allocated named blocks.  <a href="#a0588c4ceaf1b0e2f8c432911bc44b473"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#aacc63c0743db73855b502bf0fdd9f0c4">cvmx_bootmem_phy_list_print</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints the list of available memory.  <a href="#aacc63c0743db73855b502bf0fdd9f0c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a38b5caabc1a679454ef07c9cf66c63c8">cvmx_bootmem_phy_mem_list_init</a> (uint64_t mem_size, uint32_t low_reserved_bytes, <a class="el" href="structcvmx__bootmem__desc__t.html">cvmx_bootmem_desc_t</a> *desc_buffer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function initializes the free memory list used by cvmx_bootmem.  <a href="#a38b5caabc1a679454ef07c9cf66c63c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a889cd14f083017427ada048d5d5dce02">cvmx_bootmem_phy_mem_list_init_multi</a> (uint8_t nodemask, uint32_t mem_size[], uint32_t low_reserved_bytes, <a class="el" href="structcvmx__bootmem__desc__t.html">cvmx_bootmem_desc_t</a> *desc_buffer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function initializes the free memory list used by cvmx_bootmem.  <a href="#a889cd14f083017427ada048d5d5dce02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#aeb7a12587438b8e735032074a2b2b0a5">cvmx_bootmem_lock</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locks the bootmem allocator.  <a href="#aeb7a12587438b8e735032074a2b2b0a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#ae4e803936d44fb5d31bc52451fe27321">cvmx_bootmem_unlock</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlocks the bootmem allocator.  <a href="#ae4e803936d44fb5d31bc52451fe27321"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#ae8b6ba700574be9b74e7a6ac7ed07bca">__cvmx_bootmem_internal_get_desc_ptr</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal use function to get the current <a class="el" href="structdescriptor.html">descriptor</a> pointer.  <a href="#ae8b6ba700574be9b74e7a6ac7ed07bca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a034e3f5bd429e2e0fd58cb3d4fd3fd16">__cvmx_phys_addr_to_ptr</a> (uint64_t phys, int size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal use.  <a href="#a034e3f5bd429e2e0fd58cb3d4fd3fd16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <br class="typebreak"/>
<a class="el" href="structcvmx__bootmem__named__block__desc.html">cvmx_bootmem_named_block_desc_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#a52c7783f31f4ec239effb1493cf26ca3">__cvmx_bootmem_find_named_block_flags</a> (const char *name, uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a named block with flags.  <a href="#a52c7783f31f4ec239effb1493cf26ca3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#ad4d863b8a85601d6f2d9e62428a1a29c">cvmx_bootmem_alloc_named_range_flags</a> (uint64_t size, uint64_t min_addr, uint64_t max_addr, uint64_t align, const char *name, uint32_t flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-bootmem_8h.html#ace5afa0dca0a8460e4c4f927da72a22d">cvmx_bootmem_phy_alloc_range</a> (uint64_t size, uint64_t alignment, uint64_t min_addr, uint64_t max_addr)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Simple allocate only memory allocator. </p>
<p>Used to allocate memory at application start time.</p>
<hr/>
<dl class="rcs"><dt><b>Revision</b></dt><dd>130285 </dd></dl>
<hr/>
 <hr/><h2>Define Documentation</h2>
<a class="anchor" id="a5e2a61282c4ad5fc6c63e387bea9d1e9"></a><!-- doxytag: member="cvmx&#45;bootmem.h::CVMX_BOOTMEM_ALIGNMENT_SIZE" ref="a5e2a61282c4ad5fc6c63e387bea9d1e9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CVMX_BOOTMEM_ALIGNMENT_SIZE&nbsp;&nbsp;&nbsp;(16ull)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6c9a5b459a346173b44d5cb2f07bed56"></a><!-- doxytag: member="cvmx&#45;bootmem.h::CVMX_BOOTMEM_DESC_MAJ_VER" ref="a6c9a5b459a346173b44d5cb2f07bed56" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CVMX_BOOTMEM_DESC_MAJ_VER&nbsp;&nbsp;&nbsp;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a89b812218bde6471ab2ad30d891375e8"></a><!-- doxytag: member="cvmx&#45;bootmem.h::CVMX_BOOTMEM_DESC_MIN_VER" ref="a89b812218bde6471ab2ad30d891375e8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CVMX_BOOTMEM_DESC_MIN_VER&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a71dac52f76a8b8bdf87fffe889b5c7e2"></a><!-- doxytag: member="cvmx&#45;bootmem.h::CVMX_BOOTMEM_FLAG_END_ALLOC" ref="a71dac52f76a8b8bdf87fffe889b5c7e2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CVMX_BOOTMEM_FLAG_END_ALLOC&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ada6b32ecac8f6feb01cdb87fb2308398"></a><!-- doxytag: member="cvmx&#45;bootmem.h::CVMX_BOOTMEM_FLAG_NO_LOCKING" ref="ada6b32ecac8f6feb01cdb87fb2308398" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CVMX_BOOTMEM_FLAG_NO_LOCKING&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5849ce61dadf387c7bf77ea67e955af7"></a><!-- doxytag: member="cvmx&#45;bootmem.h::CVMX_BOOTMEM_NAME_LEN" ref="a5849ce61dadf387c7bf77ea67e955af7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CVMX_BOOTMEM_NAME_LEN&nbsp;&nbsp;&nbsp;128</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a45ec8b3654e1c6afc4007fa87346796a"></a><!-- doxytag: member="cvmx&#45;bootmem.h::CVMX_BOOTMEM_NUM_NAMED_BLOCKS" ref="a45ec8b3654e1c6afc4007fa87346796a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CVMX_BOOTMEM_NUM_NAMED_BLOCKS&nbsp;&nbsp;&nbsp;64</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7f6eb53dbda76b0e17246f2f87307bbe"></a><!-- doxytag: member="cvmx&#45;bootmem.h::OCTEON_DDR0_BASE" ref="a7f6eb53dbda76b0e17246f2f87307bbe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OCTEON_DDR0_BASE&nbsp;&nbsp;&nbsp;(0x0ULL)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a21813c952484e5ab8e9cbbf327d9ee46"></a><!-- doxytag: member="cvmx&#45;bootmem.h::OCTEON_DDR0_SIZE" ref="a21813c952484e5ab8e9cbbf327d9ee46" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OCTEON_DDR0_SIZE&nbsp;&nbsp;&nbsp;(0x010000000ULL)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae38dfd476e0c8287f600a38ec460567c"></a><!-- doxytag: member="cvmx&#45;bootmem.h::OCTEON_DDR1_BASE" ref="ae38dfd476e0c8287f600a38ec460567c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OCTEON_DDR1_BASE</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((<a class="code" href="octeon-model_8h.html#a78957577097ca57aff89f64acce0084f">OCTEON_IS_OCTEON2</a>() || <a class="code" href="octeon-model_8h.html#ac98a6b9c81e1a52f14e4c195b97e0199">OCTEON_IS_OCTEON3</a>()) \
                  ? 0x20000000ULL : 0x410000000ULL)
</pre></div>
</div>
</div>
<a class="anchor" id="ac95736ea00849dcb901bd957d8e8ee0f"></a><!-- doxytag: member="cvmx&#45;bootmem.h::OCTEON_DDR1_SIZE" ref="ac95736ea00849dcb901bd957d8e8ee0f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OCTEON_DDR1_SIZE&nbsp;&nbsp;&nbsp;(0x010000000ULL)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a24a5e1579b028672b4ef0e40f2551c4a"></a><!-- doxytag: member="cvmx&#45;bootmem.h::OCTEON_DDR2_BASE" ref="a24a5e1579b028672b4ef0e40f2551c4a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OCTEON_DDR2_BASE</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((<a class="code" href="octeon-model_8h.html#a78957577097ca57aff89f64acce0084f">OCTEON_IS_OCTEON2</a>() || <a class="code" href="octeon-model_8h.html#ac98a6b9c81e1a52f14e4c195b97e0199">OCTEON_IS_OCTEON3</a>()) \
                  ? 0x30000000ULL : 0x20000000ULL)
</pre></div>
</div>
</div>
<a class="anchor" id="aaf98d90d2104d5c0ffbb2d28d2f875b0"></a><!-- doxytag: member="cvmx&#45;bootmem.h::OCTEON_DDR2_SIZE" ref="aaf98d90d2104d5c0ffbb2d28d2f875b0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OCTEON_DDR2_SIZE</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((<a class="code" href="octeon-model_8h.html#a78957577097ca57aff89f64acce0084f">OCTEON_IS_OCTEON2</a>() || <a class="code" href="octeon-model_8h.html#ac98a6b9c81e1a52f14e4c195b97e0199">OCTEON_IS_OCTEON3</a>()) \
                  ? 0x7d0000000ULL : 0x3e0000000ULL)
</pre></div>
</div>
</div>
<a class="anchor" id="ae986c75c4dcd889f680489339fe67261"></a><!-- doxytag: member="cvmx&#45;bootmem.h::OCTEON_MAX_PHY_MEM_SIZE" ref="ae986c75c4dcd889f680489339fe67261" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OCTEON_MAX_PHY_MEM_SIZE</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((<a class="code" href="octeon-model_8h.html#a9234ac9e9f35fafd7fe5eedd37c9b552">OCTEON_IS_MODEL</a>(<a class="code" href="octeon-model_8h.html#ad28aa505bb4f34bb5f894ca14a8b7ba3">OCTEON_CN68XX</a>)) \
                  ? 128*1024*1024*1024<a class="code" href="cvmx-usbd_8c.html#aaecc43af33d06f506a9509a7eb6d814f">ULL</a> \
                  : (<a class="code" href="octeon-model_8h.html#a78957577097ca57aff89f64acce0084f">OCTEON_IS_OCTEON2</a>()) \
                    ? 32*1024*1024*1024ull \
                    : (<a class="code" href="octeon-model_8h.html#ac98a6b9c81e1a52f14e4c195b97e0199">OCTEON_IS_OCTEON3</a>()) \
                       ? 512*1024*1024*1024<a class="code" href="cvmx-usbd_8c.html#aaecc43af33d06f506a9509a7eb6d814f">ULL</a> \
                       : 16*1024*1024*1024<a class="code" href="cvmx-usbd_8c.html#aaecc43af33d06f506a9509a7eb6d814f">ULL</a>)
</pre></div>
</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a487d2ecb767f3a3845907473fe6cc38f"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_named_block_desc_t" ref="a487d2ecb767f3a3845907473fe6cc38f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structcvmx__bootmem__named__block__desc.html">cvmx_bootmem_named_block_desc</a> <a class="el" href="structcvmx__bootmem__named__block__desc.html">cvmx_bootmem_named_block_desc_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a52c7783f31f4ec239effb1493cf26ca3"></a><!-- doxytag: member="cvmx&#45;bootmem.h::__cvmx_bootmem_find_named_block_flags" ref="a52c7783f31f4ec239effb1493cf26ca3" args="(const char *name, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structcvmx__bootmem__named__block__desc.html">cvmx_bootmem_named_block_desc_t</a>* __cvmx_bootmem_find_named_block_flags </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find a named block with flags. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>is the block name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>indicates the need to use locking during search </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to named block <a class="el" href="structdescriptor.html">descriptor</a></dd></dl>
<p>Note: this function returns a pointer to a static structure, and is therefore not re-entrant. Making this function re-entrant will break backward compatibility. </p>

</div>
</div>
<a class="anchor" id="ae8b6ba700574be9b74e7a6ac7ed07bca"></a><!-- doxytag: member="cvmx&#45;bootmem.h::__cvmx_bootmem_internal_get_desc_ptr" ref="ae8b6ba700574be9b74e7a6ac7ed07bca" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* __cvmx_bootmem_internal_get_desc_ptr </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal use function to get the current <a class="el" href="structdescriptor.html">descriptor</a> pointer. </p>

</div>
</div>
<a class="anchor" id="a4e0316bb1cdb654122be084dce233757"></a><!-- doxytag: member="cvmx&#45;bootmem.h::__cvmx_bootmem_phy_free" ref="a4e0316bb1cdb654122be084dce233757" args="(uint64_t phy_addr, uint64_t size, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __cvmx_bootmem_phy_free </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>phy_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees a block to the bootmem allocator list. </p>
<p>This must be used with care, as the size provided must match the size of the block that was allocated, or the list will become corrupted.</p>
<p>IMPORTANT: This is only intended to be used as part of named block frees and initial population of the free memory list. *</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>phy_addr</em>&nbsp;</td><td>physical address of block </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>size of block in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>flags for passing options</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 on success, 0 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a034e3f5bd429e2e0fd58cb3d4fd3fd16"></a><!-- doxytag: member="cvmx&#45;bootmem.h::__cvmx_phys_addr_to_ptr" ref="a034e3f5bd429e2e0fd58cb3d4fd3fd16" args="(uint64_t phys, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* __cvmx_phys_addr_to_ptr </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>phys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal use. </p>
<p>This is userd to get a pointer to a physical address. For linux n32 the physical address in mmaped to a virtual address and the virtual address is returned. For n64 the address is converted to an xkphys address and the xkhpys address is returned. </p>

</div>
</div>
<a class="anchor" id="a4295ccfec5aeb9b415c92fbbb1f5873e"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_alloc" ref="a4295ccfec5aeb9b415c92fbbb1f5873e" args="(uint64_t size, uint64_t alignment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cvmx_bootmem_alloc </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>alignment</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a block of memory from the free list that was passed to the application by the bootloader. </p>
<p>This is an allocate-only algorithm, so freeing memory is not possible.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size in bytes of block to allocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alignment</em>&nbsp;</td><td>Alignment required - must be power of 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to block of memory, NULL on error </dd></dl>

</div>
</div>
<a class="anchor" id="a1aeeabcff132e8b9152bf5fa69068b87"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_alloc_address" ref="a1aeeabcff132e8b9152bf5fa69068b87" args="(uint64_t size, uint64_t address, uint64_t alignment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cvmx_bootmem_alloc_address </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>alignment</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a block of memory from the free list that was passed to the application by the bootloader at a specific address. </p>
<p>This is an allocate-only algorithm, so freeing memory is not possible. Allocation will fail if memory cannot be allocated at the specified address.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size in bytes of block to allocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>address</em>&nbsp;</td><td>Physical address to allocate memory at. If this memory is not available, the allocation fails. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alignment</em>&nbsp;</td><td>Alignment required - must be power of 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to block of memory, NULL on error </dd></dl>

</div>
</div>
<a class="anchor" id="ab787a63a038bd4e79d3b80f832b361f9"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_alloc_named" ref="ab787a63a038bd4e79d3b80f832b361f9" args="(uint64_t size, uint64_t alignment, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cvmx_bootmem_alloc_named </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a block of memory from the free list that was passed to the application by the bootloader, and assign it a name in the global named block table. </p>
<p>(part of the cvmx_bootmem_descriptor_t structure) Named blocks can later be freed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size in bytes of block to allocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alignment</em>&nbsp;</td><td>Alignment required - must be power of 2 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of block - must be less than CVMX_BOOTMEM_NAME_LEN bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to block of memory, NULL on error </dd></dl>

</div>
</div>
<a class="anchor" id="a30d21e76d1041d8ffbc92858e4008379"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_alloc_named_address" ref="a30d21e76d1041d8ffbc92858e4008379" args="(uint64_t size, uint64_t address, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cvmx_bootmem_alloc_named_address </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a block of memory from the free list that was passed to the application by the bootloader, and assign it a name in the global named block table. </p>
<p>(part of the cvmx_bootmem_descriptor_t structure) Named blocks can later be freed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size in bytes of block to allocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>address</em>&nbsp;</td><td>Physical address to allocate memory at. If this memory is not available, the allocation fails. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of block - must be less than CVMX_BOOTMEM_NAME_LEN bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to block of memory, NULL on error </dd></dl>

</div>
</div>
<a class="anchor" id="a88c92a0277cfce15ae750bd32e66ed0a"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_alloc_named_flags" ref="a88c92a0277cfce15ae750bd32e66ed0a" args="(uint64_t size, uint64_t alignment, const char *name, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cvmx_bootmem_alloc_named_flags </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a block of memory from the free list that was passed to the application by the bootloader, and assign it a name in the global named block table. </p>
<p>(part of the cvmx_bootmem_descriptor_t structure) Named blocks can later be freed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size in bytes of block to allocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alignment</em>&nbsp;</td><td>Alignment required - must be power of 2 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of block - must be less than CVMX_BOOTMEM_NAME_LEN bytes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags to control options for the allocation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to block of memory, NULL on error </dd></dl>

</div>
</div>
<a class="anchor" id="a9e6982b83394b6e740b938ed540d3cb1"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_alloc_named_range" ref="a9e6982b83394b6e740b938ed540d3cb1" args="(uint64_t size, uint64_t min_addr, uint64_t max_addr, uint64_t align, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cvmx_bootmem_alloc_named_range </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>min_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>max_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a block of memory from a specific range of the free list that was passed to the application by the bootloader, and assign it a name in the global named block table. </p>
<p>(part of the cvmx_bootmem_descriptor_t structure) Named blocks can later be freed. If request cannot be satisfied within the address range specified, NULL is returned</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size in bytes of block to allocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>min_addr</em>&nbsp;</td><td>minimum address of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_addr</em>&nbsp;</td><td>maximum address of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>align</em>&nbsp;</td><td>Alignment of memory to be allocated. (must be a power of 2) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of block - must be less than CVMX_BOOTMEM_NAME_LEN bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to block of memory, NULL on error </dd></dl>

</div>
</div>
<a class="anchor" id="ad4d863b8a85601d6f2d9e62428a1a29c"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_alloc_named_range_flags" ref="ad4d863b8a85601d6f2d9e62428a1a29c" args="(uint64_t size, uint64_t min_addr, uint64_t max_addr, uint64_t align, const char *name, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cvmx_bootmem_alloc_named_range_flags </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>min_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>max_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a287cdc81b2cc4249792c199242096b32"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_alloc_named_range_once" ref="a287cdc81b2cc4249792c199242096b32" args="(uint64_t size, uint64_t min_addr, uint64_t max_addr, uint64_t align, const char *name, void(*init)(void *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cvmx_bootmem_alloc_named_range_once </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>min_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>max_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>init</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate if needed a block of memory from a specific range of the free list that was passed to the application by the bootloader, and assign it a name in the global named block table. </p>
<p>(part of the cvmx_bootmem_descriptor_t structure) Named blocks can later be freed. If the requested name block is already allocated, return the pointer to block of memory. If request cannot be satisfied within the address range specified, NULL is returned</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size in bytes of block to allocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>min_addr</em>&nbsp;</td><td>minimum address of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_addr</em>&nbsp;</td><td>maximum address of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>align</em>&nbsp;</td><td>Alignment of memory to be allocated. (must be a power of 2) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of block - must be less than CVMX_BOOTMEM_NAME_LEN bytes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>init</em>&nbsp;</td><td>Initialization function</td></tr>
  </table>
  </dd>
</dl>
<p>The initialization function is optional, if omitted the named block is initialized to all zeros when it is created, i.e. once.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to block of memory, NULL on error </dd></dl>

</div>
</div>
<a class="anchor" id="a918fa07da4cdfaf9e8c09edd9eacf027"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_alloc_node" ref="a918fa07da4cdfaf9e8c09edd9eacf027" args="(uint64_t node, uint64_t size, uint64_t alignment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cvmx_bootmem_alloc_node </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>alignment</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a block of memory from the free list that was passed to the application by the bootloader from a specific node. </p>
<p>This is an allocate-only algorithm, so freeing memory is not possible.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>The node to allocate memory from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size in bytes of block to allocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alignment</em>&nbsp;</td><td>Alignment required - must be power of 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to block of memory, NULL on error </dd></dl>

</div>
</div>
<a class="anchor" id="a5f1db600138f2c00bc9e34e15a585e60"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_alloc_range" ref="a5f1db600138f2c00bc9e34e15a585e60" args="(uint64_t size, uint64_t alignment, uint64_t min_addr, uint64_t max_addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cvmx_bootmem_alloc_range </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>min_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>max_addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a block of memory from the free list that was passed to the application by the bootloader within a specified address range. </p>
<p>This is an allocate-only algorithm, so freeing memory is not possible. Allocation will fail if memory cannot be allocated in the requested range.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size in bytes of block to allocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>min_addr</em>&nbsp;</td><td>defines the minimum address of the range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_addr</em>&nbsp;</td><td>defines the maximum address of the range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alignment</em>&nbsp;</td><td>Alignment required - must be power of 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to block of memory, NULL on error </dd></dl>

</div>
</div>
<a class="anchor" id="ae8a84e6ef38c952b26e76f23c148c03d"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_alloc_range_flags" ref="ae8a84e6ef38c952b26e76f23c148c03d" args="(uint64_t size, uint64_t alignment, uint64_t min_addr, uint64_t max_addr, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cvmx_bootmem_alloc_range_flags </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>min_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>max_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a block of memory from the free list that was passed to the application by the bootloader within a specified address range. </p>
<p>This is an allocate-only algorithm, so freeing memory is not possible. Allocation will fail if memory cannot be allocated in the requested range.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size in bytes of block to allocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>min_addr</em>&nbsp;</td><td>defines the minimum address of the range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_addr</em>&nbsp;</td><td>defines the maximum address of the range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alignment</em>&nbsp;</td><td>Alignment required - must be power of 2 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags to control options for the allocation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to block of memory, NULL on error </dd></dl>

</div>
</div>
<a class="anchor" id="a6b2363b2a5328771ab156f8081fbc53b"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_available_mem" ref="a6b2363b2a5328771ab156f8081fbc53b" args="(uint64_t min_block_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cvmx_bootmem_available_mem </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>min_block_size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the size of available memory in bytes, only counting blocks that are at least as big as the minimum block size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>min_block_size</em>&nbsp;</td><td>Minimum block size to count in total.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes available for allocation that meet the block size requirement </dd></dl>

</div>
</div>
<a class="anchor" id="a91ab83d95ecdc1fce1a0d32d09aaab9b"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_find_named_block" ref="a91ab83d95ecdc1fce1a0d32d09aaab9b" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structcvmx__bootmem__named__block__desc.html">cvmx_bootmem_named_block_desc_t</a>* cvmx_bootmem_find_named_block </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds a named bootmem block by name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of block to free</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to named block <a class="el" href="structdescriptor.html">descriptor</a> on success 0 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="aad826d085ebf8a452e6120be2579c8bb"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_free_named" ref="aad826d085ebf8a452e6120be2579c8bb" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_bootmem_free_named </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees a previously allocated named bootmem block. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of block to free</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on failure, !0 on success </dd></dl>

</div>
</div>
<a class="anchor" id="acdcc9ba322d4fc16a8a1099b59445901"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_init" ref="acdcc9ba322d4fc16a8a1099b59445901" args="(uint64_t mem_desc_addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_bootmem_init </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>mem_desc_addr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the boot alloc memory structures. </p>
<p>This is normally called inside of <a class="el" href="cvmx-access_8h.html#a22c7fb96aa0426a2a74f7ff47c153e64" title="This function performs some default initialization of the Octeon executive.">cvmx_user_app_init()</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mem_desc_addr</em>&nbsp;</td><td>Address of the free memory list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aeb7a12587438b8e735032074a2b2b0a5"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_lock" ref="aeb7a12587438b8e735032074a2b2b0a5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvmx_bootmem_lock </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Locks the bootmem allocator. </p>
<p>This is useful in certain situations where multiple allocations must be made without being interrupted. This should be used with the CVMX_BOOTMEM_FLAG_NO_LOCKING flag. </p>

</div>
</div>
<a class="anchor" id="a05957d11119b4bd7b75623a209043fa2"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_phy_alloc" ref="a05957d11119b4bd7b75623a209043fa2" args="(uint64_t req_size, uint64_t address_min, uint64_t address_max, uint64_t alignment, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t cvmx_bootmem_phy_alloc </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>req_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>address_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>address_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates a block of physical memory from the free list, at (optional) requested address and alignment. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>req_size</em>&nbsp;</td><td>size of region to allocate. All requests are rounded up to be a multiple CVMX_BOOTMEM_ALIGNMENT_SIZE bytes size</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>address_min</em>&nbsp;</td><td>Minimum address that block can occupy.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>address_max</em>&nbsp;</td><td>Specifies the maximum address_min (inclusive) that the allocation can use.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alignment</em>&nbsp;</td><td>Requested alignment of the block. If this alignment cannot be met, the allocation fails. This must be a power of 2. (Note: Alignment of CVMX_BOOTMEM_ALIGNMENT_SIZE bytes is required, and internally enforced. Requested alignments of less than CVMX_BOOTMEM_ALIGNMENT_SIZE are set to CVMX_BOOTMEM_ALIGNMENT_SIZE.) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags to control options for the allocation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>physical address of block allocated, or -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ace5afa0dca0a8460e4c4f927da72a22d"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_phy_alloc_range" ref="ace5afa0dca0a8460e4c4f927da72a22d" args="(uint64_t size, uint64_t alignment, uint64_t min_addr, uint64_t max_addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cvmx_bootmem_phy_alloc_range </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>min_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>max_addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4d5b3fa2c531740d9ff3adef43fba6c9"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_phy_available_mem" ref="a4d5b3fa2c531740d9ff3adef43fba6c9" args="(uint64_t min_block_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cvmx_bootmem_phy_available_mem </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>min_block_size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the size of available memory in bytes, only counting blocks that are at least as big as the minimum block size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>min_block_size</em>&nbsp;</td><td>Minimum block size to count in total.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes available for allocation that meet the block size requirement </dd></dl>

</div>
</div>
<a class="anchor" id="aacc63c0743db73855b502bf0fdd9f0c4"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_phy_list_print" ref="aacc63c0743db73855b502bf0fdd9f0c4" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvmx_bootmem_phy_list_print </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints the list of available memory. </p>

</div>
</div>
<a class="anchor" id="a38b5caabc1a679454ef07c9cf66c63c8"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_phy_mem_list_init" ref="a38b5caabc1a679454ef07c9cf66c63c8" args="(uint64_t mem_size, uint32_t low_reserved_bytes, cvmx_bootmem_desc_t *desc_buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t cvmx_bootmem_phy_mem_list_init </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>mem_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>low_reserved_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvmx__bootmem__desc__t.html">cvmx_bootmem_desc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>desc_buffer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function initializes the free memory list used by cvmx_bootmem. </p>
<p>This must be called before any allocations can be done.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mem_size</em>&nbsp;</td><td>Total memory available, in bytes</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>low_reserved_bytes</em>&nbsp;</td><td>Number of bytes to reserve (leave out of free list) at address 0x0.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>desc_buffer</em>&nbsp;</td><td>Buffer for the bootmem <a class="el" href="structdescriptor.html">descriptor</a>. This must be a 32 bit addressable address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 on success 0 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a889cd14f083017427ada048d5d5dce02"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_phy_mem_list_init_multi" ref="a889cd14f083017427ada048d5d5dce02" args="(uint8_t nodemask, uint32_t mem_size[], uint32_t low_reserved_bytes, cvmx_bootmem_desc_t *desc_buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t cvmx_bootmem_phy_mem_list_init_multi </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>nodemask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>mem_size</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>low_reserved_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvmx__bootmem__desc__t.html">cvmx_bootmem_desc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>desc_buffer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function initializes the free memory list used by cvmx_bootmem. </p>
<p>This must be called before any allocations can be done.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nodemask</em>&nbsp;</td><td>Nodemask - one bit per node (bit0-&gt;node0, bit1-&gt;node1,...)</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mem_size[]</em>&nbsp;</td><td>Array of memory sizes in MBytes per node ([0]-&gt;node0,...)</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>low_reserved_bytes</em>&nbsp;</td><td>Number of bytes to reserve (leave out of free list) at address 0x0.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>desc_buffer</em>&nbsp;</td><td>Buffer for the bootmem <a class="el" href="structdescriptor.html">descriptor</a>. This must be a 32 bit addressable address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 on success 0 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a33a73dcc74933f5701804d0b51129ba6"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_phy_named_block_alloc" ref="a33a73dcc74933f5701804d0b51129ba6" args="(uint64_t size, uint64_t min_addr, uint64_t max_addr, uint64_t alignment, const char *name, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t cvmx_bootmem_phy_named_block_alloc </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>min_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>max_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates a named block of physical memory from the free list, at (optional) requested address and alignment. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>size of region to allocate. All requests are rounded up to be a multiple CVMX_BOOTMEM_ALIGNMENT_SIZE bytes size</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>min_addr</em>&nbsp;</td><td>Minimum address that block can occupy.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_addr</em>&nbsp;</td><td>Specifies the maximum address_min (inclusive) that the allocation can use.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alignment</em>&nbsp;</td><td>Requested alignment of the block. If this alignment cannot be met, the allocation fails. This must be a power of 2. (Note: Alignment of CVMX_BOOTMEM_ALIGNMENT_SIZE bytes is required, and internally enforced. Requested alignments of less than CVMX_BOOTMEM_ALIGNMENT_SIZE are set to CVMX_BOOTMEM_ALIGNMENT_SIZE.)</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name to assign to named block</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags to control options for the allocation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>physical address of block allocated, or -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a3275ade53d91556abc9d46247211fca4"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_phy_named_block_find" ref="a3275ade53d91556abc9d46247211fca4" args="(const char *name, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cvmx_bootmem_phy_named_block_find </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds a named memory block by name. </p>
<p>Also used for finding an unused entry in the named block table.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of memory block to find. If NULL pointer given, then finds unused <a class="el" href="structdescriptor.html">descriptor</a>, if available.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags to control options for the allocation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Physical address of the memory block <a class="el" href="structdescriptor.html">descriptor</a>, zero if not found. If zero returned when name parameter is NULL, then no memory block descriptors are available. </dd></dl>

</div>
</div>
<a class="anchor" id="a7457209ef2001be22938846c4c3f114b"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_phy_named_block_free" ref="a7457209ef2001be22938846c4c3f114b" args="(const char *name, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_bootmem_phy_named_block_free </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees a named block. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of block to free </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>flags for passing options</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on failure 1 on success </dd></dl>

</div>
</div>
<a class="anchor" id="a0588c4ceaf1b0e2f8c432911bc44b473"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_phy_named_block_print" ref="a0588c4ceaf1b0e2f8c432911bc44b473" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvmx_bootmem_phy_named_block_print </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints the list of currently allocated named blocks. </p>

</div>
</div>
<a class="anchor" id="a307ac29a8eda478a2c7b7f88fb29ba14"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_print_named" ref="a307ac29a8eda478a2c7b7f88fb29ba14" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvmx_bootmem_print_named </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints out the list of named blocks that have been allocated along with their addresses and sizes. </p>
<p>This is primarily used for debugging purposes </p>

</div>
</div>
<a class="anchor" id="acf313732820de4a5b08256b087212248"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_reserve_memory" ref="acf313732820de4a5b08256b087212248" args="(uint64_t start_addr, uint64_t size, const char *name, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_bootmem_reserve_memory </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>start_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate all free memory starting at the start address. </p>
<p>This is used to prevent any free blocks from later being allocated within the reserved space. Note that any memory allocated with this function cannot be later freed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start_addr</em>&nbsp;</td><td>Starting address to reserve </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size in bytes to reserve starting at start_addr </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name to assign to reserved blocks </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags to use when reserving memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on failure, !0 on success </dd></dl>

</div>
</div>
<a class="anchor" id="ae4e803936d44fb5d31bc52451fe27321"></a><!-- doxytag: member="cvmx&#45;bootmem.h::cvmx_bootmem_unlock" ref="ae4e803936d44fb5d31bc52451fe27321" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvmx_bootmem_unlock </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlocks the bootmem allocator. </p>
<p>This is useful in certain situations where multiple allocations must be made without being interrupted. This should be used with the CVMX_BOOTMEM_FLAG_NO_LOCKING flag. </p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Oct 2017 for Octeon Software Development Kit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
