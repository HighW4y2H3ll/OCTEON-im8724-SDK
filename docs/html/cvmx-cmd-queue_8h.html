<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Octeon Software Development Kit: cvmx-cmd-queue.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cvmx-cmd-queue.h File Reference</h1>
<p>Support functions for managing command queues used for various hardware blocks.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="cvmx-atomic_8h_source.html">cvmx-atomic.h</a>&quot;</code><br/>
<div class="dynheader">
Include dependency graph for cvmx-cmd-queue.h:</div>
<div class="dynsection">
<div class="center"><img src="cvmx-cmd-queue_8h__incl.png" border="0" usemap="#cvmx-cmd-queue_8h_map" alt=""/></div>
<map name="cvmx-cmd-queue_8h_map" id="cvmx-cmd-queue_8h">
<area shape="rect" id="node3" href="cvmx-atomic_8h.html" title="This file provides atomic operations." alt="" coords="21,83,144,112"/><area shape="rect" id="node5" href="cvmx-asm_8h.html" title="This is file defines ASM primitives for the executive." alt="" coords="31,160,135,189"/></map>
</div>
<div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dynsection">
<div class="center"><img src="cvmx-cmd-queue_8h__dep__incl.png" border="0" usemap="#cvmx-cmd-queue_8hdep_map" alt=""/></div>
<map name="cvmx-cmd-queue_8hdep_map" id="cvmx-cmd-queue_8hdep">
<area shape="rect" id="node3" href="cvmx-bch_8c.html" title="Interface to the CN70XX, CN78XX hardware BCH engine." alt="" coords="188,83,289,112"/><area shape="rect" id="node5" href="cvmx-cmd-queue_8c.html" title="Support functions for managing command queues used for various hardware blocks." alt="" coords="313,83,468,112"/><area shape="rect" id="node7" href="cvmx-dma-engine_8c.html" title="Interface to the PCI / PCIe DMA engines." alt="" coords="492,83,649,112"/><area shape="rect" id="node9" href="cvmx-hfa_8c.html" title="Support library for the CN63XX, CN68XX hardware HFA engine." alt="" coords="673,83,772,112"/><area shape="rect" id="node11" href="cvmx-hwpko_8h.html" title="Interface to the hardware Packet Output unit." alt="" coords="796,83,913,112"/><area shape="rect" id="node43" href="cvmx-raid_8c.html" title="Interface to RAID block." alt="" coords="937,83,1039,112"/><area shape="rect" id="node45" href="cvmx-zip_8c.html" title="Source file for the zip (deflate) block." alt="" coords="1063,83,1159,112"/><area shape="rect" id="node13" href="cvmx-helper-errata_8c.html" title="Fixes and workaround for Octeon chip errata." alt="" coords="5,160,171,189"/><area shape="rect" id="node15" href="cvmx-helper-ilk_8c.html" title="Functions for ILK initialization, configuration, and monitoring." alt="" coords="195,160,331,189"/><area shape="rect" id="node17" href="cvmx-helper-npi_8c.html" title="Functions for NPI initialization, configuration, and monitoring." alt="" coords="355,160,496,189"/><area shape="rect" id="node19" href="cvmx-helper-pko_8c.html" title="Helper Functions for the PKO." alt="" coords="520,160,667,189"/><area shape="rect" id="node21" href="cvmx-helper-rgmii_8c.html" title="Functions for RGMII/GMII/MII initialization, configuration, and monitoring." alt="" coords="691,160,845,189"/><area shape="rect" id="node23" href="cvmx-helper-util_8c.html" title="Small helper utilities." alt="" coords="869,160,1013,189"/><area shape="rect" id="node25" href="cvmx-ilk_8c.html" title="Support library for the ILK." alt="" coords="1037,160,1128,189"/><area shape="rect" id="node27" href="cvmx-pko_8h.html" title="cvmx&#45;pko.h" alt="" coords="1152,160,1251,189"/><area shape="rect" id="node39" href="cvmx-pko3_8c.html" title="cvmx&#45;pko3.c" alt="" coords="1275,160,1381,189"/><area shape="rect" id="node41" href="cvmx-spi_8c.html" title="Support library for the SPI." alt="" coords="1405,160,1499,189"/><area shape="rect" id="node29" href="cvmx-config-init_8c.html" title="cvmx&#45;config&#45;init.c" alt="" coords="807,237,951,267"/><area shape="rect" id="node31" href="cvmx-helper-fpa_8c.html" title="Helper functions for FPA setup." alt="" coords="975,237,1119,267"/><area shape="rect" id="node33" href="cvmx-helper_8c.html" title="Helper functions for common, but complicated tasks." alt="" coords="1143,237,1260,267"/><area shape="rect" id="node35" href="cvmx-pko_8c.html" title="Support library for the hardware Packet Output unit." alt="" coords="1284,237,1383,267"/><area shape="rect" id="node37" href="cvmx-pko3-compat_8c.html" title="cvmx&#45;pko3&#45;compat.c" alt="" coords="1407,237,1572,267"/></map>
</div>

<p><a href="cvmx-cmd-queue_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct____cvmx__cmd__queue__state__t.html">__cvmx_cmd_queue_state_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct____cvmx__cmd__queue__lock__t.html">__cvmx_cmd_queue_lock_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">command-queue locking uses a fair ticket spinlock algo, with 64-bit tickets for endianness-neutrality and counter overflow protection.  <a href="struct____cvmx__cmd__queue__lock__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct____cvmx__cmd__queue__all__state__t.html">__cvmx_cmd_queue_all_state_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal use function.  <a href="struct____cvmx__cmd__queue__all__state__t.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-cmd-queue_8h.html#ac4d43c8f2b330d837c81f4f9587dd55d">CVMX_CMD_QUEUE_ENABLE_MAX_DEPTH</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">By default we disable the max depth support.  <a href="#ac4d43c8f2b330d837c81f4f9587dd55d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-cmd-queue_8h.html#aea4d9a65fa8362fdcbf7c7780544f5fc">NUM_ELEMENTS</a>(arr)&nbsp;&nbsp;&nbsp;(sizeof(arr)/sizeof((arr)[0]))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-cmd-queue_8h.html#a0a878a80a0429d43d2952387ea239c54">CVMX_CMD_QUEUE_PKO</a>(queue)&nbsp;&nbsp;&nbsp;((<a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a>)(CVMX_CMD_QUEUE_PKO_BASE + (0xffff&amp;(queue))))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-cmd-queue_8h.html#a5c13f5c8405bda57227175586369a7c1">CVMX_CMD_QUEUE_ZIP_QUE</a>(queue)&nbsp;&nbsp;&nbsp;((<a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a>)(CVMX_CMD_QUEUE_ZIP + (0xffff&amp;(queue))))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-cmd-queue_8h.html#a1c19f82c5e2f99ddac2dbe357c7b5c73">CVMX_CMD_QUEUE_DMA</a>(queue)&nbsp;&nbsp;&nbsp;((<a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a>)(CVMX_CMD_QUEUE_DMA_BASE + (0xffff&amp;(queue))))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-cmd-queue_8h.html#a935049725d1d2bd671f32c25138628d6">CVMX_CMD_QUEUE_BCH</a>(queue)&nbsp;&nbsp;&nbsp;((<a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a>)(CVMX_CMD_QUEUE_BCH + (0xffff&amp;(queue))))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-cmd-queue_8h.html#a90073abc196fdca85af01f9f7445745c">CVMX_CMD_QUEUE_ZIP3_QUE</a>(node, queue)&nbsp;&nbsp;&nbsp;((<a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a>)((node) &lt;&lt; 24 | CVMX_CMD_QUEUE_ZIP | (0xffff&amp;(queue))))</td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a> { <a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2da635d1df239ec3ce9762c8c190ab545f2">CVMX_CMD_QUEUE_PKO_BASE</a> =  0x00000
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Enumeration representing all hardware blocks that use command queues. </p>
 <a href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-cmd-queue_8h.html#a2958d98fa19b89ef3b9083dbb3cbee6a">cvmx_cmd_queue_result_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="cvmx-cmd-queue_8h.html#a2958d98fa19b89ef3b9083dbb3cbee6aaecb62ecf845ba091b1e9d81a4acdc50f">CVMX_CMD_QUEUE_SUCCESS</a> =  0, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-cmd-queue_8h.html#a2958d98fa19b89ef3b9083dbb3cbee6aa5f002527d9f6108027e9fbfc980bd7b3">CVMX_CMD_QUEUE_NO_MEMORY</a> =  -1, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-cmd-queue_8h.html#a2958d98fa19b89ef3b9083dbb3cbee6aa2c628d914ce835a7e4a49bb59e0876ab">CVMX_CMD_QUEUE_FULL</a> =  -2, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-cmd-queue_8h.html#a2958d98fa19b89ef3b9083dbb3cbee6aacade2201fd39f2afbfd2873881cb76db">CVMX_CMD_QUEUE_INVALID_PARAM</a> =  -3, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-cmd-queue_8h.html#a2958d98fa19b89ef3b9083dbb3cbee6aa2bbf7d74e5d23f4524f14f283de1cee8">CVMX_CMD_QUEUE_ALREADY_SETUP</a> =  -4
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Command write operations can fail if the command queue needs a new buffer and the associated FPA pool is empty. </p>
 <a href="cvmx-cmd-queue_8h.html#a2958d98fa19b89ef3b9083dbb3cbee6a">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cvmx-cmd-queue_8h.html#a2958d98fa19b89ef3b9083dbb3cbee6a">cvmx_cmd_queue_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-cmd-queue_8h.html#ad19552e1597b5a9c10717a54dccea03d">__cvmx_cmd_queue_write_raw</a> (<a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a> queue_id, <a class="el" href="struct____cvmx__cmd__queue__state__t.html">__cvmx_cmd_queue_state_t</a> *qptr, int cmd_count, const uint64_t *cmds)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal use function.  <a href="#ad19552e1597b5a9c10717a54dccea03d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cvmx-cmd-queue_8h.html#a2958d98fa19b89ef3b9083dbb3cbee6a">cvmx_cmd_queue_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-cmd-queue_8h.html#aa9b2a7ae6be1bec01b6689533bb93569">cvmx_cmd_queue_initialize</a> (<a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a> queue_id, int max_depth, int fpa_pool, int pool_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a command queue for use.  <a href="#aa9b2a7ae6be1bec01b6689533bb93569"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cvmx-cmd-queue_8h.html#a2958d98fa19b89ef3b9083dbb3cbee6a">cvmx_cmd_queue_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-cmd-queue_8h.html#ad96e7820890ba73e3fd85382341d813b">cvmx_cmd_queue_shutdown</a> (<a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a> queue_id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shutdown a queue a free it's command buffers to the FPA.  <a href="#ad96e7820890ba73e3fd85382341d813b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-cmd-queue_8h.html#a70e56b69f67ab0838c921f43e9fbe829">cvmx_cmd_queue_length</a> (<a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a> queue_id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of command words pending in the queue.  <a href="#a70e56b69f67ab0838c921f43e9fbe829"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-cmd-queue_8h.html#a7eead149de2696a66acbea1875d20708">cvmx_cmd_queue_buffer</a> (<a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a> queue_id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the command buffer to be written to.  <a href="#a7eead149de2696a66acbea1875d20708"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cvmx-cmd-queue_8h.html#a2958d98fa19b89ef3b9083dbb3cbee6a">cvmx_cmd_queue_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-cmd-queue_8h.html#a55a4c53d1ce56878f66c43a53ee62576">__cvmx_cmd_queue_init_state_ptr</a> (unsigned node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal use function.  <a href="#a55a4c53d1ce56878f66c43a53ee62576"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-cmd-queue_8h.html#a6d2a4c32836f3c88e06072396de6fc2c">__cvmx_cmd_queue_get_index</a> (<a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a> queue_id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal use function.  <a href="#a6d2a4c32836f3c88e06072396de6fc2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-cmd-queue_8h.html#ade12ab5f15afc054e5b0cfd1b164793c">__cvmx_cmd_queue_get_node</a> (<a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a> queue_id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-cmd-queue_8h.html#a5c7f39f1c9f3415b933fad287d40e128">__cvmx_cmd_queue_lock</a> (<a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a> queue_id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal use function.  <a href="#a5c7f39f1c9f3415b933fad287d40e128"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-cmd-queue_8h.html#a4a5774f4054a8d6dffe4a049b6d932c3">__cvmx_cmd_queue_unlock</a> (<a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a> queue_id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal use function.  <a href="#a4a5774f4054a8d6dffe4a049b6d932c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-cmd-queue_8h.html#a5c8879681302fe33fc1e425d459ba913">__cvmx_cmd_queue_lock_init</a> (<a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a> queue_id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal use function.  <a href="#a5c8879681302fe33fc1e425d459ba913"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct____cvmx__cmd__queue__state__t.html">__cvmx_cmd_queue_state_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-cmd-queue_8h.html#ab99fe30e444ea25b0f196439d857298c">__cvmx_cmd_queue_get_state</a> (<a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a> queue_id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal use function.  <a href="#ab99fe30e444ea25b0f196439d857298c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="cvmx-cmd-queue_8h.html#a2958d98fa19b89ef3b9083dbb3cbee6a">cvmx_cmd_queue_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-cmd-queue_8h.html#aecf92c051ffdbab9c1c23cb146c92fc7">cvmx_cmd_queue_write</a> (<a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a> queue_id, bool use_locking, int cmd_count, const uint64_t *cmds)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write an arbitrary number of command words to a command queue.  <a href="#aecf92c051ffdbab9c1c23cb146c92fc7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="cvmx-cmd-queue_8h.html#a2958d98fa19b89ef3b9083dbb3cbee6a">cvmx_cmd_queue_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-cmd-queue_8h.html#ae29cf3c3be700e5b7c146c120136b1a0">cvmx_cmd_queue_write2</a> (<a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a> queue_id, bool use_locking, uint64_t cmd1, uint64_t cmd2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple function to write two command words to a command queue.  <a href="#ae29cf3c3be700e5b7c146c120136b1a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="cvmx-cmd-queue_8h.html#a2958d98fa19b89ef3b9083dbb3cbee6a">cvmx_cmd_queue_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-cmd-queue_8h.html#ac97a4167c9e723623d1a69a8aaefeb70">cvmx_cmd_queue_write3</a> (<a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a> queue_id, bool use_locking, uint64_t cmd1, uint64_t cmd2, uint64_t cmd3)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple function to write three command words to a command queue.  <a href="#ac97a4167c9e723623d1a69a8aaefeb70"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CVMX_SHARED <br class="typebreak"/>
<a class="el" href="struct____cvmx__cmd__queue__all__state__t.html">__cvmx_cmd_queue_all_state_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-cmd-queue_8h.html#a51844c9b38830471090d434c2d9cc587">__cvmx_cmd_queue_state_ptrs</a> [CVMX_MAX_NODES]</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This application uses this pointer to access the global queue state.  <a href="#a51844c9b38830471090d434c2d9cc587"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Support functions for managing command queues used for various hardware blocks. </p>
<p>The common command queue infrastructure abstracts out the software necessary for adding to Octeon's chained queue structures. These structures are used for commands to the PKO, ZIP, DFA, RAID, HNA, and DMA engine blocks. Although each hardware unit takes commands and CSRs of different types, they all use basic linked command buffers to store the pending request. In general, users of the CVMX API don't call cvmx-cmd-queue functions directly. Instead the hardware unit specific wrapper should be used. The wrappers perform unit specific validation and CSR writes to submit the commands.</p>
<p>Even though most software will never directly interact with cvmx-cmd-queue, knowledge of its internal workings can help in diagnosing performance problems and help with debugging.</p>
<p>Command queue pointers are stored in a global named block called "cvmx_cmd_queues". Except for the PKO queues, each hardware queue is stored in its own cache line to reduce SMP contention on spin locks. The PKO queues are stored such that every 16th queue is next to each other in memory. This scheme allows for queues being in separate cache lines when there are low number of queues per port. With 16 queues per port, the first queue for each port is in the same cache area. The second queues for each port are in another area, etc. This allows software to implement very efficient lockless PKO with 16 queues per port using a minimum of cache lines per core. All queues for a given core will be isolated in the same cache area.</p>
<p>In addition to the memory pointer layout, cvmx-cmd-queue provides an optimized fair ll/sc locking mechanism for the queues. The lock uses a "ticket / now serving" model to maintain fair order on contended locks. In addition, it uses predicted locking time to limit cache contention. When a core know it must wait in line for a lock, it spins on the internal cycle counter to completely eliminate any causes of bus traffic.</p>
<hr/>
 <dl class="rcs"><dt><b>Revision</b></dt><dd>137666 </dd></dl>
<hr/>
 <hr/><h2>Define Documentation</h2>
<a class="anchor" id="a935049725d1d2bd671f32c25138628d6"></a><!-- doxytag: member="cvmx&#45;cmd&#45;queue.h::CVMX_CMD_QUEUE_BCH" ref="a935049725d1d2bd671f32c25138628d6" args="(queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CVMX_CMD_QUEUE_BCH</td>
          <td>(</td>
          <td class="paramtype">queue&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((<a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a>)(CVMX_CMD_QUEUE_BCH + (0xffff&amp;(queue))))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1c19f82c5e2f99ddac2dbe357c7b5c73"></a><!-- doxytag: member="cvmx&#45;cmd&#45;queue.h::CVMX_CMD_QUEUE_DMA" ref="a1c19f82c5e2f99ddac2dbe357c7b5c73" args="(queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CVMX_CMD_QUEUE_DMA</td>
          <td>(</td>
          <td class="paramtype">queue&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((<a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a>)(CVMX_CMD_QUEUE_DMA_BASE + (0xffff&amp;(queue))))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac4d43c8f2b330d837c81f4f9587dd55d"></a><!-- doxytag: member="cvmx&#45;cmd&#45;queue.h::CVMX_CMD_QUEUE_ENABLE_MAX_DEPTH" ref="ac4d43c8f2b330d837c81f4f9587dd55d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CVMX_CMD_QUEUE_ENABLE_MAX_DEPTH&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>By default we disable the max depth support. </p>
<p>Most programs don't use it and it slows down the command queue processing significantly. </p>

</div>
</div>
<a class="anchor" id="a0a878a80a0429d43d2952387ea239c54"></a><!-- doxytag: member="cvmx&#45;cmd&#45;queue.h::CVMX_CMD_QUEUE_PKO" ref="a0a878a80a0429d43d2952387ea239c54" args="(queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CVMX_CMD_QUEUE_PKO</td>
          <td>(</td>
          <td class="paramtype">queue&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((<a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a>)(CVMX_CMD_QUEUE_PKO_BASE + (0xffff&amp;(queue))))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a90073abc196fdca85af01f9f7445745c"></a><!-- doxytag: member="cvmx&#45;cmd&#45;queue.h::CVMX_CMD_QUEUE_ZIP3_QUE" ref="a90073abc196fdca85af01f9f7445745c" args="(node, queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CVMX_CMD_QUEUE_ZIP3_QUE</td>
          <td>(</td>
          <td class="paramtype">node, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">queue&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((<a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a>)((node) &lt;&lt; 24 | CVMX_CMD_QUEUE_ZIP | (0xffff&amp;(queue))))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5c13f5c8405bda57227175586369a7c1"></a><!-- doxytag: member="cvmx&#45;cmd&#45;queue.h::CVMX_CMD_QUEUE_ZIP_QUE" ref="a5c13f5c8405bda57227175586369a7c1" args="(queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CVMX_CMD_QUEUE_ZIP_QUE</td>
          <td>(</td>
          <td class="paramtype">queue&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((<a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a>)(CVMX_CMD_QUEUE_ZIP + (0xffff&amp;(queue))))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aea4d9a65fa8362fdcbf7c7780544f5fc"></a><!-- doxytag: member="cvmx&#45;cmd&#45;queue.h::NUM_ELEMENTS" ref="aea4d9a65fa8362fdcbf7c7780544f5fc" args="(arr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUM_ELEMENTS</td>
          <td>(</td>
          <td class="paramtype">arr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(sizeof(arr)/sizeof((arr)[0]))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a3687cc47482faac6b54e5ee83c3a2a2d"></a><!-- doxytag: member="cvmx&#45;cmd&#45;queue.h::cvmx_cmd_queue_id_t" ref="a3687cc47482faac6b54e5ee83c3a2a2d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enumeration representing all hardware blocks that use command queues. </p>
<p>Each hardware block has up to 65536 sub identifiers for multiple command queues. Not all chips support all hardware units. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a3687cc47482faac6b54e5ee83c3a2a2da635d1df239ec3ce9762c8c190ab545f2"></a><!-- doxytag: member="CVMX_CMD_QUEUE_PKO_BASE" ref="a3687cc47482faac6b54e5ee83c3a2a2da635d1df239ec3ce9762c8c190ab545f2" args="" -->CVMX_CMD_QUEUE_PKO_BASE</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a2958d98fa19b89ef3b9083dbb3cbee6a"></a><!-- doxytag: member="cvmx&#45;cmd&#45;queue.h::cvmx_cmd_queue_result_t" ref="a2958d98fa19b89ef3b9083dbb3cbee6a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cvmx-cmd-queue_8h.html#a2958d98fa19b89ef3b9083dbb3cbee6a">cvmx_cmd_queue_result_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Command write operations can fail if the command queue needs a new buffer and the associated FPA pool is empty. </p>
<p>It can also fail if the number of queued command words reaches the maximum set at initialization. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a2958d98fa19b89ef3b9083dbb3cbee6aaecb62ecf845ba091b1e9d81a4acdc50f"></a><!-- doxytag: member="CVMX_CMD_QUEUE_SUCCESS" ref="a2958d98fa19b89ef3b9083dbb3cbee6aaecb62ecf845ba091b1e9d81a4acdc50f" args="" -->CVMX_CMD_QUEUE_SUCCESS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a2958d98fa19b89ef3b9083dbb3cbee6aa5f002527d9f6108027e9fbfc980bd7b3"></a><!-- doxytag: member="CVMX_CMD_QUEUE_NO_MEMORY" ref="a2958d98fa19b89ef3b9083dbb3cbee6aa5f002527d9f6108027e9fbfc980bd7b3" args="" -->CVMX_CMD_QUEUE_NO_MEMORY</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a2958d98fa19b89ef3b9083dbb3cbee6aa2c628d914ce835a7e4a49bb59e0876ab"></a><!-- doxytag: member="CVMX_CMD_QUEUE_FULL" ref="a2958d98fa19b89ef3b9083dbb3cbee6aa2c628d914ce835a7e4a49bb59e0876ab" args="" -->CVMX_CMD_QUEUE_FULL</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a2958d98fa19b89ef3b9083dbb3cbee6aacade2201fd39f2afbfd2873881cb76db"></a><!-- doxytag: member="CVMX_CMD_QUEUE_INVALID_PARAM" ref="a2958d98fa19b89ef3b9083dbb3cbee6aacade2201fd39f2afbfd2873881cb76db" args="" -->CVMX_CMD_QUEUE_INVALID_PARAM</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a2958d98fa19b89ef3b9083dbb3cbee6aa2bbf7d74e5d23f4524f14f283de1cee8"></a><!-- doxytag: member="CVMX_CMD_QUEUE_ALREADY_SETUP" ref="a2958d98fa19b89ef3b9083dbb3cbee6aa2bbf7d74e5d23f4524f14f283de1cee8" args="" -->CVMX_CMD_QUEUE_ALREADY_SETUP</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a6d2a4c32836f3c88e06072396de6fc2c"></a><!-- doxytag: member="cvmx&#45;cmd&#45;queue.h::__cvmx_cmd_queue_get_index" ref="a6d2a4c32836f3c88e06072396de6fc2c" args="(cvmx_cmd_queue_id_t queue_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned __cvmx_cmd_queue_get_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue_id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal use function. </p>
<p><b>This function's parameters and processing may change in future SDKs.</b><br/>
<br/>
 Get the index into the state arrays for the supplied queue id.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue_id</em>&nbsp;</td><td>Queue ID to get an index for</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Index into the state arrays </dd></dl>

</div>
</div>
<a class="anchor" id="ade12ab5f15afc054e5b0cfd1b164793c"></a><!-- doxytag: member="cvmx&#45;cmd&#45;queue.h::__cvmx_cmd_queue_get_node" ref="ade12ab5f15afc054e5b0cfd1b164793c" args="(cvmx_cmd_queue_id_t queue_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int __cvmx_cmd_queue_get_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue_id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab99fe30e444ea25b0f196439d857298c"></a><!-- doxytag: member="cvmx&#45;cmd&#45;queue.h::__cvmx_cmd_queue_get_state" ref="ab99fe30e444ea25b0f196439d857298c" args="(cvmx_cmd_queue_id_t queue_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct____cvmx__cmd__queue__state__t.html">__cvmx_cmd_queue_state_t</a>* __cvmx_cmd_queue_get_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue_id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal use function. </p>
<p><b>This function's parameters and processing may change in future SDKs.</b><br/>
<br/>
 Get the queue state structure for the given queue id</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue_id</em>&nbsp;</td><td>Queue id to get</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Queue structure or NULL on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a55a4c53d1ce56878f66c43a53ee62576"></a><!-- doxytag: member="cvmx&#45;cmd&#45;queue.h::__cvmx_cmd_queue_init_state_ptr" ref="a55a4c53d1ce56878f66c43a53ee62576" args="(unsigned node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cvmx-cmd-queue_8h.html#a2958d98fa19b89ef3b9083dbb3cbee6a">cvmx_cmd_queue_result_t</a> __cvmx_cmd_queue_init_state_ptr </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal use function. </p>
<p><b>This function's parameters and processing may change in future SDKs.</b><br/>
<br/>
 Retreive or allocate command queue state named block</p>
<p><b>This function's parameters and processing may change in future SDKs.</b><br/>
<br/>
 Initialize the Global queue state pointer.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>CVMX_CMD_QUEUE_SUCCESS or a failure code </dd></dl>

</div>
</div>
<a class="anchor" id="a5c7f39f1c9f3415b933fad287d40e128"></a><!-- doxytag: member="cvmx&#45;cmd&#45;queue.h::__cvmx_cmd_queue_lock" ref="a5c7f39f1c9f3415b933fad287d40e128" args="(cvmx_cmd_queue_id_t queue_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void __cvmx_cmd_queue_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue_id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal use function. </p>
<p><b>This function's parameters and processing may change in future SDKs.</b><br/>
<br/>
 Lock the supplied queue so nobody else is updating it at the same time as us.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue_id</em>&nbsp;</td><td>Queue ID to lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5c8879681302fe33fc1e425d459ba913"></a><!-- doxytag: member="cvmx&#45;cmd&#45;queue.h::__cvmx_cmd_queue_lock_init" ref="a5c8879681302fe33fc1e425d459ba913" args="(cvmx_cmd_queue_id_t queue_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void __cvmx_cmd_queue_lock_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue_id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal use function. </p>
<p><b>This function's parameters and processing may change in future SDKs.</b><br/>
<br/>
 Initialize a command-queue lock to "unlocked" state. </p>

</div>
</div>
<a class="anchor" id="a4a5774f4054a8d6dffe4a049b6d932c3"></a><!-- doxytag: member="cvmx&#45;cmd&#45;queue.h::__cvmx_cmd_queue_unlock" ref="a4a5774f4054a8d6dffe4a049b6d932c3" args="(cvmx_cmd_queue_id_t queue_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void __cvmx_cmd_queue_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue_id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal use function. </p>
<p><b>This function's parameters and processing may change in future SDKs.</b><br/>
<br/>
 Unlock the queue, flushing all writes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue_id</em>&nbsp;</td><td>Queue ID to lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad19552e1597b5a9c10717a54dccea03d"></a><!-- doxytag: member="cvmx&#45;cmd&#45;queue.h::__cvmx_cmd_queue_write_raw" ref="ad19552e1597b5a9c10717a54dccea03d" args="(cvmx_cmd_queue_id_t queue_id, __cvmx_cmd_queue_state_t *qptr, int cmd_count, const uint64_t *cmds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cvmx-cmd-queue_8h.html#a2958d98fa19b89ef3b9083dbb3cbee6a">cvmx_cmd_queue_result_t</a> __cvmx_cmd_queue_write_raw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct____cvmx__cmd__queue__state__t.html">__cvmx_cmd_queue_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>qptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>cmd_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t *&nbsp;</td>
          <td class="paramname"> <em>cmds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal use function. </p>
<p><b>This function's parameters and processing may change in future SDKs.</b><br/>
<br/>
 Internal function to handle the corner cases of adding command words to a queue when the current block is getting full.</p>
<p><b>This function's parameters and processing may change in future SDKs.</b><br/>
<br/>
 Add command words into a queue, handles all the corener cases where only some of the words might fit into the current block, and a new block may need to be allocated. Locking and argument checks are done in the front-end in-line functions that call this one for the rare corner cases. </p>

</div>
</div>
<a class="anchor" id="a7eead149de2696a66acbea1875d20708"></a><!-- doxytag: member="cvmx&#45;cmd&#45;queue.h::cvmx_cmd_queue_buffer" ref="a7eead149de2696a66acbea1875d20708" args="(cvmx_cmd_queue_id_t queue_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cvmx_cmd_queue_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue_id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the command buffer to be written to. </p>
<p>The purpose of this function is to allow CVMX routine access to the low level buffer for initial hardware setup. User applications should not call this function directly.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue_id</em>&nbsp;</td><td>Command queue to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Command buffer or NULL on failure </dd></dl>

</div>
</div>
<a class="anchor" id="aa9b2a7ae6be1bec01b6689533bb93569"></a><!-- doxytag: member="cvmx&#45;cmd&#45;queue.h::cvmx_cmd_queue_initialize" ref="aa9b2a7ae6be1bec01b6689533bb93569" args="(cvmx_cmd_queue_id_t queue_id, int max_depth, int fpa_pool, int pool_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cvmx-cmd-queue_8h.html#a2958d98fa19b89ef3b9083dbb3cbee6a">cvmx_cmd_queue_result_t</a> cvmx_cmd_queue_initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fpa_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pool_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize a command queue for use. </p>
<p>The initial FPA buffer is allocated and the hardware unit is configured to point to the new command queue.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue_id</em>&nbsp;</td><td>Hardware command queue to initialize. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_depth</em>&nbsp;</td><td>Maximum outstanding commands that can be queued. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fpa_pool</em>&nbsp;</td><td>FPA pool the command queues should come from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pool_size</em>&nbsp;</td><td>Size of each buffer in the FPA pool (bytes)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CVMX_CMD_QUEUE_SUCCESS or a failure code </dd></dl>

</div>
</div>
<a class="anchor" id="a70e56b69f67ab0838c921f43e9fbe829"></a><!-- doxytag: member="cvmx&#45;cmd&#45;queue.h::cvmx_cmd_queue_length" ref="a70e56b69f67ab0838c921f43e9fbe829" args="(cvmx_cmd_queue_id_t queue_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_cmd_queue_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue_id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of command words pending in the queue. </p>
<p>This function may be relatively slow for some hardware units.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue_id</em>&nbsp;</td><td>Hardware command queue to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of outstanding commands </dd></dl>

</div>
</div>
<a class="anchor" id="ad96e7820890ba73e3fd85382341d813b"></a><!-- doxytag: member="cvmx&#45;cmd&#45;queue.h::cvmx_cmd_queue_shutdown" ref="ad96e7820890ba73e3fd85382341d813b" args="(cvmx_cmd_queue_id_t queue_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cvmx-cmd-queue_8h.html#a2958d98fa19b89ef3b9083dbb3cbee6a">cvmx_cmd_queue_result_t</a> cvmx_cmd_queue_shutdown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue_id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shutdown a queue a free it's command buffers to the FPA. </p>
<p>The hardware connected to the queue must be stopped before this function is called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue_id</em>&nbsp;</td><td>Queue to shutdown</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CVMX_CMD_QUEUE_SUCCESS or a failure code </dd></dl>

</div>
</div>
<a class="anchor" id="aecf92c051ffdbab9c1c23cb146c92fc7"></a><!-- doxytag: member="cvmx&#45;cmd&#45;queue.h::cvmx_cmd_queue_write" ref="aecf92c051ffdbab9c1c23cb146c92fc7" args="(cvmx_cmd_queue_id_t queue_id, bool use_locking, int cmd_count, const uint64_t *cmds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="cvmx-cmd-queue_8h.html#a2958d98fa19b89ef3b9083dbb3cbee6a">cvmx_cmd_queue_result_t</a> cvmx_cmd_queue_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_locking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>cmd_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t *&nbsp;</td>
          <td class="paramname"> <em>cmds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write an arbitrary number of command words to a command queue. </p>
<p>This is a generic function; the fixed number of command word functions yield higher performance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue_id</em>&nbsp;</td><td>Hardware command queue to write to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>use_locking</em>&nbsp;</td><td>Use internal locking to ensure exclusive access for queue updates. If you don't use this locking you must ensure exclusivity some other way. Locking is strongly recommended. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmd_count</em>&nbsp;</td><td>Number of command words to write </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmds</em>&nbsp;</td><td>Array of commands to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CVMX_CMD_QUEUE_SUCCESS or a failure code </dd></dl>

</div>
</div>
<a class="anchor" id="ae29cf3c3be700e5b7c146c120136b1a0"></a><!-- doxytag: member="cvmx&#45;cmd&#45;queue.h::cvmx_cmd_queue_write2" ref="ae29cf3c3be700e5b7c146c120136b1a0" args="(cvmx_cmd_queue_id_t queue_id, bool use_locking, uint64_t cmd1, uint64_t cmd2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="cvmx-cmd-queue_8h.html#a2958d98fa19b89ef3b9083dbb3cbee6a">cvmx_cmd_queue_result_t</a> cvmx_cmd_queue_write2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_locking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>cmd1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>cmd2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Simple function to write two command words to a command queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue_id</em>&nbsp;</td><td>Hardware command queue to write to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>use_locking</em>&nbsp;</td><td>Use internal locking to ensure exclusive access for queue updates. If you don't use this locking you must ensure exclusivity some other way. Locking is strongly recommended. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmd1</em>&nbsp;</td><td>Command </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmd2</em>&nbsp;</td><td>Command</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CVMX_CMD_QUEUE_SUCCESS or a failure code </dd></dl>

</div>
</div>
<a class="anchor" id="ac97a4167c9e723623d1a69a8aaefeb70"></a><!-- doxytag: member="cvmx&#45;cmd&#45;queue.h::cvmx_cmd_queue_write3" ref="ac97a4167c9e723623d1a69a8aaefeb70" args="(cvmx_cmd_queue_id_t queue_id, bool use_locking, uint64_t cmd1, uint64_t cmd2, uint64_t cmd3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="cvmx-cmd-queue_8h.html#a2958d98fa19b89ef3b9083dbb3cbee6a">cvmx_cmd_queue_result_t</a> cvmx_cmd_queue_write3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cvmx-cmd-queue_8h.html#a3687cc47482faac6b54e5ee83c3a2a2d">cvmx_cmd_queue_id_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_locking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>cmd1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>cmd2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>cmd3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Simple function to write three command words to a command queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue_id</em>&nbsp;</td><td>Hardware command queue to write to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>use_locking</em>&nbsp;</td><td>Use internal locking to ensure exclusive access for queue updates. If you don't use this locking you must ensure exclusivity some other way. Locking is strongly recommended. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmd1</em>&nbsp;</td><td>Command </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmd2</em>&nbsp;</td><td>Command </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmd3</em>&nbsp;</td><td>Command</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CVMX_CMD_QUEUE_SUCCESS or a failure code </dd></dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a51844c9b38830471090d434c2d9cc587"></a><!-- doxytag: member="cvmx&#45;cmd&#45;queue.h::__cvmx_cmd_queue_state_ptrs" ref="a51844c9b38830471090d434c2d9cc587" args="[CVMX_MAX_NODES]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVMX_SHARED <a class="el" href="struct____cvmx__cmd__queue__all__state__t.html">__cvmx_cmd_queue_all_state_t</a>* <a class="el" href="cvmx-cmd-queue_8h.html#a51844c9b38830471090d434c2d9cc587">__cvmx_cmd_queue_state_ptrs</a>[CVMX_MAX_NODES]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This application uses this pointer to access the global queue state. </p>
<p>It points to a bootmem named block. </p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Oct 2017 for Octeon Software Development Kit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
