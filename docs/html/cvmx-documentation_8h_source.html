<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Octeon Software Development Kit: cvmx-documentation.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>cvmx-documentation.h</h1><a href="cvmx-documentation_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/***********************license start************************************</span>
<a name="l00002"></a>00002 <span class="comment"> * OCTEON SDK</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * Copyright (c) 2007 Cavium Inc.. All rights reserved.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * This file, which is part of the OCTEON SDK from Cavium Inc.,</span>
<a name="l00007"></a>00007 <span class="comment"> * contains proprietary and confidential information of Cavium Inc. and</span>
<a name="l00008"></a>00008 <span class="comment"> * its suppliers.</span>
<a name="l00009"></a>00009 <span class="comment"> * Contact Cavium Inc. at info@cavium.com for more information.</span>
<a name="l00010"></a>00010 <span class="comment"> **********************license end**************************************/</span><span class="comment"></span>
<a name="l00011"></a>00011 <span class="comment">/**</span>
<a name="l00012"></a>00012 <span class="comment"> * @file</span>
<a name="l00013"></a>00013 <span class="comment"> *</span>
<a name="l00014"></a>00014 <span class="comment"> * Simple executive general documentation.</span>
<a name="l00015"></a>00015 <span class="comment"> * @ref cvmx_overview</span>
<a name="l00016"></a>00016 <span class="comment"> */</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment">/**</span>
<a name="l00019"></a>00019 <span class="comment"></span>
<a name="l00020"></a>00020 <span class="comment">@page cvmx_overview OCTEON Simple Executive Overview</span>
<a name="l00021"></a>00021 <span class="comment"></span>
<a name="l00022"></a>00022 <span class="comment">@section cvmx_contenst Contents</span>
<a name="l00023"></a>00023 <span class="comment"></span>
<a name="l00024"></a>00024 <span class="comment"> - @ref introduction_simple_exec</span>
<a name="l00025"></a>00025 <span class="comment"> - @ref programming</span>
<a name="l00026"></a>00026 <span class="comment"> - @ref c_cpp_library</span>
<a name="l00027"></a>00027 <span class="comment"> - @ref hal</span>
<a name="l00028"></a>00028 <span class="comment"> - @ref memory</span>
<a name="l00029"></a>00029 <span class="comment"> - @ref synchronization</span>
<a name="l00030"></a>00030 <span class="comment"> - @ref interrupts</span>
<a name="l00031"></a>00031 <span class="comment"> - @ref hotplug</span>
<a name="l00032"></a>00032 <span class="comment"> - @ref models</span>
<a name="l00033"></a>00033 <span class="comment"></span>
<a name="l00034"></a>00034 <span class="comment">@section introduction_simple_exec 1 Introduction</span>
<a name="l00035"></a>00035 <span class="comment"></span>
<a name="l00036"></a>00036 <span class="comment">The OCTEON Executive Library provides runtime support, hardware</span>
<a name="l00037"></a>00037 <span class="comment">abstraction, memory managment, and synchronization routines for the OCTEON</span>
<a name="l00038"></a>00038 <span class="comment">processor.  It is composed of the libcvmx.a library as well as header</span>
<a name="l00039"></a>00039 <span class="comment">files that provide a lot of functionality with inline functions.  The</span>
<a name="l00040"></a>00040 <span class="comment">Executive is designed to provide an efficient environment for developing</span>
<a name="l00041"></a>00041 <span class="comment">data plane code for OCTEON.  It supports a single thread of execution per</span>
<a name="l00042"></a>00042 <span class="comment">cnMIPS core.</span>
<a name="l00043"></a>00043 <span class="comment"></span>
<a name="l00044"></a>00044 <span class="comment"></span>
<a name="l00045"></a>00045 <span class="comment">@section programming 2 Programming Model</span>
<a name="l00046"></a>00046 <span class="comment"></span>
<a name="l00047"></a>00047 <span class="comment">@subsection process_per_core_memory_model 2.1 Single Process per core memory model</span>
<a name="l00048"></a>00048 <span class="comment"></span>
<a name="l00049"></a>00049 <span class="comment">    When a simple executive application is run on multiple cores, it is run</span>
<a name="l00050"></a>00050 <span class="comment">    as one &apos;process&apos; per core (as opposed to one &apos;thread&apos;.)  Each core has its</span>
<a name="l00051"></a>00051 <span class="comment">    own copy of global variables - nothing is shared by default.  Shared</span>
<a name="l00052"></a>00052 <span class="comment">    variables can be created at compile time with the CVMX_SHARED attribute.</span>
<a name="l00053"></a>00053 <span class="comment">    Variables with the CVMX_SHARED attribute are shared between all cores</span>
<a name="l00054"></a>00054 <span class="comment">    running the same application image.  The TLB is used to map each core&apos;s</span>
<a name="l00055"></a>00055 <span class="comment">    copy of the global data to the same virtual address, allowing each core to have</span>
<a name="l00056"></a>00056 <span class="comment">    its own copy.</span>
<a name="l00057"></a>00057 <span class="comment"></span>
<a name="l00058"></a>00058 <span class="comment"> @subsection tlb_usage 2.2 TLB usage</span>
<a name="l00059"></a>00059 <span class="comment"></span>
<a name="l00060"></a>00060 <span class="comment">    The simple executive uses TLB mappings for the following purposes:</span>
<a name="l00061"></a>00061 <span class="comment">    - to allow each core to have its own copy of global data at the same</span>
<a name="l00062"></a>00062 <span class="comment">        virtual address (process memory model)</span>
<a name="l00063"></a>00063 <span class="comment">    - to provide readonly access to code</span>
<a name="l00064"></a>00064 <span class="comment">    - to provide stack overflow protection</span>
<a name="l00065"></a>00065 <span class="comment">    - to simplify sharing of memory addresses with hardware units</span>
<a name="l00066"></a>00066 <span class="comment"></span>
<a name="l00067"></a>00067 <span class="comment">    The bootloader configures the TLB for all the above mappings except the</span>
<a name="l00068"></a>00068 <span class="comment">    1-1 mapping used to simplify address sharing with hardware units.</span>
<a name="l00069"></a>00069 <span class="comment"></span>
<a name="l00070"></a>00070 <span class="comment">@subsection read_only_access_to_code 2.2.1 Read only access to code</span>
<a name="l00071"></a>00071 <span class="comment"></span>
<a name="l00072"></a>00072 <span class="comment">    The TLB is used to provide read only access to the application code.</span>
<a name="l00073"></a>00073 <span class="comment"></span>
<a name="l00074"></a>00074 <span class="comment">    (Note: this is not implemented in the current version.)</span>
<a name="l00075"></a>00075 <span class="comment"></span>
<a name="l00076"></a>00076 <span class="comment">@subsection stack_overflow_protection 2.2.2 Stack overflow protection</span>
<a name="l00077"></a>00077 <span class="comment"></span>
<a name="l00078"></a>00078 <span class="comment">    The stack and heap for each core are mapped into a virtual address range</span>
<a name="l00079"></a>00079 <span class="comment">    that does not have mapped virtual addresses directly below it.  The stack</span>
<a name="l00080"></a>00080 <span class="comment">    occupies the lower portion of the this range, and grows down.  When the</span>
<a name="l00081"></a>00081 <span class="comment">    stack overflows, the stack pointer points to an unmapped virtual address and any access to this</span>
<a name="l00082"></a>00082 <span class="comment">    memory generates a TLB miss exception.  The stack and heap are mapped with a virtual address</span>
<a name="l00083"></a>00083 <span class="comment">    in the range 0x10000000 - 0x20000000 since this range does not conflict with any 1-1 TLB mappings.</span>
<a name="l00084"></a>00084 <span class="comment"></span>
<a name="l00085"></a>00085 <span class="comment"></span>
<a name="l00086"></a>00086 <span class="comment">@subsection simplified_address_sharing_with_hardware_units 2.2.3 Simplified address sharing with hardware units</span>
<a name="l00087"></a>00087 <span class="comment"></span>
<a name="l00088"></a>00088 <span class="comment">    The OCTEON hardware blocks use physical memory addresses.  (Virtual</span>
<a name="l00089"></a>00089 <span class="comment">    addresses make no sense as there is a separate virtual to physical mapping</span>
<a name="l00090"></a>00090 <span class="comment">    for each core.) In order for a core to directly access a specific physical</span>
<a name="l00091"></a>00091 <span class="comment">    memory location, it must use the XKPHYS address space.  This requires</span>
<a name="l00092"></a>00092 <span class="comment">    setting bit 63 of the address.  In order to avoid repeated</span>
<a name="l00093"></a>00093 <span class="comment">    setting/clearing of bit 63, the simple exec uses 1-1 virtual-physical</span>
<a name="l00094"></a>00094 <span class="comment">    address mapping.  This allows &apos;physical&apos; addressing to be used without setting bit</span>
<a name="l00095"></a>00095 <span class="comment">    63.  (Virtual addressing is still used, but for the memory regions shared</span>
<a name="l00096"></a>00096 <span class="comment">    with the hardware, the physical and virtual addresses are the same.) It is up to the</span>
<a name="l00097"></a>00097 <span class="comment">    application to enable this mapping.  This is done by the function cvmx_user_app_init()</span>
<a name="l00098"></a>00098 <span class="comment">    which is provided to simplify typical application configurations.</span>
<a name="l00099"></a>00099 <span class="comment"></span>
<a name="l00100"></a>00100 <span class="comment">@subsection virtual_memory_map_summary 2.2.4 Virtual memory map summary</span>
<a name="l00101"></a>00101 <span class="comment"></span>
<a name="l00102"></a>00102 <span class="comment">    - 0x1000 0000 to 0x2000 0000:   This range is used to map the application&apos;s</span>
<a name="l00103"></a>00103 <span class="comment">    code, data, stack, and heap.  This address range coresponds to the physical addresses for the OCTEON boot bus, so this does not</span>
<a name="l00104"></a>00104 <span class="comment">    conflict with any potential 1-1 DRAM mappings.  The stack and heap are placed</span>
<a name="l00105"></a>00105 <span class="comment">    at the top of this range.  These addresses are the same for both 64 bit and 32 bit ABIs.</span>
<a name="l00106"></a>00106 <span class="comment">    - 1-1 mappings as configured by the application  (Typically done in cvmx_user_app_init())</span>
<a name="l00107"></a>00107 <span class="comment">    These mappings are done to avoid having to set and clear the XKPHYS bit (bit 63) in the address.</span>
<a name="l00108"></a>00108 <span class="comment">    With these mappings in place, the application can use &apos;physical&apos; addresses directly.</span>
<a name="l00109"></a>00109 <span class="comment"></span>
<a name="l00110"></a>00110 <span class="comment">@subsection memory_allocation_options 2.2.5 Memory allocation methods</span>
<a name="l00111"></a>00111 <span class="comment">    - local variables:  These are placed on the stack, which is private to each core.  All cores</span>
<a name="l00112"></a>00112 <span class="comment">    have their stack mapped to the same virtual address, but each core&apos;s TLB entry maps this virtual</span>
<a name="l00113"></a>00113 <span class="comment">    address to a different physical address.</span>
<a name="l00114"></a>00114 <span class="comment">    - malloc(): This allocates from a core local heap.  All cores</span>
<a name="l00115"></a>00115 <span class="comment">    have their heap mapped to the same virtual address, but each core&apos;s TLB entry maps this virtual</span>
<a name="l00116"></a>00116 <span class="comment">    address to a different physical address.</span>
<a name="l00117"></a>00117 <span class="comment">    - cvmx_bootmem_alloc(): This returns a physical address from a global pool of available physical memory.</span>
<a name="l00118"></a>00118 <span class="comment">    This pool is set up by the bootloader, and at application start time contains all free memory that is</span>
<a name="l00119"></a>00119 <span class="comment">    not in use by the programs&apos; stack/heap/code/data or in use by a named block that was allocated by the bootloader.</span>
<a name="l00120"></a>00120 <span class="comment">    Note that this function returns physical addresses, so either 1-1 TLB mappings must be set up, or</span>
<a name="l00121"></a>00121 <span class="comment">    the XKPHYS bit must be set in the address.  Typically 1-1 TLB mappings will be used.  cvmx_bootmem_alloc()</span>
<a name="l00122"></a>00122 <span class="comment">    does the required locking to be multi-core safe.</span>
<a name="l00123"></a>00123 <span class="comment">    - cvmx_malloc(): This returns an address from one of the arenas that it was populated with.  The addresses</span>
<a name="l00124"></a>00124 <span class="comment">    returned will be of the type the arena was populated with.  Typically the arenas will be populated with physical</span>
<a name="l00125"></a>00125 <span class="comment">    addresses from cvmx_bootmem_alloc() and 1-1 TLB mappings will be used to access this memory.  This allows cvmx_malloc()</span>
<a name="l00126"></a>00126 <span class="comment">    to be used as a shared memory allocater for multiple cores.  cvmx_malloc() does the required locking to be</span>
<a name="l00127"></a>00127 <span class="comment">    multi-core safe.</span>
<a name="l00128"></a>00128 <span class="comment"></span>
<a name="l00129"></a>00129 <span class="comment">@subsection bootloader_sec 2.3 Bootloader</span>
<a name="l00130"></a>00130 <span class="comment"></span>
<a name="l00131"></a>00131 <span class="comment">    The bootloader is responsible for loading the OCTEON application ELF file into</span>
<a name="l00132"></a>00132 <span class="comment">    DRAM from the boot bus (flash memory) and setting up the TLB mappings required for running the</span>
<a name="l00133"></a>00133 <span class="comment">    application.  The bootloader passes a list of the available memory to the</span>
<a name="l00134"></a>00134 <span class="comment">    application, and this is available to the application in the</span>
<a name="l00135"></a>00135 <span class="comment">    cvmx_sysinfo_t structure.  For more information on the bootloader and the physical memory map please refer to the</span>
<a name="l00136"></a>00136 <span class="comment">    &lt;a href=bootloader.html&gt;OCTEON Bootloader documentation&lt;/a&gt;.</span>
<a name="l00137"></a>00137 <span class="comment"></span>
<a name="l00138"></a>00138 <span class="comment">@section c_cpp_library 3 C/C++ Runtime support</span>
<a name="l00139"></a>00139 <span class="comment"></span>
<a name="l00140"></a>00140 <span class="comment">@subsection c_library 3.1 C library</span>
<a name="l00141"></a>00141 <span class="comment"></span>
<a name="l00142"></a>00142 <span class="comment">    The executive provides a C library based on the newlib C library. Optimized</span>
<a name="l00143"></a>00143 <span class="comment">    versions of memset and memcpy are provided.</span>
<a name="l00144"></a>00144 <span class="comment"></span>
<a name="l00145"></a>00145 <span class="comment">    Standard Utility Functions (`stdlib.h&apos;):</span>
<a name="l00146"></a>00146 <span class="comment"></span>
<a name="l00147"></a>00147 <span class="comment">        - abort, abs, assert, atof, atoff, atoi, atol, atoll, calloc, div, ecvt,</span>
<a name="l00148"></a>00148 <span class="comment">        ecvtf, fcvt, fcvtf, gvcvt, gcvtf, ecvtbuf, fcvtbuf, exit, labs, ldiv,</span>
<a name="l00149"></a>00149 <span class="comment">        llabs,lldiv, malloc, realloc, free, rand, srand, rand48, drand48,</span>
<a name="l00150"></a>00150 <span class="comment">        erand48, lrand48, nrand48, mrand48, jrand48, srand48, seed48, lcong48,</span>
<a name="l00151"></a>00151 <span class="comment">        strtod, strtof, strtol, strtoul</span>
<a name="l00152"></a>00152 <span class="comment"></span>
<a name="l00153"></a>00153 <span class="comment">    Character Type Macros and Functions (`ctype.h&apos;):</span>
<a name="l00154"></a>00154 <span class="comment"></span>
<a name="l00155"></a>00155 <span class="comment">        - isalnum, isalpha, isascii, iscntrl, isdigit, islower, isprint, isgraph,</span>
<a name="l00156"></a>00156 <span class="comment">        ispunct, isspace, isupper, isxdigit, toascii, tolower, toupper</span>
<a name="l00157"></a>00157 <span class="comment"></span>
<a name="l00158"></a>00158 <span class="comment">    Input and Output (`stdio.h&apos;):</span>
<a name="l00159"></a>00159 <span class="comment"></span>
<a name="l00160"></a>00160 <span class="comment">        - fflush, fgets, fiprintf, fputc, fputs, fread, freopen, ftell, ftello,</span>
<a name="l00161"></a>00161 <span class="comment">        fwrite, getc, getchar, gets, getw, iprintf, perror, putc, putchar, puts,</span>
<a name="l00162"></a>00162 <span class="comment">        putw, siprintf, printf, fprintf, asprintf, sprintf, snprintf, scanf,</span>
<a name="l00163"></a>00163 <span class="comment">        fscanf, sscanf, vprintf, vfprintf, vsprintf</span>
<a name="l00164"></a>00164 <span class="comment"></span>
<a name="l00165"></a>00165 <span class="comment">    There is no filesystem support in the simple exec. Input from stdin and output</span>
<a name="l00166"></a>00166 <span class="comment">    to stdout and stderr are mapped to the OCTEON uart.</span>
<a name="l00167"></a>00167 <span class="comment"></span>
<a name="l00168"></a>00168 <span class="comment">    Strings and Memory (`string.h&apos;) :</span>
<a name="l00169"></a>00169 <span class="comment"></span>
<a name="l00170"></a>00170 <span class="comment">        - bcmp, bcopy, bzero, index, memccpy, memchr, memcmp, memcpy, memmove,</span>
<a name="l00171"></a>00171 <span class="comment">        abort, abs, assert, atof, atoff, atoi, atol, atoll, calloc, div, ecvt,</span>
<a name="l00172"></a>00172 <span class="comment">        ecvtf, fcvt,fcvtf, gvcvt, gcvtf, ecvtbuf, fcvtbuf, exit, labs, ldiv,</span>
<a name="l00173"></a>00173 <span class="comment">        llabs, lldiv, malloc, realloc, free</span>
<a name="l00174"></a>00174 <span class="comment"></span>
<a name="l00175"></a>00175 <span class="comment">    Character Type Macros and Functions (`ctype.h&apos;):</span>
<a name="l00176"></a>00176 <span class="comment"></span>
<a name="l00177"></a>00177 <span class="comment">        - isalnum, isalpha, isascii, iscntrl, isdigit, islower, isprint, isgraph,</span>
<a name="l00178"></a>00178 <span class="comment">        ispunct, isspace, isupper, isxdigit, toascii, tolower, toupper</span>
<a name="l00179"></a>00179 <span class="comment"></span>
<a name="l00180"></a>00180 <span class="comment">    Variable Argument Lists:</span>
<a name="l00181"></a>00181 <span class="comment"></span>
<a name="l00182"></a>00182 <span class="comment">       - ANSI-standard macros, `stdarg.h&apos;</span>
<a name="l00183"></a>00183 <span class="comment"></span>
<a name="l00184"></a>00184 <span class="comment">@subsection system_calls 3.2 System calls</span>
<a name="l00185"></a>00185 <span class="comment"></span>
<a name="l00186"></a>00186 <span class="comment">    The executive will provide a basic set of system calls to support the C</span>
<a name="l00187"></a>00187 <span class="comment">    library and applications.  The executive is implemented as a library, so</span>
<a name="l00188"></a>00188 <span class="comment">    there is no trap/syscall overhead for system calls.</span>
<a name="l00189"></a>00189 <span class="comment"></span>
<a name="l00190"></a>00190 <span class="comment">    Summary of provided system calls:</span>
<a name="l00191"></a>00191 <span class="comment">        - brk() - allocate memory for an applications heap.  The heap size is</span>
<a name="l00192"></a>00192 <span class="comment">            determined at startup, and does not grow.  This is for C-library</span>
<a name="l00193"></a>00193 <span class="comment">            support, and should not be used directly by the application.</span>
<a name="l00194"></a>00194 <span class="comment">        - read() / write() - provide basic I/O over the serial port.</span>
<a name="l00195"></a>00195 <span class="comment">        - exit() - allow graceful termination of program.  OCTEON core is idle after exit().</span>
<a name="l00196"></a>00196 <span class="comment">        - simprintf() - A simulator specific output routine similar to printf.</span>
<a name="l00197"></a>00197 <span class="comment"></span>
<a name="l00198"></a>00198 <span class="comment">@subsection backtrace 3.3 Obtaining backtrace information programmatically</span>
<a name="l00199"></a>00199 <span class="comment"></span>
<a name="l00200"></a>00200 <span class="comment">    The MIPS ABIs do not require the use of a frame pointer and the location</span>
<a name="l00201"></a>00201 <span class="comment">    of the saved return address within the stack frame is not fixed.  One can</span>
<a name="l00202"></a>00202 <span class="comment">    only walk the frames by virtually unwinding them using auxiliary</span>
<a name="l00203"></a>00203 <span class="comment">    information describing the frames. In case of C++, this information is</span>
<a name="l00204"></a>00204 <span class="comment">    needed for exception handling and is generated by default.  For C, it can</span>
<a name="l00205"></a>00205 <span class="comment">    be requested with -funwind-tables or -fasynchronous-unwind-tables.</span>
<a name="l00206"></a>00206 <span class="comment"></span>
<a name="l00207"></a>00207 <span class="comment">    The simple-execuctive toolchain is set up to generate frame information by</span>
<a name="l00208"></a>00208 <span class="comment">    default (-fasynchronous-unwind-tables is passed).  This has no effect on</span>
<a name="l00209"></a>00209 <span class="comment">    the generated code -- it only ensures that the tables necessary for</span>
<a name="l00210"></a>00210 <span class="comment">    unwinding are generated by GCC and put into the the .eh_frame section.</span>
<a name="l00211"></a>00211 <span class="comment"></span>
<a name="l00212"></a>00212 <span class="comment">    The OCTEON-specific newlib header execinfo.h provides functions to access</span>
<a name="l00213"></a>00213 <span class="comment">    this information.  Below is an example of how to print the trace using @b</span>
<a name="l00214"></a>00214 <span class="comment">    __octeon_print_backtrace.  To change how the backtrace is printed one can</span>
<a name="l00215"></a>00215 <span class="comment">    pass a custom printf-style function to @b __octeon_print_backtrace_func.</span>
<a name="l00216"></a>00216 <span class="comment">    Finally, @b backtrace, similarly to function with the same name in glibc,</span>
<a name="l00217"></a>00217 <span class="comment">    returns the pc values in memory.</span>
<a name="l00218"></a>00218 <span class="comment"></span>
<a name="l00219"></a>00219 <span class="comment">    Here is an example with @b __octeon_print_backtrace:</span>
<a name="l00220"></a>00220 <span class="comment"></span>
<a name="l00221"></a>00221 <span class="comment">@verbatim</span>
<a name="l00222"></a>00222 <span class="comment">$ cat -n bt.c</span>
<a name="l00223"></a>00223 <span class="comment">     1  #include &lt;execinfo.h&gt;</span>
<a name="l00224"></a>00224 <span class="comment">     2</span>
<a name="l00225"></a>00225 <span class="comment">     3  int i;</span>
<a name="l00226"></a>00226 <span class="comment">     4</span>
<a name="l00227"></a>00227 <span class="comment">     5  __attribute__ ((noinline))</span>
<a name="l00228"></a>00228 <span class="comment">     6  void f ()</span>
<a name="l00229"></a>00229 <span class="comment">     7  {</span>
<a name="l00230"></a>00230 <span class="comment">     8    __octeon_print_backtrace ();</span>
<a name="l00231"></a>00231 <span class="comment">     9    i = 1;</span>
<a name="l00232"></a>00232 <span class="comment">    10  }</span>
<a name="l00233"></a>00233 <span class="comment">    11</span>
<a name="l00234"></a>00234 <span class="comment">    12  main ()</span>
<a name="l00235"></a>00235 <span class="comment">    13  {</span>
<a name="l00236"></a>00236 <span class="comment">    14    f ();</span>
<a name="l00237"></a>00237 <span class="comment">    15    return 0;</span>
<a name="l00238"></a>00238 <span class="comment">    16  }</span>
<a name="l00239"></a>00239 <span class="comment"></span>
<a name="l00240"></a>00240 <span class="comment">$ mipsisa64-octeon-elf-gcc -O2 bt.c</span>
<a name="l00241"></a>00241 <span class="comment"></span>
<a name="l00242"></a>00242 <span class="comment">$ oct-sim ./a.out -quiet  -noperf | grep CONSOLE</span>
<a name="l00243"></a>00243 <span class="comment">PP0:~CONSOLE-&gt;   #0  0x100002e8</span>
<a name="l00244"></a>00244 <span class="comment">PP0:~CONSOLE-&gt;   #1  0x10000310</span>
<a name="l00245"></a>00245 <span class="comment">PP0:~CONSOLE-&gt;   #2  0x100002b8</span>
<a name="l00246"></a>00246 <span class="comment">@endverbatim</span>
<a name="l00247"></a>00247 <span class="comment"></span>
<a name="l00248"></a>00248 <span class="comment">    GCC has been extended to support unwinding through the first</span>
<a name="l00249"></a>00249 <span class="comment">    exception handler frame.  This is how the backtrace printed in</span>
<a name="l00250"></a>00250 <span class="comment">    cvmx_interrupt_default_exception_handler() can trace back to the</span>
<a name="l00251"></a>00251 <span class="comment">    function causing the exception and continue the backtrace from</span>
<a name="l00252"></a>00252 <span class="comment">    there (see @ref interrupt_exception).</span>
<a name="l00253"></a>00253 <span class="comment"></span>
<a name="l00254"></a>00254 <span class="comment">    With optimization on, GCC tries to turn the last function call of a</span>
<a name="l00255"></a>00255 <span class="comment">    function into a tail call.  This means that the frame of the caller is</span>
<a name="l00256"></a>00256 <span class="comment">    removed before the callee is invoked.  Note that if you backtrace from a</span>
<a name="l00257"></a>00257 <span class="comment">    tail-called function the backtrace information will have the caller frame</span>
<a name="l00258"></a>00258 <span class="comment">    omitted.  For example in the code above without the assignment to the global &apos;i&apos;,</span>
<a name="l00259"></a>00259 <span class="comment">    the call __octeon_print_backtrace would qualify as a tail-call and the</span>
<a name="l00260"></a>00260 <span class="comment">    first frame printed would be &apos;main&apos;.</span>
<a name="l00261"></a>00261 <span class="comment"></span>
<a name="l00262"></a>00262 <span class="comment">    If you compiled with -g you can even trace the pc values back to source</span>
<a name="l00263"></a>00263 <span class="comment">    line numbers using oct-debuginfo or mipsisa64-octeon-elf-addr2line:</span>
<a name="l00264"></a>00264 <span class="comment"></span>
<a name="l00265"></a>00265 <span class="comment">@verbatim</span>
<a name="l00266"></a>00266 <span class="comment">$ oct-debuginfo ./a.out 0x100002e8 0x10000310 0x100002b8</span>
<a name="l00267"></a>00267 <span class="comment"></span>
<a name="l00268"></a>00268 <span class="comment">Reading line information</span>
<a name="l00269"></a>00269 <span class="comment">    vi +9 /tmp/bt.c</span>
<a name="l00270"></a>00270 <span class="comment">    vi +16 /tmp/bt.c</span>
<a name="l00271"></a>00271 <span class="comment">    vi +117 /home/anemet/octsw/toolchain/src/newlib/libc/sys/octeon/crt0.S</span>
<a name="l00272"></a>00272 <span class="comment">Reading dwarf information</span>
<a name="l00273"></a>00273 <span class="comment">Function Scope Information:</span>
<a name="l00274"></a>00274 <span class="comment">    f():</span>
<a name="l00275"></a>00275 <span class="comment">      PC range                           = 0x00000000100002d8 - 0x00000000100002fc</span>
<a name="l00276"></a>00276 <span class="comment">      Frame ptr                          = &lt;lowpc=0x0&gt;&lt;highpc=0x4&gt;sp</span>
<a name="l00277"></a>00277 <span class="comment"></span>
<a name="l00278"></a>00278 <span class="comment">Function Scope Information:</span>
<a name="l00279"></a>00279 <span class="comment">    main():</span>
<a name="l00280"></a>00280 <span class="comment">      PC range                           = 0x0000000010000300 - 0x0000000010000320</span>
<a name="l00281"></a>00281 <span class="comment">      Frame ptr                          = &lt;lowpc=0x28&gt;&lt;highpc=0x2c&gt;sp</span>
<a name="l00282"></a>00282 <span class="comment"></span>
<a name="l00283"></a>00283 <span class="comment">Function Scope Information:</span>
<a name="l00284"></a>00284 <span class="comment">@endverbatim</span>
<a name="l00285"></a>00285 <span class="comment"></span>
<a name="l00286"></a>00286 <span class="comment">    Without debug info, you can disassemble the exectuable and see which</span>
<a name="l00287"></a>00287 <span class="comment">    function the address falls under:</span>
<a name="l00288"></a>00288 <span class="comment"></span>
<a name="l00289"></a>00289 <span class="comment">@verbatim</span>
<a name="l00290"></a>00290 <span class="comment">$ mipsisa64-octeon-elf-objdump --prefix-addresses -d a.out | grep 100002e8</span>
<a name="l00291"></a>00291 <span class="comment">100002e8 &lt;f+0x10&gt; li    v0,1</span>
<a name="l00292"></a>00292 <span class="comment">@endverbatim</span>
<a name="l00293"></a>00293 <span class="comment"></span>
<a name="l00294"></a>00294 <span class="comment">    On bigger applications we measured an increase of about 4% in the size of</span>
<a name="l00295"></a>00295 <span class="comment">    the application due to the additional frame information required by</span>
<a name="l00296"></a>00296 <span class="comment">    backtrace.</span>
<a name="l00297"></a>00297 <span class="comment"></span>
<a name="l00298"></a>00298 <span class="comment">    As mentioned above by default the compiler will emit frame information.</span>
<a name="l00299"></a>00299 <span class="comment">    You can override the default behavior by compiling with</span>
<a name="l00300"></a>00300 <span class="comment">    -fno-asynchronous-unwind-tables or if you use the CVMX build system by</span>
<a name="l00301"></a>00301 <span class="comment">    defining the makefile variable @b OCTEON_DISABLE_BACKTRACE in your</span>
<a name="l00302"></a>00302 <span class="comment">    Makefile.  Note that in this case upon machine exception the backtrace</span>
<a name="l00303"></a>00303 <span class="comment">    information will also be omitted (see @ref interrupt_exception).</span>
<a name="l00304"></a>00304 <span class="comment"></span>
<a name="l00305"></a>00305 <span class="comment">    Frame information for system libraries (libc, etc.) will still be present</span>
<a name="l00306"></a>00306 <span class="comment">    in the final executable.  To remove it, when stripping the executable</span>
<a name="l00307"></a>00307 <span class="comment">    besides the usual .comment section, also remove the .eh_frame section:</span>
<a name="l00308"></a>00308 <span class="comment"></span>
<a name="l00309"></a>00309 <span class="comment">@verbatim</span>
<a name="l00310"></a>00310 <span class="comment">mipsisa64-octeon-elf-strip -R .comment -R .eh_frame a.out</span>
<a name="l00311"></a>00311 <span class="comment">@endverbatim</span>
<a name="l00312"></a>00312 <span class="comment"></span>
<a name="l00313"></a>00313 <span class="comment">    Note that the frame information in section .eh_frame is also used in C++</span>
<a name="l00314"></a>00314 <span class="comment">    exception handling so if your application is in C++, by removing this</span>
<a name="l00315"></a>00315 <span class="comment">    section you will break exception handling functionality.</span>
<a name="l00316"></a>00316 <span class="comment"></span>
<a name="l00317"></a>00317 <span class="comment">@subsection cpp_library 3.4 C++ library</span>
<a name="l00318"></a>00318 <span class="comment"></span>
<a name="l00319"></a>00319 <span class="comment">    The OCTEON toolchain includes the GCC standard C++ and template library.</span>
<a name="l00320"></a>00320 <span class="comment"></span>
<a name="l00321"></a>00321 <span class="comment">@section hal 4 Hardware Abstraction Layer (HAL)</span>
<a name="l00322"></a>00322 <span class="comment"></span>
<a name="l00323"></a>00323 <span class="comment">    The details of communicating with the low level OCTEON hardware requires</span>
<a name="l00324"></a>00324 <span class="comment">    the programmer to generate specific bitfields and I/O addresses. These</span>
<a name="l00325"></a>00325 <span class="comment">    operations have been abstracted into a set of libraries and inline</span>
<a name="l00326"></a>00326 <span class="comment">    functions for faster software development. The header files cvmx-*.h each</span>
<a name="l00327"></a>00327 <span class="comment">    provide a simplified interface to hardware. Refer to the</span>
<a name="l00328"></a>00328 <span class="comment">    &lt;a href=files.html&gt;File List&lt;/a&gt; for a brief description of each of these</span>
<a name="l00329"></a>00329 <span class="comment">    files.</span>
<a name="l00330"></a>00330 <span class="comment"></span>
<a name="l00331"></a>00331 <span class="comment">@subsection basic_support 4.1 Basic support</span>
<a name="l00332"></a>00332 <span class="comment"></span>
<a name="l00333"></a>00333 <span class="comment">    - cvmx-config.h</span>
<a name="l00334"></a>00334 <span class="comment">        - Overall system configuration is present in this file. Applications</span>
<a name="l00335"></a>00335 <span class="comment">        should customize as needed and include it before any other simple</span>
<a name="l00336"></a>00336 <span class="comment">        executive header. See the following section (Configuration) for more</span>
<a name="l00337"></a>00337 <span class="comment">        information about this file.</span>
<a name="l00338"></a>00338 <span class="comment">    - @link cvmx.h cvmx.h @endlink</span>
<a name="l00339"></a>00339 <span class="comment">        - This provides common macros and inline functions required by all</span>
<a name="l00340"></a>00340 <span class="comment">        programs running on OCTEON. This file should be the second simple</span>
<a name="l00341"></a>00341 <span class="comment">        executive header file included, after &quot;cvmx-config.h&quot;.</span>
<a name="l00342"></a>00342 <span class="comment">    - @link cvmx-asm.h cvmx-asm.h @endlink</span>
<a name="l00343"></a>00343 <span class="comment">        - This file provides useful macros for inserting OCTEON specific</span>
<a name="l00344"></a>00344 <span class="comment">        assembly instructions into C source code. The assembly instructions</span>
<a name="l00345"></a>00345 <span class="comment">        provide various low level hardware optimizations available in OCTEON</span>
<a name="l00346"></a>00346 <span class="comment">        directly.</span>
<a name="l00347"></a>00347 <span class="comment">    - @link cvmx-csr.h cvmx-csr.h @endlink</span>
<a name="l00348"></a>00348 <span class="comment">        - This file defines the hardware addresses used to reference the</span>
<a name="l00349"></a>00349 <span class="comment">        OCTEON control and status registers (CSRs). The format of each CSR</span>
<a name="l00350"></a>00350 <span class="comment">        and how to access it is provided in the &quot;cvmx-*.h&quot; file for the</span>
<a name="l00351"></a>00351 <span class="comment">        associated hardware unit.</span>
<a name="l00352"></a>00352 <span class="comment"></span>
<a name="l00353"></a>00353 <span class="comment">@subsection configuration 4.2 Configuration</span>
<a name="l00354"></a>00354 <span class="comment"></span>
<a name="l00355"></a>00355 <span class="comment">    Static configuration of the hardware resources are controlled by the</span>
<a name="l00356"></a>00356 <span class="comment">    include file &quot;cvmx-config.h&quot;. This file is generated from the executive-config.h</span>
<a name="l00357"></a>00357 <span class="comment">    file and other files in the config directory of the application. Please refer to</span>
<a name="l00358"></a>00358 <span class="comment">    the configuration and build system page for more information.</span>
<a name="l00359"></a>00359 <span class="comment">    Applications can use this file to control</span>
<a name="l00360"></a>00360 <span class="comment">    how the global hardware resources are configured / allocated. The</span>
<a name="l00361"></a>00361 <span class="comment">    following resources are controlled by this file:</span>
<a name="l00362"></a>00362 <span class="comment"></span>
<a name="l00363"></a>00363 <span class="comment">    - Free Pool Unit (FPA) block sizes.</span>
<a name="l00364"></a>00364 <span class="comment">    - FPA pool usage by hardware unit.</span>
<a name="l00365"></a>00365 <span class="comment">    - Fetch and Add (FAU) register utilization.</span>
<a name="l00366"></a>00366 <span class="comment">    - Scratch Pad (Scratch) memory allocation.</span>
<a name="l00367"></a>00367 <span class="comment"></span>
<a name="l00368"></a>00368 <span class="comment">    A default configuration file can be found in &quot;cvmx-config.h&quot;.</span>
<a name="l00369"></a>00369 <span class="comment">    Applications needing to modify setting should make a local copy of this</span>
<a name="l00370"></a>00370 <span class="comment">    file and modify it as needed.</span>
<a name="l00371"></a>00371 <span class="comment"></span>
<a name="l00372"></a>00372 <span class="comment"></span>
<a name="l00373"></a>00373 <span class="comment">@subsection hal_fau 4.3 Fetch and Add Unit (FAU) (cvmx-fau.h)</span>
<a name="l00374"></a>00374 <span class="comment"></span>
<a name="l00375"></a>00375 <span class="comment">For the CN78XX series the FAU has been replaced with a hardware</span>
<a name="l00376"></a>00376 <span class="comment">atomic instruction implementation. For compatibility reasons an emulated</span>
<a name="l00377"></a>00377 <span class="comment">FAU exists to support legacy software. See section titled </span>
<a name="l00378"></a>00378 <span class="comment">Packet Descriptor Manipulation in @ref cn78xx_native for</span>
<a name="l00379"></a>00379 <span class="comment">more information on implementing the hardware counter decrement in the PKO3.</span>
<a name="l00380"></a>00380 <span class="comment"></span>
<a name="l00381"></a>00381 <span class="comment">    The Fetch and Add Unit (FAU) is a 2 KB register file supporting read, write,</span>
<a name="l00382"></a>00382 <span class="comment">    atomic fetch-and-add, and atomic update operations. The unit can be accessed</span>
<a name="l00383"></a>00383 <span class="comment">    from both the Cores and the centralized Packet Output (PKO) unit. The Cores use</span>
<a name="l00384"></a>00384 <span class="comment">    the FAU for general synchronization purposes, including applications like</span>
<a name="l00385"></a>00385 <span class="comment">    assigning unique positions for inserting items into shared queues.</span>
<a name="l00386"></a>00386 <span class="comment"></span>
<a name="l00387"></a>00387 <span class="comment"></span>
<a name="l00388"></a>00388 <span class="comment">    - cvmx_fau_async_fetch_and_add16()</span>
<a name="l00389"></a>00389 <span class="comment">    - cvmx_fau_async_fetch_and_add32()</span>
<a name="l00390"></a>00390 <span class="comment">    - cvmx_fau_async_fetch_and_add64()</span>
<a name="l00391"></a>00391 <span class="comment">    - cvmx_fau_async_fetch_and_add8()</span>
<a name="l00392"></a>00392 <span class="comment">    - cvmx_fau_async_tagwait_fetch_and_add16()</span>
<a name="l00393"></a>00393 <span class="comment">    - cvmx_fau_async_tagwait_fetch_and_add32()</span>
<a name="l00394"></a>00394 <span class="comment">    - cvmx_fau_async_tagwait_fetch_and_add64()</span>
<a name="l00395"></a>00395 <span class="comment">    - cvmx_fau_async_tagwait_fetch_and_add8()</span>
<a name="l00396"></a>00396 <span class="comment">    - cvmx_fau_atomic_add16()</span>
<a name="l00397"></a>00397 <span class="comment">    - cvmx_fau_atomic_add32()</span>
<a name="l00398"></a>00398 <span class="comment">    - cvmx_fau_atomic_add64()</span>
<a name="l00399"></a>00399 <span class="comment">    - cvmx_fau_atomic_add8()</span>
<a name="l00400"></a>00400 <span class="comment">    - cvmx_fau_atomic_write16()</span>
<a name="l00401"></a>00401 <span class="comment">    - cvmx_fau_atomic_write32()</span>
<a name="l00402"></a>00402 <span class="comment">    - cvmx_fau_atomic_write64()</span>
<a name="l00403"></a>00403 <span class="comment">    - cvmx_fau_atomic_write8()</span>
<a name="l00404"></a>00404 <span class="comment">    - cvmx_fau_fetch_and_add16()</span>
<a name="l00405"></a>00405 <span class="comment">    - cvmx_fau_fetch_and_add32()</span>
<a name="l00406"></a>00406 <span class="comment">    - cvmx_fau_fetch_and_add64()</span>
<a name="l00407"></a>00407 <span class="comment">    - cvmx_fau_fetch_and_add8()</span>
<a name="l00408"></a>00408 <span class="comment">    - cvmx_fau_tagwait_fetch_and_add16()</span>
<a name="l00409"></a>00409 <span class="comment">    - cvmx_fau_tagwait_fetch_and_add32()</span>
<a name="l00410"></a>00410 <span class="comment">    - cvmx_fau_tagwait_fetch_and_add64()</span>
<a name="l00411"></a>00411 <span class="comment">    - cvmx_fau_tagwait_fetch_and_add8()</span>
<a name="l00412"></a>00412 <span class="comment"></span>
<a name="l00413"></a>00413 <span class="comment">@subsection hal_scratch 4.4 CPU Cores (scratch) (cvmx-scratch.h)</span>
<a name="l00414"></a>00414 <span class="comment"></span>
<a name="l00415"></a>00415 <span class="comment">    The L1 cache for each processor may be used for a fast access processor</span>
<a name="l00416"></a>00416 <span class="comment">    local scratch pad memory area. This area is partitioned off of the L1</span>
<a name="l00417"></a>00417 <span class="comment">    cache at initialization time for user program usage. This area can be</span>
<a name="l00418"></a>00418 <span class="comment">    used for local variables and the results of IOBDMAs. Address offsets are in bytes.</span>
<a name="l00419"></a>00419 <span class="comment"></span>
<a name="l00420"></a>00420 <span class="comment"></span>
<a name="l00421"></a>00421 <span class="comment">    - cvmx_scratch_read8()</span>
<a name="l00422"></a>00422 <span class="comment">    - cvmx_scratch_read16()</span>
<a name="l00423"></a>00423 <span class="comment">    - cvmx_scratch_read32()</span>
<a name="l00424"></a>00424 <span class="comment">    - cvmx_scratch_read64()</span>
<a name="l00425"></a>00425 <span class="comment">    - cvmx_scratch_write8()</span>
<a name="l00426"></a>00426 <span class="comment">    - cvmx_scratch_write16()</span>
<a name="l00427"></a>00427 <span class="comment">    - cvmx_scratch_write32()</span>
<a name="l00428"></a>00428 <span class="comment">    - cvmx_scratch_write64()</span>
<a name="l00429"></a>00429 <span class="comment"></span>
<a name="l00430"></a>00430 <span class="comment">@subsection hal_pow 4.5 Packet Order / Work Unit (POW) (cvmx-pow.h)</span>
<a name="l00431"></a>00431 <span class="comment"></span>
<a name="l00432"></a>00432 <span class="comment">    The OCTEON Packet Order / Work Unit is an OCTEON co-processor that provides</span>
<a name="l00433"></a>00433 <span class="comment">    a number of important functions.</span>
<a name="l00434"></a>00434 <span class="comment"></span>
<a name="l00435"></a>00435 <span class="comment">@subsection hal_pow_wq 4.5.1 Work Queueing</span>
<a name="l00436"></a>00436 <span class="comment"></span>
<a name="l00437"></a>00437 <span class="comment">    Work is described by an associated work queue entry and may be created by either</span>
<a name="l00438"></a>00438 <span class="comment">    HW units or Core SW. The OCTEON centralized Packet Input Processing and Input</span>
<a name="l00439"></a>00439 <span class="comment">    Packet Data Unit (PIP/IPD) hardware creates a work queue entry and submits</span>
<a name="l00440"></a>00440 <span class="comment">    work for each packet arrival. Core SW can create work queue entries and submit</span>
<a name="l00441"></a>00441 <span class="comment">    work as desired. The OCTEON packet output (PKO), PCI, Timer (TIM), and</span>
<a name="l00442"></a>00442 <span class="comment">    Deterministic Finite Automata (DFA) HW units can also submit work queue</span>
<a name="l00443"></a>00443 <span class="comment">    entries created by Core SW after completing an operation/instruction.</span>
<a name="l00444"></a>00444 <span class="comment">    POW implements eight input work queues. The different work queues can be used</span>
<a name="l00445"></a>00445 <span class="comment">    to provide different service levels.</span>
<a name="l00446"></a>00446 <span class="comment"></span>
<a name="l00447"></a>00447 <span class="comment">    The input work queues can be infinitely large, overflowing to DRAM when</span>
<a name="l00448"></a>00448 <span class="comment">    necessary.</span>
<a name="l00449"></a>00449 <span class="comment"></span>
<a name="l00450"></a>00450 <span class="comment">@subsection hal_pow_ws 4.5.2 Work Scheduling / Descheduling</span>
<a name="l00451"></a>00451 <span class="comment"></span>
<a name="l00452"></a>00452 <span class="comment">    Core SW requests work from the POW. The POW selects (i.e. schedules) work for the Core</span>
<a name="l00453"></a>00453 <span class="comment">    and returns a pointer to the work queue entry that describes the work to Core SW.</span>
<a name="l00454"></a>00454 <span class="comment">    This off-loads much overhead from the Cores and the coherent memory bus.</span>
<a name="l00455"></a>00455 <span class="comment"></span>
<a name="l00456"></a>00456 <span class="comment">    All work is not equal since the POW HW supports (16) groups. Each piece of work</span>
<a name="l00457"></a>00457 <span class="comment">    has an associated group identifier. A configuration variable for each Core specifies</span>
<a name="l00458"></a>00458 <span class="comment">    the groups that the associated Core will accept when it requests work. This</span>
<a name="l00459"></a>00459 <span class="comment">    configuration variable is a 16 bit bitmask, one bit per group, so Core SW can</span>
<a name="l00460"></a>00460 <span class="comment">    specify all possible combinations of groups. The POW HW does not schedule a</span>
<a name="l00461"></a>00461 <span class="comment">    piece of work if the Core doesn&apos;t accept the group associated with the work.</span>
<a name="l00462"></a>00462 <span class="comment"></span>
<a name="l00463"></a>00463 <span class="comment">    Groups provide a means to execute different functions on different Cores, though</span>
<a name="l00464"></a>00464 <span class="comment">    all Cores share the same POW HW. For example, packet processing may be</span>
<a name="l00465"></a>00465 <span class="comment">    pipelined from one group of Cores to another group of Cores, with the first group</span>
<a name="l00466"></a>00466 <span class="comment">    performing the first stage of work and the next group performing the next stage of</span>
<a name="l00467"></a>00467 <span class="comment">    work.</span>
<a name="l00468"></a>00468 <span class="comment"></span>
<a name="l00469"></a>00469 <span class="comment">    A Core can deschedule a piece of work. Deschedule means that the SW running on</span>
<a name="l00470"></a>00470 <span class="comment">    this Core will not complete the work at this time, and the POW HW should</span>
<a name="l00471"></a>00471 <span class="comment">    reschedule it later. The POW HW reschedules previously descheduled work at</span>
<a name="l00472"></a>00472 <span class="comment">    higher priority than it schedules new work from an input queue. Deschedule can</span>
<a name="l00473"></a>00473 <span class="comment">    be useful in a number of circumstances:</span>
<a name="l00474"></a>00474 <span class="comment">        - It can transfer work from one Core group to another. This is one mechanism to</span>
<a name="l00475"></a>00475 <span class="comment">        implement &quot;work pipelining&quot;.</span>
<a name="l00476"></a>00476 <span class="comment">        - It can avoid consuming a Core for work that requires a large synchronization</span>
<a name="l00477"></a>00477 <span class="comment">        delay.</span>
<a name="l00478"></a>00478 <span class="comment">        - It can make work interruptible.</span>
<a name="l00479"></a>00479 <span class="comment"></span>
<a name="l00480"></a>00480 <span class="comment">@subsection hal_pow_os 4.5.3 Ordering and Synchronization of Work</span>
<a name="l00481"></a>00481 <span class="comment"></span>
<a name="l00482"></a>00482 <span class="comment">    The POW HW associates a 32 bit tag value and a tag type with each piece of work.</span>
<a name="l00483"></a>00483 <span class="comment">    The work queue entry and the request to add work to an input work queue</span>
<a name="l00484"></a>00484 <span class="comment">    contain the initial tag value. (This initial tag value may be created by either the</span>
<a name="l00485"></a>00485 <span class="comment">    centralized input packet processing HW or by Core SW.) Core SW can also later</span>
<a name="l00486"></a>00486 <span class="comment">    switch the tag/type as the work progresses through different phases of the</span>
<a name="l00487"></a>00487 <span class="comment">    application. If the same tag value sequences are used by two packets, the packets</span>
<a name="l00488"></a>00488 <span class="comment">    are ordered.</span>
<a name="l00489"></a>00489 <span class="comment"></span>
<a name="l00490"></a>00490 <span class="comment">    There are three different tag types:</span>
<a name="l00491"></a>00491 <span class="comment">        - ORDERED - Ordering is guaranteed with this tag type. (Atomicity is not.)</span>
<a name="l00492"></a>00492 <span class="comment">        - ATOMIC - Ordering and atomicity are guaranteed with this tag type. Two</span>
<a name="l00493"></a>00493 <span class="comment">        pieces of work cannot simultaneously hold the same ATOMIC tag.</span>
<a name="l00494"></a>00494 <span class="comment">        - NULL - No ordering is guaranteed with this tag type, and work cannot be in-</span>
<a name="l00495"></a>00495 <span class="comment">        flight (with respect to the POW HW) with this tag type.</span>
<a name="l00496"></a>00496 <span class="comment"></span>
<a name="l00497"></a>00497 <span class="comment">    The POW HW, in combination with Core SW, uses these tag/type values to order</span>
<a name="l00498"></a>00498 <span class="comment">    and synchronize related work, and allow unrelated work to be unordered and</span>
<a name="l00499"></a>00499 <span class="comment">    unsynchronized. This is essential for efficient multi-Core execution. Two pieces of</span>
<a name="l00500"></a>00500 <span class="comment">    work may be / are related and will be ordered and synchronized when they share</span>
<a name="l00501"></a>00501 <span class="comment">    the same tag value and tag type. Two pieces of work may be unrelated and will</span>
<a name="l00502"></a>00502 <span class="comment">    execute entirely in parallel when they have different tag or tag type values.</span>
<a name="l00503"></a>00503 <span class="comment"></span>
<a name="l00504"></a>00504 <span class="comment">    For example, the tag value may be a hash of the standard TCP five-tuple (IP</span>
<a name="l00505"></a>00505 <span class="comment">    source address, IP destination address, IP protocol, TCP source port, TCP</span>
<a name="l00506"></a>00506 <span class="comment">    destination port) defining a &quot;flow&quot;. The same flow will have the same tag value, so</span>
<a name="l00507"></a>00507 <span class="comment">    it may be ordered and synchronized. Different flows will likely have different tag</span>
<a name="l00508"></a>00508 <span class="comment">    values, so will likely not be ordered and synchronized, and can be executed</span>
<a name="l00509"></a>00509 <span class="comment">    completely in parallel on different Cores.</span>
<a name="l00510"></a>00510 <span class="comment"></span>
<a name="l00511"></a>00511 <span class="comment">    At different code phases, Core SW can change the tag value via a tag switch</span>
<a name="l00512"></a>00512 <span class="comment">    transaction with separated switch request and switch completion wait operations.</span>
<a name="l00513"></a>00513 <span class="comment">    The POW HW completes a requested switch when the required ordering and</span>
<a name="l00514"></a>00514 <span class="comment">    atomicity constraints for the work are met. This separated switch transaction</span>
<a name="l00515"></a>00515 <span class="comment">    allows SW to overlap the switch request latency with other profitable work and</span>
<a name="l00516"></a>00516 <span class="comment">    also allows SW the option to deschedule the work while a tag switch is pending,</span>
<a name="l00517"></a>00517 <span class="comment">    thus avoiding long synchronization delays.</span>
<a name="l00518"></a>00518 <span class="comment"></span>
<a name="l00519"></a>00519 <span class="comment">    @link cvmx-pow.h POW Consistency Checks @endlink provide more debugging</span>
<a name="l00520"></a>00520 <span class="comment">    information.</span>
<a name="l00521"></a>00521 <span class="comment"></span>
<a name="l00522"></a>00522 <span class="comment">@subsection hal_pow_fl 4.5.4 cvmx-pow.h function list</span>
<a name="l00523"></a>00523 <span class="comment"></span>
<a name="l00524"></a>00524 <span class="comment">    - cvmx_pow_desched()</span>
<a name="l00525"></a>00525 <span class="comment">    - cvmx_pow_set_group_mask()</span>
<a name="l00526"></a>00526 <span class="comment">    - cvmx_pow_tag_compose()</span>
<a name="l00527"></a>00527 <span class="comment">    - cvmx_pow_tag_get_hw_bits()</span>
<a name="l00528"></a>00528 <span class="comment">    - cvmx_pow_tag_get_sw_bits()</span>
<a name="l00529"></a>00529 <span class="comment">    - cvmx_pow_tag_sw()</span>
<a name="l00530"></a>00530 <span class="comment">    - cvmx_pow_tag_sw_nocheck()</span>
<a name="l00531"></a>00531 <span class="comment">    - cvmx_pow_tag_sw_full()</span>
<a name="l00532"></a>00532 <span class="comment">    - cvmx_pow_tag_sw_full_nocheck()</span>
<a name="l00533"></a>00533 <span class="comment">    - cvmx_pow_tag_sw_desched()</span>
<a name="l00534"></a>00534 <span class="comment">    - cvmx_pow_tag_sw_desched_nocheck()</span>
<a name="l00535"></a>00535 <span class="comment">    - cvmx_pow_tag_sw_null()</span>
<a name="l00536"></a>00536 <span class="comment">    - cvmx_pow_tag_sw_null_nocheck()</span>
<a name="l00537"></a>00537 <span class="comment">    - cvmx_pow_tag_sw_wait()</span>
<a name="l00538"></a>00538 <span class="comment">    - cvmx_pow_work_invalid()</span>
<a name="l00539"></a>00539 <span class="comment">    - cvmx_pow_work_request_async()</span>
<a name="l00540"></a>00540 <span class="comment">    - cvmx_pow_work_request_async_nocheck()</span>
<a name="l00541"></a>00541 <span class="comment">    - cvmx_pow_work_request_sync()</span>
<a name="l00542"></a>00542 <span class="comment">    - cvmx_pow_work_request_sync_nocheck()</span>
<a name="l00543"></a>00543 <span class="comment">    - cvmx_pow_work_response_async()</span>
<a name="l00544"></a>00544 <span class="comment">    - cvmx_pow_work_request_null_rd()</span>
<a name="l00545"></a>00545 <span class="comment">    - cvmx_pow_work_submit()</span>
<a name="l00546"></a>00546 <span class="comment"></span>
<a name="l00547"></a>00547 <span class="comment">@subsection hal_fpa 4.6 Free Pool Unit (FPA) (cvmx-fpa.h)</span>
<a name="l00548"></a>00548 <span class="comment"></span>
<a name="l00549"></a>00549 <span class="comment">    The FPA unit maintains eight infinite-size pools of pointers to</span>
<a name="l00550"></a>00550 <span class="comment">    free L2/DRAM memory. Both Core SW and other OCTEON HW units allocate and</span>
<a name="l00551"></a>00551 <span class="comment">    free pointers from/to the pools. Core SW and the centralized input packet</span>
<a name="l00552"></a>00552 <span class="comment">    processing HW units allocate memory from the pools. Core SW, the OCTEON</span>
<a name="l00553"></a>00553 <span class="comment">    centralized output packet processing, PCI, Deterministic Finite Automata (DFA),</span>
<a name="l00554"></a>00554 <span class="comment">    and Timer (TIM) HW units free memory to the pools.</span>
<a name="l00555"></a>00555 <span class="comment"></span>
<a name="l00556"></a>00556 <span class="comment">    The FPA HW implements a logical stack/LIFO for each free pointer pool. The FPA</span>
<a name="l00557"></a>00557 <span class="comment">    HW unit stores/caches the top of the stacks in the unit at all times. When a pool is</span>
<a name="l00558"></a>00558 <span class="comment">    too large to fit in the in-unit store, the FPA builds a list data structure in L2/</span>
<a name="l00559"></a>00559 <span class="comment">    DRAM using the free memory in the pool to store the extra pointers. Each pool&apos;s</span>
<a name="l00560"></a>00560 <span class="comment">    size is unlimited due to this technique.</span>
<a name="l00561"></a>00561 <span class="comment"></span>
<a name="l00562"></a>00562 <span class="comment">    The only constraint required by the FPA HW is that pointers submitted to the free</span>
<a name="l00563"></a>00563 <span class="comment">    pools must be aligned on a 128 byte boundary and the free memory must be 128</span>
<a name="l00564"></a>00564 <span class="comment">    bytes or more. The free memory size can be different in different pools and, in fact,</span>
<a name="l00565"></a>00565 <span class="comment">    can also be different within the same pool.</span>
<a name="l00566"></a>00566 <span class="comment"></span>
<a name="l00567"></a>00567 <span class="comment">    FPA support functions in &quot;cvmx-fpa.h&quot;:</span>
<a name="l00568"></a>00568 <span class="comment"></span>
<a name="l00569"></a>00569 <span class="comment">    - cvmx_fpa_alloc()</span>
<a name="l00570"></a>00570 <span class="comment">    - cvmx_fpa_async_alloc()</span>
<a name="l00571"></a>00571 <span class="comment">    - cvmx_fpa_async_alloc_finish()</span>
<a name="l00572"></a>00572 <span class="comment">    - cvmx_fpa_enable()</span>
<a name="l00573"></a>00573 <span class="comment">    - cvmx_fpa_free()</span>
<a name="l00574"></a>00574 <span class="comment">    - cvmx_fpa_free_nosync()</span>
<a name="l00575"></a>00575 <span class="comment">    - cvmx_fpa_get_block_size()</span>
<a name="l00576"></a>00576 <span class="comment">    - cvmx_fpa_get_name()</span>
<a name="l00577"></a>00577 <span class="comment">    - cvmx_fpa_setup_pool()</span>
<a name="l00578"></a>00578 <span class="comment">    - cvmx_fpa_shutdown_pool()</span>
<a name="l00579"></a>00579 <span class="comment"></span>
<a name="l00580"></a>00580 <span class="comment">@subsection hal_pip 4.7 Packet Input Processing and Input Packet Data Unit (PIP/IPD) (cvmx-pip.h, cvmx-ipd.h, cvmx-wqe.h)</span>
<a name="l00581"></a>00581 <span class="comment"></span>
<a name="l00582"></a>00582 <span class="comment">Note: The CN78XX series has replaced the PIP/IPD units with the programmable PKI</span>
<a name="l00583"></a>00583 <span class="comment">interface. For compatibility reasons most functions now wrap PKI functionality.</span>
<a name="l00584"></a>00584 <span class="comment">Please see @ref cn78xx_native for more information on native PKI programming and</span>
<a name="l00585"></a>00585 <span class="comment">@ref cvmx_backward for information on compatibility mode considerations.</span>
<a name="l00586"></a>00586 <span class="comment"></span>
<a name="l00587"></a>00587 <span class="comment">    The OCTEON Centralized Packet Input Processing and Input</span>
<a name="l00588"></a>00588 <span class="comment">    Packet Data Unit (PIP/IPD) receives packet input data from any of the</span>
<a name="l00589"></a>00589 <span class="comment">    RGMII, SPI4.2, or PCI interfaces. It can have a combined total of up to 36 input</span>
<a name="l00590"></a>00590 <span class="comment">    ports for receiving packets between all these sources. This effectively means that</span>
<a name="l00591"></a>00591 <span class="comment">    PIP/IPD supports a total of up to 36 simultaneous in-flight packets. The packets</span>
<a name="l00592"></a>00592 <span class="comment">    arriving on the different ports share the same PIP/IPD HW resources, but</span>
<a name="l00593"></a>00593 <span class="comment">    logically the PIP/IPD HW treats the different in-flight packets independently.</span>
<a name="l00594"></a>00594 <span class="comment"></span>
<a name="l00595"></a>00595 <span class="comment">    The PIP/IPD units allocate and write packet data into buffers in a format that is</span>
<a name="l00596"></a>00596 <span class="comment">    convenient to higher-layer SW. The unit supports a programmable buffer size</span>
<a name="l00597"></a>00597 <span class="comment">    (with pads at the top and bottom for SW use), and can distribute packet data</span>
<a name="l00598"></a>00598 <span class="comment">    across multiple buffers to support large packet input sizes.</span>
<a name="l00599"></a>00599 <span class="comment"></span>
<a name="l00600"></a>00600 <span class="comment">    The PIP/IPD also allocates and creates a work queue entry for each packet. This</span>
<a name="l00601"></a>00601 <span class="comment">    work queue entry contains a pointer to the buffered packet, HW parsing results,</span>
<a name="l00602"></a>00602 <span class="comment">    and packet error checks. The unit performs many L2-L4 checks, including the</span>
<a name="l00603"></a>00603 <span class="comment">    TCP/UDP checksum check. The unit can skip over a programmable amount of</span>
<a name="l00604"></a>00604 <span class="comment">    user-defined input data before parsing the input packet. This is useful for user-</span>
<a name="l00605"></a>00605 <span class="comment">    defined headers passed with the packets.</span>
<a name="l00606"></a>00606 <span class="comment"></span>
<a name="l00607"></a>00607 <span class="comment">    PIP support functions in &quot;cvmx-pip.h&quot;:</span>
<a name="l00608"></a>00608 <span class="comment"></span>
<a name="l00609"></a>00609 <span class="comment">    - cvmx_pip_config_crc()</span>
<a name="l00610"></a>00610 <span class="comment">    - cvmx_pip_config_diffserv_qos()</span>
<a name="l00611"></a>00611 <span class="comment">    - cvmx_pip_config_port()</span>
<a name="l00612"></a>00612 <span class="comment">    - cvmx_pip_config_vlan_qos()</span>
<a name="l00613"></a>00613 <span class="comment">    - cvmx_pip_get_port_status()</span>
<a name="l00614"></a>00614 <span class="comment"></span>
<a name="l00615"></a>00615 <span class="comment">    IPD support functions in &quot;cvmx-ipd.h&quot;:</span>
<a name="l00616"></a>00616 <span class="comment"></span>
<a name="l00617"></a>00617 <span class="comment">    - cvmx_ipd_config()</span>
<a name="l00618"></a>00618 <span class="comment">    - cvmx_ipd_enable()</span>
<a name="l00619"></a>00619 <span class="comment"></span>
<a name="l00620"></a>00620 <span class="comment">@subsection hal_pko 4.8 Packet Output Unit (PKO) (cvmx-pko.h)</span>
<a name="l00621"></a>00621 <span class="comment"></span>
<a name="l00622"></a>00622 <span class="comment">    The OCTEON Centralized Packet Output Processing (PKO)</span>
<a name="l00623"></a>00623 <span class="comment">    unit gathers packet data from L2/DRAM and sends it out on any of the</span>
<a name="l00624"></a>00624 <span class="comment">    RGMII, SPI4.2, or PCI interfaces. It can have a combined total of up to 36 output</span>
<a name="l00625"></a>00625 <span class="comment">    ports for sending packets between all these destinations. This effectively means</span>
<a name="l00626"></a>00626 <span class="comment">    that PKO supports a total of up to 36 simultaneous in-flight packets. The packets</span>
<a name="l00627"></a>00627 <span class="comment">    sent out to the different ports share some of the same PKO HW resources, but</span>
<a name="l00628"></a>00628 <span class="comment">    logically the PKO unit treats the different in-flight packets independently.</span>
<a name="l00629"></a>00629 <span class="comment"></span>
<a name="l00630"></a>00630 <span class="comment">    The @link cvmx-pko.h PKO Description @endlink and</span>
<a name="l00631"></a>00631 <span class="comment">    @link cvmx-cmd-queue.h Common Command Queue Description @endlink provide</span>
<a name="l00632"></a>00632 <span class="comment">    more information.</span>
<a name="l00633"></a>00633 <span class="comment"></span>
<a name="l00634"></a>00634 <span class="comment">Note: The CN78XX series has replaced the PKO unit with the advanced PKO3</span>
<a name="l00635"></a>00635 <span class="comment">interface. For compatibility reasons most functions now wrap PKO functionality.</span>
<a name="l00636"></a>00636 <span class="comment">Please see @ref cn78xx_native for more information on native PKO3 programming and</span>
<a name="l00637"></a>00637 <span class="comment">@ref cvmx_backward for information on compatibility mode considerations.</span>
<a name="l00638"></a>00638 <span class="comment"></span>
<a name="l00639"></a>00639 <span class="comment">    PKO support functions in &quot;cvmx-pko.h&quot;:</span>
<a name="l00640"></a>00640 <span class="comment"></span>
<a name="l00641"></a>00641 <span class="comment">    - cvmx_pko_config_port()</span>
<a name="l00642"></a>00642 <span class="comment">    - cvmx_pko_disable()</span>
<a name="l00643"></a>00643 <span class="comment">    - cvmx_pko_doorbell()</span>
<a name="l00644"></a>00644 <span class="comment">    - cvmx_pko_enable()</span>
<a name="l00645"></a>00645 <span class="comment">    - cvmx_pko_initialize_local()</span>
<a name="l00646"></a>00646 <span class="comment">    - cvmx_pko_initialize_global()</span>
<a name="l00647"></a>00647 <span class="comment">    - cvmx_pko_send_packet_prepare()</span>
<a name="l00648"></a>00648 <span class="comment">    - cvmx_pko_send_packet_finish()</span>
<a name="l00649"></a>00649 <span class="comment">    - cvmx_pko_send_packet_finish3()</span>
<a name="l00650"></a>00650 <span class="comment">    - cvmx_pko_shutdown()</span>
<a name="l00651"></a>00651 <span class="comment"></span>
<a name="l00652"></a>00652 <span class="comment">@subsection hal_llm 4.9 Low-Latency Memory (LLM) (cvmx-llm.h)</span>
<a name="l00653"></a>00653 <span class="comment"></span>
<a name="l00654"></a>00654 <span class="comment">    Cavium&apos;s OCTEON CN38XX/CN36XX processors support two dedicated</span>
<a name="l00655"></a>00655 <span class="comment">    low-latency memory channels (in addition to main DDR-II memory interface)</span>
<a name="l00656"></a>00656 <span class="comment">    for storing/walking DFA graphs.  The OCTEON CN31XX processors support</span>
<a name="l00657"></a>00657 <span class="comment">    one channel of DDR2 SDRAM for DFA graphs and direct core access.</span>
<a name="l00658"></a>00658 <span class="comment">    The low latency memory may be accessed in two widths: narrow and wide.</span>
<a name="l00659"></a>00659 <span class="comment">    The use of LLM across the OCTEON family is very similar even though</span>
<a name="l00660"></a>00660 <span class="comment">    the widths do vary betwen the CN38XX/CN36XX and CN31XX.  Please refer</span>
<a name="l00661"></a>00661 <span class="comment">    to the HRM for details on LLM access widths and data formats.</span>
<a name="l00662"></a>00662 <span class="comment"></span>
<a name="l00663"></a>00663 <span class="comment">    The OCTEON processor supports two modes of access to the dedicated low</span>
<a name="l00664"></a>00664 <span class="comment">    latency memory channels, namely:</span>
<a name="l00665"></a>00665 <span class="comment"></span>
<a name="l00666"></a>00666 <span class="comment">    - HW-Assist Mode: Each Cavium-MIPS (CM) core writes a predefined DFA</span>
<a name="l00667"></a>00667 <span class="comment">        macro- instruction to main memory which is then assigned to one (of 16)</span>
<a name="l00668"></a>00668 <span class="comment">        DFA hardware thread engines.  A hardware thread engine will walk the DFA</span>
<a name="l00669"></a>00669 <span class="comment">        graph to completion and will also write search results to main memory.</span>
<a name="l00670"></a>00670 <span class="comment">        The initiating CAVIUM-MIPS can be alerted of the macro-instruction</span>
<a name="l00671"></a>00671 <span class="comment">        completion either by polling or by a work queue interrupt.</span>
<a name="l00672"></a>00672 <span class="comment"></span>
<a name="l00673"></a>00673 <span class="comment">    - Direct-CAVIUM-MIPS Mode: Each CM core has direct read/write access to</span>
<a name="l00674"></a>00674 <span class="comment">        LLM memory over a dedicated low-latency bus using special Cavium MIPS</span>
<a name="l00675"></a>00675 <span class="comment">        coprocessor instructions.</span>
<a name="l00676"></a>00676 <span class="comment"></span>
<a name="l00677"></a>00677 <span class="comment">    Both of these access modes can be used simultaneously to provide optimal flexibility and</span>
<a name="l00678"></a>00678 <span class="comment">    performance.</span>
<a name="l00679"></a>00679 <span class="comment"></span>
<a name="l00680"></a>00680 <span class="comment">    LLM support functions in &quot;cvmx-llm.h&quot;:</span>
<a name="l00681"></a>00681 <span class="comment"></span>
<a name="l00682"></a>00682 <span class="comment">    - cvmx_llm_ecc()</span>
<a name="l00683"></a>00683 <span class="comment">    - cvmx_llm_parity()</span>
<a name="l00684"></a>00684 <span class="comment">    - cvmx_llm_read_narrow()</span>
<a name="l00685"></a>00685 <span class="comment">    - cvmx_llm_read_wide()</span>
<a name="l00686"></a>00686 <span class="comment">    - cvmx_llm_write_narrow()</span>
<a name="l00687"></a>00687 <span class="comment">    - cvmx_llm_write_wide()</span>
<a name="l00688"></a>00688 <span class="comment"></span>
<a name="l00689"></a>00689 <span class="comment">    The following functions are deprecated, and have been replaced by the</span>
<a name="l00690"></a>00690 <span class="comment">    read/write narrow/wide functions.  Compatability macros are provided</span>
<a name="l00691"></a>00691 <span class="comment">    ease the transition.  The compatability macros are scheduled to be</span>
<a name="l00692"></a>00692 <span class="comment">    removed from the 1.4.0 SDK release.</span>
<a name="l00693"></a>00693 <span class="comment"></span>
<a name="l00694"></a>00694 <span class="comment">    - cvmx_llm_read36()</span>
<a name="l00695"></a>00695 <span class="comment">    - cvmx_llm_read64()</span>
<a name="l00696"></a>00696 <span class="comment">    - cvmx_llm_write36()</span>
<a name="l00697"></a>00697 <span class="comment">    - cvmx_llm_write64()</span>
<a name="l00698"></a>00698 <span class="comment"></span>
<a name="l00699"></a>00699 <span class="comment">@subsection hal_dfa 4.10 Deterministic Finite Automata Unit (DFA) (cvmx-dfa.h)</span>
<a name="l00700"></a>00700 <span class="comment"></span>
<a name="l00701"></a>00701 <span class="comment">    The OCTEON processor contains multiple DFA hardware engines (threads),</span>
<a name="l00702"></a>00702 <span class="comment">    each capable of walking DFA graph(s) stored across two dedicated,</span>
<a name="l00703"></a>00703 <span class="comment">    low-latency memory channels.  DFA graphs may be replicated across multiple</span>
<a name="l00704"></a>00704 <span class="comment">    internal banks and across both ports (if populated), to</span>
<a name="l00705"></a>00705 <span class="comment">    reduce the effects of bank conflicts caused by back to back</span>
<a name="l00706"></a>00706 <span class="comment">    accesses to the same bank.  Each DFA graph can be redundantly stored</span>
<a name="l00707"></a>00707 <span class="comment">    within 1, 2, 4, or 8 internal banks and also across both channels.  In</span>
<a name="l00708"></a>00708 <span class="comment">    this manner, DFA graph access can then be effectively `load balanced&apos;</span>
<a name="l00709"></a>00709 <span class="comment">    across the `least used bank/channel&apos; to provide extremely low and</span>
<a name="l00710"></a>00710 <span class="comment">    predictable DFA graph latencies and high aggregate throughput.</span>
<a name="l00711"></a>00711 <span class="comment"></span>
<a name="l00712"></a>00712 <span class="comment">    The DFA hardware engines are treated as a pool of co-processors available</span>
<a name="l00713"></a>00713 <span class="comment">    to all of the CM processors.  To initiate a DFA walk, a CM core writes a</span>
<a name="l00714"></a>00714 <span class="comment">    fixed-size/format DFA macro-instruction (created by cvmx_dfa_submit())</span>
<a name="l00715"></a>00715 <span class="comment">    into main memory which contains information for the hardware engine to</span>
<a name="l00716"></a>00716 <span class="comment">    perform the DFA graph walk.  The DFA hardware engine starts its graph</span>
<a name="l00717"></a>00717 <span class="comment">    walk from the node specified by DFA graph base + starting node offset.</span>
<a name="l00718"></a>00718 <span class="comment">    Each node contains 256 arcs.  The size of each arc in memory is defined by</span>
<a name="l00719"></a>00719 <span class="comment">    the graph type (2 Bytes in small mode or 4 Bytes in large mode).</span>
<a name="l00720"></a>00720 <span class="comment"></span>
<a name="l00721"></a>00721 <span class="comment">    The 8-bit character from the input packet data is used as an index into</span>
<a name="l00722"></a>00722 <span class="comment">    1-of-256 arcs within the starting node.  The DFA hardware engine then</span>
<a name="l00723"></a>00723 <span class="comment">    fetches the next-arc and uses it to determine the next node.  The next</span>
<a name="l00724"></a>00724 <span class="comment">    8-bit character from the input packet data is again used as an index into</span>
<a name="l00725"></a>00725 <span class="comment">    1-of-256 arcs within this next node.</span>
<a name="l00726"></a>00726 <span class="comment"></span>
<a name="l00727"></a>00727 <span class="comment">    This process is repeated until either a) all the packet input data is</span>
<a name="l00728"></a>00728 <span class="comment">    exhausted or b) a terminal node is reached c) the specified match result</span>
<a name="l00729"></a>00729 <span class="comment">    buffer becomes full or d) a parity error is detected.  A `match&apos; is noted</span>
<a name="l00730"></a>00730 <span class="comment">    whenever a node marked as `match&apos; is visited.  During the DFA walk, for</span>
<a name="l00731"></a>00731 <span class="comment">    each match detected, intermediate results are written into a specified</span>
<a name="l00732"></a>00732 <span class="comment">    result buffer.  The content of the intermediate results contains the</span>
<a name="l00733"></a>00733 <span class="comment">    character offset, and pointers to the previous and marked states of the</span>
<a name="l00734"></a>00734 <span class="comment">    DFA graph.  If the input data is exhausted before a terminal node is</span>
<a name="l00735"></a>00735 <span class="comment">    reached, the DFA context is written to the result buffer and control is</span>
<a name="l00736"></a>00736 <span class="comment">    returned to the requesting packet processor through either an interrupt</span>
<a name="l00737"></a>00737 <span class="comment">    (work queue entry) or via software polling.  The last entry in the result</span>
<a name="l00738"></a>00738 <span class="comment">    buffer will contain the DFA context which contains the input data length</span>
<a name="l00739"></a>00739 <span class="comment">    and also the current state of the DFA graph.  This facilitates packets</span>
<a name="l00740"></a>00740 <span class="comment">    which span multiple input data segments, so that subsequent search</span>
<a name="l00741"></a>00741 <span class="comment">    requests may pick up where the previous search left off.  The DFA engine</span>
<a name="l00742"></a>00742 <span class="comment">    also supports a packet gather mode, which allows a user to specify a</span>
<a name="l00743"></a>00743 <span class="comment">    gather-pointer list, which allows multi-segmented packets to be</span>
<a name="l00744"></a>00744 <span class="comment">    auto-traversed by the DFA hardware itself.</span>
<a name="l00745"></a>00745 <span class="comment"></span>
<a name="l00746"></a>00746 <span class="comment">    For simple strings (no wildcards) the size of a DFA graph will be bounded</span>
<a name="l00747"></a>00747 <span class="comment">    by the sum of the characters of all the strings, although there may be some</span>
<a name="l00748"></a>00748 <span class="comment">    slight overhead to distinguish the type of the node.  The time complexity</span>
<a name="l00749"></a>00749 <span class="comment">    of a DFA search is one memory access per input byte.  This is independent</span>
<a name="l00750"></a>00750 <span class="comment">    of the number of strings in the DFA graph.  A single search is limited in</span>
<a name="l00751"></a>00751 <span class="comment">    performance by the round trip of presenting an address (to DRAM), reading</span>
<a name="l00752"></a>00752 <span class="comment">    the DRAM data, and computing the next address.  This limitation is</span>
<a name="l00753"></a>00753 <span class="comment">    mitigated in two ways: using lower latency RLDRAMs and having many</span>
<a name="l00754"></a>00754 <span class="comment">    independent searches happening in parallel.</span>
<a name="l00755"></a>00755 <span class="comment"></span>
<a name="l00756"></a>00756 <span class="comment">@verbatim</span>
<a name="l00757"></a>00757 <span class="comment">DFA Performance Details with random data distribution (CN38XX)</span>
<a name="l00758"></a>00758 <span class="comment">  Replication       Threads      Max Nodes              Bandwidth</span>
<a name="l00759"></a>00759 <span class="comment">       1x              1             1M                  220Mb/s</span>
<a name="l00760"></a>00760 <span class="comment">       1x              16            1M                 2610Mb/s</span>
<a name="l00761"></a>00761 <span class="comment">       2x              16           512K                2690Mb/s</span>
<a name="l00762"></a>00762 <span class="comment">       4x              16           256K                2800Mb/s</span>
<a name="l00763"></a>00763 <span class="comment">       8x              16           128K                3070Mb/s</span>
<a name="l00764"></a>00764 <span class="comment">@endverbatim</span>
<a name="l00765"></a>00765 <span class="comment"></span>
<a name="l00766"></a>00766 <span class="comment">    The above table shows performance for various configurations assuming a</span>
<a name="l00767"></a>00767 <span class="comment">    random bank distribution of the data.  Replicating the graph increases</span>
<a name="l00768"></a>00768 <span class="comment">    performance but at a cost to maximum capacity.  This is programmable per</span>
<a name="l00769"></a>00769 <span class="comment">    graph.  A single thread typically requires ~20 cycles per byte of data</span>
<a name="l00770"></a>00770 <span class="comment">    searched.  Increasing the number of threads increases the latency</span>
<a name="l00771"></a>00771 <span class="comment">    of an individual thread (through memory contention) and increases the</span>
<a name="l00772"></a>00772 <span class="comment">    aggregate performance (by having more parallelism.)</span>
<a name="l00773"></a>00773 <span class="comment"></span>
<a name="l00774"></a>00774 <span class="comment">    DFA support functions in &quot;cvmx-dfa.h&quot;:</span>
<a name="l00775"></a>00775 <span class="comment"></span>
<a name="l00776"></a>00776 <span class="comment">    - cvmx_dfa_initialize()</span>
<a name="l00777"></a>00777 <span class="comment">    - cvmx_dfa_is_done()</span>
<a name="l00778"></a>00778 <span class="comment">    - cvmx_dfa_shutdown()</span>
<a name="l00779"></a>00779 <span class="comment">    - cvmx_dfa_submit()</span>
<a name="l00780"></a>00780 <span class="comment">    - cvmx_dfa_write_doorbell()</span>
<a name="l00781"></a>00781 <span class="comment">    - cvmx_dfa_write_edge_sm()</span>
<a name="l00782"></a>00782 <span class="comment">    - cvmx_dfa_write_node_lg()</span>
<a name="l00783"></a>00783 <span class="comment"></span>
<a name="l00784"></a>00784 <span class="comment">@subsection hal_pci 4.11 PCI Unit (PCI) (cvmx-pci.h, cvmx-npi.h)</span>
<a name="l00785"></a>00785 <span class="comment"></span>
<a name="l00786"></a>00786 <span class="comment">    The OCTEON supports three types of transfers over the PCI interface:</span>
<a name="l00787"></a>00787 <span class="comment"> * - Memory mapped: The OCTEON supports memory mapped PCI transactions as</span>
<a name="l00788"></a>00788 <span class="comment"> * host or target and master or slave.  It provides several Base Address Registers</span>
<a name="l00789"></a>00789 <span class="comment"> * (BARs) each with configurable attributes.</span>
<a name="l00790"></a>00790 <span class="comment"> * - Packet IO: Packet IO over the PCI bus goes through the PIP/IPD and packets</span>
<a name="l00791"></a>00791 <span class="comment"> * can be processed in the same way by hardware as if they came in over ethernet or SPI</span>
<a name="l00792"></a>00792 <span class="comment"> * interfaces.  In addition, a &apos;raw&apos; packet mode is supported that bypasses this processing</span>
<a name="l00793"></a>00793 <span class="comment"> * and allows the host to provide a WQE for each packet.</span>
<a name="l00794"></a>00794 <span class="comment"> * - DMA: OCTEON provides two general purpose bidirectional PCI&lt;-&gt;DRAM DMA engines.  The DMA engines</span>
<a name="l00795"></a>00795 <span class="comment"> * use descriptor rings to interface with the cnMIPS cores and external processors.</span>
<a name="l00796"></a>00796 <span class="comment"> *</span>
<a name="l00797"></a>00797 <span class="comment"> *</span>
<a name="l00798"></a>00798 <span class="comment"> * For more information please refer to the hardware manual.</span>
<a name="l00799"></a>00799 <span class="comment"></span>
<a name="l00800"></a>00800 <span class="comment"></span>
<a name="l00801"></a>00801 <span class="comment">@subsection hal_tim 4.12 Timer Unit (TIM) (cvmx-tim.h)</span>
<a name="l00802"></a>00802 <span class="comment"></span>
<a name="l00803"></a>00803 <span class="comment">    The OCTEON Timer consists of 16 bucketed rings held in L2/DRAM.</span>
<a name="l00804"></a>00804 <span class="comment">        - SW can program a separate ring per Core.</span>
<a name="l00805"></a>00805 <span class="comment">        - Each bucket corresponds to a different time slice.</span>
<a name="l00806"></a>00806 <span class="comment">        - Each ring has a programmable number of buckets.</span>
<a name="l00807"></a>00807 <span class="comment">        - Each ring has a programmable time interval between buckets.</span>
<a name="l00808"></a>00808 <span class="comment">    At each periodic bucket time expiration, HW processes the next bucket.</span>
<a name="l00809"></a>00809 <span class="comment">        - Each timer entry within a bucket may be a work queue entry pointer that HW submits.</span>
<a name="l00810"></a>00810 <span class="comment">        - A Bucket is a chunked list, and HW frees chunks (to a HW pool) after using them.</span>
<a name="l00811"></a>00811 <span class="comment">        - HW also resets the bucket data structure.</span>
<a name="l00812"></a>00812 <span class="comment">    The HW traverses up to 80 million timer entries per second.</span>
<a name="l00813"></a>00813 <span class="comment"></span>
<a name="l00814"></a>00814 <span class="comment">    SW inserts work queue entries into the appropriate bucket.</span>
<a name="l00815"></a>00815 <span class="comment">        - SW allocates bucket chunks as needed</span>
<a name="l00816"></a>00816 <span class="comment">        - SW can remove added entries from the bucket later by re-writing the entry to NULL (before the HW processes the bucket).</span>
<a name="l00817"></a>00817 <span class="comment"></span>
<a name="l00818"></a>00818 <span class="comment">    @dot</span>
<a name="l00819"></a>00819 <span class="comment">        digraph timers</span>
<a name="l00820"></a>00820 <span class="comment">        {</span>
<a name="l00821"></a>00821 <span class="comment">            rankdir=TB;</span>
<a name="l00822"></a>00822 <span class="comment">            node [shape=record, width=.1, height=.1, fontsize=10, font=helvitica];</span>
<a name="l00823"></a>00823 <span class="comment"></span>
<a name="l00824"></a>00824 <span class="comment">            {rank=same;</span>
<a name="l00825"></a>00825 <span class="comment">                timer0 [shape=plaintext, label=&quot;Timer 0&quot;, width=1.0];</span>
<a name="l00826"></a>00826 <span class="comment">            timer0bucket0 [label=&quot;Bucket 0&quot;];</span>
<a name="l00827"></a>00827 <span class="comment">            timer0bucket1 [label=&quot;Bucket 1&quot;];</span>
<a name="l00828"></a>00828 <span class="comment">            timer0bucket2 [label=&quot;Bucket 2&quot;];</span>
<a name="l00829"></a>00829 <span class="comment">            timer0bucket3 [label=&quot;Bucket 3&quot;];</span>
<a name="l00830"></a>00830 <span class="comment">            timer0bucket4 [label=&quot;Bucket 4&quot;]}</span>
<a name="l00831"></a>00831 <span class="comment">                timer0 -&gt; timer0bucket0 -&gt; timer0bucket1 -&gt; timer0bucket2 -&gt;</span>
<a name="l00832"></a>00832 <span class="comment">                      timer0bucket3 -&gt; timer0bucket4 -&gt; timer0bucket0;</span>
<a name="l00833"></a>00833 <span class="comment">            {rank=same;</span>
<a name="l00834"></a>00834 <span class="comment">            timer0chunk0 [label=&quot;{Chunk||}&quot;];</span>
<a name="l00835"></a>00835 <span class="comment">            timer0chunk2 [label=&quot;{Chunk||}&quot;];</span>
<a name="l00836"></a>00836 <span class="comment">            timer0chunk4 [label=&quot;{Chunk||}&quot;]}</span>
<a name="l00837"></a>00837 <span class="comment">            timer0bucket0 -&gt; timer0chunk0;</span>
<a name="l00838"></a>00838 <span class="comment">            timer0bucket2 -&gt; timer0chunk2;</span>
<a name="l00839"></a>00839 <span class="comment">            timer0bucket4 -&gt; timer0chunk4;</span>
<a name="l00840"></a>00840 <span class="comment"></span>
<a name="l00841"></a>00841 <span class="comment">            {rank=same;</span>
<a name="l00842"></a>00842 <span class="comment">                timer1 [shape=plaintext, label=&quot;Timer 1&quot;, width=1.0];</span>
<a name="l00843"></a>00843 <span class="comment">            timer1bucket0 [label=&quot;Bucket 0&quot;];</span>
<a name="l00844"></a>00844 <span class="comment">            timer1bucket1 [label=&quot;Bucket 1&quot;];</span>
<a name="l00845"></a>00845 <span class="comment">            timer1bucket2 [label=&quot;Bucket 2&quot;];</span>
<a name="l00846"></a>00846 <span class="comment">            timer1bucket3 [label=&quot;Bucket 3&quot;];</span>
<a name="l00847"></a>00847 <span class="comment">            timer1bucket4 [label=&quot;Bucket 4&quot;]}</span>
<a name="l00848"></a>00848 <span class="comment">                timer1 -&gt; timer1bucket0 -&gt; timer1bucket1 -&gt; timer1bucket2 -&gt;</span>
<a name="l00849"></a>00849 <span class="comment">                      timer1bucket3 -&gt; timer1bucket4 -&gt; timer1bucket0;</span>
<a name="l00850"></a>00850 <span class="comment">            {rank=same;</span>
<a name="l00851"></a>00851 <span class="comment">            timer1chunk0 [label=&quot;{Chunk||}&quot;];</span>
<a name="l00852"></a>00852 <span class="comment">            timer1chunk3 [label=&quot;{Chunk||}&quot;]}</span>
<a name="l00853"></a>00853 <span class="comment">            timer1bucket0 -&gt; timer1chunk0;</span>
<a name="l00854"></a>00854 <span class="comment">            timer1bucket3 -&gt; timer1chunk3;</span>
<a name="l00855"></a>00855 <span class="comment"></span>
<a name="l00856"></a>00856 <span class="comment">            {rank=same;</span>
<a name="l00857"></a>00857 <span class="comment">                timer2 [shape=plaintext, label=&quot;...&quot;, width=1.0];</span>
<a name="l00858"></a>00858 <span class="comment">            timer2bucket0 [label=&quot;Bucket 0&quot;];</span>
<a name="l00859"></a>00859 <span class="comment">            timer2bucket1 [label=&quot;Bucket 1&quot;];</span>
<a name="l00860"></a>00860 <span class="comment">            timer2bucket2 [label=&quot;Bucket 2&quot;];</span>
<a name="l00861"></a>00861 <span class="comment">            timer2bucket3 [label=&quot;Bucket 3&quot;];</span>
<a name="l00862"></a>00862 <span class="comment">            timer2bucket4 [label=&quot;Bucket 4&quot;]}</span>
<a name="l00863"></a>00863 <span class="comment">                timer2 -&gt; timer2bucket0 -&gt; timer2bucket1 -&gt; timer2bucket2 -&gt;</span>
<a name="l00864"></a>00864 <span class="comment">                      timer2bucket3 -&gt; timer2bucket4 -&gt; timer2bucket0;</span>
<a name="l00865"></a>00865 <span class="comment">            {rank=same;</span>
<a name="l00866"></a>00866 <span class="comment">            timer2chunk4 [label=&quot;{Chunk||}&quot;]}</span>
<a name="l00867"></a>00867 <span class="comment">            timer2bucket4 -&gt; timer2chunk4;</span>
<a name="l00868"></a>00868 <span class="comment"></span>
<a name="l00869"></a>00869 <span class="comment">            {rank=same;</span>
<a name="l00870"></a>00870 <span class="comment">                timer3 [shape=plaintext, label=&quot;Timer 15&quot;, width=1.0];</span>
<a name="l00871"></a>00871 <span class="comment">            timer3bucket0 [label=&quot;Bucket 0&quot;];</span>
<a name="l00872"></a>00872 <span class="comment">            timer3bucket1 [label=&quot;Bucket 1&quot;];</span>
<a name="l00873"></a>00873 <span class="comment">            timer3bucket2 [label=&quot;Bucket 2&quot;];</span>
<a name="l00874"></a>00874 <span class="comment">            timer3bucket3 [label=&quot;Bucket 3&quot;];</span>
<a name="l00875"></a>00875 <span class="comment">            timer3bucket4 [label=&quot;Bucket 4&quot;]}</span>
<a name="l00876"></a>00876 <span class="comment">                timer3 -&gt; timer3bucket0 -&gt; timer3bucket1 -&gt; timer3bucket2 -&gt;</span>
<a name="l00877"></a>00877 <span class="comment">                      timer3bucket3 -&gt; timer3bucket4 -&gt; timer3bucket0;</span>
<a name="l00878"></a>00878 <span class="comment">            {rank=same;</span>
<a name="l00879"></a>00879 <span class="comment">            timer3chunk0 [label=&quot;{Chunk||}&quot;];</span>
<a name="l00880"></a>00880 <span class="comment">            timer3chunk1 [label=&quot;{Chunk||}&quot;];</span>
<a name="l00881"></a>00881 <span class="comment">            timer3chunk2 [label=&quot;{Chunk||}&quot;];</span>
<a name="l00882"></a>00882 <span class="comment">            timer3chunk4 [label=&quot;{Chunk||}&quot;]}</span>
<a name="l00883"></a>00883 <span class="comment">            timer3bucket0 -&gt; timer3chunk0;</span>
<a name="l00884"></a>00884 <span class="comment">            timer3bucket1 -&gt; timer3chunk1;</span>
<a name="l00885"></a>00885 <span class="comment">            timer3bucket2 -&gt; timer3chunk2;</span>
<a name="l00886"></a>00886 <span class="comment">            timer3bucket4 -&gt; timer3chunk4;</span>
<a name="l00887"></a>00887 <span class="comment"></span>
<a name="l00888"></a>00888 <span class="comment"></span>
<a name="l00889"></a>00889 <span class="comment">            node [style=invis]</span>
<a name="l00890"></a>00890 <span class="comment">            timer0 -&gt; h1 -&gt; timer1 -&gt; h2 -&gt; timer2 -&gt; h3 -&gt; timer3 [style=invis];</span>
<a name="l00891"></a>00891 <span class="comment">        }</span>
<a name="l00892"></a>00892 <span class="comment">    @enddot</span>
<a name="l00893"></a>00893 <span class="comment"></span>
<a name="l00894"></a>00894 <span class="comment">    The simple executive timer library provides a simplified interface to the</span>
<a name="l00895"></a>00895 <span class="comment">    hardware timers by hiding the low level details of chunk and bucket</span>
<a name="l00896"></a>00896 <span class="comment">    allocations. Each timer is assigned to a single core to limit contention</span>
<a name="l00897"></a>00897 <span class="comment">    and locking requirements. All timers are setup (using cvmx_tim_setup) with</span>
<a name="l00898"></a>00898 <span class="comment">    the same bucket interval (period_cycles) and number of buckets</span>
<a name="l00899"></a>00899 <span class="comment">    (CVMX_TIM_NUM_BUCKETS=2048). This limits the maximum timer duration to</span>
<a name="l00900"></a>00900 <span class="comment">    (CVMX_TIM_NUM_BUCKETS - 1) * period_cycles and minimum to</span>
<a name="l00901"></a>00901 <span class="comment">    2 * period_cycles. Allocation of bucket chunks is hidden inside of</span>
<a name="l00902"></a>00902 <span class="comment">    cvmx_tim_add_entry().</span>
<a name="l00903"></a>00903 <span class="comment"></span>
<a name="l00904"></a>00904 <span class="comment">    Timer support functions in &quot;cvmx-tim.h&quot;:</span>
<a name="l00905"></a>00905 <span class="comment"></span>
<a name="l00906"></a>00906 <span class="comment">    - cvmx_tim_add_entry()</span>
<a name="l00907"></a>00907 <span class="comment">    - cvmx_tim_delete_entry()</span>
<a name="l00908"></a>00908 <span class="comment">    - cvmx_tim_setup()</span>
<a name="l00909"></a>00909 <span class="comment">    - cvmx_tim_shutdown()</span>
<a name="l00910"></a>00910 <span class="comment">    - cvmx_tim_start()</span>
<a name="l00911"></a>00911 <span class="comment">    - cvmx_tim_stop()</span>
<a name="l00912"></a>00912 <span class="comment"></span>
<a name="l00913"></a>00913 <span class="comment">@subsection hal_uart 4.13 UART Unit (UART) (cvmx-uart.h)</span>
<a name="l00914"></a>00914 <span class="comment"></span>
<a name="l00915"></a>00915 <span class="comment">    The OCTEON supports two serial uarts based on the industry standard 16550</span>
<a name="l00916"></a>00916 <span class="comment">    programatic interface. The two independent uarts are configured by the</span>
<a name="l00917"></a>00917 <span class="comment">    simple executive automatically. Uart 0 is used as a console for the boot</span>
<a name="l00918"></a>00918 <span class="comment">    loader and C libraries. Uart 1 is reserved for communications with the</span>
<a name="l00919"></a>00919 <span class="comment">    debugger. The simulator, by default, prints all uart output to stdout. If</span>
<a name="l00920"></a>00920 <span class="comment">    the &quot;-uartX=port&quot; argument is used with the simulator, it creates a</span>
<a name="l00921"></a>00921 <span class="comment">    listening port for incoming TCP connections. Serial input and</span>
<a name="l00922"></a>00922 <span class="comment">    output is then sent through this connection. For example, you can receive</span>
<a name="l00923"></a>00923 <span class="comment">    console output from the simulator in another window by connecting a telnet</span>
<a name="l00924"></a>00924 <span class="comment">    session to the simulator uart port.</span>
<a name="l00925"></a>00925 <span class="comment"></span>
<a name="l00926"></a>00926 <span class="comment">    @code</span>
<a name="l00927"></a>00927 <span class="comment">        terminal 1: $ oct-sim hello -uart0=2020 -quiet -noperf</span>
<a name="l00928"></a>00928 <span class="comment">        terminal 2: $ telnet localhost 2020</span>
<a name="l00929"></a>00929 <span class="comment">    @endcode</span>
<a name="l00930"></a>00930 <span class="comment"></span>
<a name="l00931"></a>00931 <span class="comment">    Programming the uarts is performed using the CSRs beginning with</span>
<a name="l00932"></a>00932 <span class="comment">    &quot;CVMX_MIO_UARTX_&quot;. Documentation for how each CSR is accessed is</span>
<a name="l00933"></a>00933 <span class="comment">    defined in &quot;cvmx-uart.h&quot;. For interrupt based communications, it</span>
<a name="l00934"></a>00934 <span class="comment">    is also necessary to program the CIU to enable uart interrupts.</span>
<a name="l00935"></a>00935 <span class="comment">    Uart examples for both polled and interrupt driven communications</span>
<a name="l00936"></a>00936 <span class="comment">    can be found in &quot;sdk/examples/uart&quot;.</span>
<a name="l00937"></a>00937 <span class="comment"></span>
<a name="l00938"></a>00938 <span class="comment">@subsection hal_ciu 4.14 Central Interrupt Unit (CIU)</span>
<a name="l00939"></a>00939 <span class="comment"></span>
<a name="l00940"></a>00940 <span class="comment">    The Central Interrupt Unit (CIU) controls the routing of interrupt</span>
<a name="l00941"></a>00941 <span class="comment">    requests to the processing cores. Interrupts generated by the POW,</span>
<a name="l00942"></a>00942 <span class="comment">    UART, and other units may be routed to any of the available</span>
<a name="l00943"></a>00943 <span class="comment">    cores. Once interrupt signals are routed to a core, use</span>
<a name="l00944"></a>00944 <span class="comment">    cvmx-interrupt to register a handler. More information about</span>
<a name="l00945"></a>00945 <span class="comment">    interrupt processing can be found in the &quot;Exception and Interrupt</span>
<a name="l00946"></a>00946 <span class="comment">    Handling&quot; section.</span>
<a name="l00947"></a>00947 <span class="comment"></span>
<a name="l00948"></a>00948 <span class="comment">@subsection hal_key 4.15 Key Memory (KEY) (cvmx-key.h)</span>
<a name="l00949"></a>00949 <span class="comment"></span>
<a name="l00950"></a>00950 <span class="comment">    Key memory is 8k on chip that is inaccessible from off chip. It can also be</span>
<a name="l00951"></a>00951 <span class="comment">    cleared using an external hardware pin.</span>
<a name="l00952"></a>00952 <span class="comment"></span>
<a name="l00953"></a>00953 <span class="comment">    - cvmx_key_read()</span>
<a name="l00954"></a>00954 <span class="comment">    - cvmx_key_write()</span>
<a name="l00955"></a>00955 <span class="comment"></span>
<a name="l00956"></a>00956 <span class="comment">@subsection hal_rng 4.16 Random Number Generator (RNG)</span>
<a name="l00957"></a>00957 <span class="comment"></span>
<a name="l00958"></a>00958 <span class="comment">    - cvmx_rng_enable()</span>
<a name="l00959"></a>00959 <span class="comment">    - cvmx_rng_get_random8()</span>
<a name="l00960"></a>00960 <span class="comment">    - cvmx_rng_get_random16()</span>
<a name="l00961"></a>00961 <span class="comment">    - cvmx_rng_get_random32()</span>
<a name="l00962"></a>00962 <span class="comment">    - cvmx_rng_get_random64()</span>
<a name="l00963"></a>00963 <span class="comment">    - cvmx_rng_request_random_async()</span>
<a name="l00964"></a>00964 <span class="comment"></span>
<a name="l00965"></a>00965 <span class="comment"></span>
<a name="l00966"></a>00966 <span class="comment">@subsection hal_tra 4.17 Performance Trace Buffer (TRA)</span>
<a name="l00967"></a>00967 <span class="comment"></span>
<a name="l00968"></a>00968 <span class="comment">    The performance trace buffer allows applications to collect detailed</span>
<a name="l00969"></a>00969 <span class="comment">    performance data of OCTEON during code execution.</span>
<a name="l00970"></a>00970 <span class="comment"></span>
<a name="l00971"></a>00971 <span class="comment">    Writing the trace buffer:</span>
<a name="l00972"></a>00972 <span class="comment"></span>
<a name="l00973"></a>00973 <span class="comment">    When the trace is enabled, commands are traced continuously (wrapping) or</span>
<a name="l00974"></a>00974 <span class="comment">    until the buffer is filled once (no wrapping).  Additionally and</span>
<a name="l00975"></a>00975 <span class="comment">    independent of wrapping, tracing can be temporarily enabled and disabled</span>
<a name="l00976"></a>00976 <span class="comment">    by the tracing triggers.  All XMC commands can be traced except for IDLE</span>
<a name="l00977"></a>00977 <span class="comment">    and IOBRSP.  The subset of XMC commands that are traced is determined by</span>
<a name="l00978"></a>00978 <span class="comment">    the filter and the two triggers, each of which is comprised of masks for</span>
<a name="l00979"></a>00979 <span class="comment">    command, sid, did, and address).  If triggers are disabled, then only</span>
<a name="l00980"></a>00980 <span class="comment">    those commands matching the filter are traced.  If triggers are enabled,</span>
<a name="l00981"></a>00981 <span class="comment">    then only those commands matching the filter, the start trigger, or the</span>
<a name="l00982"></a>00982 <span class="comment">    stop trigger are traced during the time between a start trigger and a stop</span>
<a name="l00983"></a>00983 <span class="comment">    trigger.</span>
<a name="l00984"></a>00984 <span class="comment"></span>
<a name="l00985"></a>00985 <span class="comment">    For a given command, its XMC data is written immediately to the buffer.</span>
<a name="l00986"></a>00986 <span class="comment">    If the command has XMD data, then that data comes in-order at some later</span>
<a name="l00987"></a>00987 <span class="comment">    time.  The XMD data is accumulated across all valid XMD cycles and written</span>
<a name="l00988"></a>00988 <span class="comment">    to the buffer or to a shallow fifo.  Data from the fifo is written to the</span>
<a name="l00989"></a>00989 <span class="comment">    buffer as soon as it gets access to write the buffer (i.e.  the buffer is</span>
<a name="l00990"></a>00990 <span class="comment">    not currently being written with XMC data).  If the fifo overflows, it</span>
<a name="l00991"></a>00991 <span class="comment">    simply overwrites itself and the previous XMD data is lost.</span>
<a name="l00992"></a>00992 <span class="comment"></span>
<a name="l00993"></a>00993 <span class="comment">    Reading the trace buffer:</span>
<a name="l00994"></a>00994 <span class="comment"></span>
<a name="l00995"></a>00995 <span class="comment">    Each entry of the trace buffer is read by a CSR read command.  The trace</span>
<a name="l00996"></a>00996 <span class="comment">    buffer services each read in order, as soon as it has access to the</span>
<a name="l00997"></a>00997 <span class="comment">    (single-ported) trace buffer.</span>
<a name="l00998"></a>00998 <span class="comment"></span>
<a name="l00999"></a>00999 <span class="comment">    Overflow, underflow and threshold events:</span>
<a name="l01000"></a>01000 <span class="comment"></span>
<a name="l01001"></a>01001 <span class="comment">    The trace buffer maintains a write pointer and a read pointer and detects</span>
<a name="l01002"></a>01002 <span class="comment">    both the overflow and underflow conditions.  Each time a new trace is</span>
<a name="l01003"></a>01003 <span class="comment">    enabled, both pointers are reset to entry 0.  Normally, each write (traced</span>
<a name="l01004"></a>01004 <span class="comment">    event) increments the write pointer and each read increments the read</span>
<a name="l01005"></a>01005 <span class="comment">    pointer.  During the overflow condition, writing (tracing) is disabled.</span>
<a name="l01006"></a>01006 <span class="comment">    Tracing will continue as soon as the overflow condition is resolved.  The</span>
<a name="l01007"></a>01007 <span class="comment">    first entry that is written immediately following the overflow condition</span>
<a name="l01008"></a>01008 <span class="comment">    may be marked to indicate that a tracing discontinuity has occurred before</span>
<a name="l01009"></a>01009 <span class="comment">    this entry.  During the underflow condition, reading does not increment</span>
<a name="l01010"></a>01010 <span class="comment">    the read pointer and the read data is marked to indicate that no read data</span>
<a name="l01011"></a>01011 <span class="comment">    is available.</span>
<a name="l01012"></a>01012 <span class="comment"></span>
<a name="l01013"></a>01013 <span class="comment">    The full threshold events are defined to signal an interrupt a certain</span>
<a name="l01014"></a>01014 <span class="comment">    levels of &quot;fullness&quot; (1/2, 3/4, 4/4).  &quot;fullness&quot; is defined as the</span>
<a name="l01015"></a>01015 <span class="comment">    relative distance between the write and read pointers (i.e.  not defined</span>
<a name="l01016"></a>01016 <span class="comment">    as the absolute distance between the write pointer and entry 0).  When</span>
<a name="l01017"></a>01017 <span class="comment">    enabled, the full threshold event occurs every time the desired level of</span>
<a name="l01018"></a>01018 <span class="comment">    &quot;fullness&quot; is achieved.</span>
<a name="l01019"></a>01019 <span class="comment"></span>
<a name="l01020"></a>01020 <span class="comment">    The data structures required to access the trace buffer are documented</span>
<a name="l01021"></a>01021 <span class="comment">    in &quot;cvmx-tra.h&quot;.</span>
<a name="l01022"></a>01022 <span class="comment"></span>
<a name="l01023"></a>01023 <span class="comment"></span>
<a name="l01024"></a>01024 <span class="comment">@subsection hal_zip 4.18 ZIP (deflate) compression/decompression block (cvmx-zip.h)</span>
<a name="l01025"></a>01025 <span class="comment"></span>
<a name="l01026"></a>01026 <span class="comment">  This block provides a hardware implementation of the deflate compression</span>
<a name="l01027"></a>01027 <span class="comment">  algorithm.  The cvmx-zip.h header file provides structure defintions for</span>
<a name="l01028"></a>01028 <span class="comment">  zip block hardware structures and configuration registers.</span>
<a name="l01029"></a>01029 <span class="comment">  The zip block uses a chunked input queue for instructions that control</span>
<a name="l01030"></a>01030 <span class="comment">  the compression/decompression operations that it performs. Once</span>
<a name="l01031"></a>01031 <span class="comment">  all instructions from a chunk are processed, the zip block frees the chunk to</span>
<a name="l01032"></a>01032 <span class="comment">  configured free pool (much like the PKO unit does.)  Each instruction specifies</span>
<a name="l01033"></a>01033 <span class="comment">  one compression or decompression operation that can operate on a gather list for</span>
<a name="l01034"></a>01034 <span class="comment">  input data and a scatter list for output data.  On completion of an instruction, the</span>
<a name="l01035"></a>01035 <span class="comment">  zip block updates the result structure specified in the instruction.</span>
<a name="l01036"></a>01036 <span class="comment"></span>
<a name="l01037"></a>01037 <span class="comment">@subsection hal_l2c 4.19 Level 2 Cache  (cvmx-l2c.h)</span>
<a name="l01038"></a>01038 <span class="comment"></span>
<a name="l01039"></a>01039 <span class="comment">  The level 2 cache controller supports locking and partitioning of the</span>
<a name="l01040"></a>01040 <span class="comment">  cache. Functions are provided to partition, lock, and unlock portions</span>
<a name="l01041"></a>01041 <span class="comment">  of the L2 cache.  Please refer to the HRM for details on cache locking</span>
<a name="l01042"></a>01042 <span class="comment">  and partitioning. The L2 controller also offers 4 performance counters</span>
<a name="l01043"></a>01043 <span class="comment">  that can count a wide variety of events.</span>
<a name="l01044"></a>01044 <span class="comment"></span>
<a name="l01045"></a>01045 <span class="comment">  - cvmx_l2c_config_perf()</span>
<a name="l01046"></a>01046 <span class="comment">  - cvmx_l2c_read_perf()</span>
<a name="l01047"></a>01047 <span class="comment">  - cvmx_l2c_get_core_way_partition()</span>
<a name="l01048"></a>01048 <span class="comment">  - cvmx_l2c_set_core_way_partition()</span>
<a name="l01049"></a>01049 <span class="comment">  - cvmx_l2c_get_hw_way_partition()</span>
<a name="l01050"></a>01050 <span class="comment">  - cvmx_l2c_set_hw_way_partition()</span>
<a name="l01051"></a>01051 <span class="comment">  - cvmx_l2c_lock_line()</span>
<a name="l01052"></a>01052 <span class="comment">  - cvmx_l2c_lock_mem_region()</span>
<a name="l01053"></a>01053 <span class="comment">  - cvmx_l2c_unlock_line()</span>
<a name="l01054"></a>01054 <span class="comment">  - cvmx_l2c_unlock_mem_region()</span>
<a name="l01055"></a>01055 <span class="comment">  - cvmx_l2c_flush()</span>
<a name="l01056"></a>01056 <span class="comment">  - cvmx_l2c_vrt_set_max_virtids()</span>
<a name="l01057"></a>01057 <span class="comment">  - cvmx_l2c_vrt_get_max_virtids()</span>
<a name="l01058"></a>01058 <span class="comment">  - cvmx_l2c_vrt_set_max_memsz()</span>
<a name="l01059"></a>01059 <span class="comment">  - cvmx_l2c_vrt_assign_virtid()</span>
<a name="l01060"></a>01060 <span class="comment">  - cvmx_l2c_vrt_remove_virtid()</span>
<a name="l01061"></a>01061 <span class="comment">  - cvmx_l2c_vrt_memprotect()</span>
<a name="l01062"></a>01062 <span class="comment">  - cvmx_l2c_vrt_enable()</span>
<a name="l01063"></a>01063 <span class="comment">  - cvmx_l2c_vrt_disable()</span>
<a name="l01064"></a>01064 <span class="comment"></span>
<a name="l01065"></a>01065 <span class="comment">@subsection hal_pth 4.20 Power Throttle (cvmx-power-throttle.h)</span>
<a name="l01066"></a>01066 <span class="comment"></span>
<a name="l01067"></a>01067 <span class="comment">  The Power Throttle feature is introduced in OCTEON II. It allows</span>
<a name="l01068"></a>01068 <span class="comment">  per-core power consumption tuning. The APIs set the power</span>
<a name="l01069"></a>01069 <span class="comment">  consumption limit to a percentage of the maximum allowed.</span>
<a name="l01070"></a>01070 <span class="comment"></span>
<a name="l01071"></a>01071 <span class="comment">  - cvmx_power_throttle_self()</span>
<a name="l01072"></a>01072 <span class="comment">  - cvmx_power_throttle()</span>
<a name="l01073"></a>01073 <span class="comment"></span>
<a name="l01074"></a>01074 <span class="comment">@section memory 5 Memory Management</span>
<a name="l01075"></a>01075 <span class="comment"></span>
<a name="l01076"></a>01076 <span class="comment"></span>
<a name="l01077"></a>01077 <span class="comment"></span>
<a name="l01078"></a>01078 <span class="comment">    @subsection memory_local 5.1 Core-local malloc()</span>
<a name="l01079"></a>01079 <span class="comment"></span>
<a name="l01080"></a>01080 <span class="comment">    The malloc() and free() functions provided by the C library manage a heap</span>
<a name="l01081"></a>01081 <span class="comment">    that is private for each core.  This memory is not shared with other cores,</span>
<a name="l01082"></a>01082 <span class="comment">    and other cores do not have a TLB mapping to access this memory.</span>
<a name="l01083"></a>01083 <span class="comment"></span>
<a name="l01084"></a>01084 <span class="comment"></span>
<a name="l01085"></a>01085 <span class="comment">    @subsection memory_arena 5.2 Arena-based shared malloc() (cvmx-malloc.h)</span>
<a name="l01086"></a>01086 <span class="comment"></span>
<a name="l01087"></a>01087 <span class="comment"></span>
<a name="l01088"></a>01088 <span class="comment">   The Executive provides an arena based shared memory allocator for applications</span>
<a name="l01089"></a>01089 <span class="comment">   that need to dynamically allocate variable sized shared memory regions.  Multiple arenas can</span>
<a name="l01090"></a>01090 <span class="comment">   be added to the list and can be used to avoid contention since cores can operate on different</span>
<a name="l01091"></a>01091 <span class="comment">   arenas independently.  Any core can allocate from or free to any arena.</span>
<a name="l01092"></a>01092 <span class="comment"></span>
<a name="l01093"></a>01093 <span class="comment"></span>
<a name="l01094"></a>01094 <span class="comment">        - cvmx_add_arena()</span>
<a name="l01095"></a>01095 <span class="comment">        - cvmx_malloc()</span>
<a name="l01096"></a>01096 <span class="comment">        - cvmx_calloc()</span>
<a name="l01097"></a>01097 <span class="comment">        - cvmx_realloc()</span>
<a name="l01098"></a>01098 <span class="comment">        - cvmx_memalign()</span>
<a name="l01099"></a>01099 <span class="comment">        - cvmx_free()</span>
<a name="l01100"></a>01100 <span class="comment"></span>
<a name="l01101"></a>01101 <span class="comment"></span>
<a name="l01102"></a>01102 <span class="comment">    @subsection memory_zone 5.3 Zone allocator (cvmx-malloc.h)</span>
<a name="l01103"></a>01103 <span class="comment"></span>
<a name="l01104"></a>01104 <span class="comment">        - cvmx_zone_alloc()</span>
<a name="l01105"></a>01105 <span class="comment">        - cvmx_zone_create_from_addr()</span>
<a name="l01106"></a>01106 <span class="comment">        - cvmx_zone_create_from_arena()</span>
<a name="l01107"></a>01107 <span class="comment">        - cvmx_zone_free()</span>
<a name="l01108"></a>01108 <span class="comment">        - cvmx_zone_name()</span>
<a name="l01109"></a>01109 <span class="comment">        - cvmx_zone_size()</span>
<a name="l01110"></a>01110 <span class="comment"></span>
<a name="l01111"></a>01111 <span class="comment">    @subsection memory_fpa 5.4 Hardware (FPA) allocator (cvmx-fpa.h)</span>
<a name="l01112"></a>01112 <span class="comment"></span>
<a name="l01113"></a>01113 <span class="comment">   The hardware free page allocator can also be used for software memory allocation and deallocation.</span>
<a name="l01114"></a>01114 <span class="comment">   Each pool must be initialized before use.  Pools can be shared between hardware and software.</span>
<a name="l01115"></a>01115 <span class="comment"></span>
<a name="l01116"></a>01116 <span class="comment">      -  cvmx_fpa_get_block_size()</span>
<a name="l01117"></a>01117 <span class="comment">      -  cvmx_fpa_enable()</span>
<a name="l01118"></a>01118 <span class="comment">      -  cvmx_fpa_alloc()</span>
<a name="l01119"></a>01119 <span class="comment">      -  cvmx_fpa_async_alloc()</span>
<a name="l01120"></a>01120 <span class="comment">      -  cvmx_fpa_async_alloc_finish()</span>
<a name="l01121"></a>01121 <span class="comment">      -  cvmx_fpa_free()</span>
<a name="l01122"></a>01122 <span class="comment">      -  cvmx_fpa_setup_pool()</span>
<a name="l01123"></a>01123 <span class="comment">      -  cvmx_fpa_shutdown_pool()</span>
<a name="l01124"></a>01124 <span class="comment"></span>
<a name="l01125"></a>01125 <span class="comment">    @subsection memory_boot 5.5 Physical memory allocator (cvmx-bootmem.h)</span>
<a name="l01126"></a>01126 <span class="comment"></span>
<a name="l01127"></a>01127 <span class="comment">    This allocator is provided to allow applications to allocate</span>
<a name="l01128"></a>01128 <span class="comment">    blocks of free physical memory after boot.  The free memory list is created</span>
<a name="l01129"></a>01129 <span class="comment">    by the bootloader, and is passed to the application(s).  Locking is provided</span>
<a name="l01130"></a>01130 <span class="comment">    to allow for multiple cores to allocate from the free memory pool.  This is an</span>
<a name="l01131"></a>01131 <span class="comment">    allocate only allocator, which allows for a zero overhead implementation (it is possible</span>
<a name="l01132"></a>01132 <span class="comment">    to allocate all of the free memory.)</span>
<a name="l01133"></a>01133 <span class="comment">    Allocated blocks can also be assigned names for sharing between applications and</span>
<a name="l01134"></a>01134 <span class="comment">    between the bootloader and applications.  Named allocations can be freed, as the</span>
<a name="l01135"></a>01135 <span class="comment">    named block descriptor keeps track of the size of the allocation to allow this.</span>
<a name="l01136"></a>01136 <span class="comment">    Bootmem block names starting with &apos;__&apos; are reserved for internal use and should not</span>
<a name="l01137"></a>01137 <span class="comment">    be used by applications.</span>
<a name="l01138"></a>01138 <span class="comment"></span>
<a name="l01139"></a>01139 <span class="comment">    - cvmx_bootmem_alloc()</span>
<a name="l01140"></a>01140 <span class="comment">    - cvmx_bootmem_alloc_address()</span>
<a name="l01141"></a>01141 <span class="comment">    - cvmx_bootmem_alloc_named()</span>
<a name="l01142"></a>01142 <span class="comment">    - cvmx_bootmem_alloc_named_address()</span>
<a name="l01143"></a>01143 <span class="comment">    - cvmx_bootmem_free_named()</span>
<a name="l01144"></a>01144 <span class="comment">    - cvmx_bootmem_free_named()</span>
<a name="l01145"></a>01145 <span class="comment"></span>
<a name="l01146"></a>01146 <span class="comment"></span>
<a name="l01147"></a>01147 <span class="comment"></span>
<a name="l01148"></a>01148 <span class="comment">@section synchronization 6 Synchronization</span>
<a name="l01149"></a>01149 <span class="comment"></span>
<a name="l01150"></a>01150 <span class="comment"></span>
<a name="l01151"></a>01151 <span class="comment">    @subsection synchronization_spinlocks 6.1 Basic Spinlocks (cvmx-spinlock.h)</span>
<a name="l01152"></a>01152 <span class="comment"></span>
<a name="l01153"></a>01153 <span class="comment">        - cvmx_spinlock_init()</span>
<a name="l01154"></a>01154 <span class="comment">        - cvmx_spinlock_locked()</span>
<a name="l01155"></a>01155 <span class="comment">        - cvmx_spinlock_unlock()</span>
<a name="l01156"></a>01156 <span class="comment">        - cvmx_spinlock_trylock()</span>
<a name="l01157"></a>01157 <span class="comment">        - cvmx_spinlock_lock()</span>
<a name="l01158"></a>01158 <span class="comment"></span>
<a name="l01159"></a>01159 <span class="comment">    @subsection synchronization_recursive 6.2 Recursive Spinlocks (cvmx-spinlock.h)</span>
<a name="l01160"></a>01160 <span class="comment"></span>
<a name="l01161"></a>01161 <span class="comment">        - cvmx_spinlock_rec_init()</span>
<a name="l01162"></a>01162 <span class="comment">        - cvmx_spinlock_rec_locked()</span>
<a name="l01163"></a>01163 <span class="comment">        - cvmx_spinlock_rec_unlock()</span>
<a name="l01164"></a>01164 <span class="comment">        - cvmx_spinlock_rec_lock()</span>
<a name="l01165"></a>01165 <span class="comment"></span>
<a name="l01166"></a>01166 <span class="comment">    @subsection synchronization_atomic 6.3 Atomic operations (cvmx-atomic.h)</span>
<a name="l01167"></a>01167 <span class="comment"></span>
<a name="l01168"></a>01168 <span class="comment">        - cvmx_atomic_set32()</span>
<a name="l01169"></a>01169 <span class="comment">        - cvmx_atomic_add32()</span>
<a name="l01170"></a>01170 <span class="comment">        - cvmx_atomic_set64()</span>
<a name="l01171"></a>01171 <span class="comment">        - cvmx_atomic_add64()</span>
<a name="l01172"></a>01172 <span class="comment">        - cvmx_atomic_compare_and_store32()</span>
<a name="l01173"></a>01173 <span class="comment">        - cvmx_atomic_compare_and_store64()</span>
<a name="l01174"></a>01174 <span class="comment"></span>
<a name="l01175"></a>01175 <span class="comment">    @subsection synchronization_rw_locks 6.4 Reader/writer locks (cvmx-rwlock.h)</span>
<a name="l01176"></a>01176 <span class="comment">   Provides reader/writer locks with writer preference.  Multiple cores may</span>
<a name="l01177"></a>01177 <span class="comment">   hold read locks, while write locks are exclusive.  Writers have preference,</span>
<a name="l01178"></a>01178 <span class="comment">   so writers can starve readers.</span>
<a name="l01179"></a>01179 <span class="comment"></span>
<a name="l01180"></a>01180 <span class="comment">        - cvmx_rwlock_wp_init()</span>
<a name="l01181"></a>01181 <span class="comment">        - cvmx_rwlock_wp_read_lock()</span>
<a name="l01182"></a>01182 <span class="comment">        - cvmx_rwlock_wp_read_unlock()</span>
<a name="l01183"></a>01183 <span class="comment">        - cvmx_rwlock_wp_write_lock()</span>
<a name="l01184"></a>01184 <span class="comment">        - cvmx_rwlock_wp_write_unlock()</span>
<a name="l01185"></a>01185 <span class="comment"></span>
<a name="l01186"></a>01186 <span class="comment">    @subsection synchronization_coremask 6.5 Coremask (cvmx-coremask.h)</span>
<a name="l01187"></a>01187 <span class="comment"></span>
<a name="l01188"></a>01188 <span class="comment">    &quot;cvmx-coremask.h&quot; provides syncronization and membership operations on</span>
<a name="l01189"></a>01189 <span class="comment">    &apos;coremask&apos; values.  A coremask is an integer that has a bit set for</span>
<a name="l01190"></a>01190 <span class="comment">    each core that is a member of the mask.  The coremask 0xffff contains</span>
<a name="l01191"></a>01191 <span class="comment">    all 16 cores, while the coremask 0x0 contains none.</span>
<a name="l01192"></a>01192 <span class="comment"></span>
<a name="l01193"></a>01193 <span class="comment">    - cvmx_is_init_core()</span>
<a name="l01194"></a>01194 <span class="comment">    - cvmx_coremask_barrier_sync()</span>
<a name="l01195"></a>01195 <span class="comment">    - cvmx_coremask_str2bmp()</span>
<a name="l01196"></a>01196 <span class="comment">    - cvmx_coremask_bmp2str()</span>
<a name="l01197"></a>01197 <span class="comment"></span>
<a name="l01198"></a>01198 <span class="comment">@section interrupts 7 Exceptions and Interrupt Handling</span>
<a name="l01199"></a>01199 <span class="comment"></span>
<a name="l01200"></a>01200 <span class="comment">    Exceptions and interrupts are handled by cvmx-interrupt. As part of</span>
<a name="l01201"></a>01201 <span class="comment">    application initialization before main(), cvmx_interrupt_initialize()</span>
<a name="l01202"></a>01202 <span class="comment">    installs a trap handler at each of the possible Mips entry points</span>
<a name="l01203"></a>01203 <span class="comment">    (0x80, 0x100, 0x180, and 0x200). The low level assembly handlers are</span>
<a name="l01204"></a>01204 <span class="comment">    located in cvmx-interrupt-handler.S. Upon an exception or interrupt,</span>
<a name="l01205"></a>01205 <span class="comment">    the following sequence is followed:</span>
<a name="l01206"></a>01206 <span class="comment"></span>
<a name="l01207"></a>01207 <span class="comment">    -# The Mips core jumps to the appropriate entry point for the trap</span>
<a name="l01208"></a>01208 <span class="comment">        (0x80, 0x100, 0x180, or 0x200).</span>
<a name="l01209"></a>01209 <span class="comment">    -# cvmx_interrupt_stage1, which was installed by</span>
<a name="l01210"></a>01210 <span class="comment">        cvmx_interrupt_initialize() at the trap location, Loads the address of</span>
<a name="l01211"></a>01211 <span class="comment">        cvmx_interrupt_stage2 into register @b k0 and jumps to it. @b k0 will</span>
<a name="l01212"></a>01212 <span class="comment">        be corrupted when a trap occurs.</span>
<a name="l01213"></a>01213 <span class="comment">    -# cvmx_interrupt_stage2 saves all of the general purpose registers to the</span>
<a name="l01214"></a>01214 <span class="comment">        application stack frame.</span>
<a name="l01215"></a>01215 <span class="comment">    -# cvmx_interrupt_do_irq() is called with a parameter pointing to an array</span>
<a name="l01216"></a>01216 <span class="comment">        of all 32 registers. This is the first C function called.</span>
<a name="l01217"></a>01217 <span class="comment"></span>
<a name="l01218"></a>01218 <span class="comment">    From this point on cvmx_interrupt_do_irq() performs processing based on</span>
<a name="l01219"></a>01219 <span class="comment">    the type of event that occurred.</span>
<a name="l01220"></a>01220 <span class="comment"></span>
<a name="l01221"></a>01221 <span class="comment">    @subsection interrupt_interrupt 7.1 Interrupt Handling</span>
<a name="l01222"></a>01222 <span class="comment"></span>
<a name="l01223"></a>01223 <span class="comment">        If the cause of the trap event is determined to not be an exception</span>
<a name="l01224"></a>01224 <span class="comment">        (COP0 status register exception bits are zero), the interrupt status</span>
<a name="l01225"></a>01225 <span class="comment">        bits are iterated through looking for interrupts. The interrupts are</span>
<a name="l01226"></a>01226 <span class="comment">        sequentially searched from 0 to 7. The first bit set causes the</span>
<a name="l01227"></a>01227 <span class="comment">        interrupt handler for that interrupt to be called. Interrupt handlers</span>
<a name="l01228"></a>01228 <span class="comment">        are registered using cvmx_interrupt_register(). The default interrupt</span>
<a name="l01229"></a>01229 <span class="comment">        handler cvmx_interrupt_default() simply displays a message and the</span>
<a name="l01230"></a>01230 <span class="comment">        contents of all registers. The exception to this is interrupt lines</span>
<a name="l01231"></a>01231 <span class="comment">        2 and 3. The handler for these lines (cvmx_interrupt_ciu()) decodes</span>
<a name="l01232"></a>01232 <span class="comment">        the CIU interrupt status lines.</span>
<a name="l01233"></a>01233 <span class="comment"></span>
<a name="l01234"></a>01234 <span class="comment">        cvmx_interrupt_ciu() decodes the CIU status lines into interrupts</span>
<a name="l01235"></a>01235 <span class="comment">        8-71 for line 2 and 72-135 for line 3.</span>
<a name="l01236"></a>01236 <span class="comment"></span>
<a name="l01237"></a>01237 <span class="comment">        The following functions can be used to control interrupts:</span>
<a name="l01238"></a>01238 <span class="comment"></span>
<a name="l01239"></a>01239 <span class="comment">        - cvmx_interrupt_register()</span>
<a name="l01240"></a>01240 <span class="comment">        - cvmx_interrupt_map()</span>
<a name="l01241"></a>01241 <span class="comment"></span>
<a name="l01242"></a>01242 <span class="comment">        As part of initialization, cvmx-interrupt registers handlers for ECC</span>
<a name="l01243"></a>01243 <span class="comment">        errors from DRAM and the L2 controller.</span>
<a name="l01244"></a>01244 <span class="comment"></span>
<a name="l01245"></a>01245 <span class="comment">    @subsection interrupt_timer 7.2 Timer Interrupts</span>
<a name="l01246"></a>01246 <span class="comment"></span>
<a name="l01247"></a>01247 <span class="comment">        The simple executive does not configure any timers or watchdogs by</span>
<a name="l01248"></a>01248 <span class="comment">        default. Applications wishing to use these features need to register</span>
<a name="l01249"></a>01249 <span class="comment">        an appropriate interrupt handler, then configure the OCTEON hardware to</span>
<a name="l01250"></a>01250 <span class="comment">        deliver the specified timer / watchdog. Some of the possible interrupt</span>
<a name="l01251"></a>01251 <span class="comment">        sources are:</span>
<a name="l01252"></a>01252 <span class="comment"></span>
<a name="l01253"></a>01253 <span class="comment">        -# Mips count and compare registers (interrupt 7)</span>
<a name="l01254"></a>01254 <span class="comment">        -# CIU watchdog timers (interrupt 52)</span>
<a name="l01255"></a>01255 <span class="comment">        -# CIU timers (interrupt 60-63)</span>
<a name="l01256"></a>01256 <span class="comment"></span>
<a name="l01257"></a>01257 <span class="comment">    @subsection interrupt_exception 7.3 Exception Handling</span>
<a name="l01258"></a>01258 <span class="comment"></span>
<a name="l01259"></a>01259 <span class="comment">        If the cause of the trap event is determined to be an exception (COP0</span>
<a name="l01260"></a>01260 <span class="comment">        status register exception bits are set), cvmx_interrupt_do_irq() calls</span>
<a name="l01261"></a>01261 <span class="comment">        the exception handler cvmx_interrupt_default_exception_handler().</span>
<a name="l01262"></a>01262 <span class="comment">        This handler prints the cause of the exception, the current register</span>
<a name="l01263"></a>01263 <span class="comment">        state and the backtrace of current function calls. This will be</span>
<a name="l01264"></a>01264 <span class="comment">        incomplete if the application was not compiled with</span>
<a name="l01265"></a>01265 <span class="comment">        -fasynchronous-unwind-tables (see @ref backtrace). It then halts the</span>
<a name="l01266"></a>01266 <span class="comment">        core that had the exception. The default exception handler can be</span>
<a name="l01267"></a>01267 <span class="comment">        replaced using cvmx_interrupt_set_exception(). See the Mips 64v2</span>
<a name="l01268"></a>01268 <span class="comment">        specification for more details about exception processing.</span>
<a name="l01269"></a>01269 <span class="comment"></span>
<a name="l01270"></a>01270 <span class="comment">@section hotplug 8 Simple Executive Hotplug </span>
<a name="l01271"></a>01271 <span class="comment"></span>
<a name="l01272"></a>01272 <span class="comment">         The hotplug APIs allow an application to register itself for  </span>
<a name="l01273"></a>01273 <span class="comment">         hotplug. The application needs to register a callback routine, which </span>
<a name="l01274"></a>01274 <span class="comment">         will be invoked when the application is requested to shutdown. </span>
<a name="l01275"></a>01275 <span class="comment"></span>
<a name="l01276"></a>01276 <span class="comment">         Refer to the SDK example program hotplug-app for an illustration </span>
<a name="l01277"></a>01277 <span class="comment">         of how to use these APIs. Please note that these APIs only take care</span>
<a name="l01278"></a>01278 <span class="comment">         of cleaning up the execution image of the application. All application</span>
<a name="l01279"></a>01279 <span class="comment">         specific cleanup, including hardare state, needs to be done by the </span>
<a name="l01280"></a>01280 <span class="comment">         application&apos;s own callback routine. </span>
<a name="l01281"></a>01281 <span class="comment"></span>
<a name="l01282"></a>01282 <span class="comment">         - cvmx_app_hotplug_register()</span>
<a name="l01283"></a>01283 <span class="comment">         - cvmx_app_hotplug_activate()</span>
<a name="l01284"></a>01284 <span class="comment">         - cvmx_app_hotplug_shutdown_complete()</span>
<a name="l01285"></a>01285 <span class="comment">         - cvmx_app_hotplug_shutdown_disable()</span>
<a name="l01286"></a>01286 <span class="comment">         - cvmx_app_hotplug_shutdown_enable()</span>
<a name="l01287"></a>01287 <span class="comment">         - cvmx_app_hotplug_shutdown_request()</span>
<a name="l01288"></a>01288 <span class="comment">    </span>
<a name="l01289"></a>01289 <span class="comment"></span>
<a name="l01290"></a>01290 <span class="comment">    @section models 9 Supporting multiple OCTEON models</span>
<a name="l01291"></a>01291 <span class="comment"></span>
<a name="l01292"></a>01292 <span class="comment">    (Runtime model checking is the preferred method of model checking.)</span>
<a name="l01293"></a>01293 <span class="comment">    Code can be written to easily support multiple OCTEON models</span>
<a name="l01294"></a>01294 <span class="comment">    using the OCTEON_IS_MODEL() macro/function.  Both runtime and compile</span>
<a name="l01295"></a>01295 <span class="comment">        time checking are supported.  The runtime model checking is enabled by</span>
<a name="l01296"></a>01296 <span class="comment">    default, same as passing --runtime argument to the env-setup script.</span>
<a name="l01297"></a>01297 <span class="comment">    Pass --noruntime-model to compile for a particular model to env-setup</span>
<a name="l01298"></a>01298 <span class="comment">    script.  The argument to OCTEON_IS_MODEL() is one of the OCTEON model</span>
<a name="l01299"></a>01299 <span class="comment">    defines in octeon-model.h, and OCTEON_IS_MODEL() returns true if</span>
<a name="l01300"></a>01300 <span class="comment">    the model that the code is running on matches the argument.  If</span>
<a name="l01301"></a>01301 <span class="comment">    no revision checking is required, then the argument should not</span>
<a name="l01302"></a>01302 <span class="comment">    include a revision - OCTEON_IS_MODEL(OCTEON_CN38XX) will return</span>
<a name="l01303"></a>01303 <span class="comment">    true for all revisions of OCTEON_CN38XX chips.</span>
<a name="l01304"></a>01304 <span class="comment">    OCTEON_IS_MODEL(OCTEON_CN3020_PASS1_1) will only match pass 1.1</span>
<a name="l01305"></a>01305 <span class="comment">    CN3020 chips.  Please note that some &apos;family&apos; defines</span>
<a name="l01306"></a>01306 <span class="comment">    (OCTEON_CN31XX, OCTEON_CN30XX, etc.) may include or exclude some</span>
<a name="l01307"></a>01307 <span class="comment">    specific models that seem like they should match.</span>
<a name="l01308"></a>01308 <span class="comment">    Please refer to octeon-model.h for a more detailed description.</span>
<a name="l01309"></a>01309 <span class="comment"></span>
<a name="l01310"></a>01310 <span class="comment">    In order to use compile time checking and OCTEON_IS_MODEL(), the</span>
<a name="l01311"></a>01311 <span class="comment">    OCTEON_IS_COMMON_BINARY() macro must be checked first.  The</span>
<a name="l01312"></a>01312 <span class="comment">    OCTEON_IS_COMMON_BINARY() macro will be defined to 1 when runtime checking</span>
<a name="l01313"></a>01313 <span class="comment">    is used, and 0 when compile time is used.  Since OCTEON_IS_MODEL()</span>
<a name="l01314"></a>01314 <span class="comment">    is a function when runtime checking is used, it cannot be used</span>
<a name="l01315"></a>01315 <span class="comment">    in a preprocessor directive (\#if.) when runtime checking is</span>
<a name="l01316"></a>01316 <span class="comment">    enabled.  To use OCTEON_IS_MODEL() in a preprocessor directive,</span>
<a name="l01317"></a>01317 <span class="comment">    it must be protected by a check of OCTEON_IS_COMMON_BINARY().</span>
<a name="l01318"></a>01318 <span class="comment"></span>
<a name="l01319"></a>01319 <span class="comment">@verbatim</span>
<a name="l01320"></a>01320 <span class="comment"></span>
<a name="l01321"></a>01321 <span class="comment">    #if !OCTEON_IS_COMMON_BINARY()</span>
<a name="l01322"></a>01322 <span class="comment">    #if OCTEON_MATCH_MODEL(OCTEON_CN38XX)</span>
<a name="l01323"></a>01323 <span class="comment">        /* Do OCTEON model specific compile time stuff here... */</span>
<a name="l01324"></a>01324 <span class="preprocessor">    #endif</span>
<a name="l01325"></a>01325 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
<a name="l01326"></a>01326 <span class="preprocessor"></span>
<a name="l01327"></a>01327 <span class="keyword">@end</span>verbatim
<a name="l01328"></a>01328 
<a name="l01329"></a>01329     Most of the time <span class="keyword">this</span> is not necessary as the compiler does a good
<a name="l01330"></a>01330     job of eliminating dead code when conditionals are based on
<a name="l01331"></a>01331     <a class="code" href="octeon-model_8h.html#a9234ac9e9f35fafd7fe5eedd37c9b552">OCTEON_IS_MODEL</a>() and compile time checking is used.  If compile
<a name="l01332"></a>01332     time checking is used, the generated program will only run on
<a name="l01333"></a>01333     the model it was compiled for.  Since all checks are compiled out,
<a name="l01334"></a>01334     all code except the startup code which validates the model assumes
<a name="l01335"></a>01335     that it is <a class="code" href="cvmx-usb-ehci_8c.html#a2f45113638a0b749a8a205d2cd7fb42b">running</a> on the model it was compiled for.
<a name="l01336"></a>01336 
<a name="l01337"></a>01337 
<a name="l01338"></a>01338 
<a name="l01339"></a>01339 
<a name="l01340"></a>01340 */
</pre></div></div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Oct 2017 for Octeon Software Development Kit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
