<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Octeon Software Development Kit: cvmx-l2c.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cvmx-l2c.c File Reference</h1>
<p>Implementation of the Level 2 Cache (L2C) control, measurement, and debugging facilities.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="cvmx_8h_source.html">cvmx.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cvmx-bootmem_8h_source.html">cvmx-bootmem.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cvmx-l2c_8h_source.html">cvmx-l2c.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cvmx-spinlock_8h_source.html">cvmx-spinlock.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cvmx-interrupt_8h_source.html">cvmx-interrupt.h</a>&quot;</code><br/>
<div class="dynheader">
Include dependency graph for cvmx-l2c.c:</div>
<div class="dynsection">
<div class="center"><img src="cvmx-l2c_8c__incl.png" border="0" usemap="#cvmx-l2c_8c_map" alt=""/></div>
<map name="cvmx-l2c_8c_map" id="cvmx-l2c_8c">
<area shape="rect" id="node3" href="cvmx_8h.html" title="Main Octeon executive header file (This should be the second header file included..." alt="" coords="966,83,1035,112"/><area shape="rect" id="node107" href="cvmx-bootmem_8h.html" title="Simple allocate only memory allocator." alt="" coords="1059,83,1201,112"/><area shape="rect" id="node109" href="cvmx-l2c_8h.html" title="Interface to the Level 2 Cache (L2C) control, measurement, and debugging facilities..." alt="" coords="1225,83,1321,112"/><area shape="rect" id="node111" href="cvmx-spinlock_8h.html" title="Implementation of spinlocks." alt="" coords="418,83,546,112"/><area shape="rect" id="node114" href="cvmx-interrupt_8h.html" title="Interface to the Mips interrupts." alt="" coords="1345,83,1481,112"/><area shape="rect" id="node5" href="cvmx-platform_8h.html" title="This file is resposible for including all system dependent headers for the cvmx&#45;*..." alt="" coords="537,237,670,267"/><area shape="rect" id="node27" href="cvmx-access_8h.html" title="Function prototypes for accessing memory and CSRs on Octeon." alt="" coords="370,237,493,267"/><area shape="rect" id="node29" href="cvmx-address_8h.html" title="Typedefs and defines for working with Octeon physical addresses." alt="" coords="905,237,1033,267"/><area shape="rect" id="node32" href="cvmx-asm_8h.html" title="This is file defines ASM primitives for the executive." alt="" coords="51,392,155,421"/><area shape="rect" id="node34" href="cvmx-packet_8h.html" title="Packet buffer defines." alt="" coords="870,160,993,189"/><area shape="rect" id="node36" href="cvmx-warn_8h.html" title="Functions for warning users about errors and such." alt="" coords="1017,160,1126,189"/><area shape="rect" id="node38" href="cvmx-sysinfo_8h.html" title="This module provides system/board information obtained by the bootloader." alt="" coords="206,160,329,189"/><area shape="rect" id="node48" href="octeon-model_8h.html" title="File defining different Octeon model IDs and macros to compare them." alt="" coords="1150,160,1278,189"/><area shape="rect" id="node50" href="cvmx-csr_8h.html" title="Configuration and status register (CSR) address and type definitions for Octoen." alt="" coords="699,160,795,189"/><area shape="rect" id="node85" href="cvmx-utils_8h.html" title="Small utility functions and macros to ease programming of Octeon." alt="" coords="242,237,346,267"/><area shape="rect" id="node88" href="cvmx-clock_8h.html" title="Interface to Core, IO and DDR Clock." alt="" coords="1302,160,1411,189"/><area shape="rect" id="node91" href="octeon-feature_8h.html" title="File defining checks for different Octeon features." alt="" coords="1435,160,1574,189"/><area shape="rect" id="node93" href="cvmx-fpa_8h.html" title="Interface to the hardware Free Pool Allocator." alt="" coords="3121,160,3219,189"/><area shape="rect" id="node7" href="cvmx-abi_8h.html" title="This file defines macros for use in determining the current calling ABI." alt="" coords="942,315,1038,344"/><area shape="rect" id="node40" href="cvmx-app-init_8h.html" title="Header file for simple executive application initialization." alt="" coords="39,237,167,267"/><area shape="rect" id="node42" href="cvmx-coremask_8h.html" title="Module to support operations on bitmap of cores." alt="" coords="33,315,174,344"/><area shape="rect" id="node53" href="cvmx-csr-enums_8h.html" title="Definitions for enumerations used with Octeon CSRs." alt="" coords="694,237,841,267"/><area shape="rect" id="node55" href="cvmx-csr-typedefs_8h.html" title="Configuration and status register (CSR) address and type definitions for Octeon." alt="" coords="2030,237,2193,267"/><area shape="rect" id="node57" href="cvmx-agl-defs_8h.html" title="cvmx&#45;agl&#45;defs.h" alt="" coords="1062,315,1193,344"/><area shape="rect" id="node59" href="cvmx-ase-defs_8h.html" title="cvmx&#45;ase&#45;defs.h" alt="" coords="1217,315,1353,344"/><area shape="rect" id="node61" href="cvmx-asxx-defs_8h.html" title="cvmx&#45;asxx&#45;defs.h" alt="" coords="1377,315,1518,344"/><area shape="rect" id="node63" href="cvmx-asx0-defs_8h.html" title="cvmx&#45;asx0&#45;defs.h" alt="" coords="1542,315,1683,344"/><area shape="rect" id="node65" href="cvmx-bbp-defs_8h.html" title="cvmx&#45;bbp&#45;defs.h" alt="" coords="1707,315,1843,344"/><area shape="rect" id="node67" href="cvmx-bbxa-defs_8h.html" title="cvmx&#45;bbxa&#45;defs.h" alt="" coords="1867,315,2011,344"/><area shape="rect" id="node69" href="cvmx-bbxbx-defs_8h.html" title="cvmx&#45;bbxbx&#45;defs.h" alt="" coords="2035,315,2187,344"/><area shape="rect" id="node71" href="cvmx-bbxc-defs_8h.html" title="cvmx&#45;bbxc&#45;defs.h" alt="" coords="2211,315,2355,344"/><area shape="rect" id="node73" href="cvmx-bch-defs_8h.html" title="cvmx&#45;bch&#45;defs.h" alt="" coords="2379,315,2515,344"/><area shape="rect" id="node75" href="cvmx-bgxx-defs_8h.html" title="cvmx&#45;bgxx&#45;defs.h" alt="" coords="2539,315,2683,344"/><area shape="rect" id="node77" href="cvmx-bts-defs_8h.html" title="cvmx&#45;bts&#45;defs.h" alt="" coords="2707,315,2841,344"/><area shape="rect" id="node79" href="cvmx-ciu2-defs_8h.html" title="cvmx&#45;ciu2&#45;defs.h" alt="" coords="2865,315,3003,344"/><area shape="rect" id="node81" href="cvmx-ciu3-defs_8h.html" title="cvmx&#45;ciu3&#45;defs.h" alt="" coords="3027,315,3166,344"/><area shape="rect" id="node83" href="cvmx-fpa-defs_8h.html" title="cvmx&#45;fpa&#45;defs.h" alt="" coords="3190,315,3323,344"/><area shape="rect" id="node95" href="cvmx-scratch_8h.html" title="This file provides support for the processor local scratch memory." alt="" coords="3347,315,3475,344"/><area shape="rect" id="node99" href="cvmx-fpa1_8h.html" title="Interface to the hardware Free Pool Allocator on Octeon chips." alt="" coords="3162,237,3269,267"/><area shape="rect" id="node103" href="cvmx-fpa3_8h.html" title="Interface to the CN78XX Free Pool Allocator, a.k.a." alt="" coords="3293,237,3399,267"/></map>
</div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="union____cvmx__l2c__tag.html">__cvmx_l2c_tag</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct____cvmx__l2c__tag_1_1cvmx__l2c__tag__cn50xx.html">__cvmx_l2c_tag::cvmx_l2c_tag_cn50xx</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct____cvmx__l2c__tag_1_1cvmx__l2c__tag__cn30xx.html">__cvmx_l2c_tag::cvmx_l2c_tag_cn30xx</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct____cvmx__l2c__tag_1_1cvmx__l2c__tag__cn31xx.html">__cvmx_l2c_tag::cvmx_l2c_tag_cn31xx</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct____cvmx__l2c__tag_1_1cvmx__l2c__tag__cn38xx.html">__cvmx_l2c_tag::cvmx_l2c_tag_cn38xx</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct____cvmx__l2c__tag_1_1cvmx__l2c__tag__cn58xx.html">__cvmx_l2c_tag::cvmx_l2c_tag_cn58xx</a></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#aa59b0d0de27ea39f19eee6f6180600f8">cvmx_l2c_get_core_way_partition</a> (uint32_t core)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the L2 Cache way partitioning for a given core.  <a href="#aa59b0d0de27ea39f19eee6f6180600f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#acfe348d22f95e9399a7645d2495a914d">cvmx_l2c_set_core_way_partition</a> (uint32_t core, uint32_t mask)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Partitions the L2 cache for a core.  <a href="#acfe348d22f95e9399a7645d2495a914d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#a2229bce8dad9aaf52a7645a8a7bbba01">cvmx_l2c_set_hw_way_partition</a> (uint32_t mask)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Partitions the L2 cache for the hardware blocks.  <a href="#a2229bce8dad9aaf52a7645a8a7bbba01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#abe33bf3c58e816363d8bfb496bc0730a">cvmx_l2c_get_hw_way_partition</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the L2 Cache way partitioning for the hw blocks.  <a href="#abe33bf3c58e816363d8bfb496bc0730a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#a78a8c411083ab9e5b0973ae292b7f5ae">cvmx_l2c_set_hw_way_partition2</a> (uint32_t mask)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Partitions the L2 cache for the second set of blocks.  <a href="#a78a8c411083ab9e5b0973ae292b7f5ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#ac731ddfab0b2599e69e5ccff719206e0">cvmx_l2c_get_hw_way_partition2</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the L2 Cache way partitioning for the second set of hw blocks.  <a href="#ac731ddfab0b2599e69e5ccff719206e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#a99da46bd27c9ab9e3bbca2482deafed8">cvmx_l2c_config_perf</a> (uint32_t counter, enum <a class="el" href="cvmx-l2c_8h.html#a27281a7d96d73dcdffc1dad8de824ad9">cvmx_l2c_event</a> event, uint32_t clear_on_read)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#a26232788686ae9eef6ba052a28ed1072">cvmx_l2c_read_perf</a> (uint32_t counter)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the given L2 Cache performance counter.  <a href="#a26232788686ae9eef6ba052a28ed1072"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#abeb6b9a50e04ecc4bfcd54aa6c01b4de">fault_in</a> (uint64_t addr, int len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal use function.  <a href="#abeb6b9a50e04ecc4bfcd54aa6c01b4de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#a26ea890e5d5f192ca5d3fa251d51813b">cvmx_l2c_lock_line</a> (uint64_t addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locks a line in the L2 cache at the specified physical address.  <a href="#a26ea890e5d5f192ca5d3fa251d51813b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#a052ab548e1a5f54e4c57a7a9e6d71f8d">cvmx_l2c_lock_mem_region</a> (uint64_t start, uint64_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locks a specified memory region in the L2 cache.  <a href="#a052ab548e1a5f54e4c57a7a9e6d71f8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#a7b32e404fbddda134f1236bdc05675fc">cvmx_l2c_flush</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flushes (and unlocks) the entire L2 cache.  <a href="#a7b32e404fbddda134f1236bdc05675fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#ad40a8f486ddfbde89f5f898b8ac2177c">cvmx_l2c_unlock_line</a> (uint64_t address)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock and flush a cache line from the L2 cache.  <a href="#ad40a8f486ddfbde89f5f898b8ac2177c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#a44e6ca56a6b43c3c86ea689fa49dda0f">cvmx_l2c_unlock_mem_region</a> (uint64_t start, uint64_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlocks a region of memory that is locked in the L2 cache.  <a href="#a44e6ca56a6b43c3c86ea689fa49dda0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static union <a class="el" href="union____cvmx__l2c__tag.html">__cvmx_l2c_tag</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#a62c379da3c5c6e8536beb68a5bc09d9b">__read_l2_tag</a> (uint64_t assoc, uint64_t index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal use function.  <a href="#a62c379da3c5c6e8536beb68a5bc09d9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union <a class="el" href="unioncvmx__l2c__tag.html">cvmx_l2c_tag</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#a63214bf127205a70b1aec7fd380467b2">cvmx_l2c_get_tag_v2</a> (uint32_t association, uint32_t index, uint32_t tad)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the L2 controller tag for a given location in L2.  <a href="#a63214bf127205a70b1aec7fd380467b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union <a class="el" href="unioncvmx__l2c__tag.html">cvmx_l2c_tag</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#ab47718c70311b83d71a91a29dbe9d4ca">cvmx_l2c_get_tag</a> (uint32_t association, uint32_t index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the L2 controller tag for a given location in L2.  <a href="#ab47718c70311b83d71a91a29dbe9d4ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#aa684791ec44cdb14a8e9b492b41ceac5">cvmx_l2c_address_to_tad</a> (uint64_t addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the TAD for the specified address.  <a href="#aa684791ec44cdb14a8e9b492b41ceac5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#aab319bb57008cda93d9c37bc845bebbb">cvmx_l2c_v2_address_to_tag</a> (uint64_t addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the L2 tag that will be used for the given physical address.  <a href="#aab319bb57008cda93d9c37bc845bebbb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#ae5eb21c5840a911648bc1efc714775f7">cvmx_l2c_address_to_index</a> (uint64_t addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the cache index for a given physical address.  <a href="#ae5eb21c5840a911648bc1efc714775f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#a194d98e7dc5b2d841a163dc221a82795">cvmx_l2c_tqdl2d_to_index_7xxx</a> (int node, int tad)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decodes TQD L2D single and double-bit errors to the appropriate cache index for the CVMX_CACHE_LTGL2I operation.  <a href="#a194d98e7dc5b2d841a163dc221a82795"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#a14f46ac3f49e6cb922073a47f05bdd20">cvmx_l2c_ttgx_to_index_7xxx</a> (int node, int tad, bool remote)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decodes TTG tag single and double-bit errors to the appropriate cache index for the CVMX_CACHE_LTGL2I operation.  <a href="#a14f46ac3f49e6cb922073a47f05bdd20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#a246b40be5ff22050a466035bf289b9be">cvmx_l2c_get_cache_size_bytes</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#a410a492416a1c1008e527db1ba80a741">cvmx_l2c_get_set_bits</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return log base 2 of the number of sets in the L2 cache.  <a href="#a410a492416a1c1008e527db1ba80a741"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#ae99519973f511459f1ec67c97b1a89a2">cvmx_l2c_get_num_sets</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of sets in the L2 Cache.  <a href="#ae99519973f511459f1ec67c97b1a89a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#a44caca04f617e523e8eea9077af832be">cvmx_l2c_get_num_assoc</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of associations in the L2 Cache.  <a href="#a44caca04f617e523e8eea9077af832be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#a0d80f07ec4366a35321d91695277ca3d">cvmx_l2c_flush_line</a> (uint32_t assoc, uint32_t index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush a line from the L2 cache This should only be called from one core at a time, as this routine sets the core to the 'debug' core in order to flush the line.  <a href="#a0d80f07ec4366a35321d91695277ca3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#ac5d084289620415e5be7939f1350c0ff">cvmx_l2c_set_big_size_node</a> (int node, uint64_t mem_size, int mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the BIG address in L2C+DRAM to generate proper error on reading/writing to an non-existant memory location.  <a href="#ac5d084289620415e5be7939f1350c0ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#ac4bdb4bf19d625f6e3130901a72cad4b">cvmx_l2c_set_big_size</a> (uint64_t mem_size, int mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the BIG address in L2C+DRAM to generate proper error on reading/writing to an non-existant memory location.  <a href="#ac4bdb4bf19d625f6e3130901a72cad4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#aa64c50956a8257cf92cf27047434ae8d">__cvmx_l2c_vrt_decode_numid</a> (int nvid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal use function.  <a href="#aa64c50956a8257cf92cf27047434ae8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#ab5bebbe37a4a7134597983e8a4b01335">cvmx_l2c_vrt_set_max_virtids</a> (int nvid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set maxium number of Virtual IDs allowed in a machine.  <a href="#ab5bebbe37a4a7134597983e8a4b01335"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#a6ea76d03c4b2a973e4c47a25e30fd543">cvmx_l2c_vrt_get_max_virtids</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get maxium number of virtual IDs allowed in a machine.  <a href="#a6ea76d03c4b2a973e4c47a25e30fd543"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#a4bcb1cf8cd2ff245a9a4b4b90c42cfb1">__cvmx_l2c_vrt_decode_memsize</a> (int memsz)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal use function.  <a href="#a4bcb1cf8cd2ff245a9a4b4b90c42cfb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#ae42e7736a4e21c9c696d15e3842878e8">cvmx_l2c_vrt_set_max_memsz</a> (int memsz)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the maxium size of memory space to be allocated for virtualization.  <a href="#ae42e7736a4e21c9c696d15e3842878e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#a5ccda8d859ff4200337bfa18d5076b46">cvmx_l2c_vrt_assign_virtid</a> (int virtid, uint32_t <a class="el" href="cvmx-coremask_8c.html#a7f11167512bd1be96db8d341ed67ba3e">coremask</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a Virtual ID to a set of cores.  <a href="#a5ccda8d859ff4200337bfa18d5076b46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#a1417dbb398d437db42580246213cc840">cvmx_l2c_vrt_remove_virtid</a> (int virtid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a virt id assigned to a set of cores.  <a href="#a1417dbb398d437db42580246213cc840"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#a6076c4ff2e996dcaa893a2df79df11d5">__cvmx_l2c_vrt_get_granularity</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function to protect the memory region based on the granularity.  <a href="#a6076c4ff2e996dcaa893a2df79df11d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#a5687830322c3c4dc53016c7b356fb45b">cvmx_l2c_vrt_memprotect</a> (uint64_t start_addr, int size, int virtid, int mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block a memory region to be updated for a given virtual id.  <a href="#a5687830322c3c4dc53016c7b356fb45b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#a15a33f262eb91c2f00634eeeab758d08">cvmx_l2c_vrt_enable</a> (int mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable virtualization.  <a href="#a15a33f262eb91c2f00634eeeab758d08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#a031082435f039868f34f097645dc1171">cvmx_l2c_vrt_disable</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable virtualization.  <a href="#a031082435f039868f34f097645dc1171"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CVMX_SHARED <a class="el" href="structcvmx__spinlock__t.html">cvmx_spinlock_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#a610fd791d1263bbdb2c4324bd036cf84">cvmx_l2c_spinlock</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CVMX_SHARED <a class="el" href="structcvmx__spinlock__t.html">cvmx_spinlock_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-l2c_8c.html#a30d4ea4a82da2082fdb468bb7381abbb">cvmx_l2c_vrt_spinlock</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Implementation of the Level 2 Cache (L2C) control, measurement, and debugging facilities. </p>
<hr/>
<dl class="rcs"><dt><b>Revision</b></dt><dd>164990 </dd></dl>
<hr/>
 <hr/><h2>Function Documentation</h2>
<a class="anchor" id="a4bcb1cf8cd2ff245a9a4b4b90c42cfb1"></a><!-- doxytag: member="cvmx&#45;l2c.c::__cvmx_l2c_vrt_decode_memsize" ref="a4bcb1cf8cd2ff245a9a4b4b90c42cfb1" args="(int memsz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int __cvmx_l2c_vrt_decode_memsize </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>memsz</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal use function. </p>
<p><b>This function's parameters and processing may change in future SDKs.</b><br/>
<br/>
 Helper function to decode VALUE to memory space coverage of L2C_VRT_MEM. Returns L2C_VRT_CTL[MEMSZ].</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>memsz</em>&nbsp;</td><td>Memory in GB. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>On success, decode to MEMSZ, or on failure return -1. </dd></dl>

</div>
</div>
<a class="anchor" id="aa64c50956a8257cf92cf27047434ae8d"></a><!-- doxytag: member="cvmx&#45;l2c.c::__cvmx_l2c_vrt_decode_numid" ref="aa64c50956a8257cf92cf27047434ae8d" args="(int nvid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int __cvmx_l2c_vrt_decode_numid </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvid</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal use function. </p>
<p><b>This function's parameters and processing may change in future SDKs.</b><br/>
<br/>
 Helper function to decode VALUE to number of allowed virtualization IDS. Returns L2C_VRT_CTL[NUMID].</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nvid</em>&nbsp;</td><td>Number of virtual Ids. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>On success decode to NUMID, or to -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a6076c4ff2e996dcaa893a2df79df11d5"></a><!-- doxytag: member="cvmx&#45;l2c.c::__cvmx_l2c_vrt_get_granularity" ref="a6076c4ff2e996dcaa893a2df79df11d5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t __cvmx_l2c_vrt_get_granularity </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function to protect the memory region based on the granularity. </p>

</div>
</div>
<a class="anchor" id="a62c379da3c5c6e8536beb68a5bc09d9b"></a><!-- doxytag: member="cvmx&#45;l2c.c::__read_l2_tag" ref="a62c379da3c5c6e8536beb68a5bc09d9b" args="(uint64_t assoc, uint64_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static union <a class="el" href="union____cvmx__l2c__tag.html">__cvmx_l2c_tag</a> __read_l2_tag </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>assoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, write]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal use function. </p>
<p><b>This function's parameters and processing may change in future SDKs.</b><br/>
<br/>
 Function to read a L2C tag. This code make the current core the 'debug core' for the L2. This code must only be executed by 1 core at a time.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>assoc</em>&nbsp;</td><td>Association (way) of the tag to dump </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>Index of the cacheline</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The Octeon model specific tag structure. This is translated by a wrapper function to a generic form that is easier for applications to use. </dd></dl>

</div>
</div>
<a class="anchor" id="ae5eb21c5840a911648bc1efc714775f7"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_address_to_index" ref="ae5eb21c5840a911648bc1efc714775f7" args="(uint64_t addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t cvmx_l2c_address_to_index </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>addr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the cache index for a given physical address. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>physical address</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>L2 cache index </dd></dl>

</div>
</div>
<a class="anchor" id="aa684791ec44cdb14a8e9b492b41ceac5"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_address_to_tad" ref="aa684791ec44cdb14a8e9b492b41ceac5" args="(uint64_t addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_l2c_address_to_tad </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>addr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the TAD for the specified address. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>physical address to get TAD for</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TAD number for address. </dd></dl>

</div>
</div>
<a class="anchor" id="a99da46bd27c9ab9e3bbca2482deafed8"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_config_perf" ref="a99da46bd27c9ab9e3bbca2482deafed8" args="(uint32_t counter, enum cvmx_l2c_event event, uint32_t clear_on_read)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvmx_l2c_config_perf </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="cvmx-l2c_8h.html#a27281a7d96d73dcdffc1dad8de824ad9">cvmx_l2c_event</a>&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>clear_on_read</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7b32e404fbddda134f1236bdc05675fc"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_flush" ref="a7b32e404fbddda134f1236bdc05675fc" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvmx_l2c_flush </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flushes (and unlocks) the entire L2 cache. </p>
<p>IMPORTANT: Must only be run by one core at a time due to use of L2C debug features. </p>

</div>
</div>
<a class="anchor" id="a0d80f07ec4366a35321d91695277ca3d"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_flush_line" ref="a0d80f07ec4366a35321d91695277ca3d" args="(uint32_t assoc, uint32_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvmx_l2c_flush_line </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>assoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flush a line from the L2 cache This should only be called from one core at a time, as this routine sets the core to the 'debug' core in order to flush the line. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>assoc</em>&nbsp;</td><td>Association (or way) to flush </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>Index to flush </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a246b40be5ff22050a466035bf289b9be"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_get_cache_size_bytes" ref="a246b40be5ff22050a466035bf289b9be" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_l2c_get_cache_size_bytes </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the size of the L2 cache in bytes, -1 on error (unrecognized model) </dd></dl>

</div>
</div>
<a class="anchor" id="aa59b0d0de27ea39f19eee6f6180600f8"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_get_core_way_partition" ref="aa59b0d0de27ea39f19eee6f6180600f8" args="(uint32_t core)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_l2c_get_core_way_partition </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>core</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the L2 Cache way partitioning for a given core. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>core</em>&nbsp;</td><td>The core processor of interest.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The mask specifying the partitioning. 0 bits in mask indicates the cache 'ways' that a core can evict from. -1 on error </dd></dl>

</div>
</div>
<a class="anchor" id="abe33bf3c58e816363d8bfb496bc0730a"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_get_hw_way_partition" ref="abe33bf3c58e816363d8bfb496bc0730a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_l2c_get_hw_way_partition </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the L2 Cache way partitioning for the hw blocks. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The mask specifying the reserved way. 0 bits in mask indicates the cache 'ways' that a core can evict from. -1 on error </dd></dl>

</div>
</div>
<a class="anchor" id="ac731ddfab0b2599e69e5ccff719206e0"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_get_hw_way_partition2" ref="ac731ddfab0b2599e69e5ccff719206e0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_l2c_get_hw_way_partition2 </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the L2 Cache way partitioning for the second set of hw blocks. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The mask specifying the reserved way. 0 bits in mask indicates the cache 'ways' that a core can evict from. -1 on error </dd></dl>

</div>
</div>
<a class="anchor" id="a44caca04f617e523e8eea9077af832be"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_get_num_assoc" ref="a44caca04f617e523e8eea9077af832be" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_l2c_get_num_assoc </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of associations in the L2 Cache. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ae99519973f511459f1ec67c97b1a89a2"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_get_num_sets" ref="ae99519973f511459f1ec67c97b1a89a2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_l2c_get_num_sets </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of sets in the L2 Cache. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a410a492416a1c1008e527db1ba80a741"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_get_set_bits" ref="a410a492416a1c1008e527db1ba80a741" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_l2c_get_set_bits </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return log base 2 of the number of sets in the L2 cache. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ab47718c70311b83d71a91a29dbe9d4ca"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_get_tag" ref="ab47718c70311b83d71a91a29dbe9d4ca" args="(uint32_t association, uint32_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unioncvmx__l2c__tag.html">cvmx_l2c_tag_t</a> cvmx_l2c_get_tag </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>association</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [write]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read the L2 controller tag for a given location in L2. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>association</em>&nbsp;</td><td>Which association to read line from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>Which way to read from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>l2c tag structure for line requested.</dd></dl>
<p>NOTE: This function is deprecated and cannot be used on devices with multiple L2C interfaces such as the OCTEON CN68XX. Please use cvmx_l2c_get_tag_v2 instead. </p>

</div>
</div>
<a class="anchor" id="a63214bf127205a70b1aec7fd380467b2"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_get_tag_v2" ref="a63214bf127205a70b1aec7fd380467b2" args="(uint32_t association, uint32_t index, uint32_t tad)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union <a class="el" href="unioncvmx__l2c__tag.html">cvmx_l2c_tag</a> cvmx_l2c_get_tag_v2 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>association</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>tad</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [write]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read the L2 controller tag for a given location in L2. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>association</em>&nbsp;</td><td>Which association to read line from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>Which way to read from.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tad</em>&nbsp;</td><td>Which TAD to read from, set to 0 except on OCTEON CN68XX.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>l2c tag structure for line requested. </dd></dl>

</div>
</div>
<a class="anchor" id="a26ea890e5d5f192ca5d3fa251d51813b"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_lock_line" ref="a26ea890e5d5f192ca5d3fa251d51813b" args="(uint64_t addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_l2c_lock_line </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>addr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Locks a line in the L2 cache at the specified physical address. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>physical address of line to lock</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, 1 if line not locked. </dd></dl>

</div>
</div>
<a class="anchor" id="a052ab548e1a5f54e4c57a7a9e6d71f8d"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_lock_mem_region" ref="a052ab548e1a5f54e4c57a7a9e6d71f8d" args="(uint64_t start, uint64_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_l2c_lock_mem_region </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Locks a specified memory region in the L2 cache. </p>
<p>Note that if not all lines can be locked, that means that all but one of the ways (associations) available to the locking core are locked. Having only 1 association available for normal caching may have a significant adverse affect on performance. Care should be taken to ensure that enough of the L2 cache is left unlocked to allow for normal caching of DRAM.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>Physical address of the start of the region to lock </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Length (in bytes) of region to lock</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of requested lines that where not locked. 0 on success (all locked) </dd></dl>

</div>
</div>
<a class="anchor" id="a26232788686ae9eef6ba052a28ed1072"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_read_perf" ref="a26232788686ae9eef6ba052a28ed1072" args="(uint32_t counter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cvmx_l2c_read_perf </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>counter</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read the given L2 Cache performance counter. </p>
<p>The counter must be configured before reading, but this routine does not enforce this requirement.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>counter</em>&nbsp;</td><td>The counter to configure. Range 0..3.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current counter value. </dd></dl>

</div>
</div>
<a class="anchor" id="ac4bdb4bf19d625f6e3130901a72cad4b"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_set_big_size" ref="ac4bdb4bf19d625f6e3130901a72cad4b" args="(uint64_t mem_size, int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvmx_l2c_set_big_size </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>mem_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the BIG address in L2C+DRAM to generate proper error on reading/writing to an non-existant memory location. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mem_size</em>&nbsp;</td><td>Amount of DRAM configured in MB. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>Allow/Disallow reporting errors L2C_INT_SUM[BIGRD,BIGWR]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5d084289620415e5be7939f1350c0ff"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_set_big_size_node" ref="ac5d084289620415e5be7939f1350c0ff" args="(int node, uint64_t mem_size, int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvmx_l2c_set_big_size_node </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>mem_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the BIG address in L2C+DRAM to generate proper error on reading/writing to an non-existant memory location. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>OCX CPU node number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mem_size</em>&nbsp;</td><td>Amount of DRAM configured in MB. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>Allow/Disallow reporting errors L2C_INT_SUM[BIGRD,BIGWR]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acfe348d22f95e9399a7645d2495a914d"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_set_core_way_partition" ref="acfe348d22f95e9399a7645d2495a914d" args="(uint32_t core, uint32_t mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_l2c_set_core_way_partition </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>core</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Partitions the L2 cache for a core. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>core</em>&nbsp;</td><td>The core that the partitioning applies to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>The partitioning of the ways expressed as a binary mask. A 0 bit allows the core to evict cache lines from a way, while a 1 bit blocks the core from evicting any lines from that way. There must be at least one allowed way (0 bit) in the mask.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If any ways are blocked for all cores and the HW blocks, then those ways will never have any cache lines evicted from them. All cores and the hardware blocks are free to read from all ways regardless of the partitioning. </dd></dl>

</div>
</div>
<a class="anchor" id="a2229bce8dad9aaf52a7645a8a7bbba01"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_set_hw_way_partition" ref="a2229bce8dad9aaf52a7645a8a7bbba01" args="(uint32_t mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_l2c_set_hw_way_partition </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>mask</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Partitions the L2 cache for the hardware blocks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>The partitioning of the ways expressed as a binary mask. A 0 bit allows the core to evict cache lines from a way, while a 1 bit blocks the core from evicting any lines from that way. There must be at least one allowed way (0 bit) in the mask.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If any ways are blocked for all cores and the HW blocks, then those ways will never have any cache lines evicted from them. All cores and the hardware blocks are free to read from all ways regardless of the partitioning. </dd></dl>

</div>
</div>
<a class="anchor" id="a78a8c411083ab9e5b0973ae292b7f5ae"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_set_hw_way_partition2" ref="a78a8c411083ab9e5b0973ae292b7f5ae" args="(uint32_t mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_l2c_set_hw_way_partition2 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>mask</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Partitions the L2 cache for the second set of blocks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>The partitioning of the ways expressed as a binary mask. A 0 bit allows the core to evict cache lines from a way, while a 1 bit blocks the core from evicting any lines from that way. There must be at least one allowed way (0 bit) in the mask.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If any ways are blocked for all cores and the HW blocks, then those ways will never have any cache lines evicted from them. All cores and the hardware blocks are free to read from all ways regardless of the partitioning. </dd></dl>

</div>
</div>
<a class="anchor" id="a194d98e7dc5b2d841a163dc221a82795"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_tqdl2d_to_index_7xxx" ref="a194d98e7dc5b2d841a163dc221a82795" args="(int node, int tad)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cvmx_l2c_tqdl2d_to_index_7xxx </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>tad</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decodes TQD L2D single and double-bit errors to the appropriate cache index for the CVMX_CACHE_LTGL2I operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>CPU node number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tad</em>&nbsp;</td><td>TAD interface</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>index address to pass to the LTGL2I cache operation (3) </dd></dl>

</div>
</div>
<a class="anchor" id="a14f46ac3f49e6cb922073a47f05bdd20"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_ttgx_to_index_7xxx" ref="a14f46ac3f49e6cb922073a47f05bdd20" args="(int node, int tad, bool remote)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cvmx_l2c_ttgx_to_index_7xxx </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>tad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>remote</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decodes TTG tag single and double-bit errors to the appropriate cache index for the CVMX_CACHE_LTGL2I operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>CPU node number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tad</em>&nbsp;</td><td>TAD interface</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>index address to pass to the LTGL2I cache operation (3) </dd></dl>

</div>
</div>
<a class="anchor" id="ad40a8f486ddfbde89f5f898b8ac2177c"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_unlock_line" ref="ad40a8f486ddfbde89f5f898b8ac2177c" args="(uint64_t address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_l2c_unlock_line </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>address</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlock and flush a cache line from the L2 cache. </p>
<p>IMPORTANT: Must only be run by one core at a time due to use of L2C debug features. Note that this function will flush a matching but unlocked cache line. (If address is not in L2, no lines are flushed.)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>address</em>&nbsp;</td><td>Physical address to unlock</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0: line not unlocked 1: line unlocked </dd></dl>

</div>
</div>
<a class="anchor" id="a44e6ca56a6b43c3c86ea689fa49dda0f"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_unlock_mem_region" ref="a44e6ca56a6b43c3c86ea689fa49dda0f" args="(uint64_t start, uint64_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_l2c_unlock_mem_region </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlocks a region of memory that is locked in the L2 cache. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>start physical address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>length (in bytes) to unlock</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of locked lines that the call unlocked </dd></dl>

</div>
</div>
<a class="anchor" id="aab319bb57008cda93d9c37bc845bebbb"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_v2_address_to_tag" ref="aab319bb57008cda93d9c37bc845bebbb" args="(uint64_t addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t cvmx_l2c_v2_address_to_tag </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>addr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the L2 tag that will be used for the given physical address. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>physical address </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>L2 cache tag. Addreses in the LMC hole are not valid. Returns 0xFFFFFFFF if the address specified is in the LMC hole. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ccda8d859ff4200337bfa18d5076b46"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_vrt_assign_virtid" ref="a5ccda8d859ff4200337bfa18d5076b46" args="(int virtid, uint32_t coremask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_l2c_vrt_assign_virtid </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>virtid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>coremask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a Virtual ID to a set of cores. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>virtid</em>&nbsp;</td><td>Assign virtid to a set of cores. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coremask</em>&nbsp;</td><td>The group of cores to assign a unique virtual id. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Return 0 on success, otherwise -1. </dd></dl>

</div>
</div>
<a class="anchor" id="a031082435f039868f34f097645dc1171"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_vrt_disable" ref="a031082435f039868f34f097645dc1171" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvmx_l2c_vrt_disable </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable virtualization. </p>

</div>
</div>
<a class="anchor" id="a15a33f262eb91c2f00634eeeab758d08"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_vrt_enable" ref="a15a33f262eb91c2f00634eeeab758d08" args="(int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvmx_l2c_vrt_enable </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable virtualization. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>Whether out of bound writes are an error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ea76d03c4b2a973e4c47a25e30fd543"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_vrt_get_max_virtids" ref="a6ea76d03c4b2a973e4c47a25e30fd543" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_l2c_vrt_get_max_virtids </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get maxium number of virtual IDs allowed in a machine. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Return number of virtual machine IDs or -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a5687830322c3c4dc53016c7b356fb45b"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_vrt_memprotect" ref="a5687830322c3c4dc53016c7b356fb45b" args="(uint64_t start_addr, int size, int virtid, int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_l2c_vrt_memprotect </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>start_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>virtid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Block a memory region to be updated for a given virtual id. </p>
<p>Block a memory region to be updated by a set of virtids.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start_addr</em>&nbsp;</td><td>Starting address of memory region </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the memory to protect </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>virtid</em>&nbsp;</td><td>Virtual ID to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>Allow/Disallow write access = 0, Allow write access by virtid = 1, Disallow write access by virtid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1417dbb398d437db42580246213cc840"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_vrt_remove_virtid" ref="a1417dbb398d437db42580246213cc840" args="(int virtid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvmx_l2c_vrt_remove_virtid </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>virtid</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a virt id assigned to a set of cores. </p>
<p>Update the virtid mask and virtid stored for each core.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>virtid</em>&nbsp;</td><td>Remove the specified Virtualization machine ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae42e7736a4e21c9c696d15e3842878e8"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_vrt_set_max_memsz" ref="ae42e7736a4e21c9c696d15e3842878e8" args="(int memsz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_l2c_vrt_set_max_memsz </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>memsz</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the maxium size of memory space to be allocated for virtualization. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>memsz</em>&nbsp;</td><td>Size of the virtual memory in GB </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Return 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5bebbe37a4a7134597983e8a4b01335"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_vrt_set_max_virtids" ref="ab5bebbe37a4a7134597983e8a4b01335" args="(int nvid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_l2c_vrt_set_max_virtids </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nvid</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set maxium number of Virtual IDs allowed in a machine. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nvid</em>&nbsp;</td><td>Number of virtial ids allowed in a machine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Return 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="abeb6b9a50e04ecc4bfcd54aa6c01b4de"></a><!-- doxytag: member="cvmx&#45;l2c.c::fault_in" ref="abeb6b9a50e04ecc4bfcd54aa6c01b4de" args="(uint64_t addr, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void fault_in </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal use function. </p>
<p><b>This function's parameters and processing may change in future SDKs.</b><br/>
<br/>
 Helper function use to fault in cache lines for L2 cache locking</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Address of base of memory region to read into L2 cache </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Length (in bytes) of region to fault in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a610fd791d1263bbdb2c4324bd036cf84"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_spinlock" ref="a610fd791d1263bbdb2c4324bd036cf84" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVMX_SHARED <a class="el" href="structcvmx__spinlock__t.html">cvmx_spinlock_t</a> <a class="el" href="cvmx-l2c_8c.html#a610fd791d1263bbdb2c4324bd036cf84">cvmx_l2c_spinlock</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a30d4ea4a82da2082fdb468bb7381abbb"></a><!-- doxytag: member="cvmx&#45;l2c.c::cvmx_l2c_vrt_spinlock" ref="a30d4ea4a82da2082fdb468bb7381abbb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVMX_SHARED <a class="el" href="structcvmx__spinlock__t.html">cvmx_spinlock_t</a> <a class="el" href="cvmx-l2c_8c.html#a30d4ea4a82da2082fdb468bb7381abbb">cvmx_l2c_vrt_spinlock</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Oct 2017 for Octeon Software Development Kit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
