<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Octeon Software Development Kit: cvmx-nand.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cvmx-nand.h File Reference</h1>
<p>This header defines the CVMX interface to the NAND flash controller.  
<a href="#_details">More...</a></p>
<div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dynsection">
<div class="center"><img src="cvmx-nand_8h__dep__incl.png" border="0" usemap="#cvmx-nand_8hdep_map" alt=""/></div>
<map name="cvmx-nand_8hdep_map" id="cvmx-nand_8hdep">
<area shape="rect" id="node3" href="cvmx-nand_8c.html" title="Interface to the NAND flash controller." alt="" coords="5,83,115,112"/></map>
</div>

<p><a href="cvmx-nand_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcvmx__nand__cmd__nop__t.html">cvmx_nand_cmd_nop_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NAND NOP command definition.  <a href="structcvmx__nand__cmd__nop__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcvmx__nand__cmd__set__tm__par__t.html">cvmx_nand_cmd_set_tm_par_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NAND SET_TM_PAR command definition.  <a href="structcvmx__nand__cmd__set__tm__par__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcvmx__nand__cmd__wait__t.html">cvmx_nand_cmd_wait_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NAND WAIT command definition.  <a href="structcvmx__nand__cmd__wait__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcvmx__nand__cmd__chip__en__t.html">cvmx_nand_cmd_chip_en_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NAND CHIP_EN command definition.  <a href="structcvmx__nand__cmd__chip__en__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcvmx__nand__cmd__chip__dis__t.html">cvmx_nand_cmd_chip_dis_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NAND CHIP_DIS command definition.  <a href="structcvmx__nand__cmd__chip__dis__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcvmx__nand__cmd__cle__t.html">cvmx_nand_cmd_cle_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NAND CLE command definition.  <a href="structcvmx__nand__cmd__cle__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcvmx__nand__cmd__ale__t.html">cvmx_nand_cmd_ale_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NAND ALE command definition.  <a href="structcvmx__nand__cmd__ale__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcvmx__nand__cmd__wr__t.html">cvmx_nand_cmd_wr_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NAND WR command definition.  <a href="structcvmx__nand__cmd__wr__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcvmx__nand__cmd__rd__t.html">cvmx_nand_cmd_rd_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NAND RD command definition.  <a href="structcvmx__nand__cmd__rd__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcvmx__nand__cmd__rd__edo__t.html">cvmx_nand_cmd_rd_edo_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NAND RD_EDO command definition.  <a href="structcvmx__nand__cmd__rd__edo__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcvmx__nand__cmd__wait__status__t.html">cvmx_nand_cmd_wait_status_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NAND WAIT_STATUS command definition.  <a href="structcvmx__nand__cmd__wait__status__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcvmx__nand__cmd__wait__status__ale__t.html">cvmx_nand_cmd_wait_status_ale_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NAND WAIT_STATUS_ALE command definition.  <a href="structcvmx__nand__cmd__wait__status__ale__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcvmx__nand__cmd__bus__acq__t.html">cvmx_nand_cmd_bus_acq_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NAND BUS_ACQ command definition.  <a href="structcvmx__nand__cmd__bus__acq__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcvmx__nand__cmd__bus__rel__t.html">cvmx_nand_cmd_bus_rel_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NAND BUS_REL command definition.  <a href="structcvmx__nand__cmd__bus__rel__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unioncvmx__nand__cmd__t.html">cvmx_nand_cmd_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NAND command union of all possible commands.  <a href="unioncvmx__nand__cmd__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcvmx__nand__onfi__param__page__t.html">cvmx_nand_onfi_param_page_t</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-nand_8h.html#a74d68388fc13c125989d334ad93c750d">CVMX_NAND_MAX_PAGE_AND_OOB_SIZE</a>&nbsp;&nbsp;&nbsp;(16384 + 512)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-nand_8h.html#a1687aa636d59d008493fdebfae09d781">CVMX_NAND_BOOT_ECC_BLOCK_SIZE</a>&nbsp;&nbsp;&nbsp;(256)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-nand_8h.html#af26410da4933c438f03b0f4d6629388c">CVMX_NAND_BOOT_ECC_ECC_SIZE</a>&nbsp;&nbsp;&nbsp;(8)</td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-nand_8h.html#a16a1444b15a746cfc6bcdc7ea2852ba2">cvmx_nand_initialize_flags_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="cvmx-nand_8h.html#a16a1444b15a746cfc6bcdc7ea2852ba2ad7fe1312cdefb54dc94905c76b4de53f">CVMX_NAND_INITIALIZE_FLAGS_16BIT</a> =  1 &lt;&lt; 0, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-nand_8h.html#a16a1444b15a746cfc6bcdc7ea2852ba2a1084249d377e5c043004901c998aa0e4">CVMX_NAND_INITIALIZE_FLAGS_DONT_PROBE</a> =  1 &lt;&lt; 1, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-nand_8h.html#a16a1444b15a746cfc6bcdc7ea2852ba2afe4ebffedde329a8abac3bc079e53f70">CVMX_NAND_INITIALIZE_FLAGS_DEBUG</a> =  1 &lt;&lt; 15
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Flags to be passed to the initialize function. </p>
 <a href="cvmx-nand_8h.html#a16a1444b15a746cfc6bcdc7ea2852ba2">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e">cvmx_nand_status_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7ea0b283d8a2005757e120b6a3d94d6d7b7">CVMX_NAND_SUCCESS</a> =  0, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7ea76f80b04f5a782ee2b9fdf77cc037657">CVMX_NAND_NO_MEMORY</a> =  -1, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7eae3651df6193757d96848e1c608ab6979">CVMX_NAND_BUSY</a> =  -2, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7ea0efc16e9ec584b118159a22480eaaf02">CVMX_NAND_INVALID_PARAM</a> =  -3, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7ea7da559e45bd5bb3665ec005ea7315f77">CVMX_NAND_TIMEOUT</a> =  -4, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7ea8e10bd7a041320af01eb5527020f715a">CVMX_NAND_ERROR</a> =  -5, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7ea856d413d967f7398570456668175a7f5">CVMX_NAND_NO_DEVICE</a> =  -6
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Return codes from NAND functions. </p>
 <a href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e">cvmx_nand_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-nand_8h.html#afa5bf87c53c60362a32a3a99a078d3a1">cvmx_nand_initialize</a> (<a class="el" href="cvmx-nand_8h.html#a16a1444b15a746cfc6bcdc7ea2852ba2">cvmx_nand_initialize_flags_t</a> flags, int active_chips)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called to initialize the NAND controller for use.  <a href="#afa5bf87c53c60362a32a3a99a078d3a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e">cvmx_nand_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-nand_8h.html#a8103e18da67b88790a7c1d833aa8c3d9">cvmx_nand_set_defaults</a> (int page_size, int oob_size, int pages_per_block, int blocks, int onfi_timing_mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function may be called before cvmx_nand_initialize to set default values that will be used for NAND chips that do not identify themselves in a way that allows autoconfiguration.  <a href="#a8103e18da67b88790a7c1d833aa8c3d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e">cvmx_nand_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-nand_8h.html#a93972a7e4c00631d921d8294082cf0cc">cvmx_nand_shutdown</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to shutdown the NAND controller after all transactions are done.  <a href="#a93972a7e4c00631d921d8294082cf0cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-nand_8h.html#acd6f9b1f5c08a186a2524c6f69c534e5">cvmx_nand_get_active_chips</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a bitmask representing the chip selects that are connected to NAND chips.  <a href="#acd6f9b1f5c08a186a2524c6f69c534e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e">cvmx_nand_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-nand_8h.html#afd05a3961ab8ee9a75815550d9b3f7a1">cvmx_nand_set_timing</a> (int chip, int tim_mult, int tim_par[7], int clen[4], int alen[4], int rdn[4], int wrn[2])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Override the timing parameters for a NAND chip.  <a href="#afd05a3961ab8ee9a75815550d9b3f7a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e">cvmx_nand_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-nand_8h.html#ad486b46c5d4dc5572acc90fbb568d64e">cvmx_nand_submit</a> (<a class="el" href="unioncvmx__nand__cmd__t.html">cvmx_nand_cmd_t</a> cmd)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Submit a command to the NAND command queue.  <a href="#ad486b46c5d4dc5572acc90fbb568d64e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-nand_8h.html#a4e923fd882cf8b709ea45bbcc97c882a">cvmx_nand_page_read</a> (int chip, uint64_t nand_address, uint64_t buffer_address, int buffer_length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a page from NAND.  <a href="#a4e923fd882cf8b709ea45bbcc97c882a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-nand_8h.html#afc8ee87e6f8bf9fc17b45cadc9f52048">cvmx_nand_random_data_out</a> (int chip, uint64_t nand_address, uint64_t buffer_address, int buffer_length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read random data from NAND.  <a href="#afc8ee87e6f8bf9fc17b45cadc9f52048"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e">cvmx_nand_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-nand_8h.html#af6431f766b56aa5518d5a1ff7064d3a8">cvmx_nand_page_write</a> (int chip, uint64_t nand_address, uint64_t buffer_address)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a page to NAND.  <a href="#af6431f766b56aa5518d5a1ff7064d3a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e">cvmx_nand_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-nand_8h.html#a3f554501e7b9d058908d4806cc14440e">cvmx_nand_block_erase</a> (int chip, uint64_t nand_address)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase a NAND block.  <a href="#a3f554501e7b9d058908d4806cc14440e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-nand_8h.html#a44711e1a29d311926cee8ca48f44f201">cvmx_nand_read_id</a> (int chip, uint64_t nand_address, uint64_t buffer_address, int buffer_length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the NAND ID information.  <a href="#a44711e1a29d311926cee8ca48f44f201"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-nand_8h.html#aff29480fd5a7ba882a9000300458de37">cvmx_nand_read_param_page</a> (int chip, uint64_t buffer_address, int buffer_length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the NAND parameter page.  <a href="#aff29480fd5a7ba882a9000300458de37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcvmx__nand__onfi__param__page__t.html">cvmx_nand_onfi_param_page_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-nand_8h.html#af7f9773c35b8169c1574395e3dd64d7f">cvmx_nand_onfi_process</a> (<a class="el" href="structcvmx__nand__onfi__param__page__t.html">cvmx_nand_onfi_param_page_t</a> param_page[3])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Validate the ONFI parameter page and return a pointer to the config values.  <a href="#af7f9773c35b8169c1574395e3dd64d7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-nand_8h.html#a5efec3568a962010d22aad3a42cfc0b8">cvmx_nand_get_status</a> (int chip)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the status of the NAND flash.  <a href="#a5efec3568a962010d22aad3a42cfc0b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e">cvmx_nand_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-nand_8h.html#a9391034206344a3b44164db430c9f372">cvmx_nand_get_feature</a> (int chip, uint8_t feat_num, uint8_t feature[4])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the specified feature number.  <a href="#a9391034206344a3b44164db430c9f372"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e">cvmx_nand_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-nand_8h.html#a2c36d924afdf9107b2634c7d18685150">cvmx_nand_set_feature</a> (int chip, uint8_t feat_num, const uint8_t feature[4])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the specified feature number.  <a href="#a2c36d924afdf9107b2634c7d18685150"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-nand_8h.html#ada46144a8bc76da93f90cf4afd683ea6">cvmx_nand_get_page_size</a> (int chip)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the page size, excluding out of band data.  <a href="#ada46144a8bc76da93f90cf4afd683ea6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-nand_8h.html#a0d4059ce266ecabd68c7c7dc7651cb6c">cvmx_nand_get_oob_size</a> (int chip)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the OOB size.  <a href="#a0d4059ce266ecabd68c7c7dc7651cb6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-nand_8h.html#a0726e6f3c510046f5b8f62b85d2ebde4">cvmx_nand_get_pages_per_block</a> (int chip)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of pages per NAND block.  <a href="#a0726e6f3c510046f5b8f62b85d2ebde4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-nand_8h.html#a85289e24ece28e5ca88d7e82499c7591">cvmx_nand_get_blocks</a> (int chip)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of blocks in the NAND flash.  <a href="#a85289e24ece28e5ca88d7e82499c7591"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e">cvmx_nand_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-nand_8h.html#a28d7bd4c07f5fcb7687e591d6419e5b0">cvmx_nand_reset</a> (int chip)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the NAND flash.  <a href="#a28d7bd4c07f5fcb7687e591d6419e5b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-nand_8h.html#ab302e98b24747989dc80014b3af8e199">cvmx_nand_compute_boot_ecc</a> (unsigned char *block, unsigned char *eccp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function computes the Octeon specific ECC data used by the NAND boot feature.  <a href="#ab302e98b24747989dc80014b3af8e199"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-nand_8h.html#a2ce204f8d9bf170edc0eff27b0d642eb">cvmx_nand_correct_boot_ecc</a> (uint8_t *block)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check an Octeon ECC block, fixing errors if possible.  <a href="#a2ce204f8d9bf170edc0eff27b0d642eb"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This header defines the CVMX interface to the NAND flash controller. </p>
<p>The basic operations common to all NAND devices are supported by this API, but many more advanced functions are not support. The low level hardware supports all types of transactions, but this API only implements the must commonly used operations. This API performs no locking, so it is the responsibility of the caller to make sure only one thread of execution is accessing the NAND controller at a time. Most applications should not use this API directly but instead use a flash logical layer supplied through a secondary system. For example, the Linux MTD layer provides a driver for running JFFS2 on top of NAND flash.</p>
<h2>Selecting the NAND Chip</h2>
<p>Octeon's NAND controller assumes a single NAND chip is connected to a boot bus chip select. Throughout this API, NAND chips are referred to by the chip select they are connected to (0-7). Chip select 0 will only be a NAND chip when you are booting from NAND flash.</p>
<h2>NAND Addressing</h2>
<p>Various functions in cvmx-nand use addresses to index into NAND flash. All functions us a uniform address translation scheme to map the passed address into a NAND block, page, and column. In NAND flash a page represents the basic unit of reads and writes. Each page contains a power of two number of bytes and some number of extra out of band (OOB) bytes. A fixed number of pages fit into each NAND block. Here is the mapping of bits in the cvmx-nand address to the NAND hardware: </p>
<pre>
 63     56      48      40      32      24      16       8      0
 +-------+-------+-------+-------+-------+-------+-------+------+
 |                                 64 bit cvmx-nand nand_address|
 +------------------------------------------------+----+--------+
 |                                          block |page| column |
 +-------+-------+-------+-------+-------+--------+----+--------+
 63     56      48      40      32      24      16       8      0
 </pre><p> Basically the block, page, and column addresses are packet together. Before being sent out the NAND pins for addressing the column is padded out to an even number of bytes. This means that column address are 2 bytes, or 2 address cycles, for page sizes between 512 and 65536 bytes. Page sizes between 128KB and 16MB would use 3 column address cycles. NAND device normally either have 32 or 64 pages per block, needing either 5 or 6 address bits respectively. This means you have 10 bits for block address using 4 address cycles, or 18 for 5 address cycles. Using the cvmx-nand addressing scheme, it is not possible to directly index the OOB data. Instead you can access it by reading or writing more data than the normal page size would allow. Logically the OOB data is appended onto the the page data. For example, this means that a read of 65 bytes from a column address of 0x7ff would yield byte 2047 of the page and then 64 bytes of OOB data.</p>
<hr/>
<dl class="rcs"><dt><b>Revision</b></dt><dd>35726 </dd></dl>
<hr/>
 <hr/><h2>Define Documentation</h2>
<a class="anchor" id="a1687aa636d59d008493fdebfae09d781"></a><!-- doxytag: member="cvmx&#45;nand.h::CVMX_NAND_BOOT_ECC_BLOCK_SIZE" ref="a1687aa636d59d008493fdebfae09d781" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CVMX_NAND_BOOT_ECC_BLOCK_SIZE&nbsp;&nbsp;&nbsp;(256)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af26410da4933c438f03b0f4d6629388c"></a><!-- doxytag: member="cvmx&#45;nand.h::CVMX_NAND_BOOT_ECC_ECC_SIZE" ref="af26410da4933c438f03b0f4d6629388c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CVMX_NAND_BOOT_ECC_ECC_SIZE&nbsp;&nbsp;&nbsp;(8)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a74d68388fc13c125989d334ad93c750d"></a><!-- doxytag: member="cvmx&#45;nand.h::CVMX_NAND_MAX_PAGE_AND_OOB_SIZE" ref="a74d68388fc13c125989d334ad93c750d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CVMX_NAND_MAX_PAGE_AND_OOB_SIZE&nbsp;&nbsp;&nbsp;(16384 + 512)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a16a1444b15a746cfc6bcdc7ea2852ba2"></a><!-- doxytag: member="cvmx&#45;nand.h::cvmx_nand_initialize_flags_t" ref="a16a1444b15a746cfc6bcdc7ea2852ba2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cvmx-nand_8h.html#a16a1444b15a746cfc6bcdc7ea2852ba2">cvmx_nand_initialize_flags_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flags to be passed to the initialize function. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a16a1444b15a746cfc6bcdc7ea2852ba2ad7fe1312cdefb54dc94905c76b4de53f"></a><!-- doxytag: member="CVMX_NAND_INITIALIZE_FLAGS_16BIT" ref="a16a1444b15a746cfc6bcdc7ea2852ba2ad7fe1312cdefb54dc94905c76b4de53f" args="" -->CVMX_NAND_INITIALIZE_FLAGS_16BIT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a16a1444b15a746cfc6bcdc7ea2852ba2a1084249d377e5c043004901c998aa0e4"></a><!-- doxytag: member="CVMX_NAND_INITIALIZE_FLAGS_DONT_PROBE" ref="a16a1444b15a746cfc6bcdc7ea2852ba2a1084249d377e5c043004901c998aa0e4" args="" -->CVMX_NAND_INITIALIZE_FLAGS_DONT_PROBE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a16a1444b15a746cfc6bcdc7ea2852ba2afe4ebffedde329a8abac3bc079e53f70"></a><!-- doxytag: member="CVMX_NAND_INITIALIZE_FLAGS_DEBUG" ref="a16a1444b15a746cfc6bcdc7ea2852ba2afe4ebffedde329a8abac3bc079e53f70" args="" -->CVMX_NAND_INITIALIZE_FLAGS_DEBUG</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a0137d742aae515cbe1dae6e1bf3a8c7e"></a><!-- doxytag: member="cvmx&#45;nand.h::cvmx_nand_status_t" ref="a0137d742aae515cbe1dae6e1bf3a8c7e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e">cvmx_nand_status_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return codes from NAND functions. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a0137d742aae515cbe1dae6e1bf3a8c7ea0b283d8a2005757e120b6a3d94d6d7b7"></a><!-- doxytag: member="CVMX_NAND_SUCCESS" ref="a0137d742aae515cbe1dae6e1bf3a8c7ea0b283d8a2005757e120b6a3d94d6d7b7" args="" -->CVMX_NAND_SUCCESS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0137d742aae515cbe1dae6e1bf3a8c7ea76f80b04f5a782ee2b9fdf77cc037657"></a><!-- doxytag: member="CVMX_NAND_NO_MEMORY" ref="a0137d742aae515cbe1dae6e1bf3a8c7ea76f80b04f5a782ee2b9fdf77cc037657" args="" -->CVMX_NAND_NO_MEMORY</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0137d742aae515cbe1dae6e1bf3a8c7eae3651df6193757d96848e1c608ab6979"></a><!-- doxytag: member="CVMX_NAND_BUSY" ref="a0137d742aae515cbe1dae6e1bf3a8c7eae3651df6193757d96848e1c608ab6979" args="" -->CVMX_NAND_BUSY</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0137d742aae515cbe1dae6e1bf3a8c7ea0efc16e9ec584b118159a22480eaaf02"></a><!-- doxytag: member="CVMX_NAND_INVALID_PARAM" ref="a0137d742aae515cbe1dae6e1bf3a8c7ea0efc16e9ec584b118159a22480eaaf02" args="" -->CVMX_NAND_INVALID_PARAM</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0137d742aae515cbe1dae6e1bf3a8c7ea7da559e45bd5bb3665ec005ea7315f77"></a><!-- doxytag: member="CVMX_NAND_TIMEOUT" ref="a0137d742aae515cbe1dae6e1bf3a8c7ea7da559e45bd5bb3665ec005ea7315f77" args="" -->CVMX_NAND_TIMEOUT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0137d742aae515cbe1dae6e1bf3a8c7ea8e10bd7a041320af01eb5527020f715a"></a><!-- doxytag: member="CVMX_NAND_ERROR" ref="a0137d742aae515cbe1dae6e1bf3a8c7ea8e10bd7a041320af01eb5527020f715a" args="" -->CVMX_NAND_ERROR</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0137d742aae515cbe1dae6e1bf3a8c7ea856d413d967f7398570456668175a7f5"></a><!-- doxytag: member="CVMX_NAND_NO_DEVICE" ref="a0137d742aae515cbe1dae6e1bf3a8c7ea856d413d967f7398570456668175a7f5" args="" -->CVMX_NAND_NO_DEVICE</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a3f554501e7b9d058908d4806cc14440e"></a><!-- doxytag: member="cvmx&#45;nand.h::cvmx_nand_block_erase" ref="a3f554501e7b9d058908d4806cc14440e" args="(int chip, uint64_t nand_address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e">cvmx_nand_status_t</a> cvmx_nand_block_erase </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>chip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>nand_address</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase a NAND block. </p>
<p>A single block contains multiple pages.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chip</em>&nbsp;</td><td>Chip select for NAND flash </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nand_address</em>&nbsp;</td><td>Location in NAND to erase. See description in file comment</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Zero on success, a negative cvmx_nand_status_t error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ab302e98b24747989dc80014b3af8e199"></a><!-- doxytag: member="cvmx&#45;nand.h::cvmx_nand_compute_boot_ecc" ref="ab302e98b24747989dc80014b3af8e199" args="(unsigned char *block, unsigned char *eccp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvmx_nand_compute_boot_ecc </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>eccp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function computes the Octeon specific ECC data used by the NAND boot feature. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>pointer to 256 bytes of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eccp</em>&nbsp;</td><td>pointer to where 8 bytes of ECC data will be stored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2ce204f8d9bf170edc0eff27b0d642eb"></a><!-- doxytag: member="cvmx&#45;nand.h::cvmx_nand_correct_boot_ecc" ref="a2ce204f8d9bf170edc0eff27b0d642eb" args="(uint8_t *block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_nand_correct_boot_ecc </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>block</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check an Octeon ECC block, fixing errors if possible. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>Pointer to block to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Zero if block has no errors, one if errors were corrected, two if the errors could not be corrected. </dd></dl>

</div>
</div>
<a class="anchor" id="acd6f9b1f5c08a186a2524c6f69c534e5"></a><!-- doxytag: member="cvmx&#45;nand.h::cvmx_nand_get_active_chips" ref="acd6f9b1f5c08a186a2524c6f69c534e5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_nand_get_active_chips </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a bitmask representing the chip selects that are connected to NAND chips. </p>
<p>This can be called after initializing to determine the actual number of NAND chips found. Each bit in the response coresponds to a chip select.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Zero if no NAND chips were found. Otherwise a bit is set for each chip select (1&lt;&lt;chip).</dd></dl>
<p>This can be called after the initialize to determine the actual number of NAND chips found. Each bit in the response coresponds to a chip select.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Zero if no NAND chips were found. Otherwise a bit is set for each chip select (1&lt;&lt;chip). </dd></dl>

</div>
</div>
<a class="anchor" id="a85289e24ece28e5ca88d7e82499c7591"></a><!-- doxytag: member="cvmx&#45;nand.h::cvmx_nand_get_blocks" ref="a85289e24ece28e5ca88d7e82499c7591" args="(int chip)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_nand_get_blocks </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>chip</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of blocks in the NAND flash. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chip</em>&nbsp;</td><td>Chip select for NAND flash</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of blocks or a negative cvmx_nand_status_t error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a9391034206344a3b44164db430c9f372"></a><!-- doxytag: member="cvmx&#45;nand.h::cvmx_nand_get_feature" ref="a9391034206344a3b44164db430c9f372" args="(int chip, uint8_t feat_num, uint8_t feature[4])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e">cvmx_nand_status_t</a> cvmx_nand_get_feature </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>chip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>feat_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>feature</em>[4]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the specified feature number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chip</em>&nbsp;</td><td>Chip select for NAND flash </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>feat_num</em>&nbsp;</td><td>Feature number to get </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>feature</em>&nbsp;</td><td>P1 - P4 of the feature data</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>cvmx_nand_status_t error code </dd></dl>

</div>
</div>
<a class="anchor" id="a0d4059ce266ecabd68c7c7dc7651cb6c"></a><!-- doxytag: member="cvmx&#45;nand.h::cvmx_nand_get_oob_size" ref="a0d4059ce266ecabd68c7c7dc7651cb6c" args="(int chip)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_nand_get_oob_size </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>chip</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the OOB size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chip</em>&nbsp;</td><td>Chip select for NAND flash</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OOB in bytes or a negative cvmx_nand_status_t error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ada46144a8bc76da93f90cf4afd683ea6"></a><!-- doxytag: member="cvmx&#45;nand.h::cvmx_nand_get_page_size" ref="ada46144a8bc76da93f90cf4afd683ea6" args="(int chip)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_nand_get_page_size </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>chip</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the page size, excluding out of band data. </p>
<p>This function will return zero for chip selects not connected to NAND.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chip</em>&nbsp;</td><td>Chip select for NAND flash</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Page size in bytes or a negative cvmx_nand_status_t error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a0726e6f3c510046f5b8f62b85d2ebde4"></a><!-- doxytag: member="cvmx&#45;nand.h::cvmx_nand_get_pages_per_block" ref="a0726e6f3c510046f5b8f62b85d2ebde4" args="(int chip)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_nand_get_pages_per_block </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>chip</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of pages per NAND block. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chip</em>&nbsp;</td><td>Chip select for NAND flash</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Numboer of pages in each block or a negative cvmx_nand_status_t error code on failure</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chip</em>&nbsp;</td><td>Chip select for NAND flash</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of pages in each block or a negative cvmx_nand_status_t error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a5efec3568a962010d22aad3a42cfc0b8"></a><!-- doxytag: member="cvmx&#45;nand.h::cvmx_nand_get_status" ref="a5efec3568a962010d22aad3a42cfc0b8" args="(int chip)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_nand_get_status </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>chip</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the status of the NAND flash. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chip</em>&nbsp;</td><td>Chip select for NAND flash</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NAND status or a negative cvmx_nand_status_t error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="afa5bf87c53c60362a32a3a99a078d3a1"></a><!-- doxytag: member="cvmx&#45;nand.h::cvmx_nand_initialize" ref="afa5bf87c53c60362a32a3a99a078d3a1" args="(cvmx_nand_initialize_flags_t flags, int active_chips)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e">cvmx_nand_status_t</a> cvmx_nand_initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cvmx-nand_8h.html#a16a1444b15a746cfc6bcdc7ea2852ba2">cvmx_nand_initialize_flags_t</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>active_chips</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called to initialize the NAND controller for use. </p>
<p>Note that you must be running out of L2 or memory and not NAND before calling this function. When probing for NAND chips, this function attempts to autoconfigure based on the NAND parts detected. It currently supports autodetection for ONFI parts (with valid parameter pages), and some Samsung NAND parts (decoding ID bits). If autoconfiguration fails, the defaults set with <a class="el" href="cvmx-nand_8c.html#a8c68ed87350f59c97c16b61bbd956a57">__set_chip_defaults()</a> prior to calling <a class="el" href="cvmx-nand_8c.html#afa5bf87c53c60362a32a3a99a078d3a1" title="Called to initialize the NAND controller for use.">cvmx_nand_initialize()</a> are used. If defaults are set and the CVMX_NAND_INITIALIZE_FLAGS_DONT_PROBE flag is provided, the defaults are used for all chips in the active_chips mask.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Optional initialization flags If the CVMX_NAND_INITIALIZE_FLAGS_DONT_PROBE flag is passed, chips are not probed and the default parameters, if set with cvmx_nand_set_defaults, are used for all chips in the active_chips mask. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>active_chips</em>&nbsp;</td><td>Each bit in this parameter represents a chip select that might contain NAND flash. Any chip select present in this bitmask may be connected to NAND. It is normally safe to pass 0xff here and let the API probe all 8 chip selects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Zero on success, a negative cvmx_nand_status_t error code on failure</dd></dl>
<p>Note that you must be running out of L2 or memory and not NAND before calling this function. When probing for NAND chips, this function attempts to autoconfigure based on the NAND parts detected. It currently supports autodetection for ONFI parts (with valid parameter pages), and some Samsung NAND parts (decoding ID bits.) If autoconfiguration fails, the defaults set with <a class="el" href="cvmx-nand_8c.html#a8c68ed87350f59c97c16b61bbd956a57">__set_chip_defaults()</a> prior to calling <a class="el" href="cvmx-nand_8c.html#afa5bf87c53c60362a32a3a99a078d3a1" title="Called to initialize the NAND controller for use.">cvmx_nand_initialize()</a> are used. If defaults are set and the CVMX_NAND_INITIALIZE_FLAGS_DONT_PROBE flag is provided, the defaults are used for all chips in the active_chips mask.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Optional initialization flags If the CVMX_NAND_INITIALIZE_FLAGS_DONT_PROBE flag is passed, chips are not probed, and the default parameters (if set with cvmx_nand_set_defaults) are used for all chips in the active_chips mask. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>active_chips</em>&nbsp;</td><td>Each bit in this parameter represents a chip select that might contain NAND flash. Any chip select present in this bitmask may be connected to NAND. It is normally safe to pass 0xff here and let the API probe all 8 chip selects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Zero on success, a negative cvmx_nand_status error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="af7f9773c35b8169c1574395e3dd64d7f"></a><!-- doxytag: member="cvmx&#45;nand.h::cvmx_nand_onfi_process" ref="af7f9773c35b8169c1574395e3dd64d7f" args="(cvmx_nand_onfi_param_page_t param_page[3])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcvmx__nand__onfi__param__page__t.html">cvmx_nand_onfi_param_page_t</a>* cvmx_nand_onfi_process </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__nand__onfi__param__page__t.html">cvmx_nand_onfi_param_page_t</a>&nbsp;</td>
          <td class="paramname"> <em>param_page</em>[3]</td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Validate the ONFI parameter page and return a pointer to the config values. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>param_page</em>&nbsp;</td><td>Pointer to the raw NAND data returned after a parameter page read. It will contain at least 3 copies of the parameter structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to a validated paramter page, or NULL if one couldn't be found. </dd></dl>

<p><p>&lt; Byte 166-253: Vendor specific </p>
</p>

</div>
</div>
<a class="anchor" id="a4e923fd882cf8b709ea45bbcc97c882a"></a><!-- doxytag: member="cvmx&#45;nand.h::cvmx_nand_page_read" ref="a4e923fd882cf8b709ea45bbcc97c882a" args="(int chip, uint64_t nand_address, uint64_t buffer_address, int buffer_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_nand_page_read </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>chip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>nand_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>buffer_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>buffer_length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a page from NAND. </p>
<p>If the buffer has room, the out of band data will be included.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chip</em>&nbsp;</td><td>Chip select for NAND flash </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nand_address</em>&nbsp;</td><td>Location in NAND to read. See description in file comment </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer_address</em>&nbsp;</td><td>Physical address to store the result at </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer_length</em>&nbsp;</td><td>Number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Bytes read on success, a negative cvmx_nand_status_t error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="af6431f766b56aa5518d5a1ff7064d3a8"></a><!-- doxytag: member="cvmx&#45;nand.h::cvmx_nand_page_write" ref="af6431f766b56aa5518d5a1ff7064d3a8" args="(int chip, uint64_t nand_address, uint64_t buffer_address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e">cvmx_nand_status_t</a> cvmx_nand_page_write </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>chip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>nand_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>buffer_address</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a page to NAND. </p>
<p>The buffer must contain the entire page including the out of band data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chip</em>&nbsp;</td><td>Chip select for NAND flash </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nand_address</em>&nbsp;</td><td>Location in NAND to write. See description in file comment </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer_address</em>&nbsp;</td><td>Physical address to read the data from</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Zero on success, a negative cvmx_nand_status_t error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="afc8ee87e6f8bf9fc17b45cadc9f52048"></a><!-- doxytag: member="cvmx&#45;nand.h::cvmx_nand_random_data_out" ref="afc8ee87e6f8bf9fc17b45cadc9f52048" args="(int chip, uint64_t nand_address, uint64_t buffer_address, int buffer_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_nand_random_data_out </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>chip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>nand_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>buffer_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>buffer_length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read random data from NAND. </p>
<p>This adjusts the column address before starting a read operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chip</em>&nbsp;</td><td>Chip select for NAND flash </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nand_address</em>&nbsp;</td><td>Location in NAND to read. NOTE: only the column bits are used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer_address</em>&nbsp;</td><td>Physical address to store the result at </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer_length</em>&nbsp;</td><td>Number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Bytes read on success, a negative cvmx_nand_status_t error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a44711e1a29d311926cee8ca48f44f201"></a><!-- doxytag: member="cvmx&#45;nand.h::cvmx_nand_read_id" ref="a44711e1a29d311926cee8ca48f44f201" args="(int chip, uint64_t nand_address, uint64_t buffer_address, int buffer_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_nand_read_id </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>chip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>nand_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>buffer_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>buffer_length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read the NAND ID information. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chip</em>&nbsp;</td><td>Chip select for NAND flash </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nand_address</em>&nbsp;</td><td>NAND address to read ID from. Usually this is either 0x0 or 0x20. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer_address</em>&nbsp;</td><td>Physical address to store data in </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer_length</em>&nbsp;</td><td>Length of the buffer. Usually this is 4 bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Bytes read on success, a negative cvmx_nand_status_t error code on failure</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chip</em>&nbsp;</td><td>Chip select for NAND flash </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nand_address</em>&nbsp;</td><td>NAND address to read ID from. Usually this is either 0 or 0x20. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer_address</em>&nbsp;</td><td>Physical address to store data in </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer_length</em>&nbsp;</td><td>Length of the buffer. Usually this is 4-8 bytes. For 16 bit mode, this must be twice as large as the actual expected data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Bytes read on success, a negative cvmx_nand_status_t error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="aff29480fd5a7ba882a9000300458de37"></a><!-- doxytag: member="cvmx&#45;nand.h::cvmx_nand_read_param_page" ref="aff29480fd5a7ba882a9000300458de37" args="(int chip, uint64_t buffer_address, int buffer_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_nand_read_param_page </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>chip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>buffer_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>buffer_length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read the NAND parameter page. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chip</em>&nbsp;</td><td>Chip select for NAND flash </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer_address</em>&nbsp;</td><td>Physical address to store data in </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer_length</em>&nbsp;</td><td>Length of the buffer. Usually this is 4 bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Bytes read on success, a negative cvmx_nand_status_t error code on failure</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chip</em>&nbsp;</td><td>Chip select for NAND flash </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer_address</em>&nbsp;</td><td>Physical address to store data in </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer_length</em>&nbsp;</td><td>Length of the buffer. Usually 1024 bytes for 8 bit, 2048 for 16 bit mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Bytes read on success, a negative cvmx_nand_status_t error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a28d7bd4c07f5fcb7687e591d6419e5b0"></a><!-- doxytag: member="cvmx&#45;nand.h::cvmx_nand_reset" ref="a28d7bd4c07f5fcb7687e591d6419e5b0" args="(int chip)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e">cvmx_nand_status_t</a> cvmx_nand_reset </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>chip</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset the NAND flash. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chip</em>&nbsp;</td><td>Chip select for NAND flash</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Zero on success, a negative cvmx_nand_status_t error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a8103e18da67b88790a7c1d833aa8c3d9"></a><!-- doxytag: member="cvmx&#45;nand.h::cvmx_nand_set_defaults" ref="a8103e18da67b88790a7c1d833aa8c3d9" args="(int page_size, int oob_size, int pages_per_block, int blocks, int onfi_timing_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e">cvmx_nand_status_t</a> cvmx_nand_set_defaults </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>oob_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pages_per_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>onfi_timing_mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function may be called before cvmx_nand_initialize to set default values that will be used for NAND chips that do not identify themselves in a way that allows autoconfiguration. </p>
<p>(ONFI chip with missing parameter page, for example). The parameters set by this function will be used by _all_ non-autoconfigured NAND chips.</p>
<p>NOTE: This function signature is _NOT_ stable, and will change in the future as required to support various NAND chips.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>page_size</em>&nbsp;</td><td>page size in bytes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oob_size</em>&nbsp;</td><td>Out of band size in bytes (per page) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pages_per_block</em>&nbsp;</td><td>number of pages per block </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blocks</em>&nbsp;</td><td>Total number of blocks in device </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>onfi_timing_mode</em>&nbsp;</td><td>ONFI timing mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Zero on success, a negative cvmx_nand_status_t error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a2c36d924afdf9107b2634c7d18685150"></a><!-- doxytag: member="cvmx&#45;nand.h::cvmx_nand_set_feature" ref="a2c36d924afdf9107b2634c7d18685150" args="(int chip, uint8_t feat_num, const uint8_t feature[4])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e">cvmx_nand_status_t</a> cvmx_nand_set_feature </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>chip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>feat_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>feature</em>[4]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the specified feature number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chip</em>&nbsp;</td><td>Chip select for NAND flash </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>feat_num</em>&nbsp;</td><td>Feature number to get </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>feature</em>&nbsp;</td><td>P1 - P4 of the feature data</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>cvmx_nand_status_t error code </dd></dl>

</div>
</div>
<a class="anchor" id="afd05a3961ab8ee9a75815550d9b3f7a1"></a><!-- doxytag: member="cvmx&#45;nand.h::cvmx_nand_set_timing" ref="afd05a3961ab8ee9a75815550d9b3f7a1" args="(int chip, int tim_mult, int tim_par[7], int clen[4], int alen[4], int rdn[4], int wrn[2])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e">cvmx_nand_status_t</a> cvmx_nand_set_timing </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>chip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>tim_mult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>tim_par</em>[7], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>clen</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>alen</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rdn</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>wrn</em>[2]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Override the timing parameters for a NAND chip. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chip</em>&nbsp;</td><td>Chip select to override </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tim_mult</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tim_par</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clen</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alen</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rdn</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wrn</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Zero on success, a negative cvmx_nand_status_t error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a93972a7e4c00631d921d8294082cf0cc"></a><!-- doxytag: member="cvmx&#45;nand.h::cvmx_nand_shutdown" ref="a93972a7e4c00631d921d8294082cf0cc" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e">cvmx_nand_status_t</a> cvmx_nand_shutdown </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call to shutdown the NAND controller after all transactions are done. </p>
<p>In most setups this will never be called.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Zero on success, a negative cvmx_nand_status_t error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ad486b46c5d4dc5572acc90fbb568d64e"></a><!-- doxytag: member="cvmx&#45;nand.h::cvmx_nand_submit" ref="ad486b46c5d4dc5572acc90fbb568d64e" args="(cvmx_nand_cmd_t cmd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e">cvmx_nand_status_t</a> cvmx_nand_submit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unioncvmx__nand__cmd__t.html">cvmx_nand_cmd_t</a>&nbsp;</td>
          <td class="paramname"> <em>cmd</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Submit a command to the NAND command queue. </p>
<p>Generally this will not be used directly. Instead most programs will use the other higher level NAND functions.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cmd</em>&nbsp;</td><td>Command to submit</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Zero on success, a negative cvmx_nand_status_t error code on failure </dd></dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Oct 2017 for Octeon Software Development Kit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
