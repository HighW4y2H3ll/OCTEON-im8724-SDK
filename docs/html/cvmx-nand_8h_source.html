<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Octeon Software Development Kit: cvmx-nand.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>cvmx-nand.h</h1><a href="cvmx-nand_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/***********************license start***************</span>
<a name="l00002"></a>00002 <span class="comment"> * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com).  All rights</span>
<a name="l00003"></a>00003 <span class="comment"> * reserved.</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<a name="l00007"></a>00007 <span class="comment"> * modification, are permitted provided that the following conditions are</span>
<a name="l00008"></a>00008 <span class="comment"> * met:</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> *   * Redistributions of source code must retain the above copyright</span>
<a name="l00011"></a>00011 <span class="comment"> *     notice, this list of conditions and the following disclaimer.</span>
<a name="l00012"></a>00012 <span class="comment"> *</span>
<a name="l00013"></a>00013 <span class="comment"> *   * Redistributions in binary form must reproduce the above</span>
<a name="l00014"></a>00014 <span class="comment"> *     copyright notice, this list of conditions and the following</span>
<a name="l00015"></a>00015 <span class="comment"> *     disclaimer in the documentation and/or other materials provided</span>
<a name="l00016"></a>00016 <span class="comment"> *     with the distribution.</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment"> *   * Neither the name of Cavium Inc. nor the names of</span>
<a name="l00019"></a>00019 <span class="comment"> *     its contributors may be used to endorse or promote products</span>
<a name="l00020"></a>00020 <span class="comment"> *     derived from this software without specific prior written</span>
<a name="l00021"></a>00021 <span class="comment"> *     permission.</span>
<a name="l00022"></a>00022 <span class="comment"></span>
<a name="l00023"></a>00023 <span class="comment"> * This Software, including technical data, may be subject to U.S. export control</span>
<a name="l00024"></a>00024 <span class="comment"> * laws, including the U.S. Export Administration Act and its  associated</span>
<a name="l00025"></a>00025 <span class="comment"> * regulations, and may be subject to export or import  regulations in other</span>
<a name="l00026"></a>00026 <span class="comment"> * countries.</span>
<a name="l00027"></a>00027 <span class="comment"></span>
<a name="l00028"></a>00028 <span class="comment"> * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED &quot;AS IS&quot;</span>
<a name="l00029"></a>00029 <span class="comment"> * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR</span>
<a name="l00030"></a>00030 <span class="comment"> * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO</span>
<a name="l00031"></a>00031 <span class="comment"> * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR</span>
<a name="l00032"></a>00032 <span class="comment"> * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM</span>
<a name="l00033"></a>00033 <span class="comment"> * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,</span>
<a name="l00034"></a>00034 <span class="comment"> * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF</span>
<a name="l00035"></a>00035 <span class="comment"> * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR</span>
<a name="l00036"></a>00036 <span class="comment"> * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR</span>
<a name="l00037"></a>00037 <span class="comment"> * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.</span>
<a name="l00038"></a>00038 <span class="comment"> ***********************license end**************************************/</span>
<a name="l00039"></a>00039 <span class="comment"></span>
<a name="l00040"></a>00040 <span class="comment">/**</span>
<a name="l00041"></a>00041 <span class="comment"> * @file</span>
<a name="l00042"></a>00042 <span class="comment"> *</span>
<a name="l00043"></a>00043 <span class="comment"> * This header defines the CVMX interface to the NAND flash controller. The</span>
<a name="l00044"></a>00044 <span class="comment"> * basic operations common to all NAND devices are supported by this API, but</span>
<a name="l00045"></a>00045 <span class="comment"> * many more advanced functions are not support. The low level hardware supports</span>
<a name="l00046"></a>00046 <span class="comment"> * all types of transactions, but this API only implements the must commonly</span>
<a name="l00047"></a>00047 <span class="comment"> * used operations. This API performs no locking, so it is the responsibility of</span>
<a name="l00048"></a>00048 <span class="comment"> * the caller to make sure only one thread of execution is accessing the NAND</span>
<a name="l00049"></a>00049 <span class="comment"> * controller at a time. Most applications should not use this API directly but</span>
<a name="l00050"></a>00050 <span class="comment"> * instead use a flash logical layer supplied through a secondary system. For</span>
<a name="l00051"></a>00051 <span class="comment"> * example, the Linux MTD layer provides a driver for running JFFS2 on top of</span>
<a name="l00052"></a>00052 <span class="comment"> * NAND flash.</span>
<a name="l00053"></a>00053 <span class="comment"> *</span>
<a name="l00054"></a>00054 <span class="comment"> * &lt;h2&gt;Selecting the NAND Chip&lt;/h2&gt;</span>
<a name="l00055"></a>00055 <span class="comment"> *</span>
<a name="l00056"></a>00056 <span class="comment"> * Octeon&apos;s NAND controller assumes a single NAND chip is connected to a boot</span>
<a name="l00057"></a>00057 <span class="comment"> * bus chip select. Throughout this API, NAND chips are referred to by the chip</span>
<a name="l00058"></a>00058 <span class="comment"> * select they are connected to (0-7). Chip select 0 will only be a NAND chip</span>
<a name="l00059"></a>00059 <span class="comment"> * when you are booting from NAND flash.</span>
<a name="l00060"></a>00060 <span class="comment"> *</span>
<a name="l00061"></a>00061 <span class="comment"> * &lt;h2&gt;NAND Addressing&lt;/h2&gt;</span>
<a name="l00062"></a>00062 <span class="comment"> *</span>
<a name="l00063"></a>00063 <span class="comment"> * Various functions in cvmx-nand use addresses to index into NAND flash. All</span>
<a name="l00064"></a>00064 <span class="comment"> * functions us a uniform address translation scheme to map the passed address</span>
<a name="l00065"></a>00065 <span class="comment"> * into a NAND block, page, and column. In NAND flash a page represents the</span>
<a name="l00066"></a>00066 <span class="comment"> * basic unit of reads and writes. Each page contains a power of two number of</span>
<a name="l00067"></a>00067 <span class="comment"> * bytes and some number of extra out of band (OOB) bytes. A fixed number of</span>
<a name="l00068"></a>00068 <span class="comment"> * pages fit into each NAND block. Here is the mapping of bits in the cvmx-nand</span>
<a name="l00069"></a>00069 <span class="comment"> * address to the NAND hardware:</span>
<a name="l00070"></a>00070 <span class="comment"> * &lt;pre&gt;</span>
<a name="l00071"></a>00071 <span class="comment"> * 63     56      48      40      32      24      16       8      0</span>
<a name="l00072"></a>00072 <span class="comment"> * +-------+-------+-------+-------+-------+-------+-------+------+</span>
<a name="l00073"></a>00073 <span class="comment"> * |                                 64 bit cvmx-nand nand_address|</span>
<a name="l00074"></a>00074 <span class="comment"> * +------------------------------------------------+----+--------+</span>
<a name="l00075"></a>00075 <span class="comment"> * |                                          block |page| column |</span>
<a name="l00076"></a>00076 <span class="comment"> * +-------+-------+-------+-------+-------+--------+----+--------+</span>
<a name="l00077"></a>00077 <span class="comment"> * 63     56      48      40      32      24      16       8      0</span>
<a name="l00078"></a>00078 <span class="comment"> * &lt;/pre&gt;</span>
<a name="l00079"></a>00079 <span class="comment"> * Basically the block, page, and column addresses are packet together. Before</span>
<a name="l00080"></a>00080 <span class="comment"> * being sent out the NAND pins for addressing the column is padded out to an</span>
<a name="l00081"></a>00081 <span class="comment"> * even number of bytes. This means that column address are 2 bytes, or 2</span>
<a name="l00082"></a>00082 <span class="comment"> * address cycles, for page sizes between 512 and 65536 bytes. Page sizes</span>
<a name="l00083"></a>00083 <span class="comment"> * between 128KB and 16MB would use 3 column address cycles. NAND device</span>
<a name="l00084"></a>00084 <span class="comment"> * normally either have 32 or 64 pages per block, needing either 5 or 6 address</span>
<a name="l00085"></a>00085 <span class="comment"> * bits respectively. This means you have 10 bits for block address using 4</span>
<a name="l00086"></a>00086 <span class="comment"> * address cycles, or 18 for 5 address cycles. Using the cvmx-nand addressing</span>
<a name="l00087"></a>00087 <span class="comment"> * scheme, it is not possible to directly index the OOB data. Instead you can</span>
<a name="l00088"></a>00088 <span class="comment"> * access it by reading or writing more data than the normal page size would</span>
<a name="l00089"></a>00089 <span class="comment"> * allow. Logically the OOB data is appended onto the the page data. For</span>
<a name="l00090"></a>00090 <span class="comment"> * example, this means that a read of 65 bytes from a column address of 0x7ff</span>
<a name="l00091"></a>00091 <span class="comment"> * would yield byte 2047 of the page and then 64 bytes of OOB data.</span>
<a name="l00092"></a>00092 <span class="comment"> *</span>
<a name="l00093"></a>00093 <span class="comment"> * &lt;hr&gt;$Revision: 35726 $&lt;hr&gt;</span>
<a name="l00094"></a>00094 <span class="comment"> */</span>
<a name="l00095"></a>00095 
<a name="l00096"></a>00096 <span class="preprocessor">#ifndef __CVMX_NAND_H__</span>
<a name="l00097"></a>00097 <span class="preprocessor"></span><span class="preprocessor">#define __CVMX_NAND_H__</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span>
<a name="l00099"></a>00099 <span class="preprocessor">#ifdef  __cplusplus</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span><span class="comment">/* *INDENT-OFF* */</span>
<a name="l00101"></a>00101 <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {
<a name="l00102"></a>00102 <span class="comment">/* *INDENT-ON* */</span>
<a name="l00103"></a>00103 <span class="preprocessor">#endif</span>
<a name="l00104"></a>00104 <span class="preprocessor"></span>
<a name="l00105"></a>00105 <span class="comment">/* Maxium PAGE + OOB size supported.  This is used to size</span>
<a name="l00106"></a>00106 <span class="comment">** buffers, some that must be statically allocated. */</span>
<a name="l00107"></a><a class="code" href="cvmx-nand_8h.html#a74d68388fc13c125989d334ad93c750d">00107</a> <span class="preprocessor">#define CVMX_NAND_MAX_PAGE_AND_OOB_SIZE      (16384 + 512)</span>
<a name="l00108"></a>00108 <span class="preprocessor"></span>
<a name="l00109"></a>00109 <span class="comment">/* Block size for boot ECC */</span>
<a name="l00110"></a><a class="code" href="cvmx-nand_8h.html#a1687aa636d59d008493fdebfae09d781">00110</a> <span class="preprocessor">#define CVMX_NAND_BOOT_ECC_BLOCK_SIZE    (256)</span>
<a name="l00111"></a>00111 <span class="preprocessor"></span><span class="comment">/* ECC bytes for each block */</span>
<a name="l00112"></a><a class="code" href="cvmx-nand_8h.html#af26410da4933c438f03b0f4d6629388c">00112</a> <span class="preprocessor">#define CVMX_NAND_BOOT_ECC_ECC_SIZE      (8)</span>
<a name="l00113"></a>00113 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00114"></a>00114 <span class="comment">/**</span>
<a name="l00115"></a>00115 <span class="comment"> * Flags to be passed to the initialize function</span>
<a name="l00116"></a>00116 <span class="comment"> */</span>
<a name="l00117"></a><a class="code" href="cvmx-nand_8h.html#a16a1444b15a746cfc6bcdc7ea2852ba2">00117</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> {
<a name="l00118"></a><a class="code" href="cvmx-nand_8h.html#a16a1444b15a746cfc6bcdc7ea2852ba2ad7fe1312cdefb54dc94905c76b4de53f">00118</a>     <a class="code" href="cvmx-nand_8h.html#a16a1444b15a746cfc6bcdc7ea2852ba2ad7fe1312cdefb54dc94905c76b4de53f">CVMX_NAND_INITIALIZE_FLAGS_16BIT</a> = 1 &lt;&lt; 0,
<a name="l00119"></a><a class="code" href="cvmx-nand_8h.html#a16a1444b15a746cfc6bcdc7ea2852ba2a1084249d377e5c043004901c998aa0e4">00119</a>     <a class="code" href="cvmx-nand_8h.html#a16a1444b15a746cfc6bcdc7ea2852ba2a1084249d377e5c043004901c998aa0e4">CVMX_NAND_INITIALIZE_FLAGS_DONT_PROBE</a> = 1 &lt;&lt; 1,
<a name="l00120"></a><a class="code" href="cvmx-nand_8h.html#a16a1444b15a746cfc6bcdc7ea2852ba2afe4ebffedde329a8abac3bc079e53f70">00120</a>     <a class="code" href="cvmx-nand_8h.html#a16a1444b15a746cfc6bcdc7ea2852ba2afe4ebffedde329a8abac3bc079e53f70">CVMX_NAND_INITIALIZE_FLAGS_DEBUG</a> = 1 &lt;&lt; 15,
<a name="l00121"></a>00121 } <a class="code" href="cvmx-nand_8h.html#a16a1444b15a746cfc6bcdc7ea2852ba2" title="Flags to be passed to the initialize function.">cvmx_nand_initialize_flags_t</a>;
<a name="l00122"></a>00122 <span class="comment"></span>
<a name="l00123"></a>00123 <span class="comment">/**</span>
<a name="l00124"></a>00124 <span class="comment"> * Return codes from NAND functions</span>
<a name="l00125"></a>00125 <span class="comment"> */</span>
<a name="l00126"></a><a class="code" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e">00126</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> {
<a name="l00127"></a><a class="code" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7ea0b283d8a2005757e120b6a3d94d6d7b7">00127</a>     <a class="code" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7ea0b283d8a2005757e120b6a3d94d6d7b7">CVMX_NAND_SUCCESS</a> = 0,
<a name="l00128"></a><a class="code" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7ea76f80b04f5a782ee2b9fdf77cc037657">00128</a>     <a class="code" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7ea76f80b04f5a782ee2b9fdf77cc037657">CVMX_NAND_NO_MEMORY</a> = -1,
<a name="l00129"></a><a class="code" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7eae3651df6193757d96848e1c608ab6979">00129</a>     <a class="code" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7eae3651df6193757d96848e1c608ab6979">CVMX_NAND_BUSY</a> = -2,
<a name="l00130"></a><a class="code" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7ea0efc16e9ec584b118159a22480eaaf02">00130</a>     <a class="code" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7ea0efc16e9ec584b118159a22480eaaf02">CVMX_NAND_INVALID_PARAM</a> = -3,
<a name="l00131"></a><a class="code" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7ea7da559e45bd5bb3665ec005ea7315f77">00131</a>     <a class="code" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7ea7da559e45bd5bb3665ec005ea7315f77">CVMX_NAND_TIMEOUT</a> = -4,
<a name="l00132"></a><a class="code" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7ea8e10bd7a041320af01eb5527020f715a">00132</a>     <a class="code" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7ea8e10bd7a041320af01eb5527020f715a">CVMX_NAND_ERROR</a> = -5,
<a name="l00133"></a><a class="code" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7ea856d413d967f7398570456668175a7f5">00133</a>     <a class="code" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7ea856d413d967f7398570456668175a7f5">CVMX_NAND_NO_DEVICE</a> = -6,
<a name="l00134"></a>00134 } <a class="code" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e" title="Return codes from NAND functions.">cvmx_nand_status_t</a>;
<a name="l00135"></a>00135 <span class="comment"></span>
<a name="l00136"></a>00136 <span class="comment">/**</span>
<a name="l00137"></a>00137 <span class="comment"> * NAND NOP command definition</span>
<a name="l00138"></a>00138 <span class="comment"> */</span>
<a name="l00139"></a><a class="code" href="structcvmx__nand__cmd__nop__t.html">00139</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00140"></a><a class="code" href="structcvmx__nand__cmd__nop__t.html#a6e7a45834713e4632a5192149babb737">00140</a>     uint64_t reserved_64_127:64;
<a name="l00141"></a><a class="code" href="structcvmx__nand__cmd__nop__t.html#a7e86c1c94c0a10cdbaf5cb7181b78924">00141</a>     uint64_t reserved_4_63:60;
<a name="l00142"></a><a class="code" href="structcvmx__nand__cmd__nop__t.html#a3cf04a6ec3ccee35c5fe8cdb1ae6499d">00142</a>     uint64_t zero:4;
<a name="l00143"></a>00143 } <a class="code" href="structcvmx__nand__cmd__nop__t.html" title="NAND NOP command definition.">cvmx_nand_cmd_nop_t</a>;
<a name="l00144"></a>00144 <span class="comment"></span>
<a name="l00145"></a>00145 <span class="comment">/**</span>
<a name="l00146"></a>00146 <span class="comment"> * NAND SET_TM_PAR command definition</span>
<a name="l00147"></a>00147 <span class="comment"> */</span>
<a name="l00148"></a><a class="code" href="structcvmx__nand__cmd__set__tm__par__t.html">00148</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00149"></a><a class="code" href="structcvmx__nand__cmd__set__tm__par__t.html#a6c3e14c9bd76e6d89ee380c52842816b">00149</a>     uint64_t reserved_64_127:64;
<a name="l00150"></a><a class="code" href="structcvmx__nand__cmd__set__tm__par__t.html#a5495af219bc722b8f1d4b552b90ff230">00150</a>     uint64_t tim_par7:8;
<a name="l00151"></a><a class="code" href="structcvmx__nand__cmd__set__tm__par__t.html#afde4a720b5a1ebf4c901eebfe6534059">00151</a>     uint64_t tim_par6:8;
<a name="l00152"></a><a class="code" href="structcvmx__nand__cmd__set__tm__par__t.html#a4cffff500da64450316e0f5496f98461">00152</a>     uint64_t tim_par5:8;
<a name="l00153"></a><a class="code" href="structcvmx__nand__cmd__set__tm__par__t.html#af061c10ded4da6001a56fa3d5305b95f">00153</a>     uint64_t tim_par4:8;
<a name="l00154"></a><a class="code" href="structcvmx__nand__cmd__set__tm__par__t.html#a8cb103461c251dcdac7e1857d042d4f7">00154</a>     uint64_t tim_par3:8;
<a name="l00155"></a><a class="code" href="structcvmx__nand__cmd__set__tm__par__t.html#ad10960f4073f8d41189b7c5bf4f6ad6e">00155</a>     uint64_t tim_par2:8;
<a name="l00156"></a><a class="code" href="structcvmx__nand__cmd__set__tm__par__t.html#af6da73a365087a36e1de78ee781217e8">00156</a>     uint64_t tim_par1:8;
<a name="l00157"></a><a class="code" href="structcvmx__nand__cmd__set__tm__par__t.html#a70dc2755f305636e6255962c02b2fcac">00157</a>     uint64_t tim_mult:4;
<a name="l00158"></a><a class="code" href="structcvmx__nand__cmd__set__tm__par__t.html#ab13734bfe07c22717697c9b8f51e8463">00158</a>     uint64_t one:4;
<a name="l00159"></a>00159 } <a class="code" href="structcvmx__nand__cmd__set__tm__par__t.html" title="NAND SET_TM_PAR command definition.">cvmx_nand_cmd_set_tm_par_t</a>;
<a name="l00160"></a>00160 <span class="comment"></span>
<a name="l00161"></a>00161 <span class="comment">/**</span>
<a name="l00162"></a>00162 <span class="comment"> * NAND WAIT command definition</span>
<a name="l00163"></a>00163 <span class="comment"> */</span>
<a name="l00164"></a><a class="code" href="structcvmx__nand__cmd__wait__t.html">00164</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00165"></a><a class="code" href="structcvmx__nand__cmd__wait__t.html#a3e353701d1f078113934f7a85658808b">00165</a>     uint64_t reserved_64_127:64;
<a name="l00166"></a><a class="code" href="structcvmx__nand__cmd__wait__t.html#ac4f7e424572b4d51aa2498f43e015439">00166</a>     uint64_t reserved_11_63:53;
<a name="l00167"></a><a class="code" href="structcvmx__nand__cmd__wait__t.html#a4734b3782b83cdc9efcd22e3a0bca307">00167</a>     uint64_t n:3;
<a name="l00168"></a><a class="code" href="structcvmx__nand__cmd__wait__t.html#a6e6603e3e03cc69e7d15e0bab42d8c7a">00168</a>     uint64_t reserved_5_7:3;
<a name="l00169"></a><a class="code" href="structcvmx__nand__cmd__wait__t.html#a4eb8ad0410554e75d65989a850bd76c6">00169</a>     uint64_t r_b:1;
<a name="l00170"></a><a class="code" href="structcvmx__nand__cmd__wait__t.html#ae599d1a66ad462a0ff53f967b68fbc22">00170</a>     uint64_t two:4;
<a name="l00171"></a>00171 } <a class="code" href="structcvmx__nand__cmd__wait__t.html" title="NAND WAIT command definition.">cvmx_nand_cmd_wait_t</a>;
<a name="l00172"></a>00172 <span class="comment"></span>
<a name="l00173"></a>00173 <span class="comment">/**</span>
<a name="l00174"></a>00174 <span class="comment"> * NAND CHIP_EN command definition</span>
<a name="l00175"></a>00175 <span class="comment"> */</span>
<a name="l00176"></a><a class="code" href="structcvmx__nand__cmd__chip__en__t.html">00176</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00177"></a><a class="code" href="structcvmx__nand__cmd__chip__en__t.html#ad6c6afbf7dda15a6d2b9a0469077a2fc">00177</a>     uint64_t reserved_64_127:64;
<a name="l00178"></a><a class="code" href="structcvmx__nand__cmd__chip__en__t.html#ae45ad167a3d1f49e0295d9f5e99bdd2f">00178</a>     uint64_t reserved_10_63:54;
<a name="l00179"></a><a class="code" href="structcvmx__nand__cmd__chip__en__t.html#a7a458825df2fae60bdf9be42792e33ef">00179</a>     uint64_t width:2;
<a name="l00180"></a><a class="code" href="structcvmx__nand__cmd__chip__en__t.html#ae1d348d5d0602462f5790d97aa37f6f7">00180</a>     uint64_t one:1;
<a name="l00181"></a><a class="code" href="structcvmx__nand__cmd__chip__en__t.html#ad27d70b0d729d6f094e60cddbc8ba2b4">00181</a>     uint64_t chip:3;
<a name="l00182"></a><a class="code" href="structcvmx__nand__cmd__chip__en__t.html#a0ce3c7c490d4926fb1e44eb03eccb814">00182</a>     uint64_t three:4;
<a name="l00183"></a>00183 } <a class="code" href="structcvmx__nand__cmd__chip__en__t.html" title="NAND CHIP_EN command definition.">cvmx_nand_cmd_chip_en_t</a>;
<a name="l00184"></a>00184 <span class="comment"></span>
<a name="l00185"></a>00185 <span class="comment">/**</span>
<a name="l00186"></a>00186 <span class="comment"> * NAND CHIP_DIS command definition</span>
<a name="l00187"></a>00187 <span class="comment"> */</span>
<a name="l00188"></a><a class="code" href="structcvmx__nand__cmd__chip__dis__t.html">00188</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00189"></a><a class="code" href="structcvmx__nand__cmd__chip__dis__t.html#aff6092f85f65d97d461cfb0ad6cd0d53">00189</a>     uint64_t reserved_64_127:64;
<a name="l00190"></a><a class="code" href="structcvmx__nand__cmd__chip__dis__t.html#ae7aa090b55b484f292ea1153353ec14c">00190</a>     uint64_t reserved_4_63:60;
<a name="l00191"></a><a class="code" href="structcvmx__nand__cmd__chip__dis__t.html#a63a9f080d4ee89323569c531fbd50d23">00191</a>     uint64_t three:4;
<a name="l00192"></a>00192 } <a class="code" href="structcvmx__nand__cmd__chip__dis__t.html" title="NAND CHIP_DIS command definition.">cvmx_nand_cmd_chip_dis_t</a>;
<a name="l00193"></a>00193 <span class="comment"></span>
<a name="l00194"></a>00194 <span class="comment">/**</span>
<a name="l00195"></a>00195 <span class="comment"> * NAND CLE command definition</span>
<a name="l00196"></a>00196 <span class="comment"> */</span>
<a name="l00197"></a><a class="code" href="structcvmx__nand__cmd__cle__t.html">00197</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00198"></a><a class="code" href="structcvmx__nand__cmd__cle__t.html#ad720cbde5c54fde9207d471170cc8bb7">00198</a>     uint64_t reserved_64_127:64;
<a name="l00199"></a><a class="code" href="structcvmx__nand__cmd__cle__t.html#ab6bfddd30ac87ff771454cb0d3d591cf">00199</a>     uint64_t reserved_25_63:39;
<a name="l00200"></a><a class="code" href="structcvmx__nand__cmd__cle__t.html#a17236d6c8858c246ec83ad948f065fd4">00200</a>     uint64_t clen3:3;
<a name="l00201"></a><a class="code" href="structcvmx__nand__cmd__cle__t.html#ae4fa72386d50845cd4452c2ea3bcbfb8">00201</a>     uint64_t clen2:3;
<a name="l00202"></a><a class="code" href="structcvmx__nand__cmd__cle__t.html#a1a2f7bfc2b9bfd1fb1fd1e2c1deb6048">00202</a>     uint64_t clen1:3;
<a name="l00203"></a><a class="code" href="structcvmx__nand__cmd__cle__t.html#add666bf195c466523f7ab865578b3a1f">00203</a>     uint64_t cmd_data:8;
<a name="l00204"></a><a class="code" href="structcvmx__nand__cmd__cle__t.html#a1f87c4117293bc34e9e64ae250c23e40">00204</a>     uint64_t reserved_4_7:4;
<a name="l00205"></a><a class="code" href="structcvmx__nand__cmd__cle__t.html#af65da61d69dd81e588ed31393377d43a">00205</a>     uint64_t four:4;
<a name="l00206"></a>00206 } <a class="code" href="structcvmx__nand__cmd__cle__t.html" title="NAND CLE command definition.">cvmx_nand_cmd_cle_t</a>;
<a name="l00207"></a>00207 <span class="comment"></span>
<a name="l00208"></a>00208 <span class="comment">/**</span>
<a name="l00209"></a>00209 <span class="comment"> * NAND ALE command definition</span>
<a name="l00210"></a>00210 <span class="comment"> */</span>
<a name="l00211"></a><a class="code" href="structcvmx__nand__cmd__ale__t.html">00211</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00212"></a><a class="code" href="structcvmx__nand__cmd__ale__t.html#a487be50485d9a79d2941cde04585d8ea">00212</a>     uint64_t reserved_96_127:32;
<a name="l00213"></a><a class="code" href="structcvmx__nand__cmd__ale__t.html#aa6f735a763ed33637edc55df6a4b329c">00213</a>     uint64_t adr_bytes_h:32;
<a name="l00214"></a><a class="code" href="structcvmx__nand__cmd__ale__t.html#a066d50aa135d0e6e1513559743e57e71">00214</a>     uint64_t adr_bytes_l:32;
<a name="l00215"></a><a class="code" href="structcvmx__nand__cmd__ale__t.html#a626892bca44586070df7ea8c3f58e135">00215</a>     uint64_t reserved_28_31:4;
<a name="l00216"></a><a class="code" href="structcvmx__nand__cmd__ale__t.html#a8f529625ae1b46728f7abd54b5b9ee40">00216</a>     uint64_t alen4:3;
<a name="l00217"></a><a class="code" href="structcvmx__nand__cmd__ale__t.html#ab6e961cfa916e9b561f1103c3fbb2344">00217</a>     uint64_t alen3:3;
<a name="l00218"></a><a class="code" href="structcvmx__nand__cmd__ale__t.html#a2e16bc2f4bc49d7855373910040fa550">00218</a>     uint64_t alen2:3;
<a name="l00219"></a><a class="code" href="structcvmx__nand__cmd__ale__t.html#aea89dc9808e29925973c41a56fe48467">00219</a>     uint64_t alen1:3;
<a name="l00220"></a><a class="code" href="structcvmx__nand__cmd__ale__t.html#a688f4c46ab676e6e0fe0a6062a08183f">00220</a>     uint64_t reserved_12_15:4;
<a name="l00221"></a><a class="code" href="structcvmx__nand__cmd__ale__t.html#ac4c47a45757761f2fdf21ae0f43af262">00221</a>     uint64_t adr_byte_num:4;
<a name="l00222"></a><a class="code" href="structcvmx__nand__cmd__ale__t.html#a66c08b7eb8bcc1e9b4a75284240040f0">00222</a>     uint64_t reserved_4_7:4;
<a name="l00223"></a><a class="code" href="structcvmx__nand__cmd__ale__t.html#af5cfa1836cf225661bf916b50d32f128">00223</a>     uint64_t five:4;
<a name="l00224"></a>00224 } <a class="code" href="structcvmx__nand__cmd__ale__t.html" title="NAND ALE command definition.">cvmx_nand_cmd_ale_t</a>;
<a name="l00225"></a>00225 <span class="comment"></span>
<a name="l00226"></a>00226 <span class="comment">/**</span>
<a name="l00227"></a>00227 <span class="comment"> * NAND WR command definition</span>
<a name="l00228"></a>00228 <span class="comment"> */</span>
<a name="l00229"></a><a class="code" href="structcvmx__nand__cmd__wr__t.html">00229</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00230"></a><a class="code" href="structcvmx__nand__cmd__wr__t.html#a244e9dd1e8e526148f38ca7eed6d3834">00230</a>     uint64_t reserved_64_127:64;
<a name="l00231"></a><a class="code" href="structcvmx__nand__cmd__wr__t.html#ac9e4065d7dd184d335a94586cbb01371">00231</a>     uint64_t reserved_31_63:34;
<a name="l00232"></a><a class="code" href="structcvmx__nand__cmd__wr__t.html#a0c0cda92585c343eab92ba7bdb610bd6">00232</a>     uint64_t wrn2:3;
<a name="l00233"></a><a class="code" href="structcvmx__nand__cmd__wr__t.html#a8dbe3189f78ec06b48f132ddf8eb85ae">00233</a>     uint64_t wrn1:3;
<a name="l00234"></a><a class="code" href="structcvmx__nand__cmd__wr__t.html#a0f3dbedb3f47cfeb7ddbe86616a22098">00234</a>     uint64_t reserved_20_24:4;
<a name="l00235"></a><a class="code" href="structcvmx__nand__cmd__wr__t.html#adba40d10e90d2ce10cdb87f631afba12">00235</a>     uint64_t data_bytes:16;
<a name="l00236"></a><a class="code" href="structcvmx__nand__cmd__wr__t.html#ad1f25c3f99148f5946f90274952015e7">00236</a>     uint64_t eight:4;
<a name="l00237"></a>00237 } <a class="code" href="structcvmx__nand__cmd__wr__t.html" title="NAND WR command definition.">cvmx_nand_cmd_wr_t</a>;
<a name="l00238"></a>00238 <span class="comment"></span>
<a name="l00239"></a>00239 <span class="comment">/**</span>
<a name="l00240"></a>00240 <span class="comment"> * NAND RD command definition</span>
<a name="l00241"></a>00241 <span class="comment"> */</span>
<a name="l00242"></a><a class="code" href="structcvmx__nand__cmd__rd__t.html">00242</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00243"></a><a class="code" href="structcvmx__nand__cmd__rd__t.html#ad05bd849395451768f7f204ef6bfc365">00243</a>     uint64_t reserved_64_127:64;
<a name="l00244"></a><a class="code" href="structcvmx__nand__cmd__rd__t.html#a726e13dd3cba6add90daf0751180dd21">00244</a>     uint64_t reserved_32_63:32;
<a name="l00245"></a><a class="code" href="structcvmx__nand__cmd__rd__t.html#a66705468f0bde7ac76c2de6c48c0b789">00245</a>     uint64_t rdn4:3;
<a name="l00246"></a><a class="code" href="structcvmx__nand__cmd__rd__t.html#ab92736ecd66e33046efe155ebb7c0fa1">00246</a>     uint64_t rdn3:3;
<a name="l00247"></a><a class="code" href="structcvmx__nand__cmd__rd__t.html#a86c6e67fe3d38f4a14367517f4d1294f">00247</a>     uint64_t rdn2:3;
<a name="l00248"></a><a class="code" href="structcvmx__nand__cmd__rd__t.html#a04f4bc17495e1c2ae2bea61feb960ffc">00248</a>     uint64_t rdn1:3;
<a name="l00249"></a><a class="code" href="structcvmx__nand__cmd__rd__t.html#a00dd98a40d7303845dbe43bf86e4ce13">00249</a>     uint64_t data_bytes:16;
<a name="l00250"></a><a class="code" href="structcvmx__nand__cmd__rd__t.html#ad729a9396978f97103ffdb6917a28376">00250</a>     uint64_t nine:4;
<a name="l00251"></a>00251 } <a class="code" href="structcvmx__nand__cmd__rd__t.html" title="NAND RD command definition.">cvmx_nand_cmd_rd_t</a>;
<a name="l00252"></a>00252 <span class="comment"></span>
<a name="l00253"></a>00253 <span class="comment">/**</span>
<a name="l00254"></a>00254 <span class="comment"> * NAND RD_EDO command definition</span>
<a name="l00255"></a>00255 <span class="comment"> */</span>
<a name="l00256"></a><a class="code" href="structcvmx__nand__cmd__rd__edo__t.html">00256</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00257"></a><a class="code" href="structcvmx__nand__cmd__rd__edo__t.html#a0544762b9ed8c2521d2191328583f68f">00257</a>     uint64_t reserved_64_127:64;
<a name="l00258"></a><a class="code" href="structcvmx__nand__cmd__rd__edo__t.html#a5eee601c3b570449c5e81022b805713b">00258</a>     uint64_t reserved_32_63:32;
<a name="l00259"></a><a class="code" href="structcvmx__nand__cmd__rd__edo__t.html#a898a14ce52e090f9c5c76d2c481ca6be">00259</a>     uint64_t rdn4:3;
<a name="l00260"></a><a class="code" href="structcvmx__nand__cmd__rd__edo__t.html#aadc5daa08616c4180ead70ccc46b8442">00260</a>     uint64_t rdn3:3;
<a name="l00261"></a><a class="code" href="structcvmx__nand__cmd__rd__edo__t.html#ab9d829750aa78048c6ac9a08a34d8d36">00261</a>     uint64_t rdn2:3;
<a name="l00262"></a><a class="code" href="structcvmx__nand__cmd__rd__edo__t.html#adacfe1fabb82564c1761fe176188c1d1">00262</a>     uint64_t rdn1:3;
<a name="l00263"></a><a class="code" href="structcvmx__nand__cmd__rd__edo__t.html#a8a34f4559b9fa5563b379b0da61f8064">00263</a>     uint64_t data_bytes:16;
<a name="l00264"></a><a class="code" href="structcvmx__nand__cmd__rd__edo__t.html#a032daeb2aa4c20e602e96ae3c054c85d">00264</a>     uint64_t ten:4;
<a name="l00265"></a>00265 } <a class="code" href="structcvmx__nand__cmd__rd__edo__t.html" title="NAND RD_EDO command definition.">cvmx_nand_cmd_rd_edo_t</a>;
<a name="l00266"></a>00266 <span class="comment"></span>
<a name="l00267"></a>00267 <span class="comment">/**</span>
<a name="l00268"></a>00268 <span class="comment"> * NAND WAIT_STATUS command definition</span>
<a name="l00269"></a>00269 <span class="comment"> */</span>
<a name="l00270"></a><a class="code" href="structcvmx__nand__cmd__wait__status__t.html">00270</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00271"></a><a class="code" href="structcvmx__nand__cmd__wait__status__t.html#a8c0fb1fc5c1e24655c2786b8dbde13cb">00271</a>     uint64_t rdn4:3;
<a name="l00272"></a><a class="code" href="structcvmx__nand__cmd__wait__status__t.html#a3c960d2d3f70ee7ebc81e322d284acaf">00272</a>     uint64_t rdn3:3;
<a name="l00273"></a><a class="code" href="structcvmx__nand__cmd__wait__status__t.html#a537b22ac8c6d1b0646374858b45da8a7">00273</a>     uint64_t rdn2:3;
<a name="l00274"></a><a class="code" href="structcvmx__nand__cmd__wait__status__t.html#ade0c0e4525dc145631e0c6663447c053">00274</a>     uint64_t rdn1:3;
<a name="l00275"></a><a class="code" href="structcvmx__nand__cmd__wait__status__t.html#ae45af877a287316aa21f1248cf6598b8">00275</a>     uint64_t comp_byte:8;
<a name="l00276"></a><a class="code" href="structcvmx__nand__cmd__wait__status__t.html#ad56f25f2ea8a1e5d665ba1ba1515ca27">00276</a>     uint64_t and_mask:8;
<a name="l00277"></a><a class="code" href="structcvmx__nand__cmd__wait__status__t.html#a3e9bccc873727ac81abae9c332552fc3">00277</a>     uint64_t nine:4;
<a name="l00278"></a><a class="code" href="structcvmx__nand__cmd__wait__status__t.html#a0d03f4326b4287f63e79bb4bf06e4791">00278</a>     uint64_t reserved_28_95:64;
<a name="l00279"></a><a class="code" href="structcvmx__nand__cmd__wait__status__t.html#a3cb1b0196d0f74950ec7dd651bffaaad">00279</a>     uint64_t clen4:3;
<a name="l00280"></a><a class="code" href="structcvmx__nand__cmd__wait__status__t.html#a773473d2f0dff7473273790921bd5bbd">00280</a>     uint64_t clen3:3;
<a name="l00281"></a><a class="code" href="structcvmx__nand__cmd__wait__status__t.html#abe61e5be0fc1bef693e4f930669df1ee">00281</a>     uint64_t clen2:3;
<a name="l00282"></a><a class="code" href="structcvmx__nand__cmd__wait__status__t.html#aa1af8e65100a9cb2ade7bc473d528ccb">00282</a>     uint64_t clen1:3;
<a name="l00283"></a><a class="code" href="structcvmx__nand__cmd__wait__status__t.html#a91c61ba3baf49f1624bdab5689724099">00283</a>     uint64_t data:8;
<a name="l00284"></a><a class="code" href="structcvmx__nand__cmd__wait__status__t.html#a46bb11c8b2a16b6c7929789ee3168fa3">00284</a>     uint64_t reserved_4_7:4;
<a name="l00285"></a><a class="code" href="structcvmx__nand__cmd__wait__status__t.html#ae10363ff38f50d62ad60ed7b101ba19e">00285</a>     uint64_t eleven:4;
<a name="l00286"></a>00286 } <a class="code" href="structcvmx__nand__cmd__wait__status__t.html" title="NAND WAIT_STATUS command definition.">cvmx_nand_cmd_wait_status_t</a>;
<a name="l00287"></a>00287 <span class="comment"></span>
<a name="l00288"></a>00288 <span class="comment">/**</span>
<a name="l00289"></a>00289 <span class="comment"> * NAND WAIT_STATUS_ALE command definition</span>
<a name="l00290"></a>00290 <span class="comment"> */</span>
<a name="l00291"></a><a class="code" href="structcvmx__nand__cmd__wait__status__ale__t.html">00291</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00292"></a><a class="code" href="structcvmx__nand__cmd__wait__status__ale__t.html#a0a5311e0e12c3a0e47e76d9c95064041">00292</a>     uint64_t rdn4:3;
<a name="l00293"></a><a class="code" href="structcvmx__nand__cmd__wait__status__ale__t.html#ae0738af51a352e85b7445562915e0331">00293</a>     uint64_t rdn3:3;
<a name="l00294"></a><a class="code" href="structcvmx__nand__cmd__wait__status__ale__t.html#a19052568d2cfa5b202065703d17987cd">00294</a>     uint64_t rdn2:3;
<a name="l00295"></a><a class="code" href="structcvmx__nand__cmd__wait__status__ale__t.html#adbe7f38e87b0ec904d0e1695f7cdac2d">00295</a>     uint64_t rdn1:3;
<a name="l00296"></a><a class="code" href="structcvmx__nand__cmd__wait__status__ale__t.html#a66c28db266cc673da1d44636d028822b">00296</a>     uint64_t comp_byte:8;
<a name="l00297"></a><a class="code" href="structcvmx__nand__cmd__wait__status__ale__t.html#a777311234764a5db7dfae695b0bf1c89">00297</a>     uint64_t and_mask:8;
<a name="l00298"></a><a class="code" href="structcvmx__nand__cmd__wait__status__ale__t.html#aa2c5af58d6fa82c5c0560b29faadb792">00298</a>     uint64_t nine:4;
<a name="l00299"></a><a class="code" href="structcvmx__nand__cmd__wait__status__ale__t.html#afa9d74bbeaf2752471879b47515313c6">00299</a>     uint64_t adr_bytes:32;
<a name="l00300"></a><a class="code" href="structcvmx__nand__cmd__wait__status__ale__t.html#a54318e721793abba67faf96d76c2ffa7">00300</a>     uint64_t reserved_60_63:4;
<a name="l00301"></a><a class="code" href="structcvmx__nand__cmd__wait__status__ale__t.html#a6de8098656186b717b3a9851d22b72bb">00301</a>     uint64_t alen4:3;
<a name="l00302"></a><a class="code" href="structcvmx__nand__cmd__wait__status__ale__t.html#a2bd46971bd5809e593e584f1d0b27b3e">00302</a>     uint64_t alen3:3;
<a name="l00303"></a><a class="code" href="structcvmx__nand__cmd__wait__status__ale__t.html#af537796348ac3f58d5672178c78d01da">00303</a>     uint64_t alen2:3;
<a name="l00304"></a><a class="code" href="structcvmx__nand__cmd__wait__status__ale__t.html#a9422018baa701ee0defa0a1c2ebc6005">00304</a>     uint64_t alen1:3;
<a name="l00305"></a><a class="code" href="structcvmx__nand__cmd__wait__status__ale__t.html#a298c2dd5a557ea7dd10eef0f6dc7eb33">00305</a>     uint64_t reserved_44_47:4;
<a name="l00306"></a><a class="code" href="structcvmx__nand__cmd__wait__status__ale__t.html#a7a8950ae3f25e246428f3e088058c85f">00306</a>     uint64_t adr_byte_num:4;
<a name="l00307"></a><a class="code" href="structcvmx__nand__cmd__wait__status__ale__t.html#ab0b2083907628eaba8f7c2d7c7211c26">00307</a>     uint64_t five:4;
<a name="l00308"></a><a class="code" href="structcvmx__nand__cmd__wait__status__ale__t.html#a7c4cd3263a187e62b35f2cd07bd8f341">00308</a>     uint64_t reserved_25_31:7;
<a name="l00309"></a><a class="code" href="structcvmx__nand__cmd__wait__status__ale__t.html#aac5fb3362ac380c34cfa372364ed9674">00309</a>     uint64_t clen3:3;
<a name="l00310"></a><a class="code" href="structcvmx__nand__cmd__wait__status__ale__t.html#aff8a329c8a33e19d8c84b5a30d2dab3f">00310</a>     uint64_t clen2:3;
<a name="l00311"></a><a class="code" href="structcvmx__nand__cmd__wait__status__ale__t.html#adc057c9900eb8124241e455967537e44">00311</a>     uint64_t clen1:3;
<a name="l00312"></a><a class="code" href="structcvmx__nand__cmd__wait__status__ale__t.html#ada254f13a965395e5d7e77fc97b1a846">00312</a>     uint64_t data:8;
<a name="l00313"></a><a class="code" href="structcvmx__nand__cmd__wait__status__ale__t.html#a1c63bc794436cfb14048e74e2687e11a">00313</a>     uint64_t reserved_4_7:4;
<a name="l00314"></a><a class="code" href="structcvmx__nand__cmd__wait__status__ale__t.html#adb551d5868939ec3446a7fa41af49fef">00314</a>     uint64_t eleven:4;
<a name="l00315"></a>00315 } <a class="code" href="structcvmx__nand__cmd__wait__status__ale__t.html" title="NAND WAIT_STATUS_ALE command definition.">cvmx_nand_cmd_wait_status_ale_t</a>;
<a name="l00316"></a>00316 <span class="comment"></span>
<a name="l00317"></a>00317 <span class="comment">/**</span>
<a name="l00318"></a>00318 <span class="comment"> * NAND BUS_ACQ command definition</span>
<a name="l00319"></a>00319 <span class="comment"> */</span>
<a name="l00320"></a><a class="code" href="structcvmx__nand__cmd__bus__acq__t.html">00320</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00321"></a><a class="code" href="structcvmx__nand__cmd__bus__acq__t.html#aa0454a635d7d2cdb2e49cb2d59546a38">00321</a>     uint64_t reserved_64_127:64;
<a name="l00322"></a><a class="code" href="structcvmx__nand__cmd__bus__acq__t.html#a4a08b529447dec603eff1deada18fbf4">00322</a>     uint64_t reserved_8_63:56;
<a name="l00323"></a><a class="code" href="structcvmx__nand__cmd__bus__acq__t.html#a60b2e978ef748edd6b1a07ca720cf1e8">00323</a>     uint64_t one:4;
<a name="l00324"></a><a class="code" href="structcvmx__nand__cmd__bus__acq__t.html#a347ac67c007a6e9dbc0bd291cabba7ea">00324</a>     uint64_t fifteen:4;
<a name="l00325"></a>00325 } <a class="code" href="structcvmx__nand__cmd__bus__acq__t.html" title="NAND BUS_ACQ command definition.">cvmx_nand_cmd_bus_acq_t</a>;
<a name="l00326"></a>00326 <span class="comment"></span>
<a name="l00327"></a>00327 <span class="comment">/**</span>
<a name="l00328"></a>00328 <span class="comment"> * NAND BUS_REL command definition</span>
<a name="l00329"></a>00329 <span class="comment"> */</span>
<a name="l00330"></a><a class="code" href="structcvmx__nand__cmd__bus__rel__t.html">00330</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00331"></a><a class="code" href="structcvmx__nand__cmd__bus__rel__t.html#a0451ce7e78f34b36f18f4a8c4487de6e">00331</a>     uint64_t reserved_64_127:64;
<a name="l00332"></a><a class="code" href="structcvmx__nand__cmd__bus__rel__t.html#aade7ac9fba2437dd15b5953d39f3efd3">00332</a>     uint64_t reserved_8_63:56;
<a name="l00333"></a><a class="code" href="structcvmx__nand__cmd__bus__rel__t.html#ac2c8e19e8daab65a168fc36a5ee8b058">00333</a>     uint64_t zero:4;
<a name="l00334"></a><a class="code" href="structcvmx__nand__cmd__bus__rel__t.html#a119e4fbbe73c1627f9a6beddced82eb3">00334</a>     uint64_t fifteen:4;
<a name="l00335"></a>00335 } <a class="code" href="structcvmx__nand__cmd__bus__rel__t.html" title="NAND BUS_REL command definition.">cvmx_nand_cmd_bus_rel_t</a>;
<a name="l00336"></a>00336 <span class="comment"></span>
<a name="l00337"></a>00337 <span class="comment">/**</span>
<a name="l00338"></a>00338 <span class="comment"> * NAND command union of all possible commands</span>
<a name="l00339"></a>00339 <span class="comment"> */</span>
<a name="l00340"></a><a class="code" href="unioncvmx__nand__cmd__t.html">00340</a> <span class="keyword">typedef</span> <span class="keyword">union </span>{
<a name="l00341"></a><a class="code" href="unioncvmx__nand__cmd__t.html#afc6e0a539e51213cb242bd929d3bbf9b">00341</a>     uint64_t u64[2];
<a name="l00342"></a><a class="code" href="unioncvmx__nand__cmd__t.html#acb8d19f1bbb586541c5dbc4eb22e5497">00342</a>     <a class="code" href="structcvmx__nand__cmd__nop__t.html" title="NAND NOP command definition.">cvmx_nand_cmd_nop_t</a> nop;
<a name="l00343"></a><a class="code" href="unioncvmx__nand__cmd__t.html#a64ceb985248c3eae80dc17f672ee0719">00343</a>     <a class="code" href="structcvmx__nand__cmd__set__tm__par__t.html" title="NAND SET_TM_PAR command definition.">cvmx_nand_cmd_set_tm_par_t</a> set_tm_par;
<a name="l00344"></a><a class="code" href="unioncvmx__nand__cmd__t.html#a328c8559d71330b9e162e7b9408d5572">00344</a>     <a class="code" href="structcvmx__nand__cmd__wait__t.html" title="NAND WAIT command definition.">cvmx_nand_cmd_wait_t</a> wait;
<a name="l00345"></a><a class="code" href="unioncvmx__nand__cmd__t.html#a92d640a40a8f15649b49bb2235d444dc">00345</a>     <a class="code" href="structcvmx__nand__cmd__chip__en__t.html" title="NAND CHIP_EN command definition.">cvmx_nand_cmd_chip_en_t</a> chip_en;
<a name="l00346"></a><a class="code" href="unioncvmx__nand__cmd__t.html#a88f57d9f761e68ac40451f14ecc171c6">00346</a>     <a class="code" href="structcvmx__nand__cmd__chip__dis__t.html" title="NAND CHIP_DIS command definition.">cvmx_nand_cmd_chip_dis_t</a> chip_dis;
<a name="l00347"></a><a class="code" href="unioncvmx__nand__cmd__t.html#a0af6a809b5b0c6e673e75f8bbbf6c170">00347</a>     <a class="code" href="structcvmx__nand__cmd__cle__t.html" title="NAND CLE command definition.">cvmx_nand_cmd_cle_t</a> cle;
<a name="l00348"></a><a class="code" href="unioncvmx__nand__cmd__t.html#a26ac47974f767c213e36211690af42f0">00348</a>     <a class="code" href="structcvmx__nand__cmd__ale__t.html" title="NAND ALE command definition.">cvmx_nand_cmd_ale_t</a> ale;
<a name="l00349"></a><a class="code" href="unioncvmx__nand__cmd__t.html#a3b74b418155f96c9499d4da1e2e1caff">00349</a>     <a class="code" href="structcvmx__nand__cmd__rd__t.html" title="NAND RD command definition.">cvmx_nand_cmd_rd_t</a> rd;
<a name="l00350"></a><a class="code" href="unioncvmx__nand__cmd__t.html#a355b57b51a02eb2826cd91217b49e931">00350</a>     <a class="code" href="structcvmx__nand__cmd__rd__edo__t.html" title="NAND RD_EDO command definition.">cvmx_nand_cmd_rd_edo_t</a> rd_edo;
<a name="l00351"></a><a class="code" href="unioncvmx__nand__cmd__t.html#aad79cad8d00443040902183011219410">00351</a>     <a class="code" href="structcvmx__nand__cmd__wr__t.html" title="NAND WR command definition.">cvmx_nand_cmd_wr_t</a> wr;
<a name="l00352"></a><a class="code" href="unioncvmx__nand__cmd__t.html#acae56231b17393f97a28090875877d8c">00352</a>     <a class="code" href="structcvmx__nand__cmd__wait__status__t.html" title="NAND WAIT_STATUS command definition.">cvmx_nand_cmd_wait_status_t</a> wait_status;
<a name="l00353"></a><a class="code" href="unioncvmx__nand__cmd__t.html#acc058ee7dae5a50891a1d2e690032eb5">00353</a>     <a class="code" href="structcvmx__nand__cmd__wait__status__ale__t.html" title="NAND WAIT_STATUS_ALE command definition.">cvmx_nand_cmd_wait_status_ale_t</a> wait_status_ale;
<a name="l00354"></a><a class="code" href="unioncvmx__nand__cmd__t.html#ac315da6f6a8e004032079325e9b35b64">00354</a>     <a class="code" href="structcvmx__nand__cmd__bus__acq__t.html" title="NAND BUS_ACQ command definition.">cvmx_nand_cmd_bus_acq_t</a> bus_acq;
<a name="l00355"></a><a class="code" href="unioncvmx__nand__cmd__t.html#a8942de20771e49f6b72bd56af2fe7118">00355</a>     <a class="code" href="structcvmx__nand__cmd__bus__rel__t.html" title="NAND BUS_REL command definition.">cvmx_nand_cmd_bus_rel_t</a> bus_rel;
<a name="l00356"></a>00356     <span class="keyword">struct </span>{
<a name="l00357"></a><a class="code" href="unioncvmx__nand__cmd__t.html#a05fb50d53e49f276dc8491f419d94992">00357</a>         uint64_t reserved_64_127:64;
<a name="l00358"></a><a class="code" href="unioncvmx__nand__cmd__t.html#a4f207198e0e2b0ee0ef991df2954e5be">00358</a>         uint64_t reserved_4_63:60;
<a name="l00359"></a><a class="code" href="unioncvmx__nand__cmd__t.html#a5e47116973894f74f685135043dc001b">00359</a>         uint64_t op_code:4;
<a name="l00360"></a>00360     } <a class="code" href="cvmx-coremask_8c.html#a7cc33a7fd56e1ab82f778fe3f0e88c25">s</a>;
<a name="l00361"></a>00361 } <a class="code" href="unioncvmx__nand__cmd__t.html" title="NAND command union of all possible commands.">cvmx_nand_cmd_t</a>;
<a name="l00362"></a>00362 
<a name="l00363"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html">00363</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>__attribute__ ((packed)) {
<a name="l00364"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a6a5e12e0c252550ed0c18721bdf08dac">00364</a>     <span class="keywordtype">char</span> onfi[4];           <span class="comment">/**</span>
<a name="l00365"></a>00365 <span class="comment">                     * Bytes 0-3: The ASCII characters</span>
<a name="l00366"></a>00366 <span class="comment">                     * &apos;O&apos;, &apos;N&apos;, &apos;F&apos;, &apos;I&apos;</span>
<a name="l00367"></a>00367 <span class="comment">                     */</span>
<a name="l00368"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a38953abc28efb9dba6e6475ec46f8828">00368</a>     uint16_t revision_number;   <span class="comment">/**</span>
<a name="l00369"></a>00369 <span class="comment">                     * Bytes 4-5: ONFI revision number</span>
<a name="l00370"></a>00370 <span class="comment">                                         * - 2-15 Reserved (0)</span>
<a name="l00371"></a>00371 <span class="comment">                                         * - 1    1 = supports ONFI version 1.0</span>
<a name="l00372"></a>00372 <span class="comment">                                         * - 0    Reserved (0)</span>
<a name="l00373"></a>00373 <span class="comment">                                         */</span>
<a name="l00374"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a902cf967f6195d72d53550ffca3a8451">00374</a>     uint16_t features;      <span class="comment">/**</span>
<a name="l00375"></a>00375 <span class="comment">                     * Bytes 6-7: Features supported</span>
<a name="l00376"></a>00376 <span class="comment">                                         * - 5-15    Reserved (0)</span>
<a name="l00377"></a>00377 <span class="comment">                                         * - 4       1 = supports odd to even</span>
<a name="l00378"></a>00378 <span class="comment">                                         *       page Copyback</span>
<a name="l00379"></a>00379 <span class="comment">                                         * - 3       1 = supports interleaved</span>
<a name="l00380"></a>00380 <span class="comment">                                         *       operations</span>
<a name="l00381"></a>00381 <span class="comment">                                         * - 2       1 = supports non-sequential</span>
<a name="l00382"></a>00382 <span class="comment">                                         *       page programming</span>
<a name="l00383"></a>00383 <span class="comment">                                         * - 1       1 = supports multiple LUN</span>
<a name="l00384"></a>00384 <span class="comment">                                         *       operations</span>
<a name="l00385"></a>00385 <span class="comment">                                         * - 0       1 = supports 16-bit data</span>
<a name="l00386"></a>00386 <span class="comment">                                         *       bus width</span>
<a name="l00387"></a>00387 <span class="comment">                                         */</span>
<a name="l00388"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a12d6c448131ee65af567b9e5b1e7fb80">00388</a>     uint16_t optional_commands; <span class="comment">/**</span>
<a name="l00389"></a>00389 <span class="comment">                     * Bytes 8-9: Optional commands</span>
<a name="l00390"></a>00390 <span class="comment">                     * supported</span>
<a name="l00391"></a>00391 <span class="comment">                     *   - 6-15   Reserved (0)</span>
<a name="l00392"></a>00392 <span class="comment">                     *   - 5      1 = supports Read Unique</span>
<a name="l00393"></a>00393 <span class="comment">                     *        ID</span>
<a name="l00394"></a>00394 <span class="comment">                     *   - 4      1 = supports Copyback</span>
<a name="l00395"></a>00395 <span class="comment">                     *   - 3      1 = supports Read Status</span>
<a name="l00396"></a>00396 <span class="comment">                     *        Enhanced</span>
<a name="l00397"></a>00397 <span class="comment">                     *   - 2      1 = supports Get Features</span>
<a name="l00398"></a>00398 <span class="comment">                     *        and Set Features</span>
<a name="l00399"></a>00399 <span class="comment">                     *   - 1      1 = supports Read Cache</span>
<a name="l00400"></a>00400 <span class="comment">                     *        commands</span>
<a name="l00401"></a>00401 <span class="comment">                     *   - 0      1 = supports Page Cache</span>
<a name="l00402"></a>00402 <span class="comment">                     *        Program command</span>
<a name="l00403"></a>00403 <span class="comment">                     */</span>
<a name="l00404"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a495d2963d6615971b08b0eebf847e49f">00404</a>     uint8_t reserved_10_11[2];  <span class="comment">/** Bytes 10-11: Reserved */</span>
<a name="l00405"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#aa86d75549c5facddff71078538418b4a">00405</a>     uint16_t extended_param_page_len;<span class="comment">/** Extended parameter page length */</span>
<a name="l00406"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#ab880b60075301b3c2e71ebff521a0f50">00406</a>     uint8_t num_param_pages;    <span class="comment">/** Number of parameter pages */</span>
<a name="l00407"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a1e335a5aa6a02b4f4ca4ce17d72c1093">00407</a>     uint8_t reserved_15_31[17]; <span class="comment">/** Bytes 15-31: Reserved */</span>
<a name="l00408"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a64b6609cf1942375d7a3c28359a6fda4">00408</a>     <span class="keywordtype">char</span> manufacturer[12];      <span class="comment">/**</span>
<a name="l00409"></a>00409 <span class="comment">                     * Bytes 32-43: Device manufacturer</span>
<a name="l00410"></a>00410 <span class="comment">                     * (12 ASCII characters)</span>
<a name="l00411"></a>00411 <span class="comment">                     */</span>
<a name="l00412"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a1c9b1e6dd12e641d6e3318763a10ecc3">00412</a>     <span class="keywordtype">char</span> model[20];         <span class="comment">/**</span>
<a name="l00413"></a>00413 <span class="comment">                     * Bytes 40-63: Device model</span>
<a name="l00414"></a>00414 <span class="comment">                     * (20 ASCII characters)</span>
<a name="l00415"></a>00415 <span class="comment">                     */</span>
<a name="l00416"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a1ebacd9360af9b85f666adf57fbfdf52">00416</a>     uint8_t jedec_id;           <span class="comment">/** Byte 64: JEDEC manufacturer ID */</span>
<a name="l00417"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#addfd6c6a0fefc80a54343ce6975170e6">00417</a>     uint16_t date_code;         <span class="comment">/** Byte 65-66: Date code */</span>
<a name="l00418"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#ab6419a66a8f06b1d9baaced1751c23e4">00418</a>     uint8_t reserved_67_79[13]; <span class="comment">/** Bytes 67-79: Reserved */</span>
<a name="l00419"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a5022fe7df4d0233f82bba55cbd66aa9b">00419</a>     uint32_t page_data_bytes;   <span class="comment">/**</span>
<a name="l00420"></a>00420 <span class="comment">                     * Bytes 80-83: Number of data bytes per</span>
<a name="l00421"></a>00421 <span class="comment">                     * page</span>
<a name="l00422"></a>00422 <span class="comment">                     */</span>
<a name="l00423"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a083c17cec65b27f58ea02fd9e09e62a9">00423</a>     uint16_t page_spare_bytes;  <span class="comment">/**</span>
<a name="l00424"></a>00424 <span class="comment">                     * Bytes 84-85: Number of spare bytes</span>
<a name="l00425"></a>00425 <span class="comment">                     * per page</span>
<a name="l00426"></a>00426 <span class="comment">                     */</span>
<a name="l00427"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a9f3b9733f555faf3af591c149b94efd9">00427</a>     uint32_t partial_page_data_bytes;   <span class="comment">/**</span>
<a name="l00428"></a>00428 <span class="comment">                        * Bytes 86-89: Number of data</span>
<a name="l00429"></a>00429 <span class="comment">                        * bytes per partial page</span>
<a name="l00430"></a>00430 <span class="comment">                        */</span>
<a name="l00431"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a38ea919db4902f507fba56071751dd68">00431</a>     uint16_t partial_page_spare_bytes;  <span class="comment">/**</span>
<a name="l00432"></a>00432 <span class="comment">                         * Bytes 90-91: Number of spare</span>
<a name="l00433"></a>00433 <span class="comment">                         * bytes per partial page</span>
<a name="l00434"></a>00434 <span class="comment">                         */</span>
<a name="l00435"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a8ff7194944509e2fbac7152e1d33fefa">00435</a>     uint32_t pages_per_block;   <span class="comment">/**</span>
<a name="l00436"></a>00436 <span class="comment">                     * Bytes 92-95: Number of pages per</span>
<a name="l00437"></a>00437 <span class="comment">                     * block</span>
<a name="l00438"></a>00438 <span class="comment">                     */</span>
<a name="l00439"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#af0711ca9048e8439cff687e9c93be868">00439</a>     uint32_t blocks_per_lun;    <span class="comment">/**</span>
<a name="l00440"></a>00440 <span class="comment">                     * Bytes 96-99: Number of blocks per</span>
<a name="l00441"></a>00441 <span class="comment">                     * logical unit (LUN)</span>
<a name="l00442"></a>00442 <span class="comment">                     */</span>
<a name="l00443"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a4a6eb2f5ab9847b270da053f8046995d">00443</a>     uint8_t number_lun;     <span class="comment">/**</span>
<a name="l00444"></a>00444 <span class="comment">                     * Byte 100: Number of logical units</span>
<a name="l00445"></a>00445 <span class="comment">                     * (LUNs)</span>
<a name="l00446"></a>00446 <span class="comment">                     */</span>
<a name="l00447"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a68d1f0884ea0b99e9af2de9fa5707261">00447</a>     uint8_t address_cycles;     <span class="comment">/**</span>
<a name="l00448"></a>00448 <span class="comment">                     * Byte 101: Number of address cycles</span>
<a name="l00449"></a>00449 <span class="comment">                                         * - 4-7     Column address cycles</span>
<a name="l00450"></a>00450 <span class="comment">                                         * - 0-3     Row address cycles</span>
<a name="l00451"></a>00451 <span class="comment">                                         */</span>
<a name="l00452"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a56c4411da756a9d5067d0ed39388ffbb">00452</a>     uint8_t bits_per_cell;      <span class="comment">/** Byte 102: Number of bits per cell */</span>
<a name="l00453"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#addcbf9869e4c98da059ad64ad0b1d122">00453</a>     uint16_t bad_block_per_lun; <span class="comment">/**</span>
<a name="l00454"></a>00454 <span class="comment">                     *  Bytes 103-104: Bad blocks maximum</span>
<a name="l00455"></a>00455 <span class="comment">                     * per LUN</span>
<a name="l00456"></a>00456 <span class="comment">                     */</span>
<a name="l00457"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#abe42015593c691d08a03d7ace14459d7">00457</a>     uint16_t block_endurance;   <span class="comment">/** Bytes 105-106: Block endurance */</span>
<a name="l00458"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a896d18d705777f91cde7782aef4714cf">00458</a>     uint8_t good_blocks;        <span class="comment">/**</span>
<a name="l00459"></a>00459 <span class="comment">                     * Byte 107: Guaranteed valid blocks at</span>
<a name="l00460"></a>00460 <span class="comment">                     * beginning of target</span>
<a name="l00461"></a>00461 <span class="comment">                     */</span>
<a name="l00462"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#aa85e680731bfee61403f8ccfaf78749f">00462</a>     uint16_t good_block_endurance;  <span class="comment">/**</span>
<a name="l00463"></a>00463 <span class="comment">                     * Bytes 108-109: Block endurance for</span>
<a name="l00464"></a>00464 <span class="comment">                     * guaranteed valid blocks</span>
<a name="l00465"></a>00465 <span class="comment">                     */</span>
<a name="l00466"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a3d6fdb517106849684c876e3cf6d7f24">00466</a>     uint8_t programs_per_page;  <span class="comment">/**</span>
<a name="l00467"></a>00467 <span class="comment">                     * Byte 110: Number of programs per page</span>
<a name="l00468"></a>00468 <span class="comment">                     */</span>
<a name="l00469"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a2fd7d42ab21233b9908b731f86ff88dd">00469</a>     uint8_t partial_program_attrib; <span class="comment">/**</span>
<a name="l00470"></a>00470 <span class="comment">                     * Byte 111: Partial programming</span>
<a name="l00471"></a>00471 <span class="comment">                     * attributes</span>
<a name="l00472"></a>00472 <span class="comment">                     * - 5-7    Reserved</span>
<a name="l00473"></a>00473 <span class="comment">                     * - 4      1 = partial page layout is</span>
<a name="l00474"></a>00474 <span class="comment">                     *      partial page data</span>
<a name="l00475"></a>00475 <span class="comment">                     *      followed by partial</span>
<a name="l00476"></a>00476 <span class="comment">                     *      page spare</span>
<a name="l00477"></a>00477 <span class="comment">                     * - 1-3    Reserved</span>
<a name="l00478"></a>00478 <span class="comment">                     * - 0      1 = partial page programming</span>
<a name="l00479"></a>00479 <span class="comment">                     *      has constraints</span>
<a name="l00480"></a>00480 <span class="comment">                     */</span>
<a name="l00481"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a4003ec382ecf00ceae2d21b4ff395e50">00481</a>     uint8_t bits_ecc;       <span class="comment">/**</span>
<a name="l00482"></a>00482 <span class="comment">                     * Byte 112: Number of bits ECC</span>
<a name="l00483"></a>00483 <span class="comment">                     * correctability</span>
<a name="l00484"></a>00484 <span class="comment">                     */</span>
<a name="l00485"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a2bef93bab756f8c841f3237aeecd9e8b">00485</a>     uint8_t interleaved_address_bits;   <span class="comment">/**</span>
<a name="l00486"></a>00486 <span class="comment">                         * Byte 113: Number of</span>
<a name="l00487"></a>00487 <span class="comment">                         * interleaved address bits</span>
<a name="l00488"></a>00488 <span class="comment">                         * - 4-7    Reserved (0)</span>
<a name="l00489"></a>00489 <span class="comment">                         * - 0-3    Number of</span>
<a name="l00490"></a>00490 <span class="comment">                         *      interleaved address</span>
<a name="l00491"></a>00491 <span class="comment">                         *      bits</span>
<a name="l00492"></a>00492 <span class="comment">                         */</span>
<a name="l00493"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a2ecfa8a05b1156c9d9f84a209c2874d0">00493</a>     uint8_t interleaved_attrib; <span class="comment">/**</span>
<a name="l00494"></a>00494 <span class="comment">                     * Byte 114: Interleaved operation</span>
<a name="l00495"></a>00495 <span class="comment">                     * attributes</span>
<a name="l00496"></a>00496 <span class="comment">                     * - 4-7    Reserved (0)</span>
<a name="l00497"></a>00497 <span class="comment">                     * - 3      Address restrictions for</span>
<a name="l00498"></a>00498 <span class="comment">                     *      program cache</span>
<a name="l00499"></a>00499 <span class="comment">                     * - 2      1 = program cache supported</span>
<a name="l00500"></a>00500 <span class="comment">                     * - 1      1 = no block address</span>
<a name="l00501"></a>00501 <span class="comment">                     *      restrictions</span>
<a name="l00502"></a>00502 <span class="comment">                     * - 0      Overlapped / concurrent</span>
<a name="l00503"></a>00503 <span class="comment">                     *      interleaving support</span>
<a name="l00504"></a>00504 <span class="comment">                     */</span>
<a name="l00505"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a8d06ac671edef7c5821386542686e446">00505</a>     uint8_t reserved_115_127[13];   <span class="comment">/** Bytes 115-127: Reserved (0) */</span>
<a name="l00506"></a>00506 
<a name="l00507"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#aa9d3d36358a21f0dad8a4bb05eda7e6b">00507</a>     uint8_t pin_capacitance;    <span class="comment">/** Byte 128: I/O pin capacitance */</span>
<a name="l00508"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a8bbd5e51128ac8a38ab06f386d590a0c">00508</a>     uint16_t timing_mode;       <span class="comment">/**</span>
<a name="l00509"></a>00509 <span class="comment">                     * Byte 129-130: Timing mode support</span>
<a name="l00510"></a>00510 <span class="comment">                     * - 6-15   Reserved (0)</span>
<a name="l00511"></a>00511 <span class="comment">                     * - 5      1 = supports timing mode 5</span>
<a name="l00512"></a>00512 <span class="comment">                     * - 4      1 = supports timing mode 4</span>
<a name="l00513"></a>00513 <span class="comment">                     * - 3      1 = supports timing mode 3</span>
<a name="l00514"></a>00514 <span class="comment">                     * - 2      1 = supports timing mode 2</span>
<a name="l00515"></a>00515 <span class="comment">                     * - 1      1 = supports timing mode 1</span>
<a name="l00516"></a>00516 <span class="comment">                     * - 0      1 = supports timing mode 0,</span>
<a name="l00517"></a>00517 <span class="comment">                     *      shall be 1</span>
<a name="l00518"></a>00518 <span class="comment">                     */</span>
<a name="l00519"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#ab56d7a73588fdc6d1d532991608136f2">00519</a>     uint16_t cache_timing_mode; <span class="comment">/**</span>
<a name="l00520"></a>00520 <span class="comment">                     * Byte 131-132: Program cache timing</span>
<a name="l00521"></a>00521 <span class="comment">                     * mode support</span>
<a name="l00522"></a>00522 <span class="comment">                     * - 6-15   Reserved (0)</span>
<a name="l00523"></a>00523 <span class="comment">                     * - 5      1 = supports timing mode 5</span>
<a name="l00524"></a>00524 <span class="comment">                     * - 4      1 = supports timing mode 4</span>
<a name="l00525"></a>00525 <span class="comment">                     * - 3      1 = supports timing mode 3</span>
<a name="l00526"></a>00526 <span class="comment">                     * - 2      1 = supports timing mode 2</span>
<a name="l00527"></a>00527 <span class="comment">                     * - 1      1 = supports timing mode 1</span>
<a name="l00528"></a>00528 <span class="comment">                     * - 0      1 = supports timing mode 0</span>
<a name="l00529"></a>00529 <span class="comment">                     */</span>
<a name="l00530"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a35a436547a85474d4316f83387030709">00530</a>     uint16_t t_prog;        <span class="comment">/**</span>
<a name="l00531"></a>00531 <span class="comment">                     * Byte 133-134: Maximum page program</span>
<a name="l00532"></a>00532 <span class="comment">                     * time (us)</span>
<a name="l00533"></a>00533 <span class="comment">                     */</span>
<a name="l00534"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a05c40ec5aad1af566c7c53ee79df78e9">00534</a>     uint16_t t_bers;        <span class="comment">/**</span>
<a name="l00535"></a>00535 <span class="comment">                     * Byte 135-136: Maximum block erase</span>
<a name="l00536"></a>00536 <span class="comment">                     * time (us)</span>
<a name="l00537"></a>00537 <span class="comment">                     */</span>
<a name="l00538"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a967d10f3186b0147c41a5471c924ee08">00538</a>     uint16_t t_r;           <span class="comment">/**</span>
<a name="l00539"></a>00539 <span class="comment">                     * Byte 137-148: Maximum page read time</span>
<a name="l00540"></a>00540 <span class="comment">                     * (us)</span>
<a name="l00541"></a>00541 <span class="comment">                     */</span>
<a name="l00542"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#ae4262ed96e69aa143b51265caac10d8b">00542</a>     uint16_t t_ccs;         <span class="comment">/**</span>
<a name="l00543"></a>00543 <span class="comment">                     * Byte 139-140: Minimum change column</span>
<a name="l00544"></a>00544 <span class="comment">                     * setup time (ns)</span>
<a name="l00545"></a>00545 <span class="comment">                     */</span>
<a name="l00546"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a35ac8f314151e25aa4704b3c5696e0d2">00546</a>     uint8_t reserved_141_163[23];   <span class="comment">/** Byte 141-163: Reserved (0) */</span>
<a name="l00547"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a809abdb7dda197bb2478014f22418f77">00547</a>     uint16_t vendor_revision;   <span class="comment">/**</span>
<a name="l00548"></a>00548 <span class="comment">                     * Byte 164-165: Vendor specific</span>
<a name="l00549"></a>00549 <span class="comment">                     * Revision number</span>
<a name="l00550"></a>00550 <span class="comment">                     */</span>
<a name="l00551"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#aa5de2a62bcf29dd62b2238e8ffed020a">00551</a>     uint8_t vendor_specific[88];    <span class="comment">/** Byte 166-253: Vendor specific */</span>
<a name="l00552"></a><a class="code" href="structcvmx__nand__onfi__param__page__t.html#a7fd30bdcc2c5eb126280ca661204273d">00552</a>     uint16_t crc;           <span class="comment">/** Byte 254-255: Integrity CRC */</span>
<a name="l00553"></a>00553 } <a class="code" href="structcvmx__nand__onfi__param__page__t.html">cvmx_nand_onfi_param_page_t</a>;
<a name="l00554"></a>00554 <span class="comment"></span>
<a name="l00555"></a>00555 <span class="comment">/**</span>
<a name="l00556"></a>00556 <span class="comment"> * Called to initialize the NAND controller for use.  Note that you must be</span>
<a name="l00557"></a>00557 <span class="comment"> * running out of L2 or memory and not NAND before calling this function.</span>
<a name="l00558"></a>00558 <span class="comment"> * When probing for NAND chips, this function attempts to autoconfigure based</span>
<a name="l00559"></a>00559 <span class="comment"> * on the NAND parts detected.  It currently supports autodetection for ONFI</span>
<a name="l00560"></a>00560 <span class="comment"> * parts (with valid parameter pages), and some Samsung NAND parts (decoding ID</span>
<a name="l00561"></a>00561 <span class="comment"> * bits).  If autoconfiguration fails, the defaults set with</span>
<a name="l00562"></a>00562 <span class="comment"> * __set_chip_defaults() prior to calling cvmx_nand_initialize() are used.</span>
<a name="l00563"></a>00563 <span class="comment"> * If defaults are set and the CVMX_NAND_INITIALIZE_FLAGS_DONT_PROBE flag is</span>
<a name="l00564"></a>00564 <span class="comment"> * provided, the defaults are used for all chips in the active_chips mask.</span>
<a name="l00565"></a>00565 <span class="comment"> *</span>
<a name="l00566"></a>00566 <span class="comment"> * @param flags  Optional initialization flags</span>
<a name="l00567"></a>00567 <span class="comment"> *               If the CVMX_NAND_INITIALIZE_FLAGS_DONT_PROBE flag is passed,</span>
<a name="l00568"></a>00568 <span class="comment"> *       chips are not probed and the default parameters, if set with</span>
<a name="l00569"></a>00569 <span class="comment"> *       cvmx_nand_set_defaults, are used for all chips</span>
<a name="l00570"></a>00570 <span class="comment"> *               in the active_chips mask.</span>
<a name="l00571"></a>00571 <span class="comment"> * @param active_chips</span>
<a name="l00572"></a>00572 <span class="comment"> *               Each bit in this parameter represents a chip select that might</span>
<a name="l00573"></a>00573 <span class="comment"> *               contain NAND flash. Any chip select present in this bitmask may</span>
<a name="l00574"></a>00574 <span class="comment"> *               be connected to NAND. It is normally safe to pass 0xff here and</span>
<a name="l00575"></a>00575 <span class="comment"> *               let the API probe all 8 chip selects.</span>
<a name="l00576"></a>00576 <span class="comment"> *</span>
<a name="l00577"></a>00577 <span class="comment"> * @return Zero on success, a negative cvmx_nand_status_t error code on failure</span>
<a name="l00578"></a>00578 <span class="comment"> */</span>
<a name="l00579"></a>00579 <span class="keyword">extern</span> <a class="code" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e" title="Return codes from NAND functions.">cvmx_nand_status_t</a> <a class="code" href="cvmx-nand_8c.html#afa5bf87c53c60362a32a3a99a078d3a1" title="Called to initialize the NAND controller for use.">cvmx_nand_initialize</a>(<a class="code" href="cvmx-nand_8h.html#a16a1444b15a746cfc6bcdc7ea2852ba2" title="Flags to be passed to the initialize function.">cvmx_nand_initialize_flags_t</a> flags,
<a name="l00580"></a>00580                            <span class="keywordtype">int</span> active_chips);
<a name="l00581"></a>00581 <span class="comment"></span>
<a name="l00582"></a>00582 <span class="comment">/**</span>
<a name="l00583"></a>00583 <span class="comment"> * This function may be called before cvmx_nand_initialize to set default values</span>
<a name="l00584"></a>00584 <span class="comment"> * that will be used for NAND chips that do not identify themselves in a way</span>
<a name="l00585"></a>00585 <span class="comment"> * that allows autoconfiguration. (ONFI chip with missing parameter page, for</span>
<a name="l00586"></a>00586 <span class="comment"> * example).</span>
<a name="l00587"></a>00587 <span class="comment"> * The parameters set by this function will be used by _all_ non-autoconfigured</span>
<a name="l00588"></a>00588 <span class="comment"> * NAND chips.</span>
<a name="l00589"></a>00589 <span class="comment"> *</span>
<a name="l00590"></a>00590 <span class="comment"> *</span>
<a name="l00591"></a>00591 <span class="comment"> *   NOTE:  This function signature is _NOT_ stable, and will change in the</span>
<a name="l00592"></a>00592 <span class="comment"> *          future as required to support various NAND chips.</span>
<a name="l00593"></a>00593 <span class="comment"> *</span>
<a name="l00594"></a>00594 <span class="comment"> * @param page_size page size in bytes</span>
<a name="l00595"></a>00595 <span class="comment"> * @param oob_size  Out of band size in bytes (per page)</span>
<a name="l00596"></a>00596 <span class="comment"> * @param pages_per_block</span>
<a name="l00597"></a>00597 <span class="comment"> *                  number of pages per block</span>
<a name="l00598"></a>00598 <span class="comment"> * @param blocks    Total number of blocks in device</span>
<a name="l00599"></a>00599 <span class="comment"> * @param onfi_timing_mode</span>
<a name="l00600"></a>00600 <span class="comment"> *                  ONFI timing mode</span>
<a name="l00601"></a>00601 <span class="comment"> *</span>
<a name="l00602"></a>00602 <span class="comment"> * @return Zero on success, a negative cvmx_nand_status_t error code on failure</span>
<a name="l00603"></a>00603 <span class="comment"> */</span>
<a name="l00604"></a>00604 <span class="keyword">extern</span> <a class="code" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e" title="Return codes from NAND functions.">cvmx_nand_status_t</a> <a class="code" href="cvmx-nand_8c.html#a8103e18da67b88790a7c1d833aa8c3d9" title="This function may be called before cvmx_nand_initialize to set default values that...">cvmx_nand_set_defaults</a>(<span class="keywordtype">int</span> page_size, <span class="keywordtype">int</span> oob_size,
<a name="l00605"></a>00605                          <span class="keywordtype">int</span> pages_per_block,
<a name="l00606"></a>00606                          <span class="keywordtype">int</span> blocks,
<a name="l00607"></a>00607                          <span class="keywordtype">int</span> onfi_timing_mode);
<a name="l00608"></a>00608 <span class="comment"></span>
<a name="l00609"></a>00609 <span class="comment">/**</span>
<a name="l00610"></a>00610 <span class="comment"> * Call to shutdown the NAND controller after all transactions</span>
<a name="l00611"></a>00611 <span class="comment"> * are done. In most setups this will never be called.</span>
<a name="l00612"></a>00612 <span class="comment"> *</span>
<a name="l00613"></a>00613 <span class="comment"> * @return Zero on success, a negative cvmx_nand_status_t error code on failure</span>
<a name="l00614"></a>00614 <span class="comment"> */</span>
<a name="l00615"></a>00615 <span class="keyword">extern</span> <a class="code" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e" title="Return codes from NAND functions.">cvmx_nand_status_t</a> <a class="code" href="cvmx-nand_8c.html#a93972a7e4c00631d921d8294082cf0cc" title="Call to shutdown the NAND controller after all transactions are done.">cvmx_nand_shutdown</a>(<span class="keywordtype">void</span>);
<a name="l00616"></a>00616 <span class="comment"></span>
<a name="l00617"></a>00617 <span class="comment">/**</span>
<a name="l00618"></a>00618 <span class="comment"> * Returns a bitmask representing the chip selects that are connected to NAND</span>
<a name="l00619"></a>00619 <span class="comment"> * chips.  This can be called after initializing to determine the actual</span>
<a name="l00620"></a>00620 <span class="comment"> * number of NAND chips found.  Each bit in the response coresponds to a chip</span>
<a name="l00621"></a>00621 <span class="comment"> * select.</span>
<a name="l00622"></a>00622 <span class="comment"> *</span>
<a name="l00623"></a>00623 <span class="comment"> * @return Zero if no NAND chips were found. Otherwise a bit is set for</span>
<a name="l00624"></a>00624 <span class="comment"> *         each chip select (1&lt;&lt;chip).</span>
<a name="l00625"></a>00625 <span class="comment"> */</span>
<a name="l00626"></a>00626 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="cvmx-nand_8c.html#acd6f9b1f5c08a186a2524c6f69c534e5" title="Returns a bitmask representing the chip selects that are connected to NAND chips...">cvmx_nand_get_active_chips</a>(<span class="keywordtype">void</span>);
<a name="l00627"></a>00627 <span class="comment"></span>
<a name="l00628"></a>00628 <span class="comment">/**</span>
<a name="l00629"></a>00629 <span class="comment"> * Override the timing parameters for a NAND chip</span>
<a name="l00630"></a>00630 <span class="comment"> *</span>
<a name="l00631"></a>00631 <span class="comment"> * @param chip     Chip select to override</span>
<a name="l00632"></a>00632 <span class="comment"> * @param tim_mult</span>
<a name="l00633"></a>00633 <span class="comment"> * @param tim_par</span>
<a name="l00634"></a>00634 <span class="comment"> * @param clen</span>
<a name="l00635"></a>00635 <span class="comment"> * @param alen</span>
<a name="l00636"></a>00636 <span class="comment"> * @param rdn</span>
<a name="l00637"></a>00637 <span class="comment"> * @param wrn</span>
<a name="l00638"></a>00638 <span class="comment"> *</span>
<a name="l00639"></a>00639 <span class="comment"> * @return Zero on success, a negative cvmx_nand_status_t error code on failure</span>
<a name="l00640"></a>00640 <span class="comment"> */</span>
<a name="l00641"></a>00641 <span class="keyword">extern</span> <a class="code" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e" title="Return codes from NAND functions.">cvmx_nand_status_t</a> <a class="code" href="cvmx-nand_8c.html#aebfe0f778917a665f7aff55442b45a44" title="Override the timing parameters for a NAND chip.">cvmx_nand_set_timing</a>(<span class="keywordtype">int</span> chip, <span class="keywordtype">int</span> tim_mult,
<a name="l00642"></a>00642                            <span class="keywordtype">int</span> tim_par[7], <span class="keywordtype">int</span> clen[4],
<a name="l00643"></a>00643                            <span class="keywordtype">int</span> alen[4], <span class="keywordtype">int</span> rdn[4],
<a name="l00644"></a>00644                            <span class="keywordtype">int</span> wrn[2]);
<a name="l00645"></a>00645 <span class="comment"></span>
<a name="l00646"></a>00646 <span class="comment">/**</span>
<a name="l00647"></a>00647 <span class="comment"> * Submit a command to the NAND command queue. Generally this</span>
<a name="l00648"></a>00648 <span class="comment"> * will not be used directly. Instead most programs will use the other</span>
<a name="l00649"></a>00649 <span class="comment"> * higher level NAND functions.</span>
<a name="l00650"></a>00650 <span class="comment"> *</span>
<a name="l00651"></a>00651 <span class="comment"> * @param cmd    Command to submit</span>
<a name="l00652"></a>00652 <span class="comment"> *</span>
<a name="l00653"></a>00653 <span class="comment"> * @return Zero on success, a negative cvmx_nand_status_t error code on failure</span>
<a name="l00654"></a>00654 <span class="comment"> */</span>
<a name="l00655"></a>00655 <span class="keyword">extern</span> <a class="code" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e" title="Return codes from NAND functions.">cvmx_nand_status_t</a> <a class="code" href="cvmx-nand_8c.html#ad486b46c5d4dc5572acc90fbb568d64e" title="Submit a command to the NAND command queue.">cvmx_nand_submit</a>(<a class="code" href="unioncvmx__nand__cmd__t.html" title="NAND command union of all possible commands.">cvmx_nand_cmd_t</a> cmd);
<a name="l00656"></a>00656 <span class="comment"></span>
<a name="l00657"></a>00657 <span class="comment">/**</span>
<a name="l00658"></a>00658 <span class="comment"> * Read a page from NAND. If the buffer has room, the out of band</span>
<a name="l00659"></a>00659 <span class="comment"> * data will be included.</span>
<a name="l00660"></a>00660 <span class="comment"> *</span>
<a name="l00661"></a>00661 <span class="comment"> * @param chip   Chip select for NAND flash</span>
<a name="l00662"></a>00662 <span class="comment"> * @param nand_address</span>
<a name="l00663"></a>00663 <span class="comment"> *               Location in NAND to read. See description in file comment</span>
<a name="l00664"></a>00664 <span class="comment"> * @param buffer_address</span>
<a name="l00665"></a>00665 <span class="comment"> *               Physical address to store the result at</span>
<a name="l00666"></a>00666 <span class="comment"> * @param buffer_length</span>
<a name="l00667"></a>00667 <span class="comment"> *               Number of bytes to read</span>
<a name="l00668"></a>00668 <span class="comment"> *</span>
<a name="l00669"></a>00669 <span class="comment"> * @return Bytes read on success, a negative cvmx_nand_status_t error code on</span>
<a name="l00670"></a>00670 <span class="comment"> *     failure</span>
<a name="l00671"></a>00671 <span class="comment"> */</span>
<a name="l00672"></a>00672 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="cvmx-nand_8c.html#a4e923fd882cf8b709ea45bbcc97c882a" title="Read a page from NAND.">cvmx_nand_page_read</a>(<span class="keywordtype">int</span> chip, uint64_t nand_address,
<a name="l00673"></a>00673                    uint64_t buffer_address, <span class="keywordtype">int</span> buffer_length);
<a name="l00674"></a>00674 <span class="comment"></span>
<a name="l00675"></a>00675 <span class="comment">/**</span>
<a name="l00676"></a>00676 <span class="comment"> * Read random data from NAND.  This adjusts the column address before starting</span>
<a name="l00677"></a>00677 <span class="comment"> * a read operation.</span>
<a name="l00678"></a>00678 <span class="comment"> *</span>
<a name="l00679"></a>00679 <span class="comment"> * @param chip   Chip select for NAND flash</span>
<a name="l00680"></a>00680 <span class="comment"> * @param nand_address</span>
<a name="l00681"></a>00681 <span class="comment"> *               Location in NAND to read.  NOTE: only the column bits are used.</span>
<a name="l00682"></a>00682 <span class="comment"> * @param buffer_address</span>
<a name="l00683"></a>00683 <span class="comment"> *               Physical address to store the result at</span>
<a name="l00684"></a>00684 <span class="comment"> * @param buffer_length</span>
<a name="l00685"></a>00685 <span class="comment"> *               Number of bytes to read</span>
<a name="l00686"></a>00686 <span class="comment"> *</span>
<a name="l00687"></a>00687 <span class="comment"> * @return Bytes read on success, a negative cvmx_nand_status_t error code on</span>
<a name="l00688"></a>00688 <span class="comment"> *     failure</span>
<a name="l00689"></a>00689 <span class="comment"> */</span>
<a name="l00690"></a>00690 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="cvmx-nand_8c.html#afc8ee87e6f8bf9fc17b45cadc9f52048" title="Read random data from NAND.">cvmx_nand_random_data_out</a>(<span class="keywordtype">int</span> chip, uint64_t nand_address,
<a name="l00691"></a>00691                      uint64_t buffer_address,
<a name="l00692"></a>00692                      <span class="keywordtype">int</span> buffer_length);
<a name="l00693"></a>00693 <span class="comment"></span>
<a name="l00694"></a>00694 <span class="comment">/**</span>
<a name="l00695"></a>00695 <span class="comment"> * Write a page to NAND. The buffer must contain the entire page</span>
<a name="l00696"></a>00696 <span class="comment"> * including the out of band data.</span>
<a name="l00697"></a>00697 <span class="comment"> *</span>
<a name="l00698"></a>00698 <span class="comment"> * @param chip   Chip select for NAND flash</span>
<a name="l00699"></a>00699 <span class="comment"> * @param nand_address</span>
<a name="l00700"></a>00700 <span class="comment"> *               Location in NAND to write. See description in file comment</span>
<a name="l00701"></a>00701 <span class="comment"> * @param buffer_address</span>
<a name="l00702"></a>00702 <span class="comment"> *               Physical address to read the data from</span>
<a name="l00703"></a>00703 <span class="comment"> *</span>
<a name="l00704"></a>00704 <span class="comment"> * @return Zero on success, a negative cvmx_nand_status_t error code on failure</span>
<a name="l00705"></a>00705 <span class="comment"> */</span>
<a name="l00706"></a>00706 <span class="keyword">extern</span> <a class="code" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e" title="Return codes from NAND functions.">cvmx_nand_status_t</a> <a class="code" href="cvmx-nand_8c.html#af6431f766b56aa5518d5a1ff7064d3a8" title="Write a page to NAND.">cvmx_nand_page_write</a>(<span class="keywordtype">int</span> chip, uint64_t nand_address,
<a name="l00707"></a>00707                            uint64_t buffer_address);
<a name="l00708"></a>00708 <span class="comment"></span>
<a name="l00709"></a>00709 <span class="comment">/**</span>
<a name="l00710"></a>00710 <span class="comment"> * Erase a NAND block. A single block contains multiple pages.</span>
<a name="l00711"></a>00711 <span class="comment"> *</span>
<a name="l00712"></a>00712 <span class="comment"> * @param chip   Chip select for NAND flash</span>
<a name="l00713"></a>00713 <span class="comment"> * @param nand_address</span>
<a name="l00714"></a>00714 <span class="comment"> *               Location in NAND to erase. See description in file comment</span>
<a name="l00715"></a>00715 <span class="comment"> *</span>
<a name="l00716"></a>00716 <span class="comment"> * @return Zero on success, a negative cvmx_nand_status_t error code on failure</span>
<a name="l00717"></a>00717 <span class="comment"> */</span>
<a name="l00718"></a>00718 <span class="keyword">extern</span> <a class="code" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e" title="Return codes from NAND functions.">cvmx_nand_status_t</a> <a class="code" href="cvmx-nand_8c.html#a3f554501e7b9d058908d4806cc14440e" title="Erase a NAND block.">cvmx_nand_block_erase</a>(<span class="keywordtype">int</span> chip, uint64_t nand_address);
<a name="l00719"></a>00719 <span class="comment"></span>
<a name="l00720"></a>00720 <span class="comment">/**</span>
<a name="l00721"></a>00721 <span class="comment"> * Read the NAND ID information</span>
<a name="l00722"></a>00722 <span class="comment"> *</span>
<a name="l00723"></a>00723 <span class="comment"> * @param chip   Chip select for NAND flash</span>
<a name="l00724"></a>00724 <span class="comment"> * @param nand_address</span>
<a name="l00725"></a>00725 <span class="comment"> *               NAND address to read ID from. Usually this is either 0x0 or</span>
<a name="l00726"></a>00726 <span class="comment"> *       0x20.</span>
<a name="l00727"></a>00727 <span class="comment"> * @param buffer_address</span>
<a name="l00728"></a>00728 <span class="comment"> *               Physical address to store data in</span>
<a name="l00729"></a>00729 <span class="comment"> * @param buffer_length</span>
<a name="l00730"></a>00730 <span class="comment"> *               Length of the buffer. Usually this is 4 bytes</span>
<a name="l00731"></a>00731 <span class="comment"> *</span>
<a name="l00732"></a>00732 <span class="comment"> * @return Bytes read on success, a negative cvmx_nand_status_t error code on</span>
<a name="l00733"></a>00733 <span class="comment"> *         failure</span>
<a name="l00734"></a>00734 <span class="comment"> */</span>
<a name="l00735"></a>00735 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="cvmx-nand_8c.html#a44711e1a29d311926cee8ca48f44f201" title="Read the NAND ID information.">cvmx_nand_read_id</a>(<span class="keywordtype">int</span> chip, uint64_t nand_address,
<a name="l00736"></a>00736                  uint64_t buffer_address, <span class="keywordtype">int</span> buffer_length);
<a name="l00737"></a>00737 <span class="comment"></span>
<a name="l00738"></a>00738 <span class="comment">/**</span>
<a name="l00739"></a>00739 <span class="comment"> * Read the NAND parameter page</span>
<a name="l00740"></a>00740 <span class="comment"> *</span>
<a name="l00741"></a>00741 <span class="comment"> * @param chip   Chip select for NAND flash</span>
<a name="l00742"></a>00742 <span class="comment"> * @param buffer_address</span>
<a name="l00743"></a>00743 <span class="comment"> *               Physical address to store data in</span>
<a name="l00744"></a>00744 <span class="comment"> * @param buffer_length</span>
<a name="l00745"></a>00745 <span class="comment"> *               Length of the buffer. Usually this is 4 bytes</span>
<a name="l00746"></a>00746 <span class="comment"> *</span>
<a name="l00747"></a>00747 <span class="comment"> * @return Bytes read on success, a negative cvmx_nand_status_t error code on</span>
<a name="l00748"></a>00748 <span class="comment"> *         failure</span>
<a name="l00749"></a>00749 <span class="comment"> */</span>
<a name="l00750"></a>00750 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="cvmx-nand_8c.html#aff29480fd5a7ba882a9000300458de37" title="Read the NAND parameter page.">cvmx_nand_read_param_page</a>(<span class="keywordtype">int</span> chip, uint64_t buffer_address,
<a name="l00751"></a>00751                      <span class="keywordtype">int</span> buffer_length);
<a name="l00752"></a>00752 <span class="comment"></span>
<a name="l00753"></a>00753 <span class="comment">/**</span>
<a name="l00754"></a>00754 <span class="comment"> * Validate the ONFI parameter page and return a pointer to the config values.</span>
<a name="l00755"></a>00755 <span class="comment"> *</span>
<a name="l00756"></a>00756 <span class="comment"> * @param param_page Pointer to the raw NAND data returned after a parameter</span>
<a name="l00757"></a>00757 <span class="comment"> *                   page read.  It will contain at least 3 copies of the</span>
<a name="l00758"></a>00758 <span class="comment"> *                   parameter structure.</span>
<a name="l00759"></a>00759 <span class="comment"> *</span>
<a name="l00760"></a>00760 <span class="comment"> * @return Pointer to a validated paramter page, or NULL if one couldn&apos;t be</span>
<a name="l00761"></a>00761 <span class="comment"> *         found.</span>
<a name="l00762"></a>00762 <span class="comment"> */</span>
<a name="l00763"></a>00763 <span class="keyword">extern</span> <a class="code" href="structcvmx__nand__onfi__param__page__t.html">cvmx_nand_onfi_param_page_t</a> *
<a name="l00764"></a>00764 <a class="code" href="cvmx-nand_8c.html#af7f9773c35b8169c1574395e3dd64d7f" title="Validate the ONFI parameter page and return a pointer to the config values.">cvmx_nand_onfi_process</a>(<a class="code" href="structcvmx__nand__onfi__param__page__t.html">cvmx_nand_onfi_param_page_t</a> param_page[3]);
<a name="l00765"></a>00765 <span class="comment"></span>
<a name="l00766"></a>00766 <span class="comment">/**</span>
<a name="l00767"></a>00767 <span class="comment"> * Get the status of the NAND flash</span>
<a name="l00768"></a>00768 <span class="comment"> *</span>
<a name="l00769"></a>00769 <span class="comment"> * @param chip   Chip select for NAND flash</span>
<a name="l00770"></a>00770 <span class="comment"> *</span>
<a name="l00771"></a>00771 <span class="comment"> * @return NAND status or a negative cvmx_nand_status_t error code on failure</span>
<a name="l00772"></a>00772 <span class="comment"> */</span>
<a name="l00773"></a>00773 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="cvmx-nand_8c.html#a5efec3568a962010d22aad3a42cfc0b8" title="Get the status of the NAND flash.">cvmx_nand_get_status</a>(<span class="keywordtype">int</span> chip);
<a name="l00774"></a>00774 <span class="comment"></span>
<a name="l00775"></a>00775 <span class="comment">/**</span>
<a name="l00776"></a>00776 <span class="comment"> * Gets the specified feature number</span>
<a name="l00777"></a>00777 <span class="comment"> *</span>
<a name="l00778"></a>00778 <span class="comment"> * @param chip     Chip select for NAND flash</span>
<a name="l00779"></a>00779 <span class="comment"> * @param feat_num Feature number to get</span>
<a name="l00780"></a>00780 <span class="comment"> * @param feature  P1 - P4 of the feature data</span>
<a name="l00781"></a>00781 <span class="comment"> *</span>
<a name="l00782"></a>00782 <span class="comment"> * @return cvmx_nand_status_t error code</span>
<a name="l00783"></a>00783 <span class="comment"> */</span>
<a name="l00784"></a>00784 <a class="code" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e" title="Return codes from NAND functions.">cvmx_nand_status_t</a> <a class="code" href="cvmx-nand_8c.html#a9391034206344a3b44164db430c9f372" title="Gets the specified feature number.">cvmx_nand_get_feature</a>(<span class="keywordtype">int</span> chip, uint8_t feat_num,
<a name="l00785"></a>00785                      uint8_t feature[4]);
<a name="l00786"></a>00786 <span class="comment"></span>
<a name="l00787"></a>00787 <span class="comment">/**</span>
<a name="l00788"></a>00788 <span class="comment"> * Sets the specified feature number</span>
<a name="l00789"></a>00789 <span class="comment"> *</span>
<a name="l00790"></a>00790 <span class="comment"> * @param chip     Chip select for NAND flash</span>
<a name="l00791"></a>00791 <span class="comment"> * @param feat_num Feature number to get</span>
<a name="l00792"></a>00792 <span class="comment"> * @param feature  P1 - P4 of the feature data</span>
<a name="l00793"></a>00793 <span class="comment"> *</span>
<a name="l00794"></a>00794 <span class="comment"> * @return cvmx_nand_status_t error code</span>
<a name="l00795"></a>00795 <span class="comment"> */</span>
<a name="l00796"></a>00796 <a class="code" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e" title="Return codes from NAND functions.">cvmx_nand_status_t</a> <a class="code" href="cvmx-nand_8c.html#a2c36d924afdf9107b2634c7d18685150" title="Sets the specified feature number.">cvmx_nand_set_feature</a>(<span class="keywordtype">int</span> chip, uint8_t feat_num,
<a name="l00797"></a>00797                      <span class="keyword">const</span> uint8_t feature[4]);
<a name="l00798"></a>00798 <span class="comment"></span>
<a name="l00799"></a>00799 <span class="comment">/**</span>
<a name="l00800"></a>00800 <span class="comment"> * Get the page size, excluding out of band data. This  function</span>
<a name="l00801"></a>00801 <span class="comment"> * will return zero for chip selects not connected to NAND.</span>
<a name="l00802"></a>00802 <span class="comment"> *</span>
<a name="l00803"></a>00803 <span class="comment"> * @param chip   Chip select for NAND flash</span>
<a name="l00804"></a>00804 <span class="comment"> *</span>
<a name="l00805"></a>00805 <span class="comment"> * @return Page size in bytes or a negative cvmx_nand_status_t error code on</span>
<a name="l00806"></a>00806 <span class="comment"> *         failure</span>
<a name="l00807"></a>00807 <span class="comment"> */</span>
<a name="l00808"></a>00808 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="cvmx-nand_8c.html#ada46144a8bc76da93f90cf4afd683ea6" title="Get the page size, excluding out of band data.">cvmx_nand_get_page_size</a>(<span class="keywordtype">int</span> chip);
<a name="l00809"></a>00809 <span class="comment"></span>
<a name="l00810"></a>00810 <span class="comment">/**</span>
<a name="l00811"></a>00811 <span class="comment"> * Get the OOB size.</span>
<a name="l00812"></a>00812 <span class="comment"> *</span>
<a name="l00813"></a>00813 <span class="comment"> * @param chip   Chip select for NAND flash</span>
<a name="l00814"></a>00814 <span class="comment"> *</span>
<a name="l00815"></a>00815 <span class="comment"> * @return OOB in bytes or a negative cvmx_nand_status_t error code on failure</span>
<a name="l00816"></a>00816 <span class="comment"> */</span>
<a name="l00817"></a>00817 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="cvmx-nand_8c.html#a0d4059ce266ecabd68c7c7dc7651cb6c" title="Get the OOB size.">cvmx_nand_get_oob_size</a>(<span class="keywordtype">int</span> chip);
<a name="l00818"></a>00818 <span class="comment"></span>
<a name="l00819"></a>00819 <span class="comment">/**</span>
<a name="l00820"></a>00820 <span class="comment"> * Get the number of pages per NAND block</span>
<a name="l00821"></a>00821 <span class="comment"> *</span>
<a name="l00822"></a>00822 <span class="comment"> * @param chip   Chip select for NAND flash</span>
<a name="l00823"></a>00823 <span class="comment"> *</span>
<a name="l00824"></a>00824 <span class="comment"> * @return Numboer of pages in each block or a negative cvmx_nand_status_t</span>
<a name="l00825"></a>00825 <span class="comment"> *         error code on failure</span>
<a name="l00826"></a>00826 <span class="comment"> */</span>
<a name="l00827"></a>00827 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="cvmx-nand_8c.html#a0726e6f3c510046f5b8f62b85d2ebde4" title="Get the number of pages per NAND block.">cvmx_nand_get_pages_per_block</a>(<span class="keywordtype">int</span> chip);
<a name="l00828"></a>00828 <span class="comment"></span>
<a name="l00829"></a>00829 <span class="comment">/**</span>
<a name="l00830"></a>00830 <span class="comment"> * Get the number of blocks in the NAND flash</span>
<a name="l00831"></a>00831 <span class="comment"> *</span>
<a name="l00832"></a>00832 <span class="comment"> * @param chip   Chip select for NAND flash</span>
<a name="l00833"></a>00833 <span class="comment"> *</span>
<a name="l00834"></a>00834 <span class="comment"> * @return Number of blocks or a negative cvmx_nand_status_t error code on</span>
<a name="l00835"></a>00835 <span class="comment"> *         failure</span>
<a name="l00836"></a>00836 <span class="comment"> */</span>
<a name="l00837"></a>00837 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="cvmx-nand_8c.html#a85289e24ece28e5ca88d7e82499c7591" title="Get the number of blocks in the NAND flash.">cvmx_nand_get_blocks</a>(<span class="keywordtype">int</span> chip);
<a name="l00838"></a>00838 <span class="comment"></span>
<a name="l00839"></a>00839 <span class="comment">/**</span>
<a name="l00840"></a>00840 <span class="comment"> * Reset the NAND flash</span>
<a name="l00841"></a>00841 <span class="comment"> *</span>
<a name="l00842"></a>00842 <span class="comment"> * @param chip   Chip select for NAND flash</span>
<a name="l00843"></a>00843 <span class="comment"> *</span>
<a name="l00844"></a>00844 <span class="comment"> * @return Zero on success, a negative cvmx_nand_status_t error code on failure</span>
<a name="l00845"></a>00845 <span class="comment"> */</span>
<a name="l00846"></a>00846 <span class="keyword">extern</span> <a class="code" href="cvmx-nand_8h.html#a0137d742aae515cbe1dae6e1bf3a8c7e" title="Return codes from NAND functions.">cvmx_nand_status_t</a> <a class="code" href="cvmx-nand_8c.html#a28d7bd4c07f5fcb7687e591d6419e5b0" title="Reset the NAND flash.">cvmx_nand_reset</a>(<span class="keywordtype">int</span> chip);
<a name="l00847"></a>00847 <span class="comment"></span>
<a name="l00848"></a>00848 <span class="comment">/**</span>
<a name="l00849"></a>00849 <span class="comment"> * This function computes the Octeon specific ECC data used by the NAND boot</span>
<a name="l00850"></a>00850 <span class="comment"> * feature.</span>
<a name="l00851"></a>00851 <span class="comment"> *</span>
<a name="l00852"></a>00852 <span class="comment"> * @param block  pointer to 256 bytes of data</span>
<a name="l00853"></a>00853 <span class="comment"> * @param eccp   pointer to where 8 bytes of ECC data will be stored</span>
<a name="l00854"></a>00854 <span class="comment"> */</span>
<a name="l00855"></a>00855 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="cvmx-nand_8c.html#ab302e98b24747989dc80014b3af8e199" title="This function computes the Octeon specific ECC data used by the NAND boot feature...">cvmx_nand_compute_boot_ecc</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *block,
<a name="l00856"></a>00856                        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *eccp);
<a name="l00857"></a>00857 
<a name="l00858"></a>00858 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="cvmx-nand_8c.html#a2ce204f8d9bf170edc0eff27b0d642eb" title="Check an Octeon ECC block, fixing errors if possible.">cvmx_nand_correct_boot_ecc</a>(uint8_t *block);
<a name="l00859"></a>00859 <span class="preprocessor">#ifdef  __cplusplus</span>
<a name="l00860"></a>00860 <span class="preprocessor"></span><span class="comment">/* *INDENT-OFF* */</span>
<a name="l00861"></a>00861 }
<a name="l00862"></a>00862 <span class="comment">/* *INDENT-ON* */</span>
<a name="l00863"></a>00863 <span class="preprocessor">#endif</span>
<a name="l00864"></a>00864 <span class="preprocessor"></span>
<a name="l00865"></a>00865 <span class="preprocessor">#endif </span><span class="comment">/* __CVMX_NAND_H__ */</span>
</pre></div></div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Oct 2017 for Octeon Software Development Kit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
