<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Octeon Software Development Kit: cvmx-pko3.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cvmx-pko3.c File Reference</h1><code>#include &quot;<a class="el" href="cvmx_8h_source.html">cvmx.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cvmx-hwpko_8h_source.html">cvmx-hwpko.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cvmx-fpa3_8h_source.html">cvmx-fpa3.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cvmx-pko3_8h_source.html">cvmx-pko3.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cvmx-pko3-resources_8h_source.html">cvmx-pko3-resources.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cvmx-helper-pko3_8h_source.html">cvmx-helper-pko3.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cvmx-helper-bgx_8h_source.html">cvmx-helper-bgx.h</a>&quot;</code><br/>
<code>#include &lt;errno.h&gt;</code><br/>
<div class="dynheader">
Include dependency graph for cvmx-pko3.c:</div>
<div class="dynsection">
<div class="center"><img src="cvmx-pko3_8c__incl.png" border="0" usemap="#cvmx-pko3_8c_map" alt=""/></div>
<map name="cvmx-pko3_8c_map" id="cvmx-pko3_8c">
<area shape="rect" id="node3" href="cvmx_8h.html" title="Main Octeon executive header file (This should be the second header file included..." alt="" coords="983,392,1052,421"/><area shape="rect" id="node77" href="cvmx-fpa3_8h.html" title="Interface to the CN78XX Free Pool Allocator, a.k.a." alt="" coords="1675,547,1781,576"/><area shape="rect" id="node81" href="cvmx-hwpko_8h.html" title="Interface to the hardware Packet Output unit." alt="" coords="1129,83,1247,112"/><area shape="rect" id="node93" href="cvmx-pko3_8h.html" title="cvmx&#45;pko3.h" alt="" coords="1443,160,1549,189"/><area shape="rect" id="node125" href="cvmx-pko3-resources_8h.html" title="cvmx&#45;pko3&#45;resources.h" alt="" coords="1888,83,2067,112"/><area shape="rect" id="node127" href="cvmx-helper-pko3_8h.html" title="cvmx&#45;helper&#45;pko3.h" alt="" coords="2091,83,2245,112"/><area shape="rect" id="node129" href="cvmx-helper-bgx_8h.html" title="Functions to configure the BGX MAC." alt="" coords="2269,83,2416,112"/><area shape="rect" id="node5" href="cvmx-platform_8h.html" title="This file is resposible for including all system dependent headers for the cvmx&#45;*..." alt="" coords="749,547,883,576"/><area shape="rect" id="node25" href="cvmx-access_8h.html" title="Function prototypes for accessing memory and CSRs on Octeon." alt="" coords="348,547,471,576"/><area shape="rect" id="node27" href="cvmx-address_8h.html" title="Typedefs and defines for working with Octeon physical addresses." alt="" coords="1291,469,1419,499"/><area shape="rect" id="node30" href="cvmx-asm_8h.html" title="This is file defines ASM primitives for the executive." alt="" coords="220,701,324,731"/><area shape="rect" id="node32" href="cvmx-packet_8h.html" title="Packet buffer defines." alt="" coords="688,469,811,499"/><area shape="rect" id="node34" href="cvmx-warn_8h.html" title="Functions for warning users about errors and such." alt="" coords="93,469,203,499"/><area shape="rect" id="node36" href="cvmx-sysinfo_8h.html" title="This module provides system/board information obtained by the bootloader." alt="" coords="491,469,613,499"/><area shape="rect" id="node46" href="octeon-model_8h.html" title="File defining different Octeon model IDs and macros to compare them." alt="" coords="955,469,1083,499"/><area shape="rect" id="node48" href="cvmx-csr_8h.html" title="Configuration and status register (CSR) address and type definitions for Octoen." alt="" coords="835,469,931,499"/><area shape="rect" id="node59" href="cvmx-utils_8h.html" title="Small utility functions and macros to ease programming of Octeon." alt="" coords="1077,547,1181,576"/><area shape="rect" id="node62" href="cvmx-clock_8h.html" title="Interface to Core, IO and DDR Clock." alt="" coords="1107,469,1216,499"/><area shape="rect" id="node65" href="octeon-feature_8h.html" title="File defining checks for different Octeon features." alt="" coords="227,469,365,499"/><area shape="rect" id="node67" href="cvmx-fpa_8h.html" title="Interface to the hardware Free Pool Allocator." alt="" coords="1493,469,1592,499"/><area shape="rect" id="node7" href="cvmx-abi_8h.html" title="This file defines macros for use in determining the current calling ABI." alt="" coords="1219,624,1315,653"/><area shape="rect" id="node38" href="cvmx-app-init_8h.html" title="Header file for simple executive application initialization." alt="" coords="545,547,673,576"/><area shape="rect" id="node40" href="cvmx-coremask_8h.html" title="Module to support operations on bitmap of cores." alt="" coords="309,624,451,653"/><area shape="rect" id="node51" href="cvmx-csr-enums_8h.html" title="Definitions for enumerations used with Octeon CSRs." alt="" coords="907,547,1053,576"/><area shape="rect" id="node53" href="cvmx-csr-typedefs_8h.html" title="Configuration and status register (CSR) address and type definitions for Octeon." alt="" coords="1256,547,1419,576"/><area shape="rect" id="node55" href="cvmx-fpa-defs_8h.html" title="cvmx&#45;fpa&#45;defs.h" alt="" coords="1511,624,1644,653"/><area shape="rect" id="node57" href="cvmx-pko-defs_8h.html" title="cvmx&#45;pko&#45;defs.h" alt="" coords="1344,624,1477,653"/><area shape="rect" id="node69" href="cvmx-scratch_8h.html" title="This file provides support for the processor local scratch memory." alt="" coords="1755,624,1883,653"/><area shape="rect" id="node73" href="cvmx-fpa1_8h.html" title="Interface to the hardware Free Pool Allocator on Octeon chips." alt="" coords="1544,547,1651,576"/><area shape="rect" id="node83" href="cvmx-hwfau_8h.html" title="Interface to the hardware Fetch and Add Unit." alt="" coords="1251,160,1368,189"/><area shape="rect" id="node86" href="cvmx-pow_8h.html" title="Interface to the hardware Scheduling unit." alt="" coords="1251,237,1352,267"/><area shape="rect" id="node98" href="cvmx-helper_8h.html" title="Helper functions for common, but complicated tasks." alt="" coords="1108,237,1225,267"/><area shape="rect" id="node101" href="cvmx-helper-util_8h.html" title="Small helper utilities." alt="" coords="944,315,1088,344"/><area shape="rect" id="node113" href="cvmx-cmd-queue_8h.html" title="Support functions for managing command queues used for various hardware blocks." alt="" coords="581,160,736,189"/><area shape="rect" id="node118" href="cvmx-helper-cfg_8h.html" title="Helper Functions for the Configuration Framework." alt="" coords="931,160,1075,189"/><area shape="rect" id="node121" href="cvmx-helper-pko_8h.html" title="PKO helper, configuration API." alt="" coords="760,160,907,189"/><area shape="rect" id="node89" href="cvmx-wqe_8h.html" title="This header file defines the work queue entry (wqe) data structure." alt="" coords="1112,315,1216,344"/><area shape="rect" id="node96" href="cvmx-pko3-queue_8h.html" title="cvmx&#45;pko3&#45;queue.h" alt="" coords="1493,237,1648,267"/><area shape="rect" id="node106" href="cvmx-ilk_8h.html" title="This file contains defines for the ILK interface." alt="" coords="1672,237,1763,267"/><area shape="rect" id="node109" href="cvmx-atomic_8h.html" title="This file provides atomic operations." alt="" coords="597,237,720,267"/></map>
</div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#ab9ae9b97ea24b60be1c36cb9acf08b44">CVMX_DUMP_REGX</a>(reg)</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#ab546d9e1311d3573dea9afde0c868f96">cvmx_pko_setup_macs</a> (int node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#a0c42000f0b3dd6bcdf81832a13b7d92a">pko_dqstatus_error</a> (<a class="el" href="cvmx-pko3_8h.html#a572304c71084c1288c294aa5ba1c4463">pko_query_dqstatus_t</a> dqstatus)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">PKO <a class="el" href="structdescriptor.html">descriptor</a> queue operation error string.  <a href="#a0c42000f0b3dd6bcdf81832a13b7d92a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#aa3803f1e6c55c560ec2a9bd31eeb1a58">cvmx_pko3_hw_init_global</a> (int node, uint16_t aura)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#ac830a9d5ba5e66dda6106b05c8f0eae2">cvmx_pko3_hw_disable</a> (int node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shutdown the entire PKO.  <a href="#ac830a9d5ba5e66dda6106b05c8f0eae2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#a139cc99f96e87e884b5d29de89ef891b">cvmx_pko3_channel_credit_level</a> (int node, enum <a class="el" href="cvmx-pko3_8h.html#adb936c330325cc89cb4ac32d4676254b">cvmx_pko3_level_e</a> level)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#abeda601cd6c628c9992ff007854d761b">cvmx_pko_dq_open</a> (int node, int dq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open configured <a class="el" href="structdescriptor.html">descriptor</a> queues before queueing packets into them.  <a href="#abeda601cd6c628c9992ff007854d761b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#ad5147bf1f6af8fe88283371a1f9108f2">cvmx_pko3_dq_close</a> (int node, int dq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a <a class="el" href="structdescriptor.html">descriptor</a> queue.  <a href="#ad5147bf1f6af8fe88283371a1f9108f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#a014bec97b3cda32ba7b9661b7976421d">cvmx_pko3_dq_drain</a> (int node, int dq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drain a <a class="el" href="structdescriptor.html">descriptor</a> queue.  <a href="#a014bec97b3cda32ba7b9661b7976421d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#ad77e7e5302376e34fc81966a0eabcbf2">cvmx_pko3_dq_query</a> (int node, int dq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query a <a class="el" href="structdescriptor.html">descriptor</a> queue.  <a href="#ad77e7e5302376e34fc81966a0eabcbf2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#a7a44d5831d7836dd5c14e136802bcc7c">cvmx_pko3_get_legacy_port_stats</a> (uint16_t ipd_port, unsigned clear, <a class="el" href="structcvmx__pko__port__status.html">cvmx_pko_port_status_t</a> *stats)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal use function.  <a href="#a7a44d5831d7836dd5c14e136802bcc7c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#ae57c08bae1f84c6ba4de598582ca9958">cvmx_pko3_interface_options</a> (int xiface, int index, bool fcs_enable, bool pad_enable, unsigned fcs_sop_off)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set MAC options.  <a href="#ae57c08bae1f84c6ba4de598582ca9958"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#a3c8d9f7aca325b5fe4bfd968eab44c5d">EXPORT_SYMBOL</a> (cvmx_pko3_interface_options)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#aa623d08e836f9ffb32831951babadd24">cvmx_pko3_dq_options</a> (unsigned node, unsigned dq, bool min_pad)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set Descriptor Queue options.  <a href="#aa623d08e836f9ffb32831951babadd24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#a91208e57e2c5d7d7dafdacac848c1e30">cvmx_pko3_internal_buffer_count</a> (unsigned node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get number of PKO internal buffers available.  <a href="#a91208e57e2c5d7d7dafdacac848c1e30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#ad72ee21a97b97dd67ccf0cd35e26b874">cvmx_pko3_port_fifo_size</a> (unsigned int xiface, unsigned index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal use function.  <a href="#ad72ee21a97b97dd67ccf0cd35e26b874"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#a84fdf59900ce0a4b5c159fe52deee557">EXPORT_SYMBOL</a> (cvmx_pko3_port_fifo_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#a9578cf19902509df773b5422f5b6f5aa">cvmx_pko3_port_xoff</a> (unsigned int xiface, unsigned index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal use function.  <a href="#a9578cf19902509df773b5422f5b6f5aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#a45049857a1e2dde10b78171957a3ce72">cvmx_pko3_port_xon</a> (unsigned int xiface, unsigned index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal use function.  <a href="#a45049857a1e2dde10b78171957a3ce72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#a2457d75d2ef80e23c4b574b9227aeba4">cvmx_pko3_pdesc_init</a> (<a class="el" href="structcvmx__pko3__pdesc__s.html">cvmx_pko3_pdesc_t</a> *pdesc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize packet <a class="el" href="structdescriptor.html">descriptor</a>.  <a href="#a2457d75d2ef80e23c4b574b9227aeba4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#ae205a7e1cc1c184c856f55422e03cab1">cvmx_pko3_pdesc_from_wqe</a> (<a class="el" href="structcvmx__pko3__pdesc__s.html">cvmx_pko3_pdesc_t</a> *pdesc, <a class="el" href="structcvmx__wqe__78xx__t.html">cvmx_wqe_78xx_t</a> *wqe, bool free_bufs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a packet <a class="el" href="structdescriptor.html">descriptor</a> from WQE.  <a href="#ae205a7e1cc1c184c856f55422e03cab1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#a4c4bef3a341353d4b9cd620020224691">cvmx_pko3_pdesc_subdc_add</a> (<a class="el" href="structcvmx__pko3__pdesc__s.html">cvmx_pko3_pdesc_t</a> *pdesc, uint64_t subdc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal use function.  <a href="#a4c4bef3a341353d4b9cd620020224691"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#a0716acbac44ccac16e283a1c95229c25">cvmx_pko3_pdesc_transmit</a> (<a class="el" href="structcvmx__pko3__pdesc__s.html">cvmx_pko3_pdesc_t</a> *pdesc, uint16_t dq, uint32_t *tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a packet in a desciptor to an output port via an output queue.  <a href="#a0716acbac44ccac16e283a1c95229c25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#a54a53de8f638b7a310bdae083946e7de">cvmx_pko3_pdesc_append_free</a> (<a class="el" href="structcvmx__pko3__pdesc__s.html">cvmx_pko3_pdesc_t</a> *pdesc, uint64_t addr, unsigned gaura)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#a376824b8c7e601d244771a5a683b1ecd">cvmx_pko3_pdesc_buf_append</a> (<a class="el" href="structcvmx__pko3__pdesc__s.html">cvmx_pko3_pdesc_t</a> *pdesc, void *p_data, unsigned data_bytes, unsigned gaura)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a packet segment to a packet <a class="el" href="structdescriptor.html">descriptor</a>.  <a href="#a376824b8c7e601d244771a5a683b1ecd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#ad94338f36d2bc14ba5ab8f1403374b78">cvmx_pko3_pdesc_notify_wqe</a> (<a class="el" href="structcvmx__pko3__pdesc__s.html">cvmx_pko3_pdesc_t</a> *pdesc, <a class="el" href="structcvmx__wqe__78xx__t.html">cvmx_wqe_78xx_t</a> *wqe, uint8_t node, uint8_t group, uint8_t tt, uint32_t tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a Work Entry for packet transmission notification.  <a href="#ad94338f36d2bc14ba5ab8f1403374b78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#a4744d965a3d8597dfdb1b43200af24be">cvmx_pko3_pdesc_notify_decrement</a> (<a class="el" href="structcvmx__pko3__pdesc__s.html">cvmx_pko3_pdesc_t</a> *pdesc, volatile uint64_t *p_counter)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request atomic memory decrement at transmission completion.  <a href="#a4744d965a3d8597dfdb1b43200af24be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#a3eb848dbe9c286294710600b73e580f9">cvmx_pko3_pdesc_notify_memclr</a> (<a class="el" href="structcvmx__pko3__pdesc__s.html">cvmx_pko3_pdesc_t</a> *pdesc, volatile uint8_t *p_mem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request atomic memory clear at transmission completion.  <a href="#a3eb848dbe9c286294710600b73e580f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#a928204fb50529f614dbd4c58d657bd76">cvmx_pko3_pdesc_hdr_offsets</a> (<a class="el" href="structcvmx__pko3__pdesc__s.html">cvmx_pko3_pdesc_t</a> *pdesc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal use function.  <a href="#a928204fb50529f614dbd4c58d657bd76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#a5511b1402dd5a8e7c2186c8f21114766">memcpy_swap</a> (void *dst, const void *src, unsigned bytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#a6db2b3e75bf3bec6dd5ee4a7ae3615b7">memcpy_from_swap</a> (void *dst, const void *src, unsigned bytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#a4d991bed9e6ee00c43ae10d5b09969cb">memcpy_to_swap</a> (void *dst, const void *src, unsigned bytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#a39ce8fe04684ac95179df6b301db8405">cvmx_pko3_pdesc_hdr_push</a> (<a class="el" href="structcvmx__pko3__pdesc__s.html">cvmx_pko3_pdesc_t</a> *pdesc, const void *p_data, uint8_t data_bytes, uint8_t layer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepend a data segment to the packet <a class="el" href="structdescriptor.html">descriptor</a>.  <a href="#a39ce8fe04684ac95179df6b301db8405"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#aff344df78201ecb32c062817fa8a1923">cvmx_pko3_pdesc_hdr_pop</a> (<a class="el" href="structcvmx__pko3__pdesc__s.html">cvmx_pko3_pdesc_t</a> *pdesc, void *hdr_buf, unsigned num_bytes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove some bytes from start of packet.  <a href="#aff344df78201ecb32c062817fa8a1923"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#ace567085ed7bd14851fadd574b4ecf4a">cvmx_pko3_pdesc_hdr_peek</a> (<a class="el" href="structcvmx__pko3__pdesc__s.html">cvmx_pko3_pdesc_t</a> *pdesc, void *hdr_buf, unsigned num_bytes, unsigned offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Peek into some header field of a packet.  <a href="#ace567085ed7bd14851fadd574b4ecf4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#a0f023ec697c1147b6ee8ab3d71dc9d6f">cvmx_pko3_pdesc_set_free</a> (<a class="el" href="structcvmx__pko3__pdesc__s.html">cvmx_pko3_pdesc_t</a> *pdesc, bool free_bufs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the packet <a class="el" href="structdescriptor.html">descriptor</a> automatic-free attribute.  <a href="#a0f023ec697c1147b6ee8ab3d71dc9d6f"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#a656b8d50e4036b8ae51663e47beea58d">debug</a> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pko3_8c.html#a8d5368f3008df1d00b865ad7f36506bf">__native_le</a> = 1</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ab9ae9b97ea24b60be1c36cb9acf08b44"></a><!-- doxytag: member="cvmx&#45;pko3.c::CVMX_DUMP_REGX" ref="ab9ae9b97ea24b60be1c36cb9acf08b44" args="(reg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CVMX_DUMP_REGX</td>
          <td>(</td>
          <td class="paramtype">reg&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">if</span>(<a class="code" href="cvmx-bch_8c.html#a6342d87e4f91ba01444a8783f2fbc08c">debug</a>)       \
    <a class="code" href="cvmx-utils_8h.html#a50112e4e118a749dcf244ccafcdc37ba">cvmx_dprintf</a>(<span class="stringliteral">&quot;%s=%#llx\n&quot;</span>,#reg,(<span class="keywordtype">long</span> <span class="keywordtype">long</span>)<a class="code" href="cvmx-access-native_8h.html#a284be8700d10b389a653f7a74d3761aa" title="Read from a CSR address on the specified node.">cvmx_read_csr_node</a>(<a class="code" href="structcvmx__interrupt.html#a1d1caa0c43d42dd85e9bc3ee1bdbfe7c" title="Set by user code.">node</a>,reg))
</pre></div>
</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a139cc99f96e87e884b5d29de89ef891b"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko3_channel_credit_level" ref="a139cc99f96e87e884b5d29de89ef891b" args="(int node, enum cvmx_pko3_level_e level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_pko3_channel_credit_level </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="cvmx-pko3_8h.html#adb936c330325cc89cb4ac32d4676254b">cvmx_pko3_level_e</a>&nbsp;</td>
          <td class="paramname"> <em>level</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad5147bf1f6af8fe88283371a1f9108f2"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko3_dq_close" ref="ad5147bf1f6af8fe88283371a1f9108f2" args="(int node, int dq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_pko3_dq_close </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dq</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close a <a class="el" href="structdescriptor.html">descriptor</a> queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>is to specify the node to which this configuration is applied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dq</em>&nbsp;</td><td>is the <a class="el" href="structdescriptor.html">descriptor</a> queue number to be opened. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>returns 0 on sucess or -1 on failure.</dd></dl>
<p>This should be called before changing the DQ parent link, topology, or when shutting down the PKO. </p>

</div>
</div>
<a class="anchor" id="a014bec97b3cda32ba7b9661b7976421d"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko3_dq_drain" ref="a014bec97b3cda32ba7b9661b7976421d" args="(int node, int dq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvmx_pko3_dq_drain </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dq</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Drain a <a class="el" href="structdescriptor.html">descriptor</a> queue. </p>
<p>Before closing a DQ, this call will drain all pending traffic on the DQ to the NULL MAC, which will circumvent any traffic shaping and flow control to quickly reclaim all packet buffers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>is to specify the node to which this configuration is applied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dq</em>&nbsp;</td><td>is the <a class="el" href="structdescriptor.html">descriptor</a> queue number to be drained. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa623d08e836f9ffb32831951babadd24"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko3_dq_options" ref="aa623d08e836f9ffb32831951babadd24" args="(unsigned node, unsigned dq, bool min_pad)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvmx_pko3_dq_options </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>dq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>min_pad</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set Descriptor Queue options. </p>
<p>The `min_pad` parameter must be in agreement with the interface-level padding option for all <a class="el" href="structdescriptor.html">descriptor</a> queues assigned to that particular interface/port.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>on which to operate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dq</em>&nbsp;</td><td><a class="el" href="structdescriptor.html">descriptor</a> queue to set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>min_pad</em>&nbsp;</td><td>minimum padding to set for dq </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad77e7e5302376e34fc81966a0eabcbf2"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko3_dq_query" ref="ad77e7e5302376e34fc81966a0eabcbf2" args="(int node, int dq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_pko3_dq_query </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dq</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query a <a class="el" href="structdescriptor.html">descriptor</a> queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>is to specify the node to which this configuration is applied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dq</em>&nbsp;</td><td>is the <a class="el" href="structdescriptor.html">descriptor</a> queue number to be opened. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>returns the <a class="el" href="structdescriptor.html">descriptor</a> queue depth on sucess or -1 on failure.</dd></dl>
<p>This should be called before changing the DQ parent link, topology, or when shutting down the PKO. </p>

</div>
</div>
<a class="anchor" id="a7a44d5831d7836dd5c14e136802bcc7c"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko3_get_legacy_port_stats" ref="a7a44d5831d7836dd5c14e136802bcc7c" args="(uint16_t ipd_port, unsigned clear, cvmx_pko_port_status_t *stats)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvmx_pko3_get_legacy_port_stats </td>
          <td>(</td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>ipd_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>clear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvmx__pko__port__status.html">cvmx_pko_port_status_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stats</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal use function. </p>
<p><b>This function's parameters and processing may change in future SDKs.</b><br/>
<br/>
 Backward compatibility for collecting statistics from PKO3</p>
<p>NOTE: The good stats are in BGX block. </p>

</div>
</div>
<a class="anchor" id="ac830a9d5ba5e66dda6106b05c8f0eae2"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko3_hw_disable" ref="ac830a9d5ba5e66dda6106b05c8f0eae2" args="(int node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_pko3_hw_disable </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shutdown the entire PKO. </p>

</div>
</div>
<a class="anchor" id="aa3803f1e6c55c560ec2a9bd31eeb1a58"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko3_hw_init_global" ref="aa3803f1e6c55c560ec2a9bd31eeb1a58" args="(int node, uint16_t aura)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_pko3_hw_init_global </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>aura</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae57c08bae1f84c6ba4de598582ca9958"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko3_interface_options" ref="ae57c08bae1f84c6ba4de598582ca9958" args="(int xiface, int index, bool fcs_enable, bool pad_enable, unsigned fcs_sop_off)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_pko3_interface_options </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>xiface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>fcs_enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>pad_enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>fcs_sop_off</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set MAC options. </p>
<p>The options supported are the parameters below:</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xiface</em>&nbsp;</td><td>The physical interface number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>The physical sub-interface port </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fcs_enable</em>&nbsp;</td><td>Enable FCS generation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pad_enable</em>&nbsp;</td><td>Enable padding to minimum packet size </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fcs_sop_off</em>&nbsp;</td><td>Number of bytes at start of packet to exclude from FCS</td></tr>
  </table>
  </dd>
</dl>
<p>The typical use for `fcs_sop_off` is when the interface is configured to use a header such as HighGig to precede every Ethernet packet, such a header usually does not partake in the CRC32 computation stream, and its size must be set with this parameter.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 on success, -1 if interface/port is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="a91208e57e2c5d7d7dafdacac848c1e30"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko3_internal_buffer_count" ref="a91208e57e2c5d7d7dafdacac848c1e30" args="(unsigned node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_pko3_internal_buffer_count </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get number of PKO internal buffers available. </p>
<p>This function may be used to throttle output processing when the PKO runs out of internal buffers, to avoid discarding of packets or returning error results from transmission function.</p>
<p>Returns negative numbers on error, positive number ti nidicate the number of buffers available, or 0 when no more buffers are available.</p>
<p>Internal use function. <b>This function's parameters and processing may change in future SDKs.</b><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a54a53de8f638b7a310bdae083946e7de"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko3_pdesc_append_free" ref="a54a53de8f638b7a310bdae083946e7de" args="(cvmx_pko3_pdesc_t *pdesc, uint64_t addr, unsigned gaura)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_pko3_pdesc_append_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__pko3__pdesc__s.html">cvmx_pko3_pdesc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pdesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>gaura</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a376824b8c7e601d244771a5a683b1ecd"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko3_pdesc_buf_append" ref="a376824b8c7e601d244771a5a683b1ecd" args="(cvmx_pko3_pdesc_t *pdesc, void *p_data, unsigned data_bytes, unsigned gaura)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_pko3_pdesc_buf_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__pko3__pdesc__s.html">cvmx_pko3_pdesc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pdesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>data_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>gaura</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append a packet segment to a packet <a class="el" href="structdescriptor.html">descriptor</a>. </p>
<p>After a packet <a class="el" href="structdescriptor.html">descriptor</a> is initialized, one or more packet data segments can be added to the packet, in the order in which they should be transmitted.</p>
<p>The size of the resulting packet will be equal to the sum of the segments appended by this function. Every segment may be contained in a buffer that belongs to a different FPA 'aura', and may be automatically released back to that aura, if required.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pdesc</em>&nbsp;</td><td>Packet Desciptor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_data</em>&nbsp;</td><td>Address of the segment first byte (virtual). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data_bytes</em>&nbsp;</td><td>Size of the data segment (in bytes). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gaura</em>&nbsp;</td><td>A global FPA 'aura' where the packet buffer was allocated from.</td></tr>
  </table>
  </dd>
</dl>
<p>The 'gaura' parameter contains the node number where the buffer pool is located, and has only a meaning if the 'free_buf' argument is 'true'. The buffer being added will be automatically freed upon transmission along with all other buffers in this <a class="el" href="structdescriptor.html">descriptor</a>, or not, depending on the <a class="el" href="structdescriptor.html">descriptor</a> 'free_bufs' attribute that is set during <a class="el" href="structdescriptor.html">descriptor</a> creation, or changed subsequently with a call to 'cvmx_pko3_pdesc_set_free()'.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 on success, -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ae205a7e1cc1c184c856f55422e03cab1"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko3_pdesc_from_wqe" ref="ae205a7e1cc1c184c856f55422e03cab1" args="(cvmx_pko3_pdesc_t *pdesc, cvmx_wqe_78xx_t *wqe, bool free_bufs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_pko3_pdesc_from_wqe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__pko3__pdesc__s.html">cvmx_pko3_pdesc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pdesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvmx__wqe__78xx__t.html">cvmx_wqe_78xx_t</a> *&nbsp;</td>
          <td class="paramname"> <em>wqe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>free_bufs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a packet <a class="el" href="structdescriptor.html">descriptor</a> from WQE. </p>
<p>Populate a packet <a class="el" href="structdescriptor.html">descriptor</a> with a packet data and meta-data located in the Work Queue Entry. After this function, it is safe to call 'cvmx-wqe-free()' to release the WQE buffer if separate from data buffers. This function discards any data or meta-data that may have been present in the packet <a class="el" href="structdescriptor.html">descriptor</a> previously, and does not require the call to 'cvmx_pko3_pdesc_init()'.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pdesc</em>&nbsp;</td><td>Packet Desciptor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wqe</em>&nbsp;</td><td>Work Queue Entry as returned from `cvmx_get_work()' </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>free_bufs</em>&nbsp;</td><td>Automatically free data buffers when transmission complete.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is the quickest way to prepare a received packet represented by a WQE for transmission via any output queue to an output port. If the packet data is to be transmitted unmodified, call 'cvmx_pko_pdesc_transmit()' immediately after this function returns. </p>

</div>
</div>
<a class="anchor" id="a928204fb50529f614dbd4c58d657bd76"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko3_pdesc_hdr_offsets" ref="a928204fb50529f614dbd4c58d657bd76" args="(cvmx_pko3_pdesc_t *pdesc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int cvmx_pko3_pdesc_hdr_offsets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__pko3__pdesc__s.html">cvmx_pko3_pdesc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pdesc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal use function. </p>
<p><b>This function's parameters and processing may change in future SDKs.</b><br/>
<br/>
</p>
<p>Decode packet header and calculate protocol header offsets</p>
<p>The protocol information and layer offset is derived from the results if decoding done by the PKI, and the appropriate PKO fields are filled.</p>
<p>The function assumes the headers have not been modified since converted from WQE, and does not (yet) implement software-based decoding to handle modified or originated packets correctly.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Need to add simple accessors to read the decoded protocol fields. </dd></dl>

</div>
</div>
<a class="anchor" id="ace567085ed7bd14851fadd574b4ecf4a"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko3_pdesc_hdr_peek" ref="ace567085ed7bd14851fadd574b4ecf4a" args="(cvmx_pko3_pdesc_t *pdesc, void *hdr_buf, unsigned num_bytes, unsigned offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_pko3_pdesc_hdr_peek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__pko3__pdesc__s.html">cvmx_pko3_pdesc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pdesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>hdr_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>num_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Peek into some header field of a packet. </p>
<p>Will return a number of bytes of packet header data at an arbitrary offset which must reside within the first packet data buffer. </p>

</div>
</div>
<a class="anchor" id="aff344df78201ecb32c062817fa8a1923"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko3_pdesc_hdr_pop" ref="aff344df78201ecb32c062817fa8a1923" args="(cvmx_pko3_pdesc_t *pdesc, void *hdr_buf, unsigned num_bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_pko3_pdesc_hdr_pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__pko3__pdesc__s.html">cvmx_pko3_pdesc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pdesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>hdr_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>num_bytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove some bytes from start of packet. </p>
<p>Useful for popping a header from a packet. It only needs to find the first segment, and adjust its address, as well as segment and total sizes.</p>
<p>Returns new packet size, or -1 if the trimmed size exceeds the size of the first data segment. </p>

</div>
</div>
<a class="anchor" id="a39ce8fe04684ac95179df6b301db8405"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko3_pdesc_hdr_push" ref="a39ce8fe04684ac95179df6b301db8405" args="(cvmx_pko3_pdesc_t *pdesc, const void *p_data, uint8_t data_bytes, uint8_t layer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_pko3_pdesc_hdr_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__pko3__pdesc__s.html">cvmx_pko3_pdesc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pdesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>data_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>layer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepend a data segment to the packet <a class="el" href="structdescriptor.html">descriptor</a>. </p>
<p>Useful for pushing additional headers</p>
<p>The initial implementation is confined by the size of the "headroom" in the first packet buffer attached to the <a class="el" href="structdescriptor.html">descriptor</a>. Future version may prepend additional buffers when this head room is insufficient, but currently will return -1 when headrom is insufficient.</p>
<p>On success, the function returns the remaining headroom in the buffer. </p>

</div>
</div>
<a class="anchor" id="a2457d75d2ef80e23c4b574b9227aeba4"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko3_pdesc_init" ref="a2457d75d2ef80e23c4b574b9227aeba4" args="(cvmx_pko3_pdesc_t *pdesc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvmx_pko3_pdesc_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__pko3__pdesc__s.html">cvmx_pko3_pdesc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pdesc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize packet <a class="el" href="structdescriptor.html">descriptor</a>. </p>
<p>Desciptor storage is provided by the caller, use this function to initialize the <a class="el" href="structdescriptor.html">descriptor</a> to a known empty state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pdesc</em>&nbsp;</td><td>Packet Desciptor.</td></tr>
  </table>
  </dd>
</dl>
<p>Do not use this function when creating a <a class="el" href="structdescriptor.html">descriptor</a> from a Work Queue Entry.</p>
<p>The default setting of the 'free_bufs' attribute is 'false'. </p>

</div>
</div>
<a class="anchor" id="a4744d965a3d8597dfdb1b43200af24be"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko3_pdesc_notify_decrement" ref="a4744d965a3d8597dfdb1b43200af24be" args="(cvmx_pko3_pdesc_t *pdesc, volatile uint64_t *p_counter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_pko3_pdesc_notify_decrement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__pko3__pdesc__s.html">cvmx_pko3_pdesc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pdesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile uint64_t *&nbsp;</td>
          <td class="paramname"> <em>p_counter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request atomic memory decrement at transmission completion. </p>
<p>Each packet <a class="el" href="structdescriptor.html">descriptor</a> may contain several decrement notification requests, but these requests must only be made after all of the packet data segments have been added, and before packet transmission commences.</p>
<p>Only decrement of a 64-bit memory location is supported.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pdesc</em>&nbsp;</td><td>Packet Descriptor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_counter</em>&nbsp;</td><td>A pointer to an atomic 64-bit memory location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a3eb848dbe9c286294710600b73e580f9"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko3_pdesc_notify_memclr" ref="a3eb848dbe9c286294710600b73e580f9" args="(cvmx_pko3_pdesc_t *pdesc, volatile uint8_t *p_mem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_pko3_pdesc_notify_memclr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__pko3__pdesc__s.html">cvmx_pko3_pdesc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pdesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile uint8_t *&nbsp;</td>
          <td class="paramname"> <em>p_mem</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request atomic memory clear at transmission completion. </p>
<p>Each packet <a class="el" href="structdescriptor.html">descriptor</a> may contain several notification requests, but these request must only be made after all of the packet data segments have been added, and before packet transmission commences.</p>
<p>Clearing of a single byte is requested by this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pdesc</em>&nbsp;</td><td>Packet Descriptor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_mem</em>&nbsp;</td><td>A pointer to a byte location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ad94338f36d2bc14ba5ab8f1403374b78"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko3_pdesc_notify_wqe" ref="ad94338f36d2bc14ba5ab8f1403374b78" args="(cvmx_pko3_pdesc_t *pdesc, cvmx_wqe_78xx_t *wqe, uint8_t node, uint8_t group, uint8_t tt, uint32_t tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_pko3_pdesc_notify_wqe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__pko3__pdesc__s.html">cvmx_pko3_pdesc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pdesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvmx__wqe__78xx__t.html">cvmx_wqe_78xx_t</a> *&nbsp;</td>
          <td class="paramname"> <em>wqe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>tt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a Work Entry for packet transmission notification. </p>
<p>Add a subcommand to notify of packet transmission completion via a Work Queue entry over the SSO. The Work Queue entry may be a 'software' event, or the content of a packet.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pdesc</em>&nbsp;</td><td>Packet Desciptor, memory provided by caller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wqe</em>&nbsp;</td><td>Work Queue Entry in a model-native format. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>The OCI node of the SSO where the WQE will be delivered. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>group</em>&nbsp;</td><td>The SSO group where the WQE is delivered. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tt</em>&nbsp;</td><td>The SSO Tag Type for the WQE. If tt is not NULL, tag should be a valid tag value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>Valid tag value to assign to WQE</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 on success, -1 on error.</dd></dl>
<p>Restrictions: There can be only one such notification per packet <a class="el" href="structdescriptor.html">descriptor</a>, but this function may be called at any time after the <a class="el" href="structdescriptor.html">descriptor</a> is first created from WQE or initialized, and before starting transmission. </p>

</div>
</div>
<a class="anchor" id="a0f023ec697c1147b6ee8ab3d71dc9d6f"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko3_pdesc_set_free" ref="a0f023ec697c1147b6ee8ab3d71dc9d6f" args="(cvmx_pko3_pdesc_t *pdesc, bool free_bufs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvmx_pko3_pdesc_set_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__pko3__pdesc__s.html">cvmx_pko3_pdesc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pdesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>free_bufs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the packet <a class="el" href="structdescriptor.html">descriptor</a> automatic-free attribute. </p>
<p>Override the 'free_bufs' attribute that was set during packet <a class="el" href="structdescriptor.html">descriptor</a> creation, or by an earlier call to this function. Setting the 'buf_free attribute to 'true' will cause the PKO3 to free all buffers associated with this packet <a class="el" href="structdescriptor.html">descriptor</a> to be released upon transmission complete. Setting this attribute to 'false' allows e.g. using the same <a class="el" href="structdescriptor.html">descriptor</a> to transmit a packet out of several ports with a minimum overhead. </p>

</div>
</div>
<a class="anchor" id="a4c4bef3a341353d4b9cd620020224691"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko3_pdesc_subdc_add" ref="a4c4bef3a341353d4b9cd620020224691" args="(cvmx_pko3_pdesc_t *pdesc, uint64_t subdc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int cvmx_pko3_pdesc_subdc_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__pko3__pdesc__s.html">cvmx_pko3_pdesc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pdesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>subdc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal use function. </p>
<p><b>This function's parameters and processing may change in future SDKs.</b><br/>
<br/>
</p>
<p>Add arbitrary subcommand to a packet desciptor.</p>
<p>This function will also allocate a jump buffer when the primary LMTDMA buffer is exhausted. The jump buffer is allocated from the internal PKO3 aura on the node where this function is running. </p>

</div>
</div>
<a class="anchor" id="a0716acbac44ccac16e283a1c95229c25"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko3_pdesc_transmit" ref="a0716acbac44ccac16e283a1c95229c25" args="(cvmx_pko3_pdesc_t *pdesc, uint16_t dq, uint32_t *tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_pko3_pdesc_transmit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__pko3__pdesc__s.html">cvmx_pko3_pdesc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pdesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>dq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send a packet in a desciptor to an output port via an output queue. </p>
<p>A call to this function must follow all other functions that create a packet <a class="el" href="structdescriptor.html">descriptor</a> from WQE, or after initializing an empty <a class="el" href="structdescriptor.html">descriptor</a> and filling it with one or more data fragments. After this function is called, the content of the packet <a class="el" href="structdescriptor.html">descriptor</a> can no longer be used, and are undefined.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pdesc</em>&nbsp;</td><td>Packet Desciptor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dq</em>&nbsp;</td><td>Descriptor Queue associated with the desired output port </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>Flow Tag pointer for packet ordering or NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 on success, -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ad72ee21a97b97dd67ccf0cd35e26b874"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko3_port_fifo_size" ref="ad72ee21a97b97dd67ccf0cd35e26b874" args="(unsigned int xiface, unsigned index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_pko3_port_fifo_size </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>xiface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal use function. </p>
<p><b>This function's parameters and processing may change in future SDKs.</b><br/>
<br/>
</p>
<p>Get actual PKO FIFO buffer size for a given port</p>
<p>Since the FIFOs are allocated dynamically based on supply/demand heuristics, it may be useful in some instances to know the actual FIFO size allocated to any specific port at run time.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xiface</em>&nbsp;</td><td>global interface number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>port index on interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the per-port FIFO size in bytes, or 0 if the port has not been configured, or a negative number if the interface and index numbers are not valid. </dd></dl>

</div>
</div>
<a class="anchor" id="a9578cf19902509df773b5422f5b6f5aa"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko3_port_xoff" ref="a9578cf19902509df773b5422f5b6f5aa" args="(unsigned int xiface, unsigned index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_pko3_port_xoff </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>xiface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal use function. </p>
<p><b>This function's parameters and processing may change in future SDKs.</b><br/>
<br/>
</p>
<p>Stop an interface port transmission and wait until its FIFO is empty. </p>

</div>
</div>
<a class="anchor" id="a45049857a1e2dde10b78171957a3ce72"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko3_port_xon" ref="a45049857a1e2dde10b78171957a3ce72" args="(unsigned int xiface, unsigned index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_pko3_port_xon </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>xiface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal use function. </p>
<p><b>This function's parameters and processing may change in future SDKs.</b><br/>
<br/>
</p>
<p>Resume transmission on an interface port. </p>

</div>
</div>
<a class="anchor" id="abeda601cd6c628c9992ff007854d761b"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko_dq_open" ref="abeda601cd6c628c9992ff007854d761b" args="(int node, int dq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_pko_dq_open </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dq</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open configured <a class="el" href="structdescriptor.html">descriptor</a> queues before queueing packets into them. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>is to specify the node to which this configuration is applied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dq</em>&nbsp;</td><td>is the <a class="el" href="structdescriptor.html">descriptor</a> queue number to be opened. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>returns 0 on sucess or -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ab546d9e1311d3573dea9afde0c868f96"></a><!-- doxytag: member="cvmx&#45;pko3.c::cvmx_pko_setup_macs" ref="ab546d9e1311d3573dea9afde0c868f96" args="(int node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int cvmx_pko_setup_macs </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a84fdf59900ce0a4b5c159fe52deee557"></a><!-- doxytag: member="cvmx&#45;pko3.c::EXPORT_SYMBOL" ref="a84fdf59900ce0a4b5c159fe52deee557" args="(cvmx_pko3_port_fifo_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL </td>
          <td>(</td>
          <td class="paramtype">cvmx_pko3_port_fifo_size&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3c8d9f7aca325b5fe4bfd968eab44c5d"></a><!-- doxytag: member="cvmx&#45;pko3.c::EXPORT_SYMBOL" ref="a3c8d9f7aca325b5fe4bfd968eab44c5d" args="(cvmx_pko3_interface_options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT_SYMBOL </td>
          <td>(</td>
          <td class="paramtype">cvmx_pko3_interface_options&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6db2b3e75bf3bec6dd5ee4a7ae3615b7"></a><!-- doxytag: member="cvmx&#45;pko3.c::memcpy_from_swap" ref="a6db2b3e75bf3bec6dd5ee4a7ae3615b7" args="(void *dst, const void *src, unsigned bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void memcpy_from_swap </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>bytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5511b1402dd5a8e7c2186c8f21114766"></a><!-- doxytag: member="cvmx&#45;pko3.c::memcpy_swap" ref="a5511b1402dd5a8e7c2186c8f21114766" args="(void *dst, const void *src, unsigned bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void memcpy_swap </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>bytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4d991bed9e6ee00c43ae10d5b09969cb"></a><!-- doxytag: member="cvmx&#45;pko3.c::memcpy_to_swap" ref="a4d991bed9e6ee00c43ae10d5b09969cb" args="(void *dst, const void *src, unsigned bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void memcpy_to_swap </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>bytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0c42000f0b3dd6bcdf81832a13b7d92a"></a><!-- doxytag: member="cvmx&#45;pko3.c::pko_dqstatus_error" ref="a0c42000f0b3dd6bcdf81832a13b7d92a" args="(pko_query_dqstatus_t dqstatus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* pko_dqstatus_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cvmx-pko3_8h.html#a572304c71084c1288c294aa5ba1c4463">pko_query_dqstatus_t</a>&nbsp;</td>
          <td class="paramname"> <em>dqstatus</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>PKO <a class="el" href="structdescriptor.html">descriptor</a> queue operation error string. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dqstatus</em>&nbsp;</td><td>is the enumeration returned from hardware, PKO_QUERY_RTN_S[DQSTATUS].</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>static constant string error description </dd></dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a8d5368f3008df1d00b865ad7f36506bf"></a><!-- doxytag: member="cvmx&#45;pko3.c::__native_le" ref="a8d5368f3008df1d00b865ad7f36506bf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="cvmx-pko3_8c.html#a8d5368f3008df1d00b865ad7f36506bf">__native_le</a> = 1<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a656b8d50e4036b8ae51663e47beea58d"></a><!-- doxytag: member="cvmx&#45;pko3.c::debug" ref="a656b8d50e4036b8ae51663e47beea58d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="cvmx-tim-atomic_8c.html#a656b8d50e4036b8ae51663e47beea58d">debug</a> = 0<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Oct 2017 for Octeon Software Development Kit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
