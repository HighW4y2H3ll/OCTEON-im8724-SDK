<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Octeon Software Development Kit: cvmx-pow.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cvmx-pow.h File Reference</h1>
<p>Interface to the hardware Scheduling unit.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="cvmx-scratch_8h_source.html">cvmx-scratch.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cvmx-wqe_8h_source.html">cvmx-wqe.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cvmx-warn_8h_source.html">cvmx-warn.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cvmx-address_8h_source.html">cvmx-address.h</a>&quot;</code><br/>
<div class="dynheader">
Include dependency graph for cvmx-pow.h:</div>
<div class="dynsection">
<div class="center"><img src="cvmx-pow_8h__incl.png" border="0" usemap="#cvmx-pow_8h_map" alt=""/></div>
<map name="cvmx-pow_8h_map" id="cvmx-pow_8h">
<area shape="rect" id="node3" href="cvmx-scratch_8h.html" title="This file provides support for the processor local scratch memory." alt="" coords="5,83,133,112"/><area shape="rect" id="node5" href="cvmx-wqe_8h.html" title="This header file defines the work queue entry (wqe) data structure." alt="" coords="157,83,261,112"/><area shape="rect" id="node11" href="cvmx-warn_8h.html" title="Functions for warning users about errors and such." alt="" coords="285,83,395,112"/><area shape="rect" id="node13" href="cvmx-address_8h.html" title="Typedefs and defines for working with Octeon physical addresses." alt="" coords="419,83,547,112"/><area shape="rect" id="node7" href="cvmx-pki-defs_8h.html" title="cvmx&#45;pki&#45;defs.h" alt="" coords="57,160,188,189"/><area shape="rect" id="node9" href="cvmx-pip-defs_8h.html" title="cvmx&#45;pip&#45;defs.h" alt="" coords="212,160,343,189"/><area shape="rect" id="node15" href="cvmx-abi_8h.html" title="This file defines macros for use in determining the current calling ABI." alt="" coords="435,160,531,189"/></map>
</div>
<div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dynsection">
<div class="center"><img src="cvmx-pow_8h__dep__incl.png" border="0" usemap="#cvmx-pow_8hdep_map" alt=""/></div>
<map name="cvmx-pow_8hdep_map" id="cvmx-pow_8hdep">
<area shape="rect" id="node3" href="cvmx-helper-errata_8c.html" title="Fixes and workaround for Octeon chip errata." alt="" coords="5,237,171,267"/><area shape="rect" id="node5" href="cvmx-helper-pki_8c.html" title="PKI helper functions." alt="" coords="1563,83,1704,112"/><area shape="rect" id="node7" href="cvmx-hwpko_8h.html" title="Interface to the hardware Packet Output unit." alt="" coords="808,160,925,189"/><area shape="rect" id="node38" href="cvmx-interrupt_8c.html" title="Interface to the Mips interrupts." alt="" coords="1728,83,1864,112"/><area shape="rect" id="node40" href="cvmx-pko3_8h.html" title="cvmx&#45;pko3.h" alt="" coords="1432,83,1539,112"/><area shape="rect" id="node56" href="cvmx-pow_8c.html" title="Interface to the hardware Packet Order / Work unit." alt="" coords="1888,83,1989,112"/><area shape="rect" id="node58" href="cvmx-sso-resources_8c.html" title="cvmx&#45;sso&#45;resources.c" alt="" coords="2013,83,2184,112"/><area shape="rect" id="node60" href="octeon-model_8c.html" title="File defining functions for working with different Octeon models." alt="" coords="2208,83,2336,112"/><area shape="rect" id="node10" href="cvmx-helper-ilk_8c.html" title="Functions for ILK initialization, configuration, and monitoring." alt="" coords="717,237,853,267"/><area shape="rect" id="node12" href="cvmx-helper-npi_8c.html" title="Functions for NPI initialization, configuration, and monitoring." alt="" coords="877,237,1019,267"/><area shape="rect" id="node14" href="cvmx-helper-pko_8c.html" title="Helper Functions for the PKO." alt="" coords="1043,237,1189,267"/><area shape="rect" id="node16" href="cvmx-helper-rgmii_8c.html" title="Functions for RGMII/GMII/MII initialization, configuration, and monitoring." alt="" coords="1213,237,1368,267"/><area shape="rect" id="node18" href="cvmx-helper-util_8c.html" title="Small helper utilities." alt="" coords="195,237,339,267"/><area shape="rect" id="node20" href="cvmx-ilk_8c.html" title="Support library for the ILK." alt="" coords="363,237,453,267"/><area shape="rect" id="node22" href="cvmx-pko_8h.html" title="cvmx&#45;pko.h" alt="" coords="477,237,576,267"/><area shape="rect" id="node34" href="cvmx-pko3_8c.html" title="cvmx&#45;pko3.c" alt="" coords="1392,237,1499,267"/><area shape="rect" id="node36" href="cvmx-spi_8c.html" title="Support library for the SPI." alt="" coords="600,237,693,267"/><area shape="rect" id="node24" href="cvmx-config-init_8c.html" title="cvmx&#45;config&#45;init.c" alt="" coords="287,315,431,344"/><area shape="rect" id="node26" href="cvmx-helper-fpa_8c.html" title="Helper functions for FPA setup." alt="" coords="455,315,599,344"/><area shape="rect" id="node28" href="cvmx-helper_8c.html" title="Helper functions for common, but complicated tasks." alt="" coords="900,315,1017,344"/><area shape="rect" id="node30" href="cvmx-pko_8c.html" title="Support library for the hardware Packet Output unit." alt="" coords="623,315,721,344"/><area shape="rect" id="node32" href="cvmx-pko3-compat_8c.html" title="cvmx&#45;pko3&#45;compat.c" alt="" coords="1349,315,1515,344"/><area shape="rect" id="node42" href="cvmx-app-init_8c.html" title="Main entry point for all simple executive based programs." alt="" coords="1624,160,1752,189"/><area shape="rect" id="node44" href="cvmx-helper-pko3_8c.html" title="cvmx&#45;helper&#45;pko3.c" alt="" coords="1776,160,1931,189"/><area shape="rect" id="node48" href="cvmx-lap_8c.html" title="Support library for the LAP." alt="" coords="1955,160,2051,189"/><area shape="rect" id="node51" href="cvmx-pko3-queue_8c.html" title="cvmx&#45;pko3&#45;queue.c" alt="" coords="1091,160,1245,189"/><area shape="rect" id="node53" href="cvmx-pko3-resources_8c.html" title="PKO resources." alt="" coords="1269,160,1448,189"/></map>
</div>

<p><a href="cvmx-pow_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unioncvmx__xgrp__t.html">cvmx_xgrp_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcvmx__pow__tag__info__t.html">cvmx_pow_tag_info_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unioncvmx__pow__tag__req__t.html">cvmx_pow_tag_req_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This structure defines the store data on a store to POW.  <a href="unioncvmx__pow__tag__req__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unioncvmx__pow__tag__req__addr.html">cvmx_pow_tag_req_addr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unioncvmx__pow__load__addr__t.html">cvmx_pow_load_addr_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This structure describes the address to load stuff from POW.  <a href="unioncvmx__pow__load__addr__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unioncvmx__pow__tag__load__resp__t.html">cvmx_pow_tag_load_resp_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This structure defines the response to a load/SENDSINGLE to POW (except CSR reads).  <a href="unioncvmx__pow__tag__load__resp__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unioncvmx__pow__sl__tag__resp__t.html">cvmx_pow_sl_tag_resp_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unioncvmx__pow__tag__store__addr__t.html">cvmx_pow_tag_store_addr_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This structure describes the address used for stores to the POW.  <a href="unioncvmx__pow__tag__store__addr__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unioncvmx__pow__iobdma__store__t.html">cvmx_pow_iobdma_store_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decode of the store data when an IOBDMA SENDSINGLE is sent to POW.  <a href="unioncvmx__pow__iobdma__store__t.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#acd422dd75166372b406f43c64aeb6db0">CVMX_ENABLE_POW_CHECKS</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a07ff20304fd0af64b5b53c356b699677">CVMX_TAG_SW_BITS</a>&nbsp;&nbsp;&nbsp;(8)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a770b6fe160cc96812d100ceae9584c82">CVMX_TAG_SW_SHIFT</a>&nbsp;&nbsp;&nbsp;(32 - CVMX_TAG_SW_BITS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#acf4e566e2933141b73861880698931c3">CVMX_TAG_SW_BITS_INTERNAL</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a19bf5c3d79c8e9b55e9a55e076067427">CVMX_TAG_SUBGROUP_MASK</a>&nbsp;&nbsp;&nbsp;0xFFFF</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a6f8ea87cb2fd6d9cbc5949da46f8478d">CVMX_TAG_SUBGROUP_SHIFT</a>&nbsp;&nbsp;&nbsp;16</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a4043a4987dff2bbacbff17d6170025b6">CVMX_TAG_SUBGROUP_PKO</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a4e5d6e63e358326be407d1c85440a86d">cvmx_sso_allocate_group_range</a>&nbsp;&nbsp;&nbsp;cvmx_sso_reserve_group_range</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a4d7aea584cdb1552c411237343b2eb1e">cvmx_sso_allocate_group</a>&nbsp;&nbsp;&nbsp;cvmx_sso_reserve_group</td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a3db4988111245427fd604c2d591629e7">cvmx_pow_wait_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="cvmx-pow_8h.html#a3db4988111245427fd604c2d591629e7ade6b49357c96e5d15d2be1af5f9b4eb5">CVMX_POW_WAIT</a> =  1, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-pow_8h.html#a3db4988111245427fd604c2d591629e7a3906f7ec2959a551da6b185c74ee079d">CVMX_POW_NO_WAIT</a> =  0
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Wait flag values for pow functions. </p>
 <a href="cvmx-pow_8h.html#a3db4988111245427fd604c2d591629e7">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a6b7d366e3c91e1a3ae398f6b2ad8ba3f">cvmx_pow_tag_op_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="cvmx-pow_8h.html#a6b7d366e3c91e1a3ae398f6b2ad8ba3faf5802fcb9babb293a69640d63c869b25">CVMX_POW_TAG_OP_SWTAG</a> =  0L, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-pow_8h.html#a6b7d366e3c91e1a3ae398f6b2ad8ba3fae21d29d5fef2adb73998532755b59ad3">CVMX_POW_TAG_OP_SWTAG_FULL</a> =  1L, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-pow_8h.html#a6b7d366e3c91e1a3ae398f6b2ad8ba3fa93b59c5bc66e80b63e2492656fcc3693">CVMX_POW_TAG_OP_SWTAG_DESCH</a> =  2L, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-pow_8h.html#a6b7d366e3c91e1a3ae398f6b2ad8ba3fa3676a2d849ec94d0c5094445e98af7bc">CVMX_POW_TAG_OP_DESCH</a> =  3L, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-pow_8h.html#a6b7d366e3c91e1a3ae398f6b2ad8ba3fae05e395f09bb03d66c7b084a4fc2d5cd">CVMX_POW_TAG_OP_ADDWQ</a> =  4L, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-pow_8h.html#a6b7d366e3c91e1a3ae398f6b2ad8ba3fa3792fdbe79460ce51fa2c8fc437c89ea">CVMX_POW_TAG_OP_UPDATE_WQP_GRP</a> =  5L, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-pow_8h.html#a6b7d366e3c91e1a3ae398f6b2ad8ba3fa8e69fc4ce99e93d316946a7024042a8e">CVMX_POW_TAG_OP_SET_NSCHED</a> =  6L, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-pow_8h.html#a6b7d366e3c91e1a3ae398f6b2ad8ba3faf5db3ed3ab41a85e41b788d3f1f93f0f">CVMX_POW_TAG_OP_CLR_NSCHED</a> =  7L, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-pow_8h.html#a6b7d366e3c91e1a3ae398f6b2ad8ba3fa96d5420fc7b61ea414f71b9bdcce7efa">CVMX_POW_TAG_OP_NOP</a> =  15L
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>POW tag operations. </p>
 <a href="cvmx-pow_8h.html#a6b7d366e3c91e1a3ae398f6b2ad8ba3f">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a4261815d55968a39541b3bf61630c3bc">cvmx_sso_group_modify_mask</a> { <br/>
&nbsp;&nbsp;<a class="el" href="cvmx-pow_8h.html#a4261815d55968a39541b3bf61630c3bca9c22653da224e984d10de59f8fd07020">CVMX_SSO_MODIFY_GROUP_PRIORITY</a> =  0x01, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-pow_8h.html#a4261815d55968a39541b3bf61630c3bca162eaef9afa8cefffbd59df49b7cb9ce">CVMX_SSO_MODIFY_GROUP_WEIGHT</a> =  0x02, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-pow_8h.html#a4261815d55968a39541b3bf61630c3bca22450d688a052f65b89d4ee0a28d92f8">CVMX_SSO_MODIFY_GROUP_AFFINITY</a> =  0x04
<br/>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#aa4853005bc11b57470c8c75c22f5d5e9">cvmx_sso_num_xgrp</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal use function.  <a href="#aa4853005bc11b57470c8c75c22f5d5e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#ad05c8b6e0d1c6b75d84185d602497654">cvmx_pow_num_groups</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal use function.  <a href="#ad05c8b6e0d1c6b75d84185d602497654"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#aa19fb1858f8ad244fee2f8bfa5825553">cvmx_sso_num_maskset</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal use function.  <a href="#aa19fb1858f8ad244fee2f8bfa5825553"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structcvmx__pow__tag__info__t.html">cvmx_pow_tag_info_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#ad02fa82d35a0645042e81b750462edac">cvmx_pow_get_current_tag</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the POW tag for this core.  <a href="#ad02fa82d35a0645042e81b750462edac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structcvmx__wqe__s.html">cvmx_wqe_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#ae721a8a083b6a7e4a085e095467a376b">cvmx_pow_get_current_wqp</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the POW WQE for this core.  <a href="#ae721a8a083b6a7e4a085e095467a376b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a22c7113b80df47a247a0e71f0952a235">__cvmx_pow_warn_if_pending_switch</a> (const char *function)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal use function.  <a href="#a22c7113b80df47a247a0e71f0952a235"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a1ff579bf32ccc0cdbcef8c23eaa53090">cvmx_pow_tag_sw_wait</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Waits for a tag switch to complete by polling the completion bit.  <a href="#a1ff579bf32ccc0cdbcef8c23eaa53090"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structcvmx__wqe__s.html">cvmx_wqe_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#acb89059e31f202c79fb282e7c3647153">cvmx_pow_work_request_sync_nocheck</a> (<a class="el" href="cvmx-pow_8h.html#a3db4988111245427fd604c2d591629e7">cvmx_pow_wait_t</a> wait)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Synchronous work request.  <a href="#acb89059e31f202c79fb282e7c3647153"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structcvmx__wqe__s.html">cvmx_wqe_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a663a32115088b6888949303edea06e5f">cvmx_pow_work_request_sync</a> (<a class="el" href="cvmx-pow_8h.html#a3db4988111245427fd604c2d591629e7">cvmx_pow_wait_t</a> wait)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Synchronous work request.  <a href="#a663a32115088b6888949303edea06e5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="cvmx-csr-enums_8h.html#a556896ab26554db9f539b17e5dbc749b">cvmx_pow_tag_type_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a6e11dd31e57dce2059d4e653fa54f8ee">cvmx_pow_work_request_null_rd</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Synchronous null_rd request.  <a href="#a6e11dd31e57dce2059d4e653fa54f8ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a0477e774db62c60e5b1ad2d04c44eedf">cvmx_pow_work_request_async_nocheck</a> (int scr_addr, <a class="el" href="cvmx-pow_8h.html#a3db4988111245427fd604c2d591629e7">cvmx_pow_wait_t</a> wait)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Asynchronous work request.  <a href="#a0477e774db62c60e5b1ad2d04c44eedf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#ab7f66e0dbe686746ec48dc25c7602645">cvmx_pow_work_request_async</a> (int scr_addr, <a class="el" href="cvmx-pow_8h.html#a3db4988111245427fd604c2d591629e7">cvmx_pow_wait_t</a> wait)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Asynchronous work request.  <a href="#ab7f66e0dbe686746ec48dc25c7602645"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structcvmx__wqe__s.html">cvmx_wqe_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a371aef3eb06e4a961607623fba6fd330">cvmx_pow_work_response_async</a> (int scr_addr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets result of asynchronous work request.  <a href="#a371aef3eb06e4a961607623fba6fd330"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a41ec9612ff526f63468c4e94ce03127b">cvmx_pow_work_invalid</a> (<a class="el" href="structcvmx__wqe__s.html">cvmx_wqe_t</a> *wqe_ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if a work queue entry pointer returned by a work request is valid.  <a href="#a41ec9612ff526f63468c4e94ce03127b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a8d7be99e09a7452658cc12c6cc320f60">cvmx_pow_tag_sw_nocheck</a> (uint32_t tag, <a class="el" href="cvmx-csr-enums_8h.html#a556896ab26554db9f539b17e5dbc749b">cvmx_pow_tag_type_t</a> tag_type)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts a tag switch to the provided tag value and tag type.  <a href="#a8d7be99e09a7452658cc12c6cc320f60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#add5b9784e9c8d6f7fda874963d1c958a">cvmx_pow_tag_sw</a> (uint32_t tag, <a class="el" href="cvmx-csr-enums_8h.html#a556896ab26554db9f539b17e5dbc749b">cvmx_pow_tag_type_t</a> tag_type)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts a tag switch to the provided tag value and tag type.  <a href="#add5b9784e9c8d6f7fda874963d1c958a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#ada0c34dfc5a7fcd0b819e3e151bc60d1">cvmx_pow_tag_sw_full_nocheck</a> (<a class="el" href="structcvmx__wqe__s.html">cvmx_wqe_t</a> *wqp, uint32_t tag, <a class="el" href="cvmx-csr-enums_8h.html#a556896ab26554db9f539b17e5dbc749b">cvmx_pow_tag_type_t</a> tag_type, uint64_t group)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts a tag switch to the provided tag value and tag type.  <a href="#ada0c34dfc5a7fcd0b819e3e151bc60d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a5c0507e9aceb32eb26c04c08881a917f">cvmx_pow_tag_sw_full</a> (<a class="el" href="structcvmx__wqe__s.html">cvmx_wqe_t</a> *wqp, uint32_t tag, <a class="el" href="cvmx-csr-enums_8h.html#a556896ab26554db9f539b17e5dbc749b">cvmx_pow_tag_type_t</a> tag_type, uint64_t group)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts a tag switch to the provided tag value and tag type.  <a href="#a5c0507e9aceb32eb26c04c08881a917f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a0ad916abec85508425ed6d68b81ddec8">cvmx_pow_tag_sw_null_nocheck</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Switch to a NULL tag, which ends any ordering or synchronization provided by the POW for the current work queue entry.  <a href="#a0ad916abec85508425ed6d68b81ddec8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a8948068d2bbabae2035789bbf82b9883">cvmx_pow_tag_sw_null</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Switch to a NULL tag, which ends any ordering or synchronization provided by the POW for the current work queue entry.  <a href="#a8948068d2bbabae2035789bbf82b9883"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#afa6ed62ed9357ec3c2b32c5534003aa3">cvmx_pow_work_submit</a> (<a class="el" href="structcvmx__wqe__s.html">cvmx_wqe_t</a> *wqp, uint32_t tag, <a class="el" href="cvmx-csr-enums_8h.html#a556896ab26554db9f539b17e5dbc749b">cvmx_pow_tag_type_t</a> tag_type, uint64_t qos, uint64_t grp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Submits work to an input queue.  <a href="#afa6ed62ed9357ec3c2b32c5534003aa3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a7b9f77dee05f3edb929830e40a0a0ace">cvmx_pow_set_group_mask</a> (uint64_t core_num, uint64_t mask)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function sets the group mask for a core.  <a href="#a7b9f77dee05f3edb929830e40a0a0ace"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a65a6f81ece3bb22fd13f33a0f62e1226">cvmx_pow_set_priority</a> (uint64_t core_num, const uint8_t priority[])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function sets POW static priorities for a core.  <a href="#a65a6f81ece3bb22fd13f33a0f62e1226"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a081fe0f3083c2bff75a9b8d1b7429712">cvmx_pow_tag_sw_desched_nocheck</a> (uint32_t tag, <a class="el" href="cvmx-csr-enums_8h.html#a556896ab26554db9f539b17e5dbc749b">cvmx_pow_tag_type_t</a> tag_type, uint64_t group, uint64_t no_sched)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a tag switch and then an immediate deschedule.  <a href="#a081fe0f3083c2bff75a9b8d1b7429712"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a373ce7f3ed51f6a682828711cfe235ff">cvmx_pow_tag_sw_desched</a> (uint32_t tag, <a class="el" href="cvmx-csr-enums_8h.html#a556896ab26554db9f539b17e5dbc749b">cvmx_pow_tag_type_t</a> tag_type, uint64_t group, uint64_t no_sched)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a tag switch and then an immediate deschedule.  <a href="#a373ce7f3ed51f6a682828711cfe235ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a3dffdb3430e009aebf426ffa26280ee7">cvmx_pow_desched</a> (uint64_t no_sched)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Descchedules the current work queue entry.  <a href="#a3dffdb3430e009aebf426ffa26280ee7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a3c903b259189845f01c886c8920bb05d">cvmx_sso_set_group_core_affinity</a> (<a class="el" href="unioncvmx__xgrp__t.html">cvmx_xgrp_t</a> xgrp, const <a class="el" href="structcvmx__coremask.html">cvmx_coremask_t</a> *core_mask, uint8_t mask_set)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function sets the the affinity of group to the cores in 78xx.  <a href="#a3c903b259189845f01c886c8920bb05d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a6e9da13e9384cb31b66941830f5b18d5">cvmx_sso_set_group_priority</a> (int node, <a class="el" href="unioncvmx__xgrp__t.html">cvmx_xgrp_t</a> xgrp, int priority, int weight, int affinity, enum <a class="el" href="cvmx-pow_8h.html#a4261815d55968a39541b3bf61630c3bc">cvmx_sso_group_modify_mask</a> modify_mask)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function sets the priority and group affinity arbitration for each group.  <a href="#a6e9da13e9384cb31b66941830f5b18d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#acb3cfb4760d3c530f3571c9c2c43006f">cvmx_sso_work_request_grp_async_nocheck</a> (int scr_addr, <a class="el" href="unioncvmx__xgrp__t.html">cvmx_xgrp_t</a> xgrp, <a class="el" href="cvmx-pow_8h.html#a3db4988111245427fd604c2d591629e7">cvmx_pow_wait_t</a> wait)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Asynchronous work request.  <a href="#acb3cfb4760d3c530f3571c9c2c43006f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#ae1519d72a55f3cbd435360880c7adf7f">cvmx_sso_work_request_grp_sync_nocheck</a> (unsigned int lgrp, <a class="el" href="cvmx-pow_8h.html#a3db4988111245427fd604c2d591629e7">cvmx_pow_wait_t</a> wait)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Synchronous work request from the node-local SSO without verifying pending tag switch.  <a href="#ae1519d72a55f3cbd435360880c7adf7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#ae0cbbfb0be90e33e76f843e7fee4826f">cvmx_sso_work_request_grp_sync</a> (unsigned int lgrp, <a class="el" href="cvmx-pow_8h.html#a3db4988111245427fd604c2d591629e7">cvmx_pow_wait_t</a> wait)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Synchronous work request from the node-local SSO.  <a href="#ae0cbbfb0be90e33e76f843e7fee4826f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a3706f37683fdb5a4f499d01cef71955c">cvmx_pow_set_xgrp_mask</a> (uint64_t core_num, uint8_t mask_set, const uint64_t xgrp_mask[])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function sets the group mask for a core.  <a href="#a3706f37683fdb5a4f499d01cef71955c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a4fef3070f7ab95a414b5cdff8454804c">cvmx_pow_tag_sw_node</a> (<a class="el" href="structcvmx__wqe__s.html">cvmx_wqe_t</a> *wqp, uint32_t tag, <a class="el" href="cvmx-csr-enums_8h.html#a556896ab26554db9f539b17e5dbc749b">cvmx_pow_tag_type_t</a> tag_type, int node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Executes SSO SWTAG command.  <a href="#a4fef3070f7ab95a414b5cdff8454804c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a9663856a3ef4eedd3a395af2e11d62d2">cvmx_pow_tag_sw_full_node</a> (<a class="el" href="structcvmx__wqe__s.html">cvmx_wqe_t</a> *wqp, uint32_t tag, <a class="el" href="cvmx-csr-enums_8h.html#a556896ab26554db9f539b17e5dbc749b">cvmx_pow_tag_type_t</a> tag_type, uint8_t xgrp, int node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Executes SSO SWTAG_FULL command.  <a href="#a9663856a3ef4eedd3a395af2e11d62d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a6ae4bc92eb3bff7c08ef34bfde89c09d">cvmx_pow_work_submit_node</a> (<a class="el" href="structcvmx__wqe__s.html">cvmx_wqe_t</a> *wqp, uint32_t tag, <a class="el" href="cvmx-csr-enums_8h.html#a556896ab26554db9f539b17e5dbc749b">cvmx_pow_tag_type_t</a> tag_type, uint8_t xgrp, uint8_t node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Submits work to an SSO group on any OCI node.  <a href="#a6ae4bc92eb3bff7c08ef34bfde89c09d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a3c9aeb8caf8ab65e7af2cd435c7a6b86">cvmx_pow_tag_sw_desched_node</a> (<a class="el" href="structcvmx__wqe__s.html">cvmx_wqe_t</a> *wqe, uint32_t tag, <a class="el" href="cvmx-csr-enums_8h.html#a556896ab26554db9f539b17e5dbc749b">cvmx_pow_tag_type_t</a> tag_type, uint8_t xgrp, uint64_t no_sched, uint8_t node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Executes the SSO SWTAG_DESCHED operation.  <a href="#a3c9aeb8caf8ab65e7af2cd435c7a6b86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a6a062008618fcc1c3ca07283374f3b56">cvmx_sso_update_wqp_group</a> (<a class="el" href="structcvmx__wqe__s.html">cvmx_wqe_t</a> *wqp, uint8_t xgrp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a7ee758c45cbfbcb9afe7d3ebecea16b2">cvmx_pow_tag_compose</a> (uint64_t sw_bits, uint64_t hw_bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function creates a 32 bit tag value from the two values provided.  <a href="#a7ee758c45cbfbcb9afe7d3ebecea16b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#adeb42784c4007b00c9d2ecd8827f04fc">cvmx_pow_tag_get_sw_bits</a> (uint64_t tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extracts the bits allocated for software use from the tag.  <a href="#adeb42784c4007b00c9d2ecd8827f04fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#abe64d694f7cbf5d8f8f8d77229baf30e">cvmx_pow_tag_get_hw_bits</a> (uint64_t tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extracts the bits allocated for hardware use from the tag.  <a href="#abe64d694f7cbf5d8f8f8d77229baf30e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a83e0c105337315ca8477905138383ed7">cvmx_sso3_get_wqe_count</a> (int node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#acaeffaa0e61c3258fa3867b00548a725">cvmx_sso_get_total_wqe_count</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a14064eead1800cef3ab4ea979ba3a55f">cvmx_pow_capture</a> (void *buffer, int buffer_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store the current POW internal state into the supplied buffer.  <a href="#a14064eead1800cef3ab4ea979ba3a55f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#ac585ad54cd2e5027b4b2216ba0b6fb05">cvmx_pow_display</a> (void *buffer, int buffer_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dump a POW capture to the console in a human readable format.  <a href="#ac585ad54cd2e5027b4b2216ba0b6fb05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a1b8c743499fbc158484199895537c628">cvmx_pow_get_num_entries</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of POW entries supported by this chip.  <a href="#a1b8c743499fbc158484199895537c628"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#ac4b5c1f860cfb85f69097835cefcf560">cvmx_pow_get_dump_size</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#af707ecacfb0fe2d30ab06ca64cd50853">cvmx_sso_reserve_group_range</a> (int node, int *base_group, int count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This will allocate count number of SSO groups on the specified node to the calling application.  <a href="#af707ecacfb0fe2d30ab06ca64cd50853"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a2d3c45099dc2940dff9621451eb8dc59">cvmx_sso_reserve_group</a> (int node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#a3b000c3a27b9808b07467f2b3dfc2d7c">cvmx_sso_release_group_range</a> (int node, int base_group, int count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#aca3afc1169a59eaf9720002d49e2f48f">cvmx_sso_release_group</a> (int node, int group)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-pow_8h.html#af8db2a54355d2ec290d32d0701ee6c43">cvmx_sso_config_dump</a> (unsigned node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Show integrated PKI configuration.  <a href="#af8db2a54355d2ec290d32d0701ee6c43"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Interface to the hardware Scheduling unit. </p>
<p>New, starting with SDK 1.7.0, cvmx-pow supports a number of extended consistency checks. The define CVMX_ENABLE_POW_CHECKS controls the runtime insertion of POW internal state checks to find common programming errors. If CVMX_ENABLE_POW_CHECKS is not defined, checks are by default enabled. For example, cvmx-pow will check for the following program errors or POW state inconsistency.</p>
<ul>
<li>Requesting a POW operation with an active tag switch in progress.</li>
<li>Waiting for a tag switch to complete for an excessively long period. This is normally a sign of an error in locking causing deadlock.</li>
<li>Illegal tag switches from NULL_NULL.</li>
<li>Illegal tag switches from NULL.</li>
<li>Illegal deschedule request.</li>
<li>WQE pointer not matching the one attached to the core by the POW. </li>
</ul>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="acd422dd75166372b406f43c64aeb6db0"></a><!-- doxytag: member="cvmx&#45;pow.h::CVMX_ENABLE_POW_CHECKS" ref="acd422dd75166372b406f43c64aeb6db0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CVMX_ENABLE_POW_CHECKS&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4d7aea584cdb1552c411237343b2eb1e"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_sso_allocate_group" ref="a4d7aea584cdb1552c411237343b2eb1e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define cvmx_sso_allocate_group&nbsp;&nbsp;&nbsp;cvmx_sso_reserve_group</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4e5d6e63e358326be407d1c85440a86d"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_sso_allocate_group_range" ref="a4e5d6e63e358326be407d1c85440a86d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define cvmx_sso_allocate_group_range&nbsp;&nbsp;&nbsp;cvmx_sso_reserve_group_range</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a19bf5c3d79c8e9b55e9a55e076067427"></a><!-- doxytag: member="cvmx&#45;pow.h::CVMX_TAG_SUBGROUP_MASK" ref="a19bf5c3d79c8e9b55e9a55e076067427" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CVMX_TAG_SUBGROUP_MASK&nbsp;&nbsp;&nbsp;0xFFFF</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4043a4987dff2bbacbff17d6170025b6"></a><!-- doxytag: member="cvmx&#45;pow.h::CVMX_TAG_SUBGROUP_PKO" ref="a4043a4987dff2bbacbff17d6170025b6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CVMX_TAG_SUBGROUP_PKO&nbsp;&nbsp;&nbsp;0x1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6f8ea87cb2fd6d9cbc5949da46f8478d"></a><!-- doxytag: member="cvmx&#45;pow.h::CVMX_TAG_SUBGROUP_SHIFT" ref="a6f8ea87cb2fd6d9cbc5949da46f8478d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CVMX_TAG_SUBGROUP_SHIFT&nbsp;&nbsp;&nbsp;16</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a07ff20304fd0af64b5b53c356b699677"></a><!-- doxytag: member="cvmx&#45;pow.h::CVMX_TAG_SW_BITS" ref="a07ff20304fd0af64b5b53c356b699677" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CVMX_TAG_SW_BITS&nbsp;&nbsp;&nbsp;(8)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acf4e566e2933141b73861880698931c3"></a><!-- doxytag: member="cvmx&#45;pow.h::CVMX_TAG_SW_BITS_INTERNAL" ref="acf4e566e2933141b73861880698931c3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CVMX_TAG_SW_BITS_INTERNAL&nbsp;&nbsp;&nbsp;0x1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a770b6fe160cc96812d100ceae9584c82"></a><!-- doxytag: member="cvmx&#45;pow.h::CVMX_TAG_SW_SHIFT" ref="a770b6fe160cc96812d100ceae9584c82" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CVMX_TAG_SW_SHIFT&nbsp;&nbsp;&nbsp;(32 - CVMX_TAG_SW_BITS)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a6b7d366e3c91e1a3ae398f6b2ad8ba3f"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_tag_op_t" ref="a6b7d366e3c91e1a3ae398f6b2ad8ba3f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cvmx-pow_8h.html#a6b7d366e3c91e1a3ae398f6b2ad8ba3f">cvmx_pow_tag_op_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>POW tag operations. </p>
<p>These are used in the data stored to the POW. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a6b7d366e3c91e1a3ae398f6b2ad8ba3faf5802fcb9babb293a69640d63c869b25"></a><!-- doxytag: member="CVMX_POW_TAG_OP_SWTAG" ref="a6b7d366e3c91e1a3ae398f6b2ad8ba3faf5802fcb9babb293a69640d63c869b25" args="" -->CVMX_POW_TAG_OP_SWTAG</em>&nbsp;</td><td>
<p>Switch the tag (only) for this PP</p>
<ul>
<li>the previous tag should be non-NULL in this case</li>
<li>tag switch response required</li>
<li>fields used: op, type, tag. </li>
</ul>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6b7d366e3c91e1a3ae398f6b2ad8ba3fae21d29d5fef2adb73998532755b59ad3"></a><!-- doxytag: member="CVMX_POW_TAG_OP_SWTAG_FULL" ref="a6b7d366e3c91e1a3ae398f6b2ad8ba3fae21d29d5fef2adb73998532755b59ad3" args="" -->CVMX_POW_TAG_OP_SWTAG_FULL</em>&nbsp;</td><td>
<p>Switch the tag for this PP, with full information</p>
<ul>
<li>this should be used when the previous tag is NULL</li>
<li>tag switch response required</li>
<li>fields used: address, op, grp, type, tag. </li>
</ul>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6b7d366e3c91e1a3ae398f6b2ad8ba3fa93b59c5bc66e80b63e2492656fcc3693"></a><!-- doxytag: member="CVMX_POW_TAG_OP_SWTAG_DESCH" ref="a6b7d366e3c91e1a3ae398f6b2ad8ba3fa93b59c5bc66e80b63e2492656fcc3693" args="" -->CVMX_POW_TAG_OP_SWTAG_DESCH</em>&nbsp;</td><td>
<p>Switch the tag (and/or group) for this PP and de-schedule</p>
<ul>
<li>OK to keep the tag the same and only change the group</li>
<li>fields used: op, no_sched, grp, type, tag. </li>
</ul>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6b7d366e3c91e1a3ae398f6b2ad8ba3fa3676a2d849ec94d0c5094445e98af7bc"></a><!-- doxytag: member="CVMX_POW_TAG_OP_DESCH" ref="a6b7d366e3c91e1a3ae398f6b2ad8ba3fa3676a2d849ec94d0c5094445e98af7bc" args="" -->CVMX_POW_TAG_OP_DESCH</em>&nbsp;</td><td>
<p>Just de-schedule</p>
<ul>
<li>fields used: op, no_sched. </li>
</ul>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6b7d366e3c91e1a3ae398f6b2ad8ba3fae05e395f09bb03d66c7b084a4fc2d5cd"></a><!-- doxytag: member="CVMX_POW_TAG_OP_ADDWQ" ref="a6b7d366e3c91e1a3ae398f6b2ad8ba3fae05e395f09bb03d66c7b084a4fc2d5cd" args="" -->CVMX_POW_TAG_OP_ADDWQ</em>&nbsp;</td><td>
<p>Create an entirely new work queue entry</p>
<ul>
<li>fields used: address, op, qos, grp, type, tag. </li>
</ul>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6b7d366e3c91e1a3ae398f6b2ad8ba3fa3792fdbe79460ce51fa2c8fc437c89ea"></a><!-- doxytag: member="CVMX_POW_TAG_OP_UPDATE_WQP_GRP" ref="a6b7d366e3c91e1a3ae398f6b2ad8ba3fa3792fdbe79460ce51fa2c8fc437c89ea" args="" -->CVMX_POW_TAG_OP_UPDATE_WQP_GRP</em>&nbsp;</td><td>
<p>Just update the work queue pointer and grp for this PP</p>
<ul>
<li>fields used: address, op, grp. </li>
</ul>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6b7d366e3c91e1a3ae398f6b2ad8ba3fa8e69fc4ce99e93d316946a7024042a8e"></a><!-- doxytag: member="CVMX_POW_TAG_OP_SET_NSCHED" ref="a6b7d366e3c91e1a3ae398f6b2ad8ba3fa8e69fc4ce99e93d316946a7024042a8e" args="" -->CVMX_POW_TAG_OP_SET_NSCHED</em>&nbsp;</td><td>
<p>Set the no_sched bit on the de-schedule list</p>
<ul>
<li>does nothing if the selected entry is not on the de-schedule list</li>
<li>does nothing if the stored work queue pointer does not match the address field</li>
<li>fields used: address, index, op Before issuing a *_NSCHED operation, SW must guarantee that all prior deschedules and set/clr NSCHED operations are complete and all prior switches are complete. </li>
</ul>
<p>The hardware provides the opsdone bit and swdone bit for SW polling. After issuing a *_NSCHED operation, SW must guarantee that the set/clr NSCHED is complete before any subsequent operations. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6b7d366e3c91e1a3ae398f6b2ad8ba3faf5db3ed3ab41a85e41b788d3f1f93f0f"></a><!-- doxytag: member="CVMX_POW_TAG_OP_CLR_NSCHED" ref="a6b7d366e3c91e1a3ae398f6b2ad8ba3faf5db3ed3ab41a85e41b788d3f1f93f0f" args="" -->CVMX_POW_TAG_OP_CLR_NSCHED</em>&nbsp;</td><td>
<p>Clears the no_sched bit on the de-schedule list</p>
<ul>
<li>does nothing if the selected entry is not on the de-schedule list</li>
<li>does nothing if the stored work queue pointer does not match the address field</li>
<li>fields used: address, index, op Before issuing a *_NSCHED operation, SW must guarantee that all prior deschedules and set/clr NSCHED operations are complete and all prior switches are complete. </li>
</ul>
<p>The hardware provides the opsdone bit and swdone bit for SW polling. After issuing a *_NSCHED operation, SW must guarantee that the set/clr NSCHED is complete before any subsequent operations. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6b7d366e3c91e1a3ae398f6b2ad8ba3fa96d5420fc7b61ea414f71b9bdcce7efa"></a><!-- doxytag: member="CVMX_POW_TAG_OP_NOP" ref="a6b7d366e3c91e1a3ae398f6b2ad8ba3fa96d5420fc7b61ea414f71b9bdcce7efa" args="" -->CVMX_POW_TAG_OP_NOP</em>&nbsp;</td><td>
<p>Do nothing. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a3db4988111245427fd604c2d591629e7"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_wait_t" ref="a3db4988111245427fd604c2d591629e7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cvmx-pow_8h.html#a3db4988111245427fd604c2d591629e7">cvmx_pow_wait_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait flag values for pow functions. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a3db4988111245427fd604c2d591629e7ade6b49357c96e5d15d2be1af5f9b4eb5"></a><!-- doxytag: member="CVMX_POW_WAIT" ref="a3db4988111245427fd604c2d591629e7ade6b49357c96e5d15d2be1af5f9b4eb5" args="" -->CVMX_POW_WAIT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3db4988111245427fd604c2d591629e7a3906f7ec2959a551da6b185c74ee079d"></a><!-- doxytag: member="CVMX_POW_NO_WAIT" ref="a3db4988111245427fd604c2d591629e7a3906f7ec2959a551da6b185c74ee079d" args="" -->CVMX_POW_NO_WAIT</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a4261815d55968a39541b3bf61630c3bc"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_sso_group_modify_mask" ref="a4261815d55968a39541b3bf61630c3bc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cvmx-pow_8h.html#a4261815d55968a39541b3bf61630c3bc">cvmx_sso_group_modify_mask</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a4261815d55968a39541b3bf61630c3bca9c22653da224e984d10de59f8fd07020"></a><!-- doxytag: member="CVMX_SSO_MODIFY_GROUP_PRIORITY" ref="a4261815d55968a39541b3bf61630c3bca9c22653da224e984d10de59f8fd07020" args="" -->CVMX_SSO_MODIFY_GROUP_PRIORITY</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4261815d55968a39541b3bf61630c3bca162eaef9afa8cefffbd59df49b7cb9ce"></a><!-- doxytag: member="CVMX_SSO_MODIFY_GROUP_WEIGHT" ref="a4261815d55968a39541b3bf61630c3bca162eaef9afa8cefffbd59df49b7cb9ce" args="" -->CVMX_SSO_MODIFY_GROUP_WEIGHT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4261815d55968a39541b3bf61630c3bca22450d688a052f65b89d4ee0a28d92f8"></a><!-- doxytag: member="CVMX_SSO_MODIFY_GROUP_AFFINITY" ref="a4261815d55968a39541b3bf61630c3bca22450d688a052f65b89d4ee0a28d92f8" args="" -->CVMX_SSO_MODIFY_GROUP_AFFINITY</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a22c7113b80df47a247a0e71f0952a235"></a><!-- doxytag: member="cvmx&#45;pow.h::__cvmx_pow_warn_if_pending_switch" ref="a22c7113b80df47a247a0e71f0952a235" args="(const char *function)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void __cvmx_pow_warn_if_pending_switch </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>function</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal use function. </p>
<p><b>This function's parameters and processing may change in future SDKs.</b><br/>
<br/>
 Print a warning if a tag switch is pending for this core</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>Function name checking for a pending tag switch </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a14064eead1800cef3ab4ea979ba3a55f"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_capture" ref="a14064eead1800cef3ab4ea979ba3a55f" args="(void *buffer, int buffer_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_pow_capture </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>buffer_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Store the current POW internal state into the supplied buffer. </p>
<p>It is recommended that you pass a buffer of at least 128KB. The format of the capture may change based on SDK version and Octeon chip.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Buffer to store capture into </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer_size</em>&nbsp;</td><td>The size of the supplied buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Zero on sucess, negative on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a3dffdb3430e009aebf426ffa26280ee7"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_desched" ref="a3dffdb3430e009aebf426ffa26280ee7" args="(uint64_t no_sched)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_pow_desched </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>no_sched</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Descchedules the current work queue entry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>no_sched</em>&nbsp;</td><td>no schedule flag value to be set on the work queue entry. If this is set the entry will not be rescheduled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac585ad54cd2e5027b4b2216ba0b6fb05"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_display" ref="ac585ad54cd2e5027b4b2216ba0b6fb05" args="(void *buffer, int buffer_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvmx_pow_display </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>buffer_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dump a POW capture to the console in a human readable format. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>POW capture from <a class="el" href="cvmx-pow_8c.html#a14064eead1800cef3ab4ea979ba3a55f" title="Store the current POW internal state into the supplied buffer.">cvmx_pow_capture()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer_size</em>&nbsp;</td><td>Size of the buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad02fa82d35a0645042e81b750462edac"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_get_current_tag" ref="ad02fa82d35a0645042e81b750462edac" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structcvmx__pow__tag__info__t.html">cvmx_pow_tag_info_t</a> cvmx_pow_get_current_tag </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the POW tag for this core. </p>
<p>This returns the current tag type, tag, group, and POW entry index associated with this core. Index is only valid if the tag type isn't NULL_NULL. If a tag switch is pending this routine returns the tag before the tag switch, not after.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current tag </dd></dl>

</div>
</div>
<a class="anchor" id="ae721a8a083b6a7e4a085e095467a376b"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_get_current_wqp" ref="ae721a8a083b6a7e4a085e095467a376b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structcvmx__wqe__s.html">cvmx_wqe_t</a>* cvmx_pow_get_current_wqp </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the POW WQE for this core. </p>
<p>This returns the work queue entry currently associated with this core.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>WQE pointer </dd></dl>

</div>
</div>
<a class="anchor" id="ac4b5c1f860cfb85f69097835cefcf560"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_get_dump_size" ref="ac4b5c1f860cfb85f69097835cefcf560" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_pow_get_dump_size </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1b8c743499fbc158484199895537c628"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_get_num_entries" ref="a1b8c743499fbc158484199895537c628" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_pow_get_num_entries </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of POW entries supported by this chip. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of POW entries </dd></dl>

</div>
</div>
<a class="anchor" id="ad05c8b6e0d1c6b75d84185d602497654"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_num_groups" ref="ad05c8b6e0d1c6b75d84185d602497654" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned cvmx_pow_num_groups </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal use function. </p>
<p><b>This function's parameters and processing may change in future SDKs.</b><br/>
<br/>
 Return the number of POW groups on current model. In case of CN78XX/CN73XX this is the number of equivalent "legacy groups" on the chip when it is used in backward compatible mode. </p>

</div>
</div>
<a class="anchor" id="a7b9f77dee05f3edb929830e40a0a0ace"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_set_group_mask" ref="a7b9f77dee05f3edb929830e40a0a0ace" args="(uint64_t core_num, uint64_t mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_pow_set_group_mask </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>core_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function sets the group mask for a core. </p>
<p>The group mask indicates which groups each core will accept work from. There are 16 groups.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>core_num</em>&nbsp;</td><td>core to apply mask to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>Group mask, one bit for up to 64 groups. Each 1 bit in the mask enables the core to accept work from the corresponding group. The CN68XX supports 64 groups, earlier models only support 16 groups.</td></tr>
  </table>
  </dd>
</dl>
<p>The CN78XX in backwards compatibility mode allows up to 32 groups, so the 'mask' argument has one bit for every of the legacy groups, and a '1' in the mask causes a total of 8 groups which share the legacy group numbher and 8 qos levels, to be enabled for the calling processor core. A '0' in the mask will disable the current core from receiving work from the associated group. </p>

</div>
</div>
<a class="anchor" id="a65a6f81ece3bb22fd13f33a0f62e1226"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_set_priority" ref="a65a6f81ece3bb22fd13f33a0f62e1226" args="(uint64_t core_num, const uint8_t priority[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_pow_set_priority </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>core_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>priority</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function sets POW static priorities for a core. </p>
<p>Each input queue has an associated priority value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>core_num</em>&nbsp;</td><td>core to apply priorities to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>priority</em>&nbsp;</td><td>Vector of 8 priorities, one per POW Input Queue (0-7). Highest priority is 0 and lowest is 7. A priority value of 0xF instructs POW to skip the Input Queue when scheduling to this specific core. NOTE: priorities should not have gaps in values, meaning {0,1,1,1,1,1,1,1} is a valid configuration while {0,2,2,2,2,2,2,2} is not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3706f37683fdb5a4f499d01cef71955c"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_set_xgrp_mask" ref="a3706f37683fdb5a4f499d01cef71955c" args="(uint64_t core_num, uint8_t mask_set, const uint64_t xgrp_mask[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_pow_set_xgrp_mask </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>core_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>mask_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&nbsp;</td>
          <td class="paramname"> <em>xgrp_mask</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function sets the group mask for a core. </p>
<p>The group mask bits indicate which groups each core will accept work from.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>core_num</em>&nbsp;</td><td>Processor core to apply mask to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask_set</em>&nbsp;</td><td>7XXX has 2 sets of masks per core. Bit 0 represents the first mask set, bit 1 -- the second. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xgrp_mask</em>&nbsp;</td><td>Group mask array. Total number of groups is divided into a number of 64-bits mask sets. Each bit in the mask, if set, enables the core to accept work from the corresponding group.</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: Each core can be configured to accept work in accordance to both mask sets, with the first having higher precedence over the second, or to accept work in accordance to just one of the two mask sets. The 'core_num' argument represents a processor core on any node in a coherent multi-chip system.</p>
<p>If the 'mask_set' argument is 3, both mask sets are configured with the same value (which is not typically the intention), so keep in mind the function needs to be called twice to set a different value into each of the mask sets, once with 'mask_set=1' and second time with 'mask_set=2'. </p>

</div>
</div>
<a class="anchor" id="a7ee758c45cbfbcb9afe7d3ebecea16b2"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_tag_compose" ref="a7ee758c45cbfbcb9afe7d3ebecea16b2" args="(uint64_t sw_bits, uint64_t hw_bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t cvmx_pow_tag_compose </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>sw_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>hw_bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function creates a 32 bit tag value from the two values provided. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sw_bits</em>&nbsp;</td><td>The upper bits (number depends on configuration) are set to this value. The remainder of bits are set by the hw_bits parameter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hw_bits</em>&nbsp;</td><td>The lower bits (number depends on configuration) are set to this value. The remainder of bits are set by the sw_bits parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>32 bit value of the combined hw and sw bits. </dd></dl>

</div>
</div>
<a class="anchor" id="abe64d694f7cbf5d8f8f8d77229baf30e"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_tag_get_hw_bits" ref="abe64d694f7cbf5d8f8f8d77229baf30e" args="(uint64_t tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t cvmx_pow_tag_get_hw_bits </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>tag</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts the bits allocated for hardware use from the tag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>32 bit tag value</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>(32 - N) bit software tag value, where N is configurable with the CVMX_TAG_SW_BITS define </dd></dl>

</div>
</div>
<a class="anchor" id="adeb42784c4007b00c9d2ecd8827f04fc"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_tag_get_sw_bits" ref="adeb42784c4007b00c9d2ecd8827f04fc" args="(uint64_t tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t cvmx_pow_tag_get_sw_bits </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>tag</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts the bits allocated for software use from the tag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>32 bit tag value</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>N bit software tag value, where N is configurable with the CVMX_TAG_SW_BITS define </dd></dl>

</div>
</div>
<a class="anchor" id="add5b9784e9c8d6f7fda874963d1c958a"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_tag_sw" ref="add5b9784e9c8d6f7fda874963d1c958a" args="(uint32_t tag, cvmx_pow_tag_type_t tag_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_pow_tag_sw </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cvmx-csr-enums_8h.html#a556896ab26554db9f539b17e5dbc749b">cvmx_pow_tag_type_t</a>&nbsp;</td>
          <td class="paramname"> <em>tag_type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts a tag switch to the provided tag value and tag type. </p>
<p>Completion for the tag switch must be checked for separately. This function does NOT update the work queue entry in dram to match tag value and type, so the application must keep track of these if they are important to the application. This tag switch command must not be used for switches to NULL, as the tag switch pending bit will be set by the switch request, but never cleared by the hardware.</p>
<p>NOTE: This should not be used when switching from a NULL tag. Use <a class="el" href="cvmx-pow_8h.html#a5c0507e9aceb32eb26c04c08881a917f" title="Starts a tag switch to the provided tag value and tag type.">cvmx_pow_tag_sw_full()</a> instead.</p>
<p>This function waits for any previous tag switch to complete, and also displays an error on tag switches to NULL.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>new tag value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag_type</em>&nbsp;</td><td>new tag type (ordered or atomic) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a373ce7f3ed51f6a682828711cfe235ff"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_tag_sw_desched" ref="a373ce7f3ed51f6a682828711cfe235ff" args="(uint32_t tag, cvmx_pow_tag_type_t tag_type, uint64_t group, uint64_t no_sched)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_pow_tag_sw_desched </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cvmx-csr-enums_8h.html#a556896ab26554db9f539b17e5dbc749b">cvmx_pow_tag_type_t</a>&nbsp;</td>
          <td class="paramname"> <em>tag_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>no_sched</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a tag switch and then an immediate deschedule. </p>
<p>This completes immediately, so completion must not be waited for. This function does NOT update the wqe in DRAM to match arguments.</p>
<p>This function waits for any prior tag switches to complete, so the calling code may call this function with a pending tag switch.</p>
<p>Note the following CAVEAT of the Octeon HW behavior when re-scheduling DE-SCHEDULEd items whose (next) state is ORDERED:</p>
<ul>
<li>If there are no switches pending at the time that the HW executes the de-schedule, the HW will only re-schedule the head of the FIFO associated with the given tag. This means that in many respects, the HW treats this ORDERED tag as an ATOMIC tag. Note that in the SWTAG_DESCH case (to an ORDERED tag), the HW will do the switch before the deschedule whenever it is possible to do the switch immediately, so it may often look like this case.</li>
<li>If there is a pending switch to ORDERED at the time the HW executes the de-schedule, the HW will perform the switch at the time it re-schedules, and will be able to reschedule any/all of the entries with the same tag. Due to this behavior, the RECOMMENDATION to software is that they have a (next) state of ATOMIC when they DE-SCHEDULE. If an ORDERED tag is what was really desired, SW can choose to immediately switch to an ORDERED tag after the work (that has an ATOMIC tag) is re-scheduled. Note that since there are never any tag switches pending when the HW re-schedules, this switch can be IMMEDIATE upon the reception of the pointer during the re-schedule.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>New tag value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag_type</em>&nbsp;</td><td>New tag type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>group</em>&nbsp;</td><td>New group value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>no_sched</em>&nbsp;</td><td>Control whether this work queue entry will be rescheduled.</p>
<ul>
<li>1 : don't schedule this work</li>
<li>0 : allow this work to be scheduled. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a081fe0f3083c2bff75a9b8d1b7429712"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_tag_sw_desched_nocheck" ref="a081fe0f3083c2bff75a9b8d1b7429712" args="(uint32_t tag, cvmx_pow_tag_type_t tag_type, uint64_t group, uint64_t no_sched)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_pow_tag_sw_desched_nocheck </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cvmx-csr-enums_8h.html#a556896ab26554db9f539b17e5dbc749b">cvmx_pow_tag_type_t</a>&nbsp;</td>
          <td class="paramname"> <em>tag_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>no_sched</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a tag switch and then an immediate deschedule. </p>
<p>This completes immediately, so completion must not be waited for. This function does NOT update the wqe in DRAM to match arguments.</p>
<p>This function does NOT wait for any prior tag switches to complete, so the calling code must do this.</p>
<p>Note the following CAVEAT of the Octeon HW behavior when re-scheduling DE-SCHEDULEd items whose (next) state is ORDERED:</p>
<ul>
<li>If there are no switches pending at the time that the HW executes the de-schedule, the HW will only re-schedule the head of the FIFO associated with the given tag. This means that in many respects, the HW treats this ORDERED tag as an ATOMIC tag. Note that in the SWTAG_DESCH case (to an ORDERED tag), the HW will do the switch before the deschedule whenever it is possible to do the switch immediately, so it may often look like this case.</li>
<li>If there is a pending switch to ORDERED at the time the HW executes the de-schedule, the HW will perform the switch at the time it re-schedules, and will be able to reschedule any/all of the entries with the same tag. Due to this behavior, the RECOMMENDATION to software is that they have a (next) state of ATOMIC when they DE-SCHEDULE. If an ORDERED tag is what was really desired, SW can choose to immediately switch to an ORDERED tag after the work (that has an ATOMIC tag) is re-scheduled. Note that since there are never any tag switches pending when the HW re-schedules, this switch can be IMMEDIATE upon the reception of the pointer during the re-schedule.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>New tag value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag_type</em>&nbsp;</td><td>New tag type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>group</em>&nbsp;</td><td>New group value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>no_sched</em>&nbsp;</td><td>Control whether this work queue entry will be rescheduled.</p>
<ul>
<li>1 : don't schedule this work</li>
<li>0 : allow this work to be scheduled. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c9aeb8caf8ab65e7af2cd435c7a6b86"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_tag_sw_desched_node" ref="a3c9aeb8caf8ab65e7af2cd435c7a6b86" args="(cvmx_wqe_t *wqe, uint32_t tag, cvmx_pow_tag_type_t tag_type, uint8_t xgrp, uint64_t no_sched, uint8_t node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_pow_tag_sw_desched_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__wqe__s.html">cvmx_wqe_t</a> *&nbsp;</td>
          <td class="paramname"> <em>wqe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cvmx-csr-enums_8h.html#a556896ab26554db9f539b17e5dbc749b">cvmx_pow_tag_type_t</a>&nbsp;</td>
          <td class="paramname"> <em>tag_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>xgrp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>no_sched</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Executes the SSO SWTAG_DESCHED operation. </p>
<p>This is similar to the <a class="el" href="cvmx-pow_8h.html#a373ce7f3ed51f6a682828711cfe235ff" title="Performs a tag switch and then an immediate deschedule.">cvmx_pow_tag_sw_desched()</a> function, but uses linear (vs. unified group-qos) group index. </p>

</div>
</div>
<a class="anchor" id="a5c0507e9aceb32eb26c04c08881a917f"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_tag_sw_full" ref="a5c0507e9aceb32eb26c04c08881a917f" args="(cvmx_wqe_t *wqp, uint32_t tag, cvmx_pow_tag_type_t tag_type, uint64_t group)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_pow_tag_sw_full </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__wqe__s.html">cvmx_wqe_t</a> *&nbsp;</td>
          <td class="paramname"> <em>wqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cvmx-csr-enums_8h.html#a556896ab26554db9f539b17e5dbc749b">cvmx_pow_tag_type_t</a>&nbsp;</td>
          <td class="paramname"> <em>tag_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>group</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts a tag switch to the provided tag value and tag type. </p>
<p>Completion for the tag switch must be checked for separately. This function does NOT update the work queue entry in dram to match tag value and type, so the application must keep track of these if they are important to the application. This tag switch command must not be used for switches to NULL, as the tag switch pending bit will be set by the switch request, but never cleared by the hardware.</p>
<p>This function must be used for tag switches from NULL.</p>
<p>This function waits for any pending tag switches to complete before requesting the tag switch.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wqp</em>&nbsp;</td><td>Pointer to work queue entry to submit. This entry is updated to match the other parameters </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>Tag value to be assigned to work queue entry </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag_type</em>&nbsp;</td><td>Type of tag </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>group</em>&nbsp;</td><td>Group value for the work queue entry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada0c34dfc5a7fcd0b819e3e151bc60d1"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_tag_sw_full_nocheck" ref="ada0c34dfc5a7fcd0b819e3e151bc60d1" args="(cvmx_wqe_t *wqp, uint32_t tag, cvmx_pow_tag_type_t tag_type, uint64_t group)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_pow_tag_sw_full_nocheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__wqe__s.html">cvmx_wqe_t</a> *&nbsp;</td>
          <td class="paramname"> <em>wqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cvmx-csr-enums_8h.html#a556896ab26554db9f539b17e5dbc749b">cvmx_pow_tag_type_t</a>&nbsp;</td>
          <td class="paramname"> <em>tag_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>group</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts a tag switch to the provided tag value and tag type. </p>
<p>Completion for the tag switch must be checked for separately. This function does NOT update the work queue entry in dram to match tag value and type, so the application must keep track of these if they are important to the application. This tag switch command must not be used for switches to NULL, as the tag switch pending bit will be set by the switch request, but never cleared by the hardware.</p>
<p>This function must be used for tag switches from NULL.</p>
<p>This function does no checks, so the caller must ensure that any previous tag switch has completed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wqp</em>&nbsp;</td><td>pointer to work queue entry to submit. This entry is updated to match the other parameters </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>tag value to be assigned to work queue entry </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag_type</em>&nbsp;</td><td>type of tag </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>group</em>&nbsp;</td><td>group value for the work queue entry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9663856a3ef4eedd3a395af2e11d62d2"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_tag_sw_full_node" ref="a9663856a3ef4eedd3a395af2e11d62d2" args="(cvmx_wqe_t *wqp, uint32_t tag, cvmx_pow_tag_type_t tag_type, uint8_t xgrp, int node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_pow_tag_sw_full_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__wqe__s.html">cvmx_wqe_t</a> *&nbsp;</td>
          <td class="paramname"> <em>wqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cvmx-csr-enums_8h.html#a556896ab26554db9f539b17e5dbc749b">cvmx_pow_tag_type_t</a>&nbsp;</td>
          <td class="paramname"> <em>tag_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>xgrp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Executes SSO SWTAG_FULL command. </p>
<p>This is similiar to <a class="el" href="cvmx-pow_8h.html#a5c0507e9aceb32eb26c04c08881a917f" title="Starts a tag switch to the provided tag value and tag type.">cvmx_pow_tag_sw_full()</a> function, but uses linear (vs. integrated group-qos) group index. </p>

</div>
</div>
<a class="anchor" id="a8d7be99e09a7452658cc12c6cc320f60"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_tag_sw_nocheck" ref="a8d7be99e09a7452658cc12c6cc320f60" args="(uint32_t tag, cvmx_pow_tag_type_t tag_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_pow_tag_sw_nocheck </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cvmx-csr-enums_8h.html#a556896ab26554db9f539b17e5dbc749b">cvmx_pow_tag_type_t</a>&nbsp;</td>
          <td class="paramname"> <em>tag_type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts a tag switch to the provided tag value and tag type. </p>
<p>Completion for the tag switch must be checked for separately. This function does NOT update the work queue entry in dram to match tag value and type, so the application must keep track of these if they are important to the application. This tag switch command must not be used for switches to NULL, as the tag switch pending bit will be set by the switch request, but never cleared by the hardware.</p>
<p>NOTE: This should not be used when switching from a NULL tag. Use <a class="el" href="cvmx-pow_8h.html#a5c0507e9aceb32eb26c04c08881a917f" title="Starts a tag switch to the provided tag value and tag type.">cvmx_pow_tag_sw_full()</a> instead.</p>
<p>This function does no checks, so the caller must ensure that any previous tag switch has completed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>new tag value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag_type</em>&nbsp;</td><td>new tag type (ordered or atomic) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4fef3070f7ab95a414b5cdff8454804c"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_tag_sw_node" ref="a4fef3070f7ab95a414b5cdff8454804c" args="(cvmx_wqe_t *wqp, uint32_t tag, cvmx_pow_tag_type_t tag_type, int node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_pow_tag_sw_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__wqe__s.html">cvmx_wqe_t</a> *&nbsp;</td>
          <td class="paramname"> <em>wqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cvmx-csr-enums_8h.html#a556896ab26554db9f539b17e5dbc749b">cvmx_pow_tag_type_t</a>&nbsp;</td>
          <td class="paramname"> <em>tag_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Executes SSO SWTAG command. </p>
<p>This is similiar to <a class="el" href="cvmx-pow_8h.html#add5b9784e9c8d6f7fda874963d1c958a" title="Starts a tag switch to the provided tag value and tag type.">cvmx_pow_tag_sw()</a> function, but uses linear (vs. integrated group-qos) group index. </p>

</div>
</div>
<a class="anchor" id="a8948068d2bbabae2035789bbf82b9883"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_tag_sw_null" ref="a8948068d2bbabae2035789bbf82b9883" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_pow_tag_sw_null </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Switch to a NULL tag, which ends any ordering or synchronization provided by the POW for the current work queue entry. </p>
<p>This operation completes immediatly, so completion should not be waited for. This function waits for any pending tag switches to complete before requesting the switch to NULL. </p>

</div>
</div>
<a class="anchor" id="a0ad916abec85508425ed6d68b81ddec8"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_tag_sw_null_nocheck" ref="a0ad916abec85508425ed6d68b81ddec8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_pow_tag_sw_null_nocheck </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Switch to a NULL tag, which ends any ordering or synchronization provided by the POW for the current work queue entry. </p>
<p>This operation completes immediately, so completion should not be waited for. This function does NOT wait for previous tag switches to complete, so the caller must ensure that any previous tag switches have completed. </p>

</div>
</div>
<a class="anchor" id="a1ff579bf32ccc0cdbcef8c23eaa53090"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_tag_sw_wait" ref="a1ff579bf32ccc0cdbcef8c23eaa53090" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_pow_tag_sw_wait </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Waits for a tag switch to complete by polling the completion bit. </p>
<p>Note that switches to NULL complete immediately and do not need to be waited for. </p>

</div>
</div>
<a class="anchor" id="a41ec9612ff526f63468c4e94ce03127b"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_work_invalid" ref="a41ec9612ff526f63468c4e94ce03127b" args="(cvmx_wqe_t *wqe_ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t cvmx_pow_work_invalid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__wqe__s.html">cvmx_wqe_t</a> *&nbsp;</td>
          <td class="paramname"> <em>wqe_ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if a work queue entry pointer returned by a work request is valid. </p>
<p>It may be invalid due to no work being available or due to a timeout.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wqe_ptr</em>&nbsp;</td><td>pointer to a work queue entry returned by the POW</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if pointer is valid 1 if invalid (no work was returned) </dd></dl>

</div>
</div>
<a class="anchor" id="ab7f66e0dbe686746ec48dc25c7602645"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_work_request_async" ref="ab7f66e0dbe686746ec48dc25c7602645" args="(int scr_addr, cvmx_pow_wait_t wait)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_pow_work_request_async </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>scr_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cvmx-pow_8h.html#a3db4988111245427fd604c2d591629e7">cvmx_pow_wait_t</a>&nbsp;</td>
          <td class="paramname"> <em>wait</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronous work request. </p>
<p>Work is requested from the POW unit, and should later be checked with function cvmx_pow_work_response_async. This function waits for any previous tag switch to complete before requesting the new work.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>scr_addr</em>&nbsp;</td><td>Scratch memory address that response will be returned to, which is either a valid WQE, or a response with the invalid bit set. Byte address, must be 8 byte aligned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wait</em>&nbsp;</td><td>1 to cause response to wait for work to become available (or timeout) 0 to cause response to return immediately </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0477e774db62c60e5b1ad2d04c44eedf"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_work_request_async_nocheck" ref="a0477e774db62c60e5b1ad2d04c44eedf" args="(int scr_addr, cvmx_pow_wait_t wait)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_pow_work_request_async_nocheck </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>scr_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cvmx-pow_8h.html#a3db4988111245427fd604c2d591629e7">cvmx_pow_wait_t</a>&nbsp;</td>
          <td class="paramname"> <em>wait</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronous work request. </p>
<p>Work is requested from the POW unit, and should later be checked with function cvmx_pow_work_response_async. This function does NOT wait for previous tag switches to complete, so the caller must ensure that there is not a pending tag switch.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>scr_addr</em>&nbsp;</td><td>Scratch memory address that response will be returned to, which is either a valid WQE, or a response with the invalid bit set. Byte address, must be 8 byte aligned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wait</em>&nbsp;</td><td>1 to cause response to wait for work to become available (or timeout) 0 to cause response to return immediately </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e11dd31e57dce2059d4e653fa54f8ee"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_work_request_null_rd" ref="a6e11dd31e57dce2059d4e653fa54f8ee" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="cvmx-csr-enums_8h.html#a556896ab26554db9f539b17e5dbc749b">cvmx_pow_tag_type_t</a> cvmx_pow_work_request_null_rd </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronous null_rd request. </p>
<p>Requests a switch out of NULL_NULL POW state. This function waits for any previous tag switch to complete before requesting the null_rd.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the POW state of type cvmx_pow_tag_type_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a663a32115088b6888949303edea06e5f"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_work_request_sync" ref="a663a32115088b6888949303edea06e5f" args="(cvmx_pow_wait_t wait)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structcvmx__wqe__s.html">cvmx_wqe_t</a>* cvmx_pow_work_request_sync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cvmx-pow_8h.html#a3db4988111245427fd604c2d591629e7">cvmx_pow_wait_t</a>&nbsp;</td>
          <td class="paramname"> <em>wait</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronous work request. </p>
<p>Requests work from the POW. This function waits for any previous tag switch to complete before requesting the new work.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wait</em>&nbsp;</td><td>When set, call stalls until work becomes avaiable, or times out. If not set, returns immediately.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the WQE pointer from POW. Returns NULL if no work was available. </dd></dl>

</div>
</div>
<a class="anchor" id="acb89059e31f202c79fb282e7c3647153"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_work_request_sync_nocheck" ref="acb89059e31f202c79fb282e7c3647153" args="(cvmx_pow_wait_t wait)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structcvmx__wqe__s.html">cvmx_wqe_t</a>* cvmx_pow_work_request_sync_nocheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cvmx-pow_8h.html#a3db4988111245427fd604c2d591629e7">cvmx_pow_wait_t</a>&nbsp;</td>
          <td class="paramname"> <em>wait</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronous work request. </p>
<p>Requests work from the POW. This function does NOT wait for previous tag switches to complete, so the caller must ensure that there is not a pending tag switch.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wait</em>&nbsp;</td><td>When set, call stalls until work becomes avaiable, or times out. If not set, returns immediately.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the WQE pointer from POW. Returns NULL if no work was available. </dd></dl>

</div>
</div>
<a class="anchor" id="a371aef3eb06e4a961607623fba6fd330"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_work_response_async" ref="a371aef3eb06e4a961607623fba6fd330" args="(int scr_addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structcvmx__wqe__s.html">cvmx_wqe_t</a>* cvmx_pow_work_response_async </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>scr_addr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets result of asynchronous work request. </p>
<p>Performs a IOBDMA sync to wait for the response.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>scr_addr</em>&nbsp;</td><td>Scratch memory address to get result from Byte address, must be 8 byte aligned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the WQE from the scratch register, or NULL if no work was available. </dd></dl>

</div>
</div>
<a class="anchor" id="afa6ed62ed9357ec3c2b32c5534003aa3"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_work_submit" ref="afa6ed62ed9357ec3c2b32c5534003aa3" args="(cvmx_wqe_t *wqp, uint32_t tag, cvmx_pow_tag_type_t tag_type, uint64_t qos, uint64_t grp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_pow_work_submit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__wqe__s.html">cvmx_wqe_t</a> *&nbsp;</td>
          <td class="paramname"> <em>wqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cvmx-csr-enums_8h.html#a556896ab26554db9f539b17e5dbc749b">cvmx_pow_tag_type_t</a>&nbsp;</td>
          <td class="paramname"> <em>tag_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>grp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Submits work to an input queue. </p>
<p>This function updates the work queue entry in DRAM to match the arguments given. Note that the tag provided is for the work queue entry submitted, and is unrelated to the tag that the core currently holds.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wqp</em>&nbsp;</td><td>pointer to work queue entry to submit. This entry is updated to match the other parameters </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>tag value to be assigned to work queue entry </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag_type</em>&nbsp;</td><td>type of tag </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>qos</em>&nbsp;</td><td>Input queue to add to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>grp</em>&nbsp;</td><td>group value for the work queue entry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ae4bc92eb3bff7c08ef34bfde89c09d"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_pow_work_submit_node" ref="a6ae4bc92eb3bff7c08ef34bfde89c09d" args="(cvmx_wqe_t *wqp, uint32_t tag, cvmx_pow_tag_type_t tag_type, uint8_t xgrp, uint8_t node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_pow_work_submit_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__wqe__s.html">cvmx_wqe_t</a> *&nbsp;</td>
          <td class="paramname"> <em>wqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cvmx-csr-enums_8h.html#a556896ab26554db9f539b17e5dbc749b">cvmx_pow_tag_type_t</a>&nbsp;</td>
          <td class="paramname"> <em>tag_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>xgrp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Submits work to an SSO group on any OCI node. </p>
<p>This function updates the work queue entry in DRAM to match the arguments given. Note that the tag provided is for the work queue entry submitted, and is unrelated to the tag that the core currently holds.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wqp</em>&nbsp;</td><td>pointer to work queue entry to submit. This entry is updated to match the other parameters </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>tag value to be assigned to work queue entry </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag_type</em>&nbsp;</td><td>type of tag </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xgrp</em>&nbsp;</td><td>native CN78XX group in the range 0..255 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>The OCI node number for the target group</td></tr>
  </table>
  </dd>
</dl>
<p>When this function is called on a model prior to CN78XX, which does not support OCI nodes, the 'node' argument is ignored, and the 'xgrp' parameter is converted into 'qos' (the lower 3 bits) and 'grp' (the higher 5 bits), following the backward-compatibility scheme of translating between new and old style group numbers. </p>

</div>
</div>
<a class="anchor" id="a83e0c105337315ca8477905138383ed7"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_sso3_get_wqe_count" ref="a83e0c105337315ca8477905138383ed7" args="(int node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t cvmx_sso3_get_wqe_count </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af8db2a54355d2ec290d32d0701ee6c43"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_sso_config_dump" ref="af8db2a54355d2ec290d32d0701ee6c43" args="(unsigned node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_sso_config_dump </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Show integrated PKI configuration. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>node number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acaeffaa0e61c3258fa3867b00548a725"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_sso_get_total_wqe_count" ref="acaeffaa0e61c3258fa3867b00548a725" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t cvmx_sso_get_total_wqe_count </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa19fb1858f8ad244fee2f8bfa5825553"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_sso_num_maskset" ref="aa19fb1858f8ad244fee2f8bfa5825553" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned cvmx_sso_num_maskset </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal use function. </p>
<p><b>This function's parameters and processing may change in future SDKs.</b><br/>
<br/>
 Return the number of mask-set registers. </p>

</div>
</div>
<a class="anchor" id="aa4853005bc11b57470c8c75c22f5d5e9"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_sso_num_xgrp" ref="aa4853005bc11b57470c8c75c22f5d5e9" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned cvmx_sso_num_xgrp </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal use function. </p>
<p><b>This function's parameters and processing may change in future SDKs.</b><br/>
<br/>
 Return the number of SSO groups for a given SoC model </p>

</div>
</div>
<a class="anchor" id="aca3afc1169a59eaf9720002d49e2f48f"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_sso_release_group" ref="aca3afc1169a59eaf9720002d49e2f48f" args="(int node, int group)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_sso_release_group </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>group</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3b000c3a27b9808b07467f2b3dfc2d7c"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_sso_release_group_range" ref="a3b000c3a27b9808b07467f2b3dfc2d7c" args="(int node, int base_group, int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_sso_release_group_range </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>base_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2d3c45099dc2940dff9621451eb8dc59"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_sso_reserve_group" ref="a2d3c45099dc2940dff9621451eb8dc59" args="(int node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_sso_reserve_group </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af707ecacfb0fe2d30ab06ca64cd50853"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_sso_reserve_group_range" ref="af707ecacfb0fe2d30ab06ca64cd50853" args="(int node, int *base_group, int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_sso_reserve_group_range </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>base_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This will allocate count number of SSO groups on the specified node to the calling application. </p>
<p>These groups will be for exclusive use of the application until they are freed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>The numa node for the allocation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>base_group</em>&nbsp;</td><td>Pointer to the initial group, -1 to allocate anywhere. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of consecutive groups to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success and -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c903b259189845f01c886c8920bb05d"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_sso_set_group_core_affinity" ref="a3c903b259189845f01c886c8920bb05d" args="(cvmx_xgrp_t xgrp, const cvmx_coremask_t *core_mask, uint8_t mask_set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_sso_set_group_core_affinity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unioncvmx__xgrp__t.html">cvmx_xgrp_t</a>&nbsp;</td>
          <td class="paramname"> <em>xgrp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcvmx__coremask.html">cvmx_coremask_t</a> *&nbsp;</td>
          <td class="paramname"> <em>core_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>mask_set</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function sets the the affinity of group to the cores in 78xx. </p>
<p>It sets up all the cores in core_mask to accept work from the specified group.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xgrp</em>&nbsp;</td><td>Group to accept work from, 0 - 255. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>core_mask</em>&nbsp;</td><td>Mask of all the cores which will accept work from this group </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask_set</em>&nbsp;</td><td>Every core has set of 2 masks which can be set to accept work from 256 groups. At the time of get_work, cores can choose which mask_set to get work from. 'mask_set' values range from 0 to 3, where each of the two bits represents a mask set. Cores will be added to the mask set with corresponding bit set, and removed from the mask set with corresponding bit clear. Note: cores can only accept work from SSO groups on the same node, so the node number for the group is derived from the core number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e9da13e9384cb31b66941830f5b18d5"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_sso_set_group_priority" ref="a6e9da13e9384cb31b66941830f5b18d5" args="(int node, cvmx_xgrp_t xgrp, int priority, int weight, int affinity, enum cvmx_sso_group_modify_mask modify_mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_sso_set_group_priority </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unioncvmx__xgrp__t.html">cvmx_xgrp_t</a>&nbsp;</td>
          <td class="paramname"> <em>xgrp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>affinity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="cvmx-pow_8h.html#a4261815d55968a39541b3bf61630c3bc">cvmx_sso_group_modify_mask</a>&nbsp;</td>
          <td class="paramname"> <em>modify_mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function sets the priority and group affinity arbitration for each group. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>Node number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xgrp</em>&nbsp;</td><td>Group 0 - 255 to apply mask parameters to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>priority</em>&nbsp;</td><td>Priority of the group relative to other groups 0x0 - highest priority 0x7 - lowest priority </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>weight</em>&nbsp;</td><td>Cross-group arbitration weight to apply to this group. valid values are 1-63 h/w default is 0x3f </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>affinity</em>&nbsp;</td><td>Processor affinity arbitration weight to apply to this group. If zero, affinity is disabled. valid values are 0-15 h/w default which is 0xf. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>modify_mask</em>&nbsp;</td><td>mask of the parameters which needs to be modified. enum cvmx_sso_group_modify_mask to modify only priority -- set bit0 to modify only weight -- set bit1 to modify only affinity -- set bit2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a062008618fcc1c3ca07283374f3b56"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_sso_update_wqp_group" ref="a6a062008618fcc1c3ca07283374f3b56" args="(cvmx_wqe_t *wqp, uint8_t xgrp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_sso_update_wqp_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__wqe__s.html">cvmx_wqe_t</a> *&nbsp;</td>
          <td class="paramname"> <em>wqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>xgrp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acb3cfb4760d3c530f3571c9c2c43006f"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_sso_work_request_grp_async_nocheck" ref="acb3cfb4760d3c530f3571c9c2c43006f" args="(int scr_addr, cvmx_xgrp_t xgrp, cvmx_pow_wait_t wait)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cvmx_sso_work_request_grp_async_nocheck </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>scr_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unioncvmx__xgrp__t.html">cvmx_xgrp_t</a>&nbsp;</td>
          <td class="paramname"> <em>xgrp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cvmx-pow_8h.html#a3db4988111245427fd604c2d591629e7">cvmx_pow_wait_t</a>&nbsp;</td>
          <td class="paramname"> <em>wait</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronous work request. </p>
<p>Only works on CN78XX style SSO.</p>
<p>Work is requested from the SSO unit, and should later be checked with function cvmx_pow_work_response_async. This function does NOT wait for previous tag switches to complete, so the caller must ensure that there is not a pending tag switch.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>scr_addr</em>&nbsp;</td><td>Scratch memory address that response will be returned to, which is either a valid WQE, or a response with the invalid bit set. Byte address, must be 8 byte aligned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xgrp</em>&nbsp;</td><td>Group to receive work for (0-255). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wait</em>&nbsp;</td><td>1 to cause response to wait for work to become available (or timeout) 0 to cause response to return immediately </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae0cbbfb0be90e33e76f843e7fee4826f"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_sso_work_request_grp_sync" ref="ae0cbbfb0be90e33e76f843e7fee4826f" args="(unsigned int lgrp, cvmx_pow_wait_t wait)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void* cvmx_sso_work_request_grp_sync </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>lgrp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cvmx-pow_8h.html#a3db4988111245427fd604c2d591629e7">cvmx_pow_wait_t</a>&nbsp;</td>
          <td class="paramname"> <em>wait</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronous work request from the node-local SSO. </p>
<p>It requests work from a specific SSO group. This function waits for any previous tag switch to complete before requesting the new work.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lgrp</em>&nbsp;</td><td>The node-local group number from which to get the work. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wait</em>&nbsp;</td><td>When set, call stalls until work becomes avaiable, or times out. If not set, returns immediately.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The WQE pointer or NULL, if work is not available. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1519d72a55f3cbd435360880c7adf7f"></a><!-- doxytag: member="cvmx&#45;pow.h::cvmx_sso_work_request_grp_sync_nocheck" ref="ae1519d72a55f3cbd435360880c7adf7f" args="(unsigned int lgrp, cvmx_pow_wait_t wait)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void* cvmx_sso_work_request_grp_sync_nocheck </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>lgrp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cvmx-pow_8h.html#a3db4988111245427fd604c2d591629e7">cvmx_pow_wait_t</a>&nbsp;</td>
          <td class="paramname"> <em>wait</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronous work request from the node-local SSO without verifying pending tag switch. </p>
<p>It requests work from a specific SSO group.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lgrp</em>&nbsp;</td><td>The local group number (within the SSO of the node of the caller) from which to get the work. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wait</em>&nbsp;</td><td>When set, call stalls until work becomes avaiable, or times out. If not set, returns immediately.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the WQE pointer from SSO. Returns NULL if no work was available. </dd></dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Oct 2017 for Octeon Software Development Kit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
