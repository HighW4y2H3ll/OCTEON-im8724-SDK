<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Octeon Software Development Kit: cvmx-usb.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cvmx-usb.h File Reference</h1>
<p>"cvmx-usb.h" defines a set of low level USB functions to help developers create Octeon USB drivers for various operating systems.  
<a href="#_details">More...</a></p>
<div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dynsection">
<div class="center"><img src="cvmx-usb_8h__dep__incl.png" border="0" usemap="#cvmx-usb_8hdep_map" alt=""/></div>
<map name="cvmx-usb_8hdep_map" id="cvmx-usb_8hdep">
<area shape="rect" id="node3" href="cvmx-usb_8c.html" title="&quot;cvmx&#45;usb.c&quot; defines a set of low level USB functions to help developers..." alt="" coords="5,83,104,112"/></map>
</div>

<p><a href="cvmx-usb_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcvmx__usb__port__status__t.html">cvmx_usb_port_status_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure returned containing the USB port status information.  <a href="structcvmx__usb__port__status__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unioncvmx__usb__control__header__t.html">cvmx_usb_control_header_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the structure of a Control packet header.  <a href="unioncvmx__usb__control__header__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcvmx__usb__iso__packet__t.html">cvmx_usb_iso_packet_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Descriptor for Isochronous packets.  <a href="structcvmx__usb__iso__packet__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">USB state internal data.  <a href="structcvmx__usb__state__t.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-usb_8h.html#ad30ee177ca41ebdc033081f1272d9275">cvmx_usb_callback_func_t</a> )(<a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *<a class="el" href="cvmx-sysinfo_8c.html#a404e470d9833683c088dfd8e8bcb0f9c">state</a>, <a class="el" href="cvmx-usb_8h.html#a7b0db95a0a4705f6a0e461f4d444e8ef">cvmx_usb_callback_t</a> reason, <a class="el" href="cvmx-usb_8h.html#a4aa70fd8c4db3e30b1acd83b7b392c1e">cvmx_usb_complete_t</a> status, int pipe_handle, int submit_handle, int bytes_transferred, void *user_data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">USB callback functions are always of the following type.  <a href="#ad30ee177ca41ebdc033081f1272d9275"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-usb_8h.html#ab60527516a0c56b1d652b5d54cf69fd2">cvmx_usb_status_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#ab60527516a0c56b1d652b5d54cf69fd2a8100d0a44b21b86d5b8470c9b79840d9">CVMX_USB_SUCCESS</a> =  0, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#ab60527516a0c56b1d652b5d54cf69fd2a5dfb93eb628d9656178a33413e80f1d5">CVMX_USB_INVALID_PARAM</a> =  -1, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#ab60527516a0c56b1d652b5d54cf69fd2a5517fed2322dd4c66f15fed7da6b4004">CVMX_USB_NO_MEMORY</a> =  -2, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#ab60527516a0c56b1d652b5d54cf69fd2a8a8c144e9758a8c6bc3fb0e26588fc29">CVMX_USB_BUSY</a> =  -3, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#ab60527516a0c56b1d652b5d54cf69fd2a7a6cd04d1fe01b1a229f385ad1ab85d7">CVMX_USB_TIMEOUT</a> =  -4, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#ab60527516a0c56b1d652b5d54cf69fd2a71d39e0fcc01c3b381cb22dd34778a45">CVMX_USB_INCORRECT_MODE</a> =  -5
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Enumerations representing the status of function calls. </p>
 <a href="cvmx-usb_8h.html#ab60527516a0c56b1d652b5d54cf69fd2">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-usb_8h.html#abeafd428d2f4b4bb5086616d60a9e333">cvmx_usb_speed_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#abeafd428d2f4b4bb5086616d60a9e333a0c91d0d12d74beb26279b468f2e5da67">CVMX_USB_SPEED_HIGH</a> =  0, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#abeafd428d2f4b4bb5086616d60a9e333a419b697ad52d8faee0c979c5d56cd596">CVMX_USB_SPEED_FULL</a> =  1, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#abeafd428d2f4b4bb5086616d60a9e333aaaecc4eed72310f15fbd56830f0aa487">CVMX_USB_SPEED_LOW</a> =  2
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Enumerations representing the possible USB device speeds. </p>
 <a href="cvmx-usb_8h.html#abeafd428d2f4b4bb5086616d60a9e333">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-usb_8h.html#a09207c64b615b8c1147ff8d5794702b3">cvmx_usb_transfer_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#a09207c64b615b8c1147ff8d5794702b3a9c7344c8b8b9e5463e2b5bb8cfa740f2">CVMX_USB_TRANSFER_CONTROL</a> =  0, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#a09207c64b615b8c1147ff8d5794702b3a726e1695832da7b6eee5a769801c40a1">CVMX_USB_TRANSFER_ISOCHRONOUS</a> =  1, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#a09207c64b615b8c1147ff8d5794702b3afea214fc860ae6096cd36456ede3e0c4">CVMX_USB_TRANSFER_BULK</a> =  2, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#a09207c64b615b8c1147ff8d5794702b3ae8db78f4faefc2cefd707e47e5a594fa">CVMX_USB_TRANSFER_INTERRUPT</a> =  3
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Enumeration representing the possible USB transfer types. </p>
 <a href="cvmx-usb_8h.html#a09207c64b615b8c1147ff8d5794702b3">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-usb_8h.html#a6f7eb40ade782b803c123c709a621598">cvmx_usb_direction_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#a6f7eb40ade782b803c123c709a621598a7d55e544b9e964815d3fa2202fe00825">CVMX_USB_DIRECTION_OUT</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#a6f7eb40ade782b803c123c709a621598a35d48981f008e13badec6e0706aaace4">CVMX_USB_DIRECTION_IN</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Enumeration of the transfer directions. </p>
 <a href="cvmx-usb_8h.html#a6f7eb40ade782b803c123c709a621598">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-usb_8h.html#a4aa70fd8c4db3e30b1acd83b7b392c1e">cvmx_usb_complete_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#a4aa70fd8c4db3e30b1acd83b7b392c1ea5f9ed359b102d561eac662da90e71863">CVMX_USB_COMPLETE_SUCCESS</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#a4aa70fd8c4db3e30b1acd83b7b392c1eae22919c4301825af0e97f754a484b15a">CVMX_USB_COMPLETE_SHORT</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#a4aa70fd8c4db3e30b1acd83b7b392c1ea80e173712d034e26a87ba312ba2b558f">CVMX_USB_COMPLETE_CANCEL</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#a4aa70fd8c4db3e30b1acd83b7b392c1ea689c7a40d9a92db955903e29a666b94e">CVMX_USB_COMPLETE_ERROR</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#a4aa70fd8c4db3e30b1acd83b7b392c1ea2c71959c0d16338a9e3b333ef1a1e15b">CVMX_USB_COMPLETE_STALL</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#a4aa70fd8c4db3e30b1acd83b7b392c1ea05aaa2c7548b3c244b24896eebe83625">CVMX_USB_COMPLETE_XACTERR</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#a4aa70fd8c4db3e30b1acd83b7b392c1eaabf061c7f86d14aab1d4d43addb242c9">CVMX_USB_COMPLETE_DATATGLERR</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#a4aa70fd8c4db3e30b1acd83b7b392c1ea897bb1bac1971352dd45f648c1dc4355">CVMX_USB_COMPLETE_BABBLEERR</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#a4aa70fd8c4db3e30b1acd83b7b392c1ea136e9921060f2071a47d644aac6861c9">CVMX_USB_COMPLETE_FRAMEERR</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Enumeration of all possible status codes passed to callback functions. </p>
 <a href="cvmx-usb_8h.html#a4aa70fd8c4db3e30b1acd83b7b392c1e">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-usb_8h.html#a7b0db95a0a4705f6a0e461f4d444e8ef">cvmx_usb_callback_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#a7b0db95a0a4705f6a0e461f4d444e8efafbac148b7e8ca56982e2bda93ffb3ed7">CVMX_USB_CALLBACK_TRANSFER_COMPLETE</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#a7b0db95a0a4705f6a0e461f4d444e8efa672c13998130ff0a1f81a61674abb3e0">CVMX_USB_CALLBACK_PORT_CHANGED</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#a7b0db95a0a4705f6a0e461f4d444e8efa50d243f089938f849ea7880b4ce2b8fe">__CVMX_USB_CALLBACK_END</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Possible callback reasons for the USB API. </p>
 <a href="cvmx-usb_8h.html#a7b0db95a0a4705f6a0e461f4d444e8ef">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-usb_8h.html#acee50b5094efcc69cd029887557a57d3">cvmx_usb_initialize_flags_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#acee50b5094efcc69cd029887557a57d3ae783cd47af23a46d71b025767c6b4d04">CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_XI</a> =  1 &lt;&lt; 0, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#acee50b5094efcc69cd029887557a57d3acd0007a7d52e28e3db4adbf129d1a79e">CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND</a> =  1 &lt;&lt; 1, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#acee50b5094efcc69cd029887557a57d3a0ae1e1f588d5295862fd59d1221e55f9">CVMX_USB_INITIALIZE_FLAGS_CLOCK_AUTO</a> =  0, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#acee50b5094efcc69cd029887557a57d3ad173a6564727c118d38054953ea667de">CVMX_USB_INITIALIZE_FLAGS_CLOCK_MHZ_MASK</a> =  3 &lt;&lt; 3, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#acee50b5094efcc69cd029887557a57d3ae3b556a77fb4d9b77d9b06365aa00948">CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ</a> =  1 &lt;&lt; 3, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#acee50b5094efcc69cd029887557a57d3af731a70cd7b8f2280a2228d054061e96">CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ</a> =  2 &lt;&lt; 3, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#acee50b5094efcc69cd029887557a57d3a39a8e172e558d1aa832921f11ce55be3">CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ</a> =  3 &lt;&lt; 3, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#acee50b5094efcc69cd029887557a57d3a4cfbfb5f3e28fa2f8347a52b33923b7e">CVMX_USB_INITIALIZE_FLAGS_NO_DMA</a> =  1 &lt;&lt; 5, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#acee50b5094efcc69cd029887557a57d3ae1cf3ca026383ad871d477cd57c8e2f1">CVMX_USB_INITIALIZE_FLAGS_DEBUG_TRANSFERS</a> =  1 &lt;&lt; 16, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#acee50b5094efcc69cd029887557a57d3a804974934009aa4cf82f739b8724c236">CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLBACKS</a> =  1 &lt;&lt; 17, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#acee50b5094efcc69cd029887557a57d3a04c23da15244ed8937a0a3c15a586e2d">CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO</a> =  1 &lt;&lt; 18, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#acee50b5094efcc69cd029887557a57d3a0c135b4b3635cc509649fe11929ad560">CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLS</a> =  1 &lt;&lt; 19, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#acee50b5094efcc69cd029887557a57d3ae71c5d9597e35bc34093f26d232e2fa8">CVMX_USB_INITIALIZE_FLAGS_DEBUG_CSRS</a> =  1 &lt;&lt; 20, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#acee50b5094efcc69cd029887557a57d3acec4a67c9c7c51666a11a904b50454e6">CVMX_USB_INITIALIZE_FLAGS_DEBUG_ALL</a> =  ((CVMX_USB_INITIALIZE_FLAGS_DEBUG_CSRS &lt;&lt; 1) - 1) - (CVMX_USB_INITIALIZE_FLAGS_DEBUG_TRANSFERS - 1)
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Flags to pass the initialization function. </p>
 <a href="cvmx-usb_8h.html#acee50b5094efcc69cd029887557a57d3">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-usb_8h.html#a5c424fc7632d3509a53199c6ae323474">cvmx_usb_pipe_flags_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#a5c424fc7632d3509a53199c6ae323474ae0cb9f98b9123faa648f679794bde0f7">CVMX_USB_PIPE_FLAGS_DEBUG_TRANSFERS</a> =  1 &lt;&lt; 15, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#a5c424fc7632d3509a53199c6ae323474a6ae8abc80bf16a17f15896c6d3377bb2">__CVMX_USB_PIPE_FLAGS_OPEN</a> =  1 &lt;&lt; 16, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#a5c424fc7632d3509a53199c6ae323474a44d9d49b75f5f73184a8be872802b18f">__CVMX_USB_PIPE_FLAGS_SCHEDULED</a> =  1 &lt;&lt; 17, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#a5c424fc7632d3509a53199c6ae323474acc4001a61e4de91c18016dceec389e2b">__CVMX_USB_PIPE_FLAGS_NEED_PING</a> =  1 &lt;&lt; 18
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Flags for passing when a pipe is created. </p>
 <a href="cvmx-usb_8h.html#a5c424fc7632d3509a53199c6ae323474">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-usb_8h.html#a549f6679e069a7acbc5d5d45bd7cbaf0">cvmx_usb_isochronous_flags_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#a549f6679e069a7acbc5d5d45bd7cbaf0a4e71c1bbf28c38662db0a6914b5f1729">CVMX_USB_ISOCHRONOUS_FLAGS_ALLOW_SHORT</a> =  1 &lt;&lt; 0, 
<br/>
&nbsp;&nbsp;<a class="el" href="cvmx-usb_8h.html#a549f6679e069a7acbc5d5d45bd7cbaf0a8c8fed1a115e312afe33644a3f5eeb3d">CVMX_USB_ISOCHRONOUS_FLAGS_ASAP</a> =  1 &lt;&lt; 1
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Flags to pass the <a class="el" href="cvmx-usb_8c.html#a81bd48a41477ab51af862910a07ab79b" title="Call to submit a USB Isochronous transfer to a pipe.">cvmx_usb_submit_isochronous()</a> function. </p>
 <a href="cvmx-usb_8h.html#a549f6679e069a7acbc5d5d45bd7cbaf0">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-usb_8h.html#a7008cf45d92d7109dcc590d9dd8f9465">cvmx_usb_get_num_ports</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of USB ports supported by this Octeon chip.  <a href="#a7008cf45d92d7109dcc590d9dd8f9465"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cvmx-usb_8h.html#ab60527516a0c56b1d652b5d54cf69fd2">cvmx_usb_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-usb_8h.html#a78c06bd132938304cf32fe2da8b83ab7">cvmx_usb_initialize</a> (<a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *<a class="el" href="cvmx-sysinfo_8c.html#a404e470d9833683c088dfd8e8bcb0f9c">state</a>, int usb_port_number, <a class="el" href="cvmx-usb_8h.html#acee50b5094efcc69cd029887557a57d3">cvmx_usb_initialize_flags_t</a> flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a USB port for use.  <a href="#a78c06bd132938304cf32fe2da8b83ab7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cvmx-usb_8h.html#ab60527516a0c56b1d652b5d54cf69fd2">cvmx_usb_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-usb_8h.html#abf0e935e37140c27e4735c054a6018d9">cvmx_usb_shutdown</a> (<a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *<a class="el" href="cvmx-sysinfo_8c.html#a404e470d9833683c088dfd8e8bcb0f9c">state</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shutdown a USB port after a call to <a class="el" href="cvmx-usb_8c.html#a78c06bd132938304cf32fe2da8b83ab7" title="Initialize a USB port for use.">cvmx_usb_initialize()</a>.  <a href="#abf0e935e37140c27e4735c054a6018d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cvmx-usb_8h.html#ab60527516a0c56b1d652b5d54cf69fd2">cvmx_usb_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-usb_8h.html#a4fe34faa4328f9017658ffd3d5f74106">cvmx_usb_enable</a> (<a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *<a class="el" href="cvmx-sysinfo_8c.html#a404e470d9833683c088dfd8e8bcb0f9c">state</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable a USB port.  <a href="#a4fe34faa4328f9017658ffd3d5f74106"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cvmx-usb_8h.html#ab60527516a0c56b1d652b5d54cf69fd2">cvmx_usb_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-usb_8h.html#a626627de3b8831b17e1cf094a037371b">cvmx_usb_disable</a> (<a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *<a class="el" href="cvmx-sysinfo_8c.html#a404e470d9833683c088dfd8e8bcb0f9c">state</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable a USB port.  <a href="#a626627de3b8831b17e1cf094a037371b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcvmx__usb__port__status__t.html">cvmx_usb_port_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-usb_8h.html#a9f66ca78263e0e13d78d2e3769dd006e">cvmx_usb_get_status</a> (<a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *<a class="el" href="cvmx-sysinfo_8c.html#a404e470d9833683c088dfd8e8bcb0f9c">state</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current state of the USB port.  <a href="#a9f66ca78263e0e13d78d2e3769dd006e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-usb_8h.html#a07642545f5c4dc7996ab884359f51fde">cvmx_usb_set_status</a> (<a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *<a class="el" href="cvmx-sysinfo_8c.html#a404e470d9833683c088dfd8e8bcb0f9c">state</a>, <a class="el" href="structcvmx__usb__port__status__t.html">cvmx_usb_port_status_t</a> port_status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the current state of the USB port.  <a href="#a07642545f5c4dc7996ab884359f51fde"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-usb_8h.html#a95dc31cdca1fb94441b5034e4f463e3b">cvmx_usb_open_pipe</a> (<a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *<a class="el" href="cvmx-sysinfo_8c.html#a404e470d9833683c088dfd8e8bcb0f9c">state</a>, <a class="el" href="cvmx-usb_8h.html#a5c424fc7632d3509a53199c6ae323474">cvmx_usb_pipe_flags_t</a> flags, int device_addr, int endpoint_num, <a class="el" href="cvmx-usb_8h.html#abeafd428d2f4b4bb5086616d60a9e333">cvmx_usb_speed_t</a> device_speed, int max_packet, <a class="el" href="cvmx-usb_8h.html#a09207c64b615b8c1147ff8d5794702b3">cvmx_usb_transfer_t</a> transfer_type, <a class="el" href="cvmx-usb_8h.html#a6f7eb40ade782b803c123c709a621598">cvmx_usb_direction_t</a> transfer_dir, int interval, int multi_count, int hub_device_addr, int hub_port)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a virtual pipe between the host and a USB device.  <a href="#a95dc31cdca1fb94441b5034e4f463e3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-usb_8h.html#a22ec1f739126b098c9537f5e6ab40bb0">cvmx_usb_submit_bulk</a> (<a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *<a class="el" href="cvmx-sysinfo_8c.html#a404e470d9833683c088dfd8e8bcb0f9c">state</a>, int pipe_handle, uint64_t buffer, int buffer_length, <a class="el" href="cvmx-usb_8h.html#ad30ee177ca41ebdc033081f1272d9275">cvmx_usb_callback_func_t</a> callback, void *user_data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to submit a USB Bulk transfer to a pipe.  <a href="#a22ec1f739126b098c9537f5e6ab40bb0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-usb_8h.html#aa785521de9f4ae8f76e0731de8dd9123">cvmx_usb_submit_interrupt</a> (<a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *<a class="el" href="cvmx-sysinfo_8c.html#a404e470d9833683c088dfd8e8bcb0f9c">state</a>, int pipe_handle, uint64_t buffer, int buffer_length, <a class="el" href="cvmx-usb_8h.html#ad30ee177ca41ebdc033081f1272d9275">cvmx_usb_callback_func_t</a> callback, void *user_data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to submit a USB Interrupt transfer to a pipe.  <a href="#aa785521de9f4ae8f76e0731de8dd9123"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-usb_8h.html#aa2198035dd5158cd25295e7e06a4bdb0">cvmx_usb_submit_control</a> (<a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *<a class="el" href="cvmx-sysinfo_8c.html#a404e470d9833683c088dfd8e8bcb0f9c">state</a>, int pipe_handle, uint64_t control_header, uint64_t buffer, int buffer_length, <a class="el" href="cvmx-usb_8h.html#ad30ee177ca41ebdc033081f1272d9275">cvmx_usb_callback_func_t</a> callback, void *user_data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to submit a USB Control transfer to a pipe.  <a href="#aa2198035dd5158cd25295e7e06a4bdb0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-usb_8h.html#a81bd48a41477ab51af862910a07ab79b">cvmx_usb_submit_isochronous</a> (<a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *<a class="el" href="cvmx-sysinfo_8c.html#a404e470d9833683c088dfd8e8bcb0f9c">state</a>, int pipe_handle, int start_frame, int flags, int number_packets, <a class="el" href="structcvmx__usb__iso__packet__t.html">cvmx_usb_iso_packet_t</a> packets[], uint64_t buffer, int buffer_length, <a class="el" href="cvmx-usb_8h.html#ad30ee177ca41ebdc033081f1272d9275">cvmx_usb_callback_func_t</a> callback, void *user_data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to submit a USB Isochronous transfer to a pipe.  <a href="#a81bd48a41477ab51af862910a07ab79b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cvmx-usb_8h.html#ab60527516a0c56b1d652b5d54cf69fd2">cvmx_usb_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-usb_8h.html#ad9eda0ae960ae84d2fac691a1d245387">cvmx_usb_cancel</a> (<a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *<a class="el" href="cvmx-sysinfo_8c.html#a404e470d9833683c088dfd8e8bcb0f9c">state</a>, int pipe_handle, int submit_handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel one outstanding request in a pipe.  <a href="#ad9eda0ae960ae84d2fac691a1d245387"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cvmx-usb_8h.html#ab60527516a0c56b1d652b5d54cf69fd2">cvmx_usb_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-usb_8h.html#a2f16c0269c47d805465ac509d07c7fc5">cvmx_usb_cancel_all</a> (<a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *<a class="el" href="cvmx-sysinfo_8c.html#a404e470d9833683c088dfd8e8bcb0f9c">state</a>, int pipe_handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel all outstanding requests in a pipe.  <a href="#a2f16c0269c47d805465ac509d07c7fc5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cvmx-usb_8h.html#ab60527516a0c56b1d652b5d54cf69fd2">cvmx_usb_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-usb_8h.html#aec3a0ceb51369082c024046efd9c6c3a">cvmx_usb_close_pipe</a> (<a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *<a class="el" href="cvmx-sysinfo_8c.html#a404e470d9833683c088dfd8e8bcb0f9c">state</a>, int pipe_handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a pipe created with <a class="el" href="cvmx-usb_8c.html#a95dc31cdca1fb94441b5034e4f463e3b" title="Open a virtual pipe between the host and a USB device.">cvmx_usb_open_pipe()</a>.  <a href="#aec3a0ceb51369082c024046efd9c6c3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cvmx-usb_8h.html#ab60527516a0c56b1d652b5d54cf69fd2">cvmx_usb_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-usb_8h.html#a96316b0ff6a459a5be35a98b9cd57c20">cvmx_usb_register_callback</a> (<a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *<a class="el" href="cvmx-sysinfo_8c.html#a404e470d9833683c088dfd8e8bcb0f9c">state</a>, <a class="el" href="cvmx-usb_8h.html#a7b0db95a0a4705f6a0e461f4d444e8ef">cvmx_usb_callback_t</a> reason, <a class="el" href="cvmx-usb_8h.html#ad30ee177ca41ebdc033081f1272d9275">cvmx_usb_callback_func_t</a> callback, void *user_data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a function to be called when various USB events occur.  <a href="#a96316b0ff6a459a5be35a98b9cd57c20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-usb_8h.html#ac81d7a3b01c0551f47f6316869430439">cvmx_usb_get_frame_number</a> (<a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *<a class="el" href="cvmx-sysinfo_8c.html#a404e470d9833683c088dfd8e8bcb0f9c">state</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current USB protocol level frame number.  <a href="#ac81d7a3b01c0551f47f6316869430439"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cvmx-usb_8h.html#ab60527516a0c56b1d652b5d54cf69fd2">cvmx_usb_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cvmx-usb_8h.html#a252858f707b491bd2c22b16c63a8520a">cvmx_usb_poll</a> (<a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *<a class="el" href="cvmx-sysinfo_8c.html#a404e470d9833683c088dfd8e8bcb0f9c">state</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Poll the USB block for status and call all needed callback handlers.  <a href="#a252858f707b491bd2c22b16c63a8520a"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>"cvmx-usb.h" defines a set of low level USB functions to help developers create Octeon USB drivers for various operating systems. </p>
<p>These functions provide a generic API to the Octeon USB blocks, hiding the internal hardware specific operations.</p>
<p>At a high level the device driver needs to:</p>
<ol type="1">
<li>Call <a class="el" href="cvmx-usb_8c.html#a7008cf45d92d7109dcc590d9dd8f9465" title="Return the number of USB ports supported by this Octeon chip.">cvmx_usb_get_num_ports()</a> to get the number of supported ports.</li>
<li>Call <a class="el" href="cvmx-usb_8c.html#a78c06bd132938304cf32fe2da8b83ab7" title="Initialize a USB port for use.">cvmx_usb_initialize()</a> for each Octeon USB port.</li>
<li>Enable the port using <a class="el" href="cvmx-usb_8c.html#a4fe34faa4328f9017658ffd3d5f74106" title="Enable a USB port.">cvmx_usb_enable()</a>.</li>
<li>Either periodically, or in an interrupt handler, call <a class="el" href="cvmx-usb_8c.html#a252858f707b491bd2c22b16c63a8520a" title="Poll the USB block for status and call all needed callback handlers.">cvmx_usb_poll()</a> to service USB events.</li>
<li>Manage pipes using <a class="el" href="cvmx-usb_8c.html#a95dc31cdca1fb94441b5034e4f463e3b" title="Open a virtual pipe between the host and a USB device.">cvmx_usb_open_pipe()</a> and <a class="el" href="cvmx-usb_8c.html#aec3a0ceb51369082c024046efd9c6c3a" title="Close a pipe created with cvmx_usb_open_pipe().">cvmx_usb_close_pipe()</a>.</li>
<li>Manage transfers using cvmx_usb_submit_*() and cvmx_usb_cancel*().</li>
<li>Shutdown USB on unload using <a class="el" href="cvmx-usb_8c.html#abf0e935e37140c27e4735c054a6018d9" title="Shutdown a USB port after a call to cvmx_usb_initialize().">cvmx_usb_shutdown()</a>.</li>
</ol>
<p>To monitor USB status changes, the device driver must use <a class="el" href="cvmx-usb_8c.html#a96316b0ff6a459a5be35a98b9cd57c20" title="Register a function to be called when various USB events occur.">cvmx_usb_register_callback()</a> to register for events that it is interested in. Below are a few hints on successfully implementing a driver on top of this API.</p>
<h2>Initialization</h2>
<p>When a driver is first loaded, it is normally not necessary to bring up the USB port completely. Most operating systems expect to initialize and enable the port in two independent steps. Normally an operating system will probe hardware, initialize anything found, and then enable the hardware.</p>
<p>In the probe phase you should:</p>
<ol type="1">
<li>Use <a class="el" href="cvmx-usb_8c.html#a7008cf45d92d7109dcc590d9dd8f9465" title="Return the number of USB ports supported by this Octeon chip.">cvmx_usb_get_num_ports()</a> to determine the number of USB port to be supported.</li>
<li>Allocate space for a <a class="el" href="structcvmx__usb__state__t.html" title="USB state internal data.">cvmx_usb_state_t</a> structure for each port.</li>
<li>Tell the operating system about each port</li>
</ol>
<p>In the initialization phase you should:</p>
<ol type="1">
<li>Use <a class="el" href="cvmx-usb_8c.html#a78c06bd132938304cf32fe2da8b83ab7" title="Initialize a USB port for use.">cvmx_usb_initialize()</a> on each port.</li>
<li>Do not call <a class="el" href="cvmx-usb_8c.html#a4fe34faa4328f9017658ffd3d5f74106" title="Enable a USB port.">cvmx_usb_enable()</a>. This leaves the USB port in the disabled state until the operating system is ready.</li>
</ol>
<p>Finally, in the enable phase you should:</p>
<ol type="1">
<li>Call <a class="el" href="cvmx-usb_8c.html#a4fe34faa4328f9017658ffd3d5f74106" title="Enable a USB port.">cvmx_usb_enable()</a> on the appropriate port.</li>
<li>Note that some operating system use a RESET instead of an enable call. To implement RESET, you should call <a class="el" href="cvmx-usb_8c.html#a626627de3b8831b17e1cf094a037371b" title="Disable a USB port.">cvmx_usb_disable()</a> followed by <a class="el" href="cvmx-usb_8c.html#a4fe34faa4328f9017658ffd3d5f74106" title="Enable a USB port.">cvmx_usb_enable()</a>.</li>
</ol>
<h2>Locking</h2>
<p>All of the functions in the cvmx-usb API assume exclusive access to the USB hardware and internal data structures. This means that the driver must provide locking as necessary.</p>
<p>In the single CPU state it is normally enough to disable interrupts before every call to cvmx_usb*() and enable them again after the call is complete. Keep in mind that it is very common for the callback handlers to make additional calls into cvmx-usb, so the disable/enable must be protected against recursion. As an example, the Linux kernel local_irq_save() and local_irq_restore() are perfect for this in the non SMP case.</p>
<p>In the SMP case, locking is more complicated. For SMP you not only need to disable interrupts on the local core, but also take a lock to make sure that another core cannot call cvmx-usb.</p>
<h2>Port callback</h2>
<p>The port callback prototype needs to look as follows:</p>
<p>void port_callback(<a class="el" href="structcvmx__usb__state__t.html" title="USB state internal data.">cvmx_usb_state_t</a> *usb, cvmx_usb_callback_t reason, cvmx_usb_complete_t status, int pipe_handle, int submit_handle, int bytes_transferred, void *user_data);</p>
<ul>
<li><b>usb</b> is the <a class="el" href="structcvmx__usb__state__t.html" title="USB state internal data.">cvmx_usb_state_t</a> for the port.</li>
<li><b>reason</b> will always be CVMX_USB_CALLBACK_PORT_CHANGED.</li>
<li><b>status</b> will always be CVMX_USB_COMPLETE_SUCCESS.</li>
<li><b>pipe_handle</b> will always be -1.</li>
<li><b>submit_handle</b> will always be -1.</li>
<li><b>bytes_transferred</b> will always be 0.</li>
<li><b>user_data</b> is the void pointer originally passed along with the callback. Use this for any state information you need.</li>
</ul>
<p>The port callback will be called whenever the user plugs / unplugs a device from the port. It will not be called when a device is plugged / unplugged from a hub connected to the root port. Normally all the callback needs to do is tell the operating system to poll the root hub for status. Under Linux, this is performed by calling usb_hcd_poll_rh_status(). In the Linux driver we use <b>user_data</b>. to pass around the Linux "hcd" structure. Once the port callback completes, Linux automatically calls octeon_usb_hub_status_data() which uses <a class="el" href="cvmx-usb_8c.html#a9f66ca78263e0e13d78d2e3769dd006e" title="Get the current state of the USB port.">cvmx_usb_get_status()</a> to determine the root port status.</p>
<h2>Complete callback</h2>
<p>The completion callback prototype needs to look as follows:</p>
<p>void complete_callback(<a class="el" href="structcvmx__usb__state__t.html" title="USB state internal data.">cvmx_usb_state_t</a> *usb, cvmx_usb_callback_t reason, cvmx_usb_complete_t status, int pipe_handle, int submit_handle, int bytes_transferred, void *user_data);</p>
<ul>
<li><b>usb</b> is the <a class="el" href="structcvmx__usb__state__t.html" title="USB state internal data.">cvmx_usb_state_t</a> for the port.</li>
<li><b>reason</b> will always be CVMX_USB_CALLBACK_TRANSFER_COMPLETE.</li>
<li><b>status</b> will be one of the cvmx_usb_complete_t enumerations.</li>
<li><b>pipe_handle</b> is the handle to the pipe the transaction was originally submitted on.</li>
<li><b>submit_handle</b> is the handle returned by the original cvmx_usb_submit_* call.</li>
<li><b>bytes_transferred</b> is the number of bytes successfully transferred in the transaction. This will be zero on most error conditions.</li>
<li><b>user_data</b> is the void pointer originally passed along with the callback. Use this for any state information you need. For example, the Linux "urb" is stored in here in the Linux driver.</li>
</ul>
<p>In general your callback handler should use <b>status</b> and <b>bytes_transferred</b> to tell the operating system the how the transaction completed. Normally the pipe is not changed in this callback.</p>
<h2>Canceling transactions</h2>
<p>When a transaction is cancelled using cvmx_usb_cancel*(), the actual length of time until the complete callback is called can vary greatly. It may be called before cvmx_usb_cancel*() returns, or it may be called a number of usb frames in the future once the hardware frees the transaction. In either of these cases, the complete handler will receive CVMX_USB_COMPLETE_CANCEL.</p>
<h2>Handling pipes</h2>
<p>USB "pipes" is a software construct created by this API to enable the ordering of usb transactions to a device endpoint. Octeon's underlying hardware doesn't have any concept equivalent to "pipes". The hardware instead has eight channels that can be used simultaneously to have up to eight transaction in process at the same time. In order to maintain ordering in a pipe, the transactions for a pipe will only be active in one hardware channel at a time. From an API user's perspective, this doesn't matter but it can be helpful to keep this in mind when you are probing hardware while debugging.</p>
<p>Also keep in mind that usb transactions contain state information about the previous transaction to the same endpoint. Each transaction has a PID toggle that changes 0/1 between each sub packet. This is maintained in the pipe data structures. For this reason, you generally cannot create and destroy a pipe for every transaction. A sequence of transaction to the same endpoint must use the same pipe.</p>
<h2>Root Hub</h2>
<p>Some operating systems view the usb root port as a normal usb hub. These systems attempt to control the root hub with messages similar to the usb 2.0 spec for hub control and status. For these systems it may be necessary to write function to decode standard usb control messages into equivalent cvmx-usb API calls. As an example, the following code is used under Linux for some of the basic hub control messages.</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">static</span> <span class="keywordtype">int</span> octeon_usb_hub_control(<span class="keyword">struct</span> usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex, <span class="keywordtype">char</span> *buf, u16 wLength)
 {
     <a class="code" href="structcvmx__usb__state__t.html" title="USB state internal data.">cvmx_usb_state_t</a> *usb = (<a class="code" href="structcvmx__usb__state__t.html" title="USB state internal data.">cvmx_usb_state_t</a> *)hcd-&gt;hcd_priv;
     <a class="code" href="structcvmx__usb__port__status__t.html" title="Structure returned containing the USB port status information.">cvmx_usb_port_status_t</a> usb_port_status;
     <span class="keywordtype">int</span> port_status;
     <span class="keyword">struct</span> usb_hub_descriptor *desc;
     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags;

     switch (typeReq)
     {
         <span class="keywordflow">case</span> ClearHubFeature:
             DEBUG_ROOT_HUB(<span class="stringliteral">&quot;OcteonUSB: ClearHubFeature\n&quot;</span>);
             <span class="keywordflow">switch</span> (wValue)
             {
                 <span class="keywordflow">case</span> <a class="code" href="cvmx-usb-ehci_8c.html#a2c2c67f43ea6c9739e130cb986a5a5fb">C_HUB_LOCAL_POWER</a>:
                 <span class="keywordflow">case</span> <a class="code" href="cvmx-usb-ehci_8c.html#a12e4f6cc9dc90679906f2eacec87553f">C_HUB_OVER_CURRENT</a>:
                     <span class="comment">// Nothing required here</span>
                     <span class="keywordflow">break</span>;
                 <span class="keywordflow">default</span>:
                     <span class="keywordflow">return</span> -EINVAL;
             }
             <span class="keywordflow">break</span>;
         <span class="keywordflow">case</span> ClearPortFeature:
             DEBUG_ROOT_HUB(<span class="stringliteral">&quot;OcteonUSB: ClearPortFeature&quot;</span>);
             <span class="keywordflow">if</span> (wIndex != 1)
             {
                 DEBUG_ROOT_HUB(<span class="stringliteral">&quot; INVALID\n&quot;</span>);
                 <span class="keywordflow">return</span> -EINVAL;
             }

             <span class="keywordflow">switch</span> (wValue)
             {
                 <span class="keywordflow">case</span> <a class="code" href="cvmx-usb-ehci_8c.html#a486596fd0abc94fb03cff19d5745965a">USB_PORT_FEAT_ENABLE</a>:
                     DEBUG_ROOT_HUB(<span class="stringliteral">&quot; ENABLE&quot;</span>);
                     local_irq_save(flags);
                     <a class="code" href="cvmx-usb_8c.html#a626627de3b8831b17e1cf094a037371b" title="Disable a USB port.">cvmx_usb_disable</a>(usb);
                     local_irq_restore(flags);
                     <span class="keywordflow">break</span>;
                 <span class="keywordflow">case</span> <a class="code" href="cvmx-usb-ehci_8c.html#a4d97eef397bf451a0d6134f7433a018b">USB_PORT_FEAT_SUSPEND</a>:
                     DEBUG_ROOT_HUB(<span class="stringliteral">&quot; SUSPEND&quot;</span>);
                     <span class="comment">// Not supported on Octeon</span>
                     <span class="keywordflow">break</span>;
                 <span class="keywordflow">case</span> <a class="code" href="cvmx-usb-ehci_8c.html#ad11d14ddfef8254936971a7c774b8d6a">USB_PORT_FEAT_POWER</a>:
                     DEBUG_ROOT_HUB(<span class="stringliteral">&quot; POWER&quot;</span>);
                     <span class="comment">// Not supported on Octeon</span>
                     <span class="keywordflow">break</span>;
                 <span class="keywordflow">case</span> USB_PORT_FEAT_INDICATOR:
                     DEBUG_ROOT_HUB(<span class="stringliteral">&quot; INDICATOR&quot;</span>);
                     <span class="comment">// Port inidicator not supported</span>
                     <span class="keywordflow">break</span>;
                 <span class="keywordflow">case</span> <a class="code" href="cvmx-usb-ehci_8c.html#a25d4fd2bedd60262756efe37b3ce076b">USB_PORT_FEAT_C_CONNECTION</a>:
                     DEBUG_ROOT_HUB(<span class="stringliteral">&quot; C_CONNECTION&quot;</span>);
                     <span class="comment">// Clears drivers internal connect status change flag</span>
                     <a class="code" href="cvmx-usb_8c.html#a07642545f5c4dc7996ab884359f51fde" title="Set the current state of the USB port.">cvmx_usb_set_status</a>(usb, <a class="code" href="cvmx-usb_8c.html#a9f66ca78263e0e13d78d2e3769dd006e" title="Get the current state of the USB port.">cvmx_usb_get_status</a>(usb));
                     <span class="keywordflow">break</span>;
                 <span class="keywordflow">case</span> <a class="code" href="cvmx-usb-ehci_8c.html#a99090be5ee961f27233b3c0524b0082c">USB_PORT_FEAT_C_RESET</a>:
                     DEBUG_ROOT_HUB(<span class="stringliteral">&quot; C_RESET&quot;</span>);
                     <span class="comment">// Clears the driver&apos;s internal Port Reset Change flag</span>
                     <a class="code" href="cvmx-usb_8c.html#a07642545f5c4dc7996ab884359f51fde" title="Set the current state of the USB port.">cvmx_usb_set_status</a>(usb, <a class="code" href="cvmx-usb_8c.html#a9f66ca78263e0e13d78d2e3769dd006e" title="Get the current state of the USB port.">cvmx_usb_get_status</a>(usb));
                     <span class="keywordflow">break</span>;
                 <span class="keywordflow">case</span> <a class="code" href="cvmx-usb-ehci_8c.html#a88b5814cba7c6e3bcc162750dd4d2b58">USB_PORT_FEAT_C_ENABLE</a>:
                     DEBUG_ROOT_HUB(<span class="stringliteral">&quot; C_ENABLE&quot;</span>);
                     <span class="comment">// Clears the driver&apos;s internal Port Enable/Disable Change flag</span>
                     <a class="code" href="cvmx-usb_8c.html#a07642545f5c4dc7996ab884359f51fde" title="Set the current state of the USB port.">cvmx_usb_set_status</a>(usb, <a class="code" href="cvmx-usb_8c.html#a9f66ca78263e0e13d78d2e3769dd006e" title="Get the current state of the USB port.">cvmx_usb_get_status</a>(usb));
                     <span class="keywordflow">break</span>;
                 <span class="keywordflow">case</span> <a class="code" href="cvmx-usb-ehci_8c.html#aaf182a49ed4df57752e72bb014771a39">USB_PORT_FEAT_C_SUSPEND</a>:
                     DEBUG_ROOT_HUB(<span class="stringliteral">&quot; C_SUSPEND&quot;</span>);
                     <span class="comment">// Clears the driver&apos;s internal Port Suspend Change flag,</span>
                         which is <span class="keyword">set</span> when resume signaling on the host port is
                         complete
                     <span class="keywordflow">break</span>;
                 <span class="keywordflow">case</span> <a class="code" href="cvmx-usb-ehci_8c.html#a7f145365ab70f0b83326ac4c6d3844a9">USB_PORT_FEAT_C_OVER_CURRENT</a>:
                     DEBUG_ROOT_HUB(<span class="stringliteral">&quot; C_OVER_CURRENT&quot;</span>);
                     <span class="comment">// Clears the driver&apos;s overcurrent Change flag</span>
                     <a class="code" href="cvmx-usb_8c.html#a07642545f5c4dc7996ab884359f51fde" title="Set the current state of the USB port.">cvmx_usb_set_status</a>(usb, <a class="code" href="cvmx-usb_8c.html#a9f66ca78263e0e13d78d2e3769dd006e" title="Get the current state of the USB port.">cvmx_usb_get_status</a>(usb));
                     <span class="keywordflow">break</span>;
                 <span class="keywordflow">default</span>:
                     DEBUG_ROOT_HUB(<span class="stringliteral">&quot; UNKNOWN\n&quot;</span>);
                     <span class="keywordflow">return</span> -EINVAL;
             }
             DEBUG_ROOT_HUB(<span class="stringliteral">&quot;\n&quot;</span>);
             <span class="keywordflow">break</span>;
         <span class="keywordflow">case</span> GetHubDescriptor:
             DEBUG_ROOT_HUB(<span class="stringliteral">&quot;OcteonUSB: GetHubDescriptor\n&quot;</span>);
             desc = (<span class="keyword">struct </span>usb_hub_descriptor *)buf;
             desc-&gt;bDescLength = 9;
             desc-&gt;bDescriptorType = 0x29;
             desc-&gt;bNbrPorts = 1;
             desc-&gt;wHubCharacteristics = 0x08;
             desc-&gt;bPwrOn2PwrGood = 1;
             desc-&gt;bHubContrCurrent = 0;
             desc-&gt;bitmap[0] = 0;
             desc-&gt;bitmap[1] = 0xff;
             <span class="keywordflow">break</span>;
         <span class="keywordflow">case</span> GetHubStatus:
             DEBUG_ROOT_HUB(<span class="stringliteral">&quot;OcteonUSB: GetHubStatus\n&quot;</span>);
             *(__le32 *)buf = 0;
             <span class="keywordflow">break</span>;
         <span class="keywordflow">case</span> GetPortStatus:
             DEBUG_ROOT_HUB(<span class="stringliteral">&quot;OcteonUSB: GetPortStatus&quot;</span>);
             <span class="keywordflow">if</span> (wIndex != 1)
             {
                 DEBUG_ROOT_HUB(<span class="stringliteral">&quot; INVALID\n&quot;</span>);
                 <span class="keywordflow">return</span> -EINVAL;
             }

             usb_port_status = <a class="code" href="cvmx-usb_8c.html#a9f66ca78263e0e13d78d2e3769dd006e" title="Get the current state of the USB port.">cvmx_usb_get_status</a>(usb);
             port_status = 0;

             <span class="keywordflow">if</span> (usb_port_status.connect_change)
             {
                 port_status |= (1 &lt;&lt; <a class="code" href="cvmx-usb-ehci_8c.html#a25d4fd2bedd60262756efe37b3ce076b">USB_PORT_FEAT_C_CONNECTION</a>);
                 DEBUG_ROOT_HUB(<span class="stringliteral">&quot; C_CONNECTION&quot;</span>);
             }

             <span class="keywordflow">if</span> (usb_port_status.port_enabled)
             {
                 port_status |= (1 &lt;&lt; <a class="code" href="cvmx-usb-ehci_8c.html#a88b5814cba7c6e3bcc162750dd4d2b58">USB_PORT_FEAT_C_ENABLE</a>);
                 DEBUG_ROOT_HUB(<span class="stringliteral">&quot; C_ENABLE&quot;</span>);
             }

             <span class="keywordflow">if</span> (usb_port_status.connected)
             {
                 port_status |= (1 &lt;&lt; <a class="code" href="cvmx-usb-ehci_8c.html#a8c7b273d0b58521653e31319bc054559">USB_PORT_FEAT_CONNECTION</a>);
                 DEBUG_ROOT_HUB(<span class="stringliteral">&quot; CONNECTION&quot;</span>);
             }

             <span class="keywordflow">if</span> (usb_port_status.port_enabled)
             {
                 port_status |= (1 &lt;&lt; <a class="code" href="cvmx-usb-ehci_8c.html#a486596fd0abc94fb03cff19d5745965a">USB_PORT_FEAT_ENABLE</a>);
                 DEBUG_ROOT_HUB(<span class="stringliteral">&quot; ENABLE&quot;</span>);
             }

             <span class="keywordflow">if</span> (usb_port_status.port_over_current)
             {
                 port_status |= (1 &lt;&lt; <a class="code" href="cvmx-usb-ehci_8c.html#a8cf4514ff584478f06b2c722b8bb597d">USB_PORT_FEAT_OVER_CURRENT</a>);
                 DEBUG_ROOT_HUB(<span class="stringliteral">&quot; OVER_CURRENT&quot;</span>);
             }

             <span class="keywordflow">if</span> (usb_port_status.port_powered)
             {
                 port_status |= (1 &lt;&lt; <a class="code" href="cvmx-usb-ehci_8c.html#ad11d14ddfef8254936971a7c774b8d6a">USB_PORT_FEAT_POWER</a>);
                 DEBUG_ROOT_HUB(<span class="stringliteral">&quot; POWER&quot;</span>);
             }

             <span class="keywordflow">if</span> (usb_port_status.port_speed == <a class="code" href="cvmx-usb_8h.html#abeafd428d2f4b4bb5086616d60a9e333a0c91d0d12d74beb26279b468f2e5da67" title="Device is operation at 480Mbps.">CVMX_USB_SPEED_HIGH</a>)
             {
                 port_status |= (1 &lt;&lt; <a class="code" href="cvmx-usb-ehci_8c.html#ad72b5e05e00bf362c79740fcb5914137">USB_PORT_FEAT_HIGHSPEED</a>);
                 DEBUG_ROOT_HUB(<span class="stringliteral">&quot; HIGHSPEED&quot;</span>);
             }
             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (usb_port_status.port_speed == <a class="code" href="cvmx-usb_8h.html#abeafd428d2f4b4bb5086616d60a9e333aaaecc4eed72310f15fbd56830f0aa487" title="Device is operation at 1.5Mbps.">CVMX_USB_SPEED_LOW</a>)
             {
                 port_status |= (1 &lt;&lt; <a class="code" href="cvmx-usb-ehci_8c.html#a688ed0343d6176b5625e3139fc8b0771">USB_PORT_FEAT_LOWSPEED</a>);
                 DEBUG_ROOT_HUB(<span class="stringliteral">&quot; LOWSPEED&quot;</span>);
             }

             *((__le32 *)buf) = <a class="code" href="cvmx-usb-ehci_8c.html#a1d5ae0c36d519a1b0a789db69a598f28">cpu_to_le32</a>(port_status);
             DEBUG_ROOT_HUB(<span class="stringliteral">&quot;\n&quot;</span>);
             <span class="keywordflow">break</span>;
         <span class="keywordflow">case</span> SetHubFeature:
             DEBUG_ROOT_HUB(<span class="stringliteral">&quot;OcteonUSB: SetHubFeature\n&quot;</span>);
             <span class="comment">// No HUB features supported</span>
             <span class="keywordflow">break</span>;
         <span class="keywordflow">case</span> SetPortFeature:
             DEBUG_ROOT_HUB(<span class="stringliteral">&quot;OcteonUSB: SetPortFeature&quot;</span>);
             <span class="keywordflow">if</span> (wIndex != 1)
             {
                 DEBUG_ROOT_HUB(<span class="stringliteral">&quot; INVALID\n&quot;</span>);
                 <span class="keywordflow">return</span> -EINVAL;
             }

             <span class="keywordflow">switch</span> (wValue)
             {
                 <span class="keywordflow">case</span> <a class="code" href="cvmx-usb-ehci_8c.html#a4d97eef397bf451a0d6134f7433a018b">USB_PORT_FEAT_SUSPEND</a>:
                     DEBUG_ROOT_HUB(<span class="stringliteral">&quot; SUSPEND\n&quot;</span>);
                     <span class="keywordflow">return</span> -EINVAL;
                 <span class="keywordflow">case</span> <a class="code" href="cvmx-usb-ehci_8c.html#ad11d14ddfef8254936971a7c774b8d6a">USB_PORT_FEAT_POWER</a>:
                     DEBUG_ROOT_HUB(<span class="stringliteral">&quot; POWER\n&quot;</span>);
                     <span class="keywordflow">return</span> -EINVAL;
                 <span class="keywordflow">case</span> <a class="code" href="cvmx-usb-ehci_8c.html#a3250c8ebf83a2f1e4fe0b275febc82a7">USB_PORT_FEAT_RESET</a>:
                     DEBUG_ROOT_HUB(<span class="stringliteral">&quot; RESET\n&quot;</span>);
                     local_irq_save(flags);
                     <a class="code" href="cvmx-usb_8c.html#a626627de3b8831b17e1cf094a037371b" title="Disable a USB port.">cvmx_usb_disable</a>(usb);
                     <span class="keywordflow">if</span> (<a class="code" href="cvmx-usb_8c.html#a4fe34faa4328f9017658ffd3d5f74106" title="Enable a USB port.">cvmx_usb_enable</a>(usb))
                         DEBUG_ERROR(<span class="stringliteral">&quot;Failed to enable the port\n&quot;</span>);
                     local_irq_restore(flags);
                     <span class="keywordflow">return</span> 0;
                 <span class="keywordflow">case</span> USB_PORT_FEAT_INDICATOR:
                     DEBUG_ROOT_HUB(<span class="stringliteral">&quot; INDICATOR\n&quot;</span>);
                     <span class="comment">// Not supported</span>
                     <span class="keywordflow">break</span>;
                 <span class="keywordflow">default</span>:
                     DEBUG_ROOT_HUB(<span class="stringliteral">&quot; UNKNOWN\n&quot;</span>);
                     <span class="keywordflow">return</span> -EINVAL;
             }
             <span class="keywordflow">break</span>;
         <span class="keywordflow">default</span>:
             DEBUG_ROOT_HUB(<span class="stringliteral">&quot;OcteonUSB: Unknown root hub request\n&quot;</span>);
             <span class="keywordflow">return</span> -EINVAL;
     }
     <span class="keywordflow">return</span> 0;
 }
</pre></div><h2>Interrupts</h2>
<p>If you plan on using usb interrupts, <a class="el" href="cvmx-usb_8c.html#a252858f707b491bd2c22b16c63a8520a" title="Poll the USB block for status and call all needed callback handlers.">cvmx_usb_poll()</a> must be called on every usb interrupt. It will read the usb state, call any needed callbacks, and schedule transactions as needed. Your device driver needs only to hookup an interrupt handler and call <a class="el" href="cvmx-usb_8c.html#a252858f707b491bd2c22b16c63a8520a" title="Poll the USB block for status and call all needed callback handlers.">cvmx_usb_poll()</a>. Octeon's usb port 0 causes CIU bit CIU_INT*_SUM0[USB] to be set (bit 56). For port 1, CIU bit CIU_INT_SUM1[USB1] is set (bit 17). How these bits are turned into interrupt numbers is operating system specific. For Linux, there are the convenient defines OCTEON_IRQ_USB0 and OCTEON_IRQ_USB1 for the IRQ numbers.</p>
<p>If you aren't using interrupts, simple call <a class="el" href="cvmx-usb_8c.html#a252858f707b491bd2c22b16c63a8520a" title="Poll the USB block for status and call all needed callback handlers.">cvmx_usb_poll()</a> in your main processing loop.</p>
<hr/>
<dl class="rcs"><dt><b>Revision</b></dt><dd>32636 </dd></dl>
<hr/>
 <hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ad30ee177ca41ebdc033081f1272d9275"></a><!-- doxytag: member="cvmx&#45;usb.h::cvmx_usb_callback_func_t" ref="ad30ee177ca41ebdc033081f1272d9275" args=")(cvmx_usb_state_t *state, cvmx_usb_callback_t reason, cvmx_usb_complete_t status, int pipe_handle, int submit_handle, int bytes_transferred, void *user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="cvmx-usb_8h.html#ad30ee177ca41ebdc033081f1272d9275">cvmx_usb_callback_func_t</a>)(<a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *<a class="el" href="cvmx-sysinfo_8c.html#a404e470d9833683c088dfd8e8bcb0f9c">state</a>, <a class="el" href="cvmx-usb_8h.html#a7b0db95a0a4705f6a0e461f4d444e8ef">cvmx_usb_callback_t</a> reason, <a class="el" href="cvmx-usb_8h.html#a4aa70fd8c4db3e30b1acd83b7b392c1e">cvmx_usb_complete_t</a> status, int pipe_handle, int submit_handle, int bytes_transferred, void *user_data)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>USB callback functions are always of the following type. </p>
<p>The parameters are as follows:</p>
<ul>
<li>state = USB device state populated by <a class="el" href="cvmx-usb_8c.html#a78c06bd132938304cf32fe2da8b83ab7" title="Initialize a USB port for use.">cvmx_usb_initialize()</a>.</li>
<li>reason = The cvmx_usb_callback_t used to register the callback.</li>
<li>status = The cvmx_usb_complete_t representing the status code of a transaction.</li>
<li>pipe_handle = The Pipe that caused this callback, or -1 if this callback wasn't associated with a pipe.</li>
<li>submit_handle = Transfer submit handle causing this callback, or -1 if this callback wasn't associated with a transfer.</li>
<li>Actual number of bytes transfer.</li>
<li>user_data = The user pointer supplied to the function cvmx_usb_submit() or <a class="el" href="cvmx-usb_8c.html#a96316b0ff6a459a5be35a98b9cd57c20" title="Register a function to be called when various USB events occur.">cvmx_usb_register_callback()</a> </li>
</ul>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a7b0db95a0a4705f6a0e461f4d444e8ef"></a><!-- doxytag: member="cvmx&#45;usb.h::cvmx_usb_callback_t" ref="a7b0db95a0a4705f6a0e461f4d444e8ef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cvmx-usb_8h.html#a7b0db95a0a4705f6a0e461f4d444e8ef">cvmx_usb_callback_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Possible callback reasons for the USB API. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a7b0db95a0a4705f6a0e461f4d444e8efafbac148b7e8ca56982e2bda93ffb3ed7"></a><!-- doxytag: member="CVMX_USB_CALLBACK_TRANSFER_COMPLETE" ref="a7b0db95a0a4705f6a0e461f4d444e8efafbac148b7e8ca56982e2bda93ffb3ed7" args="" -->CVMX_USB_CALLBACK_TRANSFER_COMPLETE</em>&nbsp;</td><td>
<p>A callback of this type is called when a submitted transfer completes. </p>
<p>The completion callback will be called even if the transfer fails or is canceled. The status parameter will contain details of why he callback was called. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a7b0db95a0a4705f6a0e461f4d444e8efa672c13998130ff0a1f81a61674abb3e0"></a><!-- doxytag: member="CVMX_USB_CALLBACK_PORT_CHANGED" ref="a7b0db95a0a4705f6a0e461f4d444e8efa672c13998130ff0a1f81a61674abb3e0" args="" -->CVMX_USB_CALLBACK_PORT_CHANGED</em>&nbsp;</td><td>
<p>The status of the port changed. </p>
<p>For example, someone may have plugged a device in. The status parameter contains CVMX_USB_COMPLETE_SUCCESS. Use <a class="el" href="cvmx-usb_8c.html#a9f66ca78263e0e13d78d2e3769dd006e" title="Get the current state of the USB port.">cvmx_usb_get_status()</a> to get the new port status. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a7b0db95a0a4705f6a0e461f4d444e8efa50d243f089938f849ea7880b4ce2b8fe"></a><!-- doxytag: member="__CVMX_USB_CALLBACK_END" ref="a7b0db95a0a4705f6a0e461f4d444e8efa50d243f089938f849ea7880b4ce2b8fe" args="" -->__CVMX_USB_CALLBACK_END</em>&nbsp;</td><td>
<p>Do not use. </p>
<p>Used internally for array bounds </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a4aa70fd8c4db3e30b1acd83b7b392c1e"></a><!-- doxytag: member="cvmx&#45;usb.h::cvmx_usb_complete_t" ref="a4aa70fd8c4db3e30b1acd83b7b392c1e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cvmx-usb_8h.html#a4aa70fd8c4db3e30b1acd83b7b392c1e">cvmx_usb_complete_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enumeration of all possible status codes passed to callback functions. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a4aa70fd8c4db3e30b1acd83b7b392c1ea5f9ed359b102d561eac662da90e71863"></a><!-- doxytag: member="CVMX_USB_COMPLETE_SUCCESS" ref="a4aa70fd8c4db3e30b1acd83b7b392c1ea5f9ed359b102d561eac662da90e71863" args="" -->CVMX_USB_COMPLETE_SUCCESS</em>&nbsp;</td><td>
<p>The transaction / operation finished without any errors. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4aa70fd8c4db3e30b1acd83b7b392c1eae22919c4301825af0e97f754a484b15a"></a><!-- doxytag: member="CVMX_USB_COMPLETE_SHORT" ref="a4aa70fd8c4db3e30b1acd83b7b392c1eae22919c4301825af0e97f754a484b15a" args="" -->CVMX_USB_COMPLETE_SHORT</em>&nbsp;</td><td>
<p>This is currently not implemented. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4aa70fd8c4db3e30b1acd83b7b392c1ea80e173712d034e26a87ba312ba2b558f"></a><!-- doxytag: member="CVMX_USB_COMPLETE_CANCEL" ref="a4aa70fd8c4db3e30b1acd83b7b392c1ea80e173712d034e26a87ba312ba2b558f" args="" -->CVMX_USB_COMPLETE_CANCEL</em>&nbsp;</td><td>
<p>The transaction was canceled while in flight by a user call to cvmx_usb_cancel*. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4aa70fd8c4db3e30b1acd83b7b392c1ea689c7a40d9a92db955903e29a666b94e"></a><!-- doxytag: member="CVMX_USB_COMPLETE_ERROR" ref="a4aa70fd8c4db3e30b1acd83b7b392c1ea689c7a40d9a92db955903e29a666b94e" args="" -->CVMX_USB_COMPLETE_ERROR</em>&nbsp;</td><td>
<p>The transaction aborted with an unexpected error status. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4aa70fd8c4db3e30b1acd83b7b392c1ea2c71959c0d16338a9e3b333ef1a1e15b"></a><!-- doxytag: member="CVMX_USB_COMPLETE_STALL" ref="a4aa70fd8c4db3e30b1acd83b7b392c1ea2c71959c0d16338a9e3b333ef1a1e15b" args="" -->CVMX_USB_COMPLETE_STALL</em>&nbsp;</td><td>
<p>The transaction received a USB STALL response from the device. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4aa70fd8c4db3e30b1acd83b7b392c1ea05aaa2c7548b3c244b24896eebe83625"></a><!-- doxytag: member="CVMX_USB_COMPLETE_XACTERR" ref="a4aa70fd8c4db3e30b1acd83b7b392c1ea05aaa2c7548b3c244b24896eebe83625" args="" -->CVMX_USB_COMPLETE_XACTERR</em>&nbsp;</td><td>
<p>The transaction failed with an error from the device even after a number of retries. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4aa70fd8c4db3e30b1acd83b7b392c1eaabf061c7f86d14aab1d4d43addb242c9"></a><!-- doxytag: member="CVMX_USB_COMPLETE_DATATGLERR" ref="a4aa70fd8c4db3e30b1acd83b7b392c1eaabf061c7f86d14aab1d4d43addb242c9" args="" -->CVMX_USB_COMPLETE_DATATGLERR</em>&nbsp;</td><td>
<p>The transaction failed with a data toggle error even after a number of retries. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4aa70fd8c4db3e30b1acd83b7b392c1ea897bb1bac1971352dd45f648c1dc4355"></a><!-- doxytag: member="CVMX_USB_COMPLETE_BABBLEERR" ref="a4aa70fd8c4db3e30b1acd83b7b392c1ea897bb1bac1971352dd45f648c1dc4355" args="" -->CVMX_USB_COMPLETE_BABBLEERR</em>&nbsp;</td><td>
<p>The transaction failed with a babble error. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4aa70fd8c4db3e30b1acd83b7b392c1ea136e9921060f2071a47d644aac6861c9"></a><!-- doxytag: member="CVMX_USB_COMPLETE_FRAMEERR" ref="a4aa70fd8c4db3e30b1acd83b7b392c1ea136e9921060f2071a47d644aac6861c9" args="" -->CVMX_USB_COMPLETE_FRAMEERR</em>&nbsp;</td><td>
<p>The transaction failed with a frame error even after a number of retries. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f7eb40ade782b803c123c709a621598"></a><!-- doxytag: member="cvmx&#45;usb.h::cvmx_usb_direction_t" ref="a6f7eb40ade782b803c123c709a621598" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cvmx-usb_8h.html#a6f7eb40ade782b803c123c709a621598">cvmx_usb_direction_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enumeration of the transfer directions. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a6f7eb40ade782b803c123c709a621598a7d55e544b9e964815d3fa2202fe00825"></a><!-- doxytag: member="CVMX_USB_DIRECTION_OUT" ref="a6f7eb40ade782b803c123c709a621598a7d55e544b9e964815d3fa2202fe00825" args="" -->CVMX_USB_DIRECTION_OUT</em>&nbsp;</td><td>
<p>Data is transferring from Octeon to the device/host. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6f7eb40ade782b803c123c709a621598a35d48981f008e13badec6e0706aaace4"></a><!-- doxytag: member="CVMX_USB_DIRECTION_IN" ref="a6f7eb40ade782b803c123c709a621598a35d48981f008e13badec6e0706aaace4" args="" -->CVMX_USB_DIRECTION_IN</em>&nbsp;</td><td>
<p>Data is transferring from the device/host to Octeon. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="acee50b5094efcc69cd029887557a57d3"></a><!-- doxytag: member="cvmx&#45;usb.h::cvmx_usb_initialize_flags_t" ref="acee50b5094efcc69cd029887557a57d3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cvmx-usb_8h.html#acee50b5094efcc69cd029887557a57d3">cvmx_usb_initialize_flags_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flags to pass the initialization function. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="acee50b5094efcc69cd029887557a57d3ae783cd47af23a46d71b025767c6b4d04"></a><!-- doxytag: member="CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_XI" ref="acee50b5094efcc69cd029887557a57d3ae783cd47af23a46d71b025767c6b4d04" args="" -->CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_XI</em>&nbsp;</td><td>
<p>The USB port uses a 12MHz crystal as clock source at USB_XO and USB_XI. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acee50b5094efcc69cd029887557a57d3acd0007a7d52e28e3db4adbf129d1a79e"></a><!-- doxytag: member="CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND" ref="acee50b5094efcc69cd029887557a57d3acd0007a7d52e28e3db4adbf129d1a79e" args="" -->CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND</em>&nbsp;</td><td>
<p>The USB port uses 12/24/48MHz 2.5V board clock source at USB_XO. </p>
<p>USB_XI should be tied to GND. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acee50b5094efcc69cd029887557a57d3a0ae1e1f588d5295862fd59d1221e55f9"></a><!-- doxytag: member="CVMX_USB_INITIALIZE_FLAGS_CLOCK_AUTO" ref="acee50b5094efcc69cd029887557a57d3a0ae1e1f588d5295862fd59d1221e55f9" args="" -->CVMX_USB_INITIALIZE_FLAGS_CLOCK_AUTO</em>&nbsp;</td><td>
<p>Automatically determine clock type based on function in <a class="el" href="cvmx-helper-board_8c.html" title="Helper functions to abstract board specific data about network ports from the rest...">cvmx-helper-board.c</a>. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acee50b5094efcc69cd029887557a57d3ad173a6564727c118d38054953ea667de"></a><!-- doxytag: member="CVMX_USB_INITIALIZE_FLAGS_CLOCK_MHZ_MASK" ref="acee50b5094efcc69cd029887557a57d3ad173a6564727c118d38054953ea667de" args="" -->CVMX_USB_INITIALIZE_FLAGS_CLOCK_MHZ_MASK</em>&nbsp;</td><td>
<p>Mask for clock speed field. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acee50b5094efcc69cd029887557a57d3ae3b556a77fb4d9b77d9b06365aa00948"></a><!-- doxytag: member="CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ" ref="acee50b5094efcc69cd029887557a57d3ae3b556a77fb4d9b77d9b06365aa00948" args="" -->CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ</em>&nbsp;</td><td>
<p>Speed of reference clock or crystal. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acee50b5094efcc69cd029887557a57d3af731a70cd7b8f2280a2228d054061e96"></a><!-- doxytag: member="CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ" ref="acee50b5094efcc69cd029887557a57d3af731a70cd7b8f2280a2228d054061e96" args="" -->CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ</em>&nbsp;</td><td>
<p>Speed of reference clock. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acee50b5094efcc69cd029887557a57d3a39a8e172e558d1aa832921f11ce55be3"></a><!-- doxytag: member="CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ" ref="acee50b5094efcc69cd029887557a57d3a39a8e172e558d1aa832921f11ce55be3" args="" -->CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ</em>&nbsp;</td><td>
<p>Speed of reference clock. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acee50b5094efcc69cd029887557a57d3a4cfbfb5f3e28fa2f8347a52b33923b7e"></a><!-- doxytag: member="CVMX_USB_INITIALIZE_FLAGS_NO_DMA" ref="acee50b5094efcc69cd029887557a57d3a4cfbfb5f3e28fa2f8347a52b33923b7e" args="" -->CVMX_USB_INITIALIZE_FLAGS_NO_DMA</em>&nbsp;</td><td>
<p>Disable DMA and used polled IO for data transfer use for the USB. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acee50b5094efcc69cd029887557a57d3ae1cf3ca026383ad871d477cd57c8e2f1"></a><!-- doxytag: member="CVMX_USB_INITIALIZE_FLAGS_DEBUG_TRANSFERS" ref="acee50b5094efcc69cd029887557a57d3ae1cf3ca026383ad871d477cd57c8e2f1" args="" -->CVMX_USB_INITIALIZE_FLAGS_DEBUG_TRANSFERS</em>&nbsp;</td><td>
<p>Enable extra console output for debugging USB transfers. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acee50b5094efcc69cd029887557a57d3a804974934009aa4cf82f739b8724c236"></a><!-- doxytag: member="CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLBACKS" ref="acee50b5094efcc69cd029887557a57d3a804974934009aa4cf82f739b8724c236" args="" -->CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLBACKS</em>&nbsp;</td><td>
<p>Enable extra console output for debugging USB callbacks. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acee50b5094efcc69cd029887557a57d3a04c23da15244ed8937a0a3c15a586e2d"></a><!-- doxytag: member="CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO" ref="acee50b5094efcc69cd029887557a57d3a04c23da15244ed8937a0a3c15a586e2d" args="" -->CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO</em>&nbsp;</td><td>
<p>Enable extra console output for USB informational data. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acee50b5094efcc69cd029887557a57d3a0c135b4b3635cc509649fe11929ad560"></a><!-- doxytag: member="CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLS" ref="acee50b5094efcc69cd029887557a57d3a0c135b4b3635cc509649fe11929ad560" args="" -->CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLS</em>&nbsp;</td><td>
<p>Enable extra console output for every function call. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acee50b5094efcc69cd029887557a57d3ae71c5d9597e35bc34093f26d232e2fa8"></a><!-- doxytag: member="CVMX_USB_INITIALIZE_FLAGS_DEBUG_CSRS" ref="acee50b5094efcc69cd029887557a57d3ae71c5d9597e35bc34093f26d232e2fa8" args="" -->CVMX_USB_INITIALIZE_FLAGS_DEBUG_CSRS</em>&nbsp;</td><td>
<p>Enable extra console output for every CSR access. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acee50b5094efcc69cd029887557a57d3acec4a67c9c7c51666a11a904b50454e6"></a><!-- doxytag: member="CVMX_USB_INITIALIZE_FLAGS_DEBUG_ALL" ref="acee50b5094efcc69cd029887557a57d3acec4a67c9c7c51666a11a904b50454e6" args="" -->CVMX_USB_INITIALIZE_FLAGS_DEBUG_ALL</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a549f6679e069a7acbc5d5d45bd7cbaf0"></a><!-- doxytag: member="cvmx&#45;usb.h::cvmx_usb_isochronous_flags_t" ref="a549f6679e069a7acbc5d5d45bd7cbaf0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cvmx-usb_8h.html#a549f6679e069a7acbc5d5d45bd7cbaf0">cvmx_usb_isochronous_flags_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flags to pass the <a class="el" href="cvmx-usb_8c.html#a81bd48a41477ab51af862910a07ab79b" title="Call to submit a USB Isochronous transfer to a pipe.">cvmx_usb_submit_isochronous()</a> function. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a549f6679e069a7acbc5d5d45bd7cbaf0a4e71c1bbf28c38662db0a6914b5f1729"></a><!-- doxytag: member="CVMX_USB_ISOCHRONOUS_FLAGS_ALLOW_SHORT" ref="a549f6679e069a7acbc5d5d45bd7cbaf0a4e71c1bbf28c38662db0a6914b5f1729" args="" -->CVMX_USB_ISOCHRONOUS_FLAGS_ALLOW_SHORT</em>&nbsp;</td><td>
<p>Do not return an error if a transfer is less than the maximum packet size of the device. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a549f6679e069a7acbc5d5d45bd7cbaf0a8c8fed1a115e312afe33644a3f5eeb3d"></a><!-- doxytag: member="CVMX_USB_ISOCHRONOUS_FLAGS_ASAP" ref="a549f6679e069a7acbc5d5d45bd7cbaf0a8c8fed1a115e312afe33644a3f5eeb3d" args="" -->CVMX_USB_ISOCHRONOUS_FLAGS_ASAP</em>&nbsp;</td><td>
<p>Schedule the transaction as soon as possible. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a5c424fc7632d3509a53199c6ae323474"></a><!-- doxytag: member="cvmx&#45;usb.h::cvmx_usb_pipe_flags_t" ref="a5c424fc7632d3509a53199c6ae323474" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cvmx-usb_8h.html#a5c424fc7632d3509a53199c6ae323474">cvmx_usb_pipe_flags_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flags for passing when a pipe is created. </p>
<p>Currently no flags need to be passed. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a5c424fc7632d3509a53199c6ae323474ae0cb9f98b9123faa648f679794bde0f7"></a><!-- doxytag: member="CVMX_USB_PIPE_FLAGS_DEBUG_TRANSFERS" ref="a5c424fc7632d3509a53199c6ae323474ae0cb9f98b9123faa648f679794bde0f7" args="" -->CVMX_USB_PIPE_FLAGS_DEBUG_TRANSFERS</em>&nbsp;</td><td>
<p>Used to display CVMX_USB_INITIALIZE_FLAGS_DEBUG_TRANSFERS for a specific pipe only. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5c424fc7632d3509a53199c6ae323474a6ae8abc80bf16a17f15896c6d3377bb2"></a><!-- doxytag: member="__CVMX_USB_PIPE_FLAGS_OPEN" ref="a5c424fc7632d3509a53199c6ae323474a6ae8abc80bf16a17f15896c6d3377bb2" args="" -->__CVMX_USB_PIPE_FLAGS_OPEN</em>&nbsp;</td><td>
<p>Used internally to determine if a pipe is open. </p>
<p>Do not use </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5c424fc7632d3509a53199c6ae323474a44d9d49b75f5f73184a8be872802b18f"></a><!-- doxytag: member="__CVMX_USB_PIPE_FLAGS_SCHEDULED" ref="a5c424fc7632d3509a53199c6ae323474a44d9d49b75f5f73184a8be872802b18f" args="" -->__CVMX_USB_PIPE_FLAGS_SCHEDULED</em>&nbsp;</td><td>
<p>Used internally to determine if a pipe is actively using hardware. </p>
<p>Do not use </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5c424fc7632d3509a53199c6ae323474acc4001a61e4de91c18016dceec389e2b"></a><!-- doxytag: member="__CVMX_USB_PIPE_FLAGS_NEED_PING" ref="a5c424fc7632d3509a53199c6ae323474acc4001a61e4de91c18016dceec389e2b" args="" -->__CVMX_USB_PIPE_FLAGS_NEED_PING</em>&nbsp;</td><td>
<p>Used internally to determine if a high speed pipe is in the ping state. </p>
<p>Do not use </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="abeafd428d2f4b4bb5086616d60a9e333"></a><!-- doxytag: member="cvmx&#45;usb.h::cvmx_usb_speed_t" ref="abeafd428d2f4b4bb5086616d60a9e333" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cvmx-usb_8h.html#abeafd428d2f4b4bb5086616d60a9e333">cvmx_usb_speed_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enumerations representing the possible USB device speeds. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="abeafd428d2f4b4bb5086616d60a9e333a0c91d0d12d74beb26279b468f2e5da67"></a><!-- doxytag: member="CVMX_USB_SPEED_HIGH" ref="abeafd428d2f4b4bb5086616d60a9e333a0c91d0d12d74beb26279b468f2e5da67" args="" -->CVMX_USB_SPEED_HIGH</em>&nbsp;</td><td>
<p>Device is operation at 480Mbps. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="abeafd428d2f4b4bb5086616d60a9e333a419b697ad52d8faee0c979c5d56cd596"></a><!-- doxytag: member="CVMX_USB_SPEED_FULL" ref="abeafd428d2f4b4bb5086616d60a9e333a419b697ad52d8faee0c979c5d56cd596" args="" -->CVMX_USB_SPEED_FULL</em>&nbsp;</td><td>
<p>Device is operation at 12Mbps. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="abeafd428d2f4b4bb5086616d60a9e333aaaecc4eed72310f15fbd56830f0aa487"></a><!-- doxytag: member="CVMX_USB_SPEED_LOW" ref="abeafd428d2f4b4bb5086616d60a9e333aaaecc4eed72310f15fbd56830f0aa487" args="" -->CVMX_USB_SPEED_LOW</em>&nbsp;</td><td>
<p>Device is operation at 1.5Mbps. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ab60527516a0c56b1d652b5d54cf69fd2"></a><!-- doxytag: member="cvmx&#45;usb.h::cvmx_usb_status_t" ref="ab60527516a0c56b1d652b5d54cf69fd2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cvmx-usb_8h.html#ab60527516a0c56b1d652b5d54cf69fd2">cvmx_usb_status_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enumerations representing the status of function calls. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ab60527516a0c56b1d652b5d54cf69fd2a8100d0a44b21b86d5b8470c9b79840d9"></a><!-- doxytag: member="CVMX_USB_SUCCESS" ref="ab60527516a0c56b1d652b5d54cf69fd2a8100d0a44b21b86d5b8470c9b79840d9" args="" -->CVMX_USB_SUCCESS</em>&nbsp;</td><td>
<p>There were no errors. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab60527516a0c56b1d652b5d54cf69fd2a5dfb93eb628d9656178a33413e80f1d5"></a><!-- doxytag: member="CVMX_USB_INVALID_PARAM" ref="ab60527516a0c56b1d652b5d54cf69fd2a5dfb93eb628d9656178a33413e80f1d5" args="" -->CVMX_USB_INVALID_PARAM</em>&nbsp;</td><td>
<p>A parameter to the function was invalid. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab60527516a0c56b1d652b5d54cf69fd2a5517fed2322dd4c66f15fed7da6b4004"></a><!-- doxytag: member="CVMX_USB_NO_MEMORY" ref="ab60527516a0c56b1d652b5d54cf69fd2a5517fed2322dd4c66f15fed7da6b4004" args="" -->CVMX_USB_NO_MEMORY</em>&nbsp;</td><td>
<p>Insufficient resources were available for the request. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab60527516a0c56b1d652b5d54cf69fd2a8a8c144e9758a8c6bc3fb0e26588fc29"></a><!-- doxytag: member="CVMX_USB_BUSY" ref="ab60527516a0c56b1d652b5d54cf69fd2a8a8c144e9758a8c6bc3fb0e26588fc29" args="" -->CVMX_USB_BUSY</em>&nbsp;</td><td>
<p>The resource is busy and cannot service the request. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab60527516a0c56b1d652b5d54cf69fd2a7a6cd04d1fe01b1a229f385ad1ab85d7"></a><!-- doxytag: member="CVMX_USB_TIMEOUT" ref="ab60527516a0c56b1d652b5d54cf69fd2a7a6cd04d1fe01b1a229f385ad1ab85d7" args="" -->CVMX_USB_TIMEOUT</em>&nbsp;</td><td>
<p>Waiting for an action timed out. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab60527516a0c56b1d652b5d54cf69fd2a71d39e0fcc01c3b381cb22dd34778a45"></a><!-- doxytag: member="CVMX_USB_INCORRECT_MODE" ref="ab60527516a0c56b1d652b5d54cf69fd2a71d39e0fcc01c3b381cb22dd34778a45" args="" -->CVMX_USB_INCORRECT_MODE</em>&nbsp;</td><td>
<p>The function call doesn't work in the current USB mode. </p>
<p>This happens when host only functions are called in device mode or vice versa </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a09207c64b615b8c1147ff8d5794702b3"></a><!-- doxytag: member="cvmx&#45;usb.h::cvmx_usb_transfer_t" ref="a09207c64b615b8c1147ff8d5794702b3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cvmx-usb_8h.html#a09207c64b615b8c1147ff8d5794702b3">cvmx_usb_transfer_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enumeration representing the possible USB transfer types. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a09207c64b615b8c1147ff8d5794702b3a9c7344c8b8b9e5463e2b5bb8cfa740f2"></a><!-- doxytag: member="CVMX_USB_TRANSFER_CONTROL" ref="a09207c64b615b8c1147ff8d5794702b3a9c7344c8b8b9e5463e2b5bb8cfa740f2" args="" -->CVMX_USB_TRANSFER_CONTROL</em>&nbsp;</td><td>
<p>USB transfer type control for hub and status transfers. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a09207c64b615b8c1147ff8d5794702b3a726e1695832da7b6eee5a769801c40a1"></a><!-- doxytag: member="CVMX_USB_TRANSFER_ISOCHRONOUS" ref="a09207c64b615b8c1147ff8d5794702b3a726e1695832da7b6eee5a769801c40a1" args="" -->CVMX_USB_TRANSFER_ISOCHRONOUS</em>&nbsp;</td><td>
<p>USB transfer type isochronous for low priority periodic transfers. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a09207c64b615b8c1147ff8d5794702b3afea214fc860ae6096cd36456ede3e0c4"></a><!-- doxytag: member="CVMX_USB_TRANSFER_BULK" ref="a09207c64b615b8c1147ff8d5794702b3afea214fc860ae6096cd36456ede3e0c4" args="" -->CVMX_USB_TRANSFER_BULK</em>&nbsp;</td><td>
<p>USB transfer type bulk for large low priority transfers. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a09207c64b615b8c1147ff8d5794702b3ae8db78f4faefc2cefd707e47e5a594fa"></a><!-- doxytag: member="CVMX_USB_TRANSFER_INTERRUPT" ref="a09207c64b615b8c1147ff8d5794702b3ae8db78f4faefc2cefd707e47e5a594fa" args="" -->CVMX_USB_TRANSFER_INTERRUPT</em>&nbsp;</td><td>
<p>USB transfer type interrupt for high priority periodic transfers. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ad9eda0ae960ae84d2fac691a1d245387"></a><!-- doxytag: member="cvmx&#45;usb.h::cvmx_usb_cancel" ref="ad9eda0ae960ae84d2fac691a1d245387" args="(cvmx_usb_state_t *state, int pipe_handle, int submit_handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cvmx-usb_8h.html#ab60527516a0c56b1d652b5d54cf69fd2">cvmx_usb_status_t</a> cvmx_usb_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pipe_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>submit_handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancel one outstanding request in a pipe. </p>
<p>Canceling a request can fail if the transaction has already completed before cancel is called. Even after a successful cancel call, it may take a frame or two for the <a class="el" href="cvmx-usb_8c.html#a252858f707b491bd2c22b16c63a8520a" title="Poll the USB block for status and call all needed callback handlers.">cvmx_usb_poll()</a> function to call the associated callback.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>USB device state populated by <a class="el" href="cvmx-usb_8c.html#a78c06bd132938304cf32fe2da8b83ab7" title="Initialize a USB port for use.">cvmx_usb_initialize()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pipe_handle</em>&nbsp;</td><td>Pipe handle to cancel requests in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>submit_handle</em>&nbsp;</td><td>Handle to transaction to cancel, returned by the submit function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CVMX_USB_SUCCESS or a negative error code defined in cvmx_usb_status_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f16c0269c47d805465ac509d07c7fc5"></a><!-- doxytag: member="cvmx&#45;usb.h::cvmx_usb_cancel_all" ref="a2f16c0269c47d805465ac509d07c7fc5" args="(cvmx_usb_state_t *state, int pipe_handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cvmx-usb_8h.html#ab60527516a0c56b1d652b5d54cf69fd2">cvmx_usb_status_t</a> cvmx_usb_cancel_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pipe_handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancel all outstanding requests in a pipe. </p>
<p>Logically all this does is call <a class="el" href="cvmx-usb_8c.html#ad9eda0ae960ae84d2fac691a1d245387" title="Cancel one outstanding request in a pipe.">cvmx_usb_cancel()</a> in a loop.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>USB device state populated by <a class="el" href="cvmx-usb_8c.html#a78c06bd132938304cf32fe2da8b83ab7" title="Initialize a USB port for use.">cvmx_usb_initialize()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pipe_handle</em>&nbsp;</td><td>Pipe handle to cancel requests in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CVMX_USB_SUCCESS or a negative error code defined in cvmx_usb_status_t. </dd></dl>

</div>
</div>
<a class="anchor" id="aec3a0ceb51369082c024046efd9c6c3a"></a><!-- doxytag: member="cvmx&#45;usb.h::cvmx_usb_close_pipe" ref="aec3a0ceb51369082c024046efd9c6c3a" args="(cvmx_usb_state_t *state, int pipe_handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cvmx-usb_8h.html#ab60527516a0c56b1d652b5d54cf69fd2">cvmx_usb_status_t</a> cvmx_usb_close_pipe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pipe_handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close a pipe created with <a class="el" href="cvmx-usb_8c.html#a95dc31cdca1fb94441b5034e4f463e3b" title="Open a virtual pipe between the host and a USB device.">cvmx_usb_open_pipe()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>USB device state populated by <a class="el" href="cvmx-usb_8c.html#a78c06bd132938304cf32fe2da8b83ab7" title="Initialize a USB port for use.">cvmx_usb_initialize()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pipe_handle</em>&nbsp;</td><td>Pipe handle to close.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CVMX_USB_SUCCESS or a negative error code defined in cvmx_usb_status_t. CVMX_USB_BUSY is returned if the pipe has outstanding transfers. </dd></dl>

</div>
</div>
<a class="anchor" id="a626627de3b8831b17e1cf094a037371b"></a><!-- doxytag: member="cvmx&#45;usb.h::cvmx_usb_disable" ref="a626627de3b8831b17e1cf094a037371b" args="(cvmx_usb_state_t *state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cvmx-usb_8h.html#ab60527516a0c56b1d652b5d54cf69fd2">cvmx_usb_status_t</a> cvmx_usb_disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>state</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable a USB port. </p>
<p>After this call the USB port will not generate data transfers and will not generate events. Transactions in process will fail and call their associated callbacks.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>USB device state populated by <a class="el" href="cvmx-usb_8c.html#a78c06bd132938304cf32fe2da8b83ab7" title="Initialize a USB port for use.">cvmx_usb_initialize()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CVMX_USB_SUCCESS or a negative error code defined in cvmx_usb_status_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a4fe34faa4328f9017658ffd3d5f74106"></a><!-- doxytag: member="cvmx&#45;usb.h::cvmx_usb_enable" ref="a4fe34faa4328f9017658ffd3d5f74106" args="(cvmx_usb_state_t *state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cvmx-usb_8h.html#ab60527516a0c56b1d652b5d54cf69fd2">cvmx_usb_status_t</a> cvmx_usb_enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>state</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable a USB port. </p>
<p>After this call succeeds, the USB port is online and servicing requests.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>USB device state populated by <a class="el" href="cvmx-usb_8c.html#a78c06bd132938304cf32fe2da8b83ab7" title="Initialize a USB port for use.">cvmx_usb_initialize()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CVMX_USB_SUCCESS or a negative error code defined in cvmx_usb_status_t. </dd></dl>

</div>
</div>
<a class="anchor" id="ac81d7a3b01c0551f47f6316869430439"></a><!-- doxytag: member="cvmx&#45;usb.h::cvmx_usb_get_frame_number" ref="ac81d7a3b01c0551f47f6316869430439" args="(cvmx_usb_state_t *state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_usb_get_frame_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>state</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current USB protocol level frame number. </p>
<p>The frame number is always in the range of 0-0x7ff.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>USB device state populated by <a class="el" href="cvmx-usb_8c.html#a78c06bd132938304cf32fe2da8b83ab7" title="Initialize a USB port for use.">cvmx_usb_initialize()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>USB frame number </dd></dl>

</div>
</div>
<a class="anchor" id="a7008cf45d92d7109dcc590d9dd8f9465"></a><!-- doxytag: member="cvmx&#45;usb.h::cvmx_usb_get_num_ports" ref="a7008cf45d92d7109dcc590d9dd8f9465" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_usb_get_num_ports </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of USB ports supported by this Octeon chip. </p>
<p>If the chip doesn't support USB, or is not supported by this API, a zero will be returned. Most Octeon chips support one usb port, but some support two ports. <a class="el" href="cvmx-usb_8c.html#a78c06bd132938304cf32fe2da8b83ab7" title="Initialize a USB port for use.">cvmx_usb_initialize()</a> must be called on independent <a class="el" href="structcvmx__usb__state__t.html" title="USB state internal data.">cvmx_usb_state_t</a> structures.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of port, zero if usb isn't supported</dd></dl>
<p>If the chip doesn't support USB, or is not supported by this API, a zero will be returned. Most Octeon chips support one usb port, but some support two ports. <a class="el" href="cvmx-usb_8c.html#a78c06bd132938304cf32fe2da8b83ab7" title="Initialize a USB port for use.">cvmx_usb_initialize()</a> must be called on independent <a class="el" href="structcvmx__usb__state__t.html" title="USB state internal data.">cvmx_usb_state_t</a> structures.</p>
<p>This utilizes cvmx_helper_board_usb_get_num_ports() to get any board specific variations.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of port, zero if usb isn't supported </dd></dl>

</div>
</div>
<a class="anchor" id="a9f66ca78263e0e13d78d2e3769dd006e"></a><!-- doxytag: member="cvmx&#45;usb.h::cvmx_usb_get_status" ref="a9f66ca78263e0e13d78d2e3769dd006e" args="(cvmx_usb_state_t *state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcvmx__usb__port__status__t.html">cvmx_usb_port_status_t</a> cvmx_usb_get_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>state</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current state of the USB port. </p>
<p>Use this call to determine if the usb port has anything connected, is enabled, or has some sort of error condition. The return value of this call has "changed" bits to signal of the value of some fields have changed between calls. These "changed" fields are based on the last call to <a class="el" href="cvmx-usb_8c.html#a07642545f5c4dc7996ab884359f51fde" title="Set the current state of the USB port.">cvmx_usb_set_status()</a>. In order to clear them, you must update the status through <a class="el" href="cvmx-usb_8c.html#a07642545f5c4dc7996ab884359f51fde" title="Set the current state of the USB port.">cvmx_usb_set_status()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>USB device state populated by <a class="el" href="cvmx-usb_8c.html#a78c06bd132938304cf32fe2da8b83ab7" title="Initialize a USB port for use.">cvmx_usb_initialize()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Port status information </dd></dl>

</div>
</div>
<a class="anchor" id="a78c06bd132938304cf32fe2da8b83ab7"></a><!-- doxytag: member="cvmx&#45;usb.h::cvmx_usb_initialize" ref="a78c06bd132938304cf32fe2da8b83ab7" args="(cvmx_usb_state_t *state, int usb_port_number, cvmx_usb_initialize_flags_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cvmx-usb_8h.html#ab60527516a0c56b1d652b5d54cf69fd2">cvmx_usb_status_t</a> cvmx_usb_initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>usb_port_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cvmx-usb_8h.html#acee50b5094efcc69cd029887557a57d3">cvmx_usb_initialize_flags_t</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize a USB port for use. </p>
<p>This must be called before any other access to the Octeon USB port is made. The port starts off in the disabled state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>Pointer to an empty <a class="el" href="structcvmx__usb__state__t.html" title="USB state internal data.">cvmx_usb_state_t</a> structure that will be populated by the initialize call. This structure is then passed to all other USB functions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>usb_port_number</em>&nbsp;</td><td>Which Octeon USB port to initialize. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags to control hardware initialization. See cvmx_usb_initialize_flags_t for the flag definitions. Some flags are mandatory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CVMX_USB_SUCCESS or a negative error code defined in cvmx_usb_status_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a95dc31cdca1fb94441b5034e4f463e3b"></a><!-- doxytag: member="cvmx&#45;usb.h::cvmx_usb_open_pipe" ref="a95dc31cdca1fb94441b5034e4f463e3b" args="(cvmx_usb_state_t *state, cvmx_usb_pipe_flags_t flags, int device_addr, int endpoint_num, cvmx_usb_speed_t device_speed, int max_packet, cvmx_usb_transfer_t transfer_type, cvmx_usb_direction_t transfer_dir, int interval, int multi_count, int hub_device_addr, int hub_port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_usb_open_pipe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cvmx-usb_8h.html#a5c424fc7632d3509a53199c6ae323474">cvmx_usb_pipe_flags_t</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>device_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>endpoint_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cvmx-usb_8h.html#abeafd428d2f4b4bb5086616d60a9e333">cvmx_usb_speed_t</a>&nbsp;</td>
          <td class="paramname"> <em>device_speed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max_packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cvmx-usb_8h.html#a09207c64b615b8c1147ff8d5794702b3">cvmx_usb_transfer_t</a>&nbsp;</td>
          <td class="paramname"> <em>transfer_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cvmx-usb_8h.html#a6f7eb40ade782b803c123c709a621598">cvmx_usb_direction_t</a>&nbsp;</td>
          <td class="paramname"> <em>transfer_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>multi_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>hub_device_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>hub_port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a virtual pipe between the host and a USB device. </p>
<p>A pipe must be opened before data can be transferred between a device and Octeon.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>USB device state populated by <a class="el" href="cvmx-usb_8c.html#a78c06bd132938304cf32fe2da8b83ab7" title="Initialize a USB port for use.">cvmx_usb_initialize()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Optional pipe flags defined in cvmx_usb_pipe_flags_t. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>device_addr</em>&nbsp;</td><td>USB device address to open the pipe to (0-127). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>endpoint_num</em>&nbsp;</td><td>USB endpoint number to open the pipe to (0-15). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>device_speed</em>&nbsp;</td><td>The speed of the device the pipe is going to. This must match the device's speed, which may be different than the port speed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_packet</em>&nbsp;</td><td>The maximum packet length the device can transmit/receive (low speed=0-8, full speed=0-1023, high speed=0-1024). This value comes from the standard endpoint <a class="el" href="structdescriptor.html">descriptor</a> field wMaxPacketSize bits &lt;10:0&gt;. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>transfer_type</em>&nbsp;</td><td>The type of transfer this pipe is for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>transfer_dir</em>&nbsp;</td><td>The direction the pipe is in. This is not used for control pipes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interval</em>&nbsp;</td><td>For ISOCHRONOUS and INTERRUPT transfers, this is how often the transfer is scheduled for. All other transfers should specify zero. The units are in frames (8000/sec at high speed, 1000/sec for full speed). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>multi_count</em>&nbsp;</td><td>For high speed devices, this is the maximum allowed number of packet per microframe. Specify zero for non high speed devices. This value comes from the standard endpoint <a class="el" href="structdescriptor.html">descriptor</a> field wMaxPacketSize bits &lt;12:11&gt;. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hub_device_addr</em>&nbsp;</td><td>Hub device address this device is connected to. Devices connected directly to Octeon use zero. This is only used when the device is full/low speed behind a high speed hub. The address will be of the high speed hub, not and full speed hubs after it. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hub_port</em>&nbsp;</td><td>Which port on the hub the device is connected. Use zero for devices connected directly to Octeon. Like hub_device_addr, this is only used for full/low speed devices behind a high speed hub.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A non negative value is a pipe handle. Negative values are failure codes from cvmx_usb_status_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a252858f707b491bd2c22b16c63a8520a"></a><!-- doxytag: member="cvmx&#45;usb.h::cvmx_usb_poll" ref="a252858f707b491bd2c22b16c63a8520a" args="(cvmx_usb_state_t *state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cvmx-usb_8h.html#ab60527516a0c56b1d652b5d54cf69fd2">cvmx_usb_status_t</a> cvmx_usb_poll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>state</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Poll the USB block for status and call all needed callback handlers. </p>
<p>This function is meant to be called in the interrupt handler for the USB controller. It can also be called periodically in a loop for non-interrupt based operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>USB device state populated by <a class="el" href="cvmx-usb_8c.html#a78c06bd132938304cf32fe2da8b83ab7" title="Initialize a USB port for use.">cvmx_usb_initialize()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CVMX_USB_SUCCESS or a negative error code defined in cvmx_usb_status_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a96316b0ff6a459a5be35a98b9cd57c20"></a><!-- doxytag: member="cvmx&#45;usb.h::cvmx_usb_register_callback" ref="a96316b0ff6a459a5be35a98b9cd57c20" args="(cvmx_usb_state_t *state, cvmx_usb_callback_t reason, cvmx_usb_callback_func_t callback, void *user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cvmx-usb_8h.html#ab60527516a0c56b1d652b5d54cf69fd2">cvmx_usb_status_t</a> cvmx_usb_register_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cvmx-usb_8h.html#a7b0db95a0a4705f6a0e461f4d444e8ef">cvmx_usb_callback_t</a>&nbsp;</td>
          <td class="paramname"> <em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cvmx-usb_8h.html#ad30ee177ca41ebdc033081f1272d9275">cvmx_usb_callback_func_t</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>user_data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register a function to be called when various USB events occur. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>USB device state populated by <a class="el" href="cvmx-usb_8c.html#a78c06bd132938304cf32fe2da8b83ab7" title="Initialize a USB port for use.">cvmx_usb_initialize()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reason</em>&nbsp;</td><td>Which event to register for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>Function to call when the event occurs. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>user_data</em>&nbsp;</td><td>User data parameter to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CVMX_USB_SUCCESS or a negative error code defined in cvmx_usb_status_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a07642545f5c4dc7996ab884359f51fde"></a><!-- doxytag: member="cvmx&#45;usb.h::cvmx_usb_set_status" ref="a07642545f5c4dc7996ab884359f51fde" args="(cvmx_usb_state_t *state, cvmx_usb_port_status_t port_status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cvmx_usb_set_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvmx__usb__port__status__t.html">cvmx_usb_port_status_t</a>&nbsp;</td>
          <td class="paramname"> <em>port_status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the current state of the USB port. </p>
<p>The status is used as a reference for the "changed" bits returned by <a class="el" href="cvmx-usb_8c.html#a9f66ca78263e0e13d78d2e3769dd006e" title="Get the current state of the USB port.">cvmx_usb_get_status()</a>. Other than serving as a reference, the status passed to this function is not used. No fields can be changed through this call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>USB device state populated by <a class="el" href="cvmx-usb_8c.html#a78c06bd132938304cf32fe2da8b83ab7" title="Initialize a USB port for use.">cvmx_usb_initialize()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port_status</em>&nbsp;</td><td>Port status to set, most like returned by <a class="el" href="cvmx-usb_8c.html#a9f66ca78263e0e13d78d2e3769dd006e" title="Get the current state of the USB port.">cvmx_usb_get_status()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf0e935e37140c27e4735c054a6018d9"></a><!-- doxytag: member="cvmx&#45;usb.h::cvmx_usb_shutdown" ref="abf0e935e37140c27e4735c054a6018d9" args="(cvmx_usb_state_t *state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cvmx-usb_8h.html#ab60527516a0c56b1d652b5d54cf69fd2">cvmx_usb_status_t</a> cvmx_usb_shutdown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>state</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shutdown a USB port after a call to <a class="el" href="cvmx-usb_8c.html#a78c06bd132938304cf32fe2da8b83ab7" title="Initialize a USB port for use.">cvmx_usb_initialize()</a>. </p>
<p>The port should be disabled with all pipes closed when this function is called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>USB device state populated by <a class="el" href="cvmx-usb_8c.html#a78c06bd132938304cf32fe2da8b83ab7" title="Initialize a USB port for use.">cvmx_usb_initialize()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CVMX_USB_SUCCESS or a negative error code defined in cvmx_usb_status_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a22ec1f739126b098c9537f5e6ab40bb0"></a><!-- doxytag: member="cvmx&#45;usb.h::cvmx_usb_submit_bulk" ref="a22ec1f739126b098c9537f5e6ab40bb0" args="(cvmx_usb_state_t *state, int pipe_handle, uint64_t buffer, int buffer_length, cvmx_usb_callback_func_t callback, void *user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_usb_submit_bulk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pipe_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>buffer_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cvmx-usb_8h.html#ad30ee177ca41ebdc033081f1272d9275">cvmx_usb_callback_func_t</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>user_data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call to submit a USB Bulk transfer to a pipe. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>USB device state populated by <a class="el" href="cvmx-usb_8c.html#a78c06bd132938304cf32fe2da8b83ab7" title="Initialize a USB port for use.">cvmx_usb_initialize()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pipe_handle</em>&nbsp;</td><td>Handle to the pipe for the transfer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Physical address of the data buffer in memory. Note that this is NOT A POINTER, but the full 64bit physical address of the buffer. This may be zero if buffer_length is zero. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer_length</em>&nbsp;</td><td>Length of buffer in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>Function to call when this transaction completes. If the return value of this function isn't an error, then this function is guaranteed to be called when the transaction completes. If this parameter is NULL, then the generic callback registered through cvmx_usb_register_callback is called. If both are NULL, then there is no way to know when a transaction completes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>user_data</em>&nbsp;</td><td>User supplied data returned when the callback is called. This is only used if callback in not NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A submitted transaction handle or negative on failure. Negative values are failure codes from cvmx_usb_status_t. </dd></dl>

</div>
</div>
<a class="anchor" id="aa2198035dd5158cd25295e7e06a4bdb0"></a><!-- doxytag: member="cvmx&#45;usb.h::cvmx_usb_submit_control" ref="aa2198035dd5158cd25295e7e06a4bdb0" args="(cvmx_usb_state_t *state, int pipe_handle, uint64_t control_header, uint64_t buffer, int buffer_length, cvmx_usb_callback_func_t callback, void *user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_usb_submit_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pipe_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>control_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>buffer_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cvmx-usb_8h.html#ad30ee177ca41ebdc033081f1272d9275">cvmx_usb_callback_func_t</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>user_data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call to submit a USB Control transfer to a pipe. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>USB device state populated by <a class="el" href="cvmx-usb_8c.html#a78c06bd132938304cf32fe2da8b83ab7" title="Initialize a USB port for use.">cvmx_usb_initialize()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pipe_handle</em>&nbsp;</td><td>Handle to the pipe for the transfer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>control_header</em>&nbsp;</td><td>USB 8 byte control header physical address. Note that this is NOT A POINTER, but the full 64bit physical address of the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Physical address of the data buffer in memory. Note that this is NOT A POINTER, but the full 64bit physical address of the buffer. This may be zero if buffer_length is zero. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer_length</em>&nbsp;</td><td>Length of buffer in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>Function to call when this transaction completes. If the return value of this function isn't an error, then this function is guaranteed to be called when the transaction completes. If this parameter is NULL, then the generic callback registered through cvmx_usb_register_callback is called. If both are NULL, then there is no way to know when a transaction completes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>user_data</em>&nbsp;</td><td>User supplied data returned when the callback is called. This is only used if callback in not NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A submitted transaction handle or negative on failure. Negative values are failure codes from cvmx_usb_status_t. </dd></dl>

</div>
</div>
<a class="anchor" id="aa785521de9f4ae8f76e0731de8dd9123"></a><!-- doxytag: member="cvmx&#45;usb.h::cvmx_usb_submit_interrupt" ref="aa785521de9f4ae8f76e0731de8dd9123" args="(cvmx_usb_state_t *state, int pipe_handle, uint64_t buffer, int buffer_length, cvmx_usb_callback_func_t callback, void *user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_usb_submit_interrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pipe_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>buffer_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cvmx-usb_8h.html#ad30ee177ca41ebdc033081f1272d9275">cvmx_usb_callback_func_t</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>user_data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call to submit a USB Interrupt transfer to a pipe. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>USB device state populated by <a class="el" href="cvmx-usb_8c.html#a78c06bd132938304cf32fe2da8b83ab7" title="Initialize a USB port for use.">cvmx_usb_initialize()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pipe_handle</em>&nbsp;</td><td>Handle to the pipe for the transfer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Physical address of the data buffer in memory. Note that this is NOT A POINTER, but the full 64bit physical address of the buffer. This may be zero if buffer_length is zero. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer_length</em>&nbsp;</td><td>Length of buffer in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>Function to call when this transaction completes. If the return value of this function isn't an error, then this function is guaranteed to be called when the transaction completes. If this parameter is NULL, then the generic callback registered through cvmx_usb_register_callback is called. If both are NULL, then there is no way to know when a transaction completes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>user_data</em>&nbsp;</td><td>User supplied data returned when the callback is called. This is only used if callback in not NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A submitted transaction handle or negative on failure. Negative values are failure codes from cvmx_usb_status_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a81bd48a41477ab51af862910a07ab79b"></a><!-- doxytag: member="cvmx&#45;usb.h::cvmx_usb_submit_isochronous" ref="a81bd48a41477ab51af862910a07ab79b" args="(cvmx_usb_state_t *state, int pipe_handle, int start_frame, int flags, int number_packets, cvmx_usb_iso_packet_t packets[], uint64_t buffer, int buffer_length, cvmx_usb_callback_func_t callback, void *user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cvmx_usb_submit_isochronous </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcvmx__usb__state__t.html">cvmx_usb_state_t</a> *&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pipe_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>start_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>number_packets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcvmx__usb__iso__packet__t.html">cvmx_usb_iso_packet_t</a>&nbsp;</td>
          <td class="paramname"> <em>packets</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>buffer_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cvmx-usb_8h.html#ad30ee177ca41ebdc033081f1272d9275">cvmx_usb_callback_func_t</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>user_data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call to submit a USB Isochronous transfer to a pipe. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>USB device state populated by <a class="el" href="cvmx-usb_8c.html#a78c06bd132938304cf32fe2da8b83ab7" title="Initialize a USB port for use.">cvmx_usb_initialize()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pipe_handle</em>&nbsp;</td><td>Handle to the pipe for the transfer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_frame</em>&nbsp;</td><td>Number of frames into the future to schedule this transaction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags to control the transfer. See cvmx_usb_isochronous_flags_t for the flag definitions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>number_packets</em>&nbsp;</td><td>Number of sequential packets to transfer. "packets" is a pointer to an array of this many packet structures. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packets</em>&nbsp;</td><td>Description of each transfer packet as defined by <a class="el" href="structcvmx__usb__iso__packet__t.html" title="Descriptor for Isochronous packets.">cvmx_usb_iso_packet_t</a>. The array pointed to here must stay valid until the complete callback is called. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Physical address of the data buffer in memory. Note that this is NOT A POINTER, but the full 64bit physical address of the buffer. This may be zero if buffer_length is zero. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer_length</em>&nbsp;</td><td>Length of buffer in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>Function to call when this transaction completes. If the return value of this function isn't an error, then this function is guaranteed to be called when the transaction completes. If this parameter is NULL, then the generic callback registered through cvmx_usb_register_callback is called. If both are NULL, then there is no way to know when a transaction completes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>user_data</em>&nbsp;</td><td>User supplied data returned when the callback is called. This is only used if callback in not NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A submitted transaction handle or negative on failure. Negative values are failure codes from cvmx_usb_status_t. </dd></dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Oct 2017 for Octeon Software Development Kit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
