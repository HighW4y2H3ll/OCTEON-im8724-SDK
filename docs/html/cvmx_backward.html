<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Octeon Software Development Kit: CN7XXX backward compatibility support</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="cvmx_backward">CN7XXX backward compatibility support </a></h1><p>Here CN7XXX means, CN78XX, CN73XX, CNF75XX that use OCTEON III packet IO blocks.</p>
<ul>
<li><a class="el" href="cvmx_backward.html#cvmx_compat_limitations">Compatibility mode limitations</a></li>
<li><a class="el" href="cvmx_backward.html#cvmx_feat_unsupp">Features not supported</a></li>
<li><a class="el" href="cvmx_backward.html#cvmx_pko_bc">PKO Backward Compatibility</a></li>
<li><a class="el" href="cvmx_backward.html#cvmx_sso_bc">SSO considerations</a></li>
<li><a class="el" href="cvmx_backward.html#cvmx_fpa_bc">FPA considerations</a></li>
<li><a class="el" href="cvmx_backward.html#cvmx_wqe_bc">WQE considerations</a></li>
<li><a class="el" href="cvmx_backward.html#cvmx_fau_bc">FAU considerations</a></li>
</ul>
<h2><a class="anchor" id="cvmx_compat_limitations">
Compatibility mode limitations</a></h2>
<p><a class="el" href="cvmx-cmd-queue_8c.html#a70e56b69f67ab0838c921f43e9fbe829" title="Return the number of command words pending in the queue.">cvmx_cmd_queue_length()</a> should not be called directly for PKO queues. use <a class="el" href="cvmx-hwpko_8h.html#a46f18222419161fbd240062b17741ac8">cvmx_pko_queue_pend_count()</a> instead for PKO queues</p>
<p>Legacy SE applications are confined to using resources located on the same node as the executing core.</p>
<h2><a class="anchor" id="cvmx_feat_unsupp">
Features not supported</a></h2>
<p>Backpressure is not supported in legacy mode.</p>
<h2><a class="anchor" id="cvmx_pko_bc">
PKO Backward Compatibility</a></h2>
<p>The CN7XXX does not make any use of PKO internal ports, and therefore all functions that refer to "pko_port" are made to use "IPD port" to take its place. Also note that cvmx_pko_ipd2pko() and related functions that relate to "PKO internal ports" are now obsolete, and maintained solely for backward-compatibility, therefore should not be used in new applications.</p>
<p>pko_get_base_queue(), pko_get_num_queues() return the Descriptor Queue range assigned to the IPD port passed as argument. Note that with the current helper configuration, these queues are in order of actual priority, highest to lowest.</p>
<p>Legacy PKO packet transmission functions support the use of legacy PKO command and buffer pointer structure on the CN78XX and new Octeon III models. The legacy buffer pointer "pool" field is supported, in that it is each buffer can be released to a different aura if required. The legacy structures are translated to CN7XXX native data structures which incurrs some overhead, therefore for performance-sensitive applications, the new native Octeon3 API is strongly recommended.</p>
<p>There are a few limitations on legacy PKO transmission function: The PTP bit in the 3rd command word is not supported, it can not be readily distinguished from an extension of a physical address. The software-emulated FAU is supported via the legacy PKO transmit function, but it does not support 16-bit counters, as these are not supported by PKO3 hardware.</p>
<p><a class="el" href="cvmx-hwpko_8h.html#a47f494b2ac045081be7b44f2234ef2f4" title="Get the status counters for a port.">cvmx_pko_get_port_status()</a> retreives the CN7XXX PKO counters for total octets and packets transmitted on a given Descriptor Queue, but it does not retreive other counters (such as dropped packets). A more complete set of statistics counter is implemented by the BGX module, although these counters are per interface port.</p>
<p>The DQ range per IPD port is contigous, so as not to sacrifice performance. This means that all DQs (both Static and WRR priority) must be allocated all at once. PKO port-to-queue translation is a per-node BSS array, for node-local searches to be the fastest.</p>
<h2><a class="anchor" id="cvmx_sso_bc">
SSO considerations</a></h2>
<p>The major change to the SSO is the change in the nature of group ids. Previous chips had 8 priorities with 16 groups each. The CN78XX has 256 groups (or 64 groups on CN73xx/CNF75xx), with configurable priority levels, allowing greater flexibility. To avoid confusion, function arguments that refer to the new extended group numbering scheme are named "xgrp", whereas argument named "group" or "grp" are treated in a backward-compatible fashion, according to the following convention: the 3 lowest bits are designated to represent the 'qos value, and by default all 256 groups will be configured to mimic the functionality found in older models, and organized in set of 8 "xgrp"s, where e.g. each set always assigned a processor core together.</p>
<h2><a class="anchor" id="cvmx_fpa_bc">
FPA considerations</a></h2>
<p>The first 8 auras are reserved to represent the 8 legacy buffer pools, so that the legacy pool number is translated into a node-local aura number one-to-one. Also the FPA is only supported in Natural Alignment mode when using the legacy api.</p>
<p>For details about a CN7XXX-specific API additions that enable the use of new features introduced, please see 'CN7XXX native api reference' section in the Octeon Software Development Kit document and 'cvmx-fpa3.h file under executive directory.</p>
<h2><a class="anchor" id="cvmx_wqe_bc">
WQE considerations</a></h2>
<p>The most critical hardware-controlled data structure that has dramatically changed in the CN7XXX is the Work Queue Entry, specifically in the way it is filled in by the PKI and delivered to the application from the cvmx_get_work() function. Because of these changes, it is no longer recommended to inspect packets by simply dereferencing the WQE pointer, but instead application developers are advised to take advantage of the new accessor functions now provided in <a class="el" href="cvmx-wqe_8h.html" title="This header file defines the work queue entry (wqe) data structure.">executive/cvmx-wqe.h</a>. This is the most important category of changes for an application to implement if it intends to support CN78XX and future devices. It is permissible for applications that prefer to handle the SoC model dependencies by themselves to access the model-specific members of the WQE data structure, but applications must themselves ensure the correct member fields are accessed as appropriate for the target hardware. Most WQE accessor functions are simple and self-explanatory, as they are named for the field they intend to access, but certain critical accessor routines handle functionality which is considerably more complex on the CN7XXX and will be documented here.</p>
<p>cvmx_buf_ptr_t <a class="el" href="cvmx-wqe_8h.html#a7e6a73696c2727e9282a315900d59002" title="Extract packet data buffer pointer from work queue entry.">cvmx_wqe_get_packet_ptr(cvmx_wqe_t *work)</a></p>
<p>This function is critical for understanding the backwards-compatible packet I/O API. This function will return a buffer link pointer compatible with legacy models, even when running on the CN7XXX.</p>
<p>When running on the CN7XXX this function will convert the buffer link pointer contained in the work queue entry to the legacy format, compatible with older models such that the application may process the packet data without any changes. The buffer link pointer also needs to be converted to the legacy format so it can be ultimately passed as an argument to the cvmx_pko_send_finish() function for transmit. A reserved bit within the WQE is set as a flag indicating this conversion has been performed, and to ensure multiple calls will not attempt to reconvert the WQE. The conversion of the buffer link pointer imposes several limitations on the backward-compatible use of the CN7XXX, and these limitations have implications for other subsystems as well.</p>
<p>1. The legacy buffer link pointer has a 3-bit "pool" field, and for this reason a backward-compatible application can only use auras numbered 0-7 (inclusive) for any buffers containing packets.</p>
<p>2. The physical address field of the buffer link pointer is 40-bits wide, which implies that all buffers used to contain packets can not store the information of the node where the buffer memory is residing. The backward-compatible PKO API will however recieve the node information based on the node number on which the application is running, so that as long as each SE application is confined to using buffers residing in the same node that it runs on, the buffers should get transmitted. Beware however when accessing packet data, because translating the partial physical address to an XKPHYS virtual address for a buffer that stored on non-zero node memory will result in an incorrect translation. For this reason, it is recommended that applications that are taking advantage of the backward-compatibility API be deployed only on node 0.</p>
<p>When this function is invoked on CN68XX and earlier models, while it returns the buffer link pointer in IPD format, it also performs the necessary handling of packets that are contained within the WQE itself, including the handling of "dynamic short" packets, as well as the "NO_WPTR" mode option supported by the CN68XX. Using this accessor on legacy devices eliminatesi the need to detect and handle the above-mentioned cases within application code, and makes the application code simpler and easier to maintain.</p>
<p>int <a class="el" href="cvmx-wqe_8h.html#a0c3d2589d8b6c097a7f96cd467c64d71">cvmx_wqe_get_bufs(cvmx_wqe_t *work)</a></p>
<p>This function is intended to extract the number of buffers attached to the work queue entry. It will, however, also call cvmx_wqe_bufptr() if the work queue entry needs to be processed for backwards-compatibility when running on CN7XXX, or for processing packets contained within the WQE. For that reason it will return at least 1 as the buffer count, and prepares the buffer link pointer to the correct address of the packet data even if contained within the WQE.</p>
<p>void <a class="el" href="cvmx-wqe_8h.html#a3178b90be403d7078fb5643c9af08ae8" title="Free Work Queue Entry memory.">cvmx_wqe_free(cvmx_wqe_t *work)</a></p>
<p>This function is not an accessor per se, but a helper that will correctly release the memory (if any) that is occupied by the work queue entry to the same aura(or pool) it was allocated from. If packet data is contained within the WQE however, this call will not free any memory, but will instead rely on the PKO to release the buffer upon completion of processing. It is advised to use this function instead of calling <a class="el" href="cvmx-fpa_8h.html#a953ef29fcfef0ca074e2cfc1c294e4bf" title="Free a block allocated with a FPA pool.">cvmx_fpa_free()</a> directly as it does not require the application to detect if the first packet buffer is inside or outside the WQE, and does not need to have separate knowledge of which aura/pool the WQE should be released to (ie which aura/pool the PKI allocated it from originally). Note that on the CN78XX the WQE and packet buffers may be allocated from any of the 1024 (or 64 on CN73xx/CNF75XX) available auras, therefore for legacy applications the additional logic required is non-trivial.</p>
<p>Setting WQEs for two-buffer mode Function void cvmx_helper_pki_set_wqe_mode(int node, uint64_t ipd_port, bool pkt_outside_wqe) sets up wqe mode. To make wqe use a separate buffer from packet data, you will need to set mode to 1. Warning: number of packet buffers needs to be doubled since wqe buffer also comes from packet data now. It will consume double the memory.</p>
<h2><a class="anchor" id="cvmx_fau_bc">
FAU considerations</a></h2>
<p>There is no hardware FAU block in the CN7XXX. For legacy applications the api is emulated using atomic writes by both the CPU and PKO block. However, the async fau functions are no longer async, and iobdma operations are handled as direct atomic operations. </p>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Oct 2017 for Octeon Software Development Kit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
