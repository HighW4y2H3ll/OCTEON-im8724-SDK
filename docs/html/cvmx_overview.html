<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Octeon Software Development Kit: OCTEON Simple Executive Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="cvmx_overview">OCTEON Simple Executive Overview </a></h1><h2><a class="anchor" id="cvmx_contenst">
Contents</a></h2>
<ul>
<li><a class="el" href="cvmx_overview.html#introduction_simple_exec">1 Introduction</a></li>
<li><a class="el" href="cvmx_overview.html#programming">2 Programming Model</a></li>
<li><a class="el" href="cvmx_overview.html#c_cpp_library">3 C/C++ Runtime support</a></li>
<li><a class="el" href="cvmx_overview.html#hal">4 Hardware Abstraction Layer (HAL)</a></li>
<li><a class="el" href="cvmx_overview.html#memory">5 Memory Management</a></li>
<li><a class="el" href="cvmx_overview.html#synchronization">6 Synchronization</a></li>
<li><a class="el" href="cvmx_overview.html#interrupts">7 Exceptions and Interrupt Handling</a></li>
<li><a class="el" href="cvmx_overview.html#hotplug">8 Simple Executive Hotplug</a></li>
<li><a class="el" href="cvmx_overview.html#models">9 Supporting multiple OCTEON models</a></li>
</ul>
<h2><a class="anchor" id="introduction_simple_exec">
1 Introduction</a></h2>
<p>The OCTEON Executive Library provides runtime support, hardware abstraction, memory managment, and synchronization routines for the OCTEON processor. It is composed of the libcvmx.a library as well as header files that provide a lot of functionality with inline functions. The Executive is designed to provide an efficient environment for developing data plane code for OCTEON. It supports a single thread of execution per cnMIPS core.</p>
<h2><a class="anchor" id="programming">
2 Programming Model</a></h2>
<h3><a class="anchor" id="process_per_core_memory_model">
2.1 Single Process per core memory model</a></h3>
<p>When a simple executive application is run on multiple cores, it is run as one 'process' per core (as opposed to one 'thread'.) Each core has its own copy of global variables - nothing is shared by default. Shared variables can be created at compile time with the CVMX_SHARED attribute. Variables with the CVMX_SHARED attribute are shared between all cores running the same application image. The TLB is used to map each core's copy of the global data to the same virtual address, allowing each core to have its own copy.</p>
<h3><a class="anchor" id="tlb_usage">
2.2 TLB usage</a></h3>
<p>The simple executive uses TLB mappings for the following purposes:</p>
<ul>
<li>to allow each core to have its own copy of global data at the same virtual address (process memory model)</li>
<li>to provide readonly access to code</li>
<li>to provide stack overflow protection</li>
<li>to simplify sharing of memory addresses with hardware units</li>
</ul>
<p>The bootloader configures the TLB for all the above mappings except the 1-1 mapping used to simplify address sharing with hardware units.</p>
<h3><a class="anchor" id="read_only_access_to_code">
2.2.1 Read only access to code</a></h3>
<p>The TLB is used to provide read only access to the application code.</p>
<p>(Note: this is not implemented in the current version.)</p>
<h3><a class="anchor" id="stack_overflow_protection">
2.2.2 Stack overflow protection</a></h3>
<p>The stack and heap for each core are mapped into a virtual address range that does not have mapped virtual addresses directly below it. The stack occupies the lower portion of the this range, and grows down. When the stack overflows, the stack pointer points to an unmapped virtual address and any access to this memory generates a TLB miss exception. The stack and heap are mapped with a virtual address in the range 0x10000000 - 0x20000000 since this range does not conflict with any 1-1 TLB mappings.</p>
<h3><a class="anchor" id="simplified_address_sharing_with_hardware_units">
2.2.3 Simplified address sharing with hardware units</a></h3>
<p>The OCTEON hardware blocks use physical memory addresses. (Virtual addresses make no sense as there is a separate virtual to physical mapping for each core.) In order for a core to directly access a specific physical memory location, it must use the XKPHYS address space. This requires setting bit 63 of the address. In order to avoid repeated setting/clearing of bit 63, the simple exec uses 1-1 virtual-physical address mapping. This allows 'physical' addressing to be used without setting bit 63. (Virtual addressing is still used, but for the memory regions shared with the hardware, the physical and virtual addresses are the same.) It is up to the application to enable this mapping. This is done by the function <a class="el" href="cvmx-access_8h.html#a22c7fb96aa0426a2a74f7ff47c153e64" title="This function performs some default initialization of the Octeon executive.">cvmx_user_app_init()</a> which is provided to simplify typical application configurations.</p>
<h3><a class="anchor" id="virtual_memory_map_summary">
2.2.4 Virtual memory map summary</a></h3>
<ul>
<li>0x1000 0000 to 0x2000 0000: This range is used to map the application's code, data, stack, and heap. This address range coresponds to the physical addresses for the OCTEON boot bus, so this does not conflict with any potential 1-1 DRAM mappings. The stack and heap are placed at the top of this range. These addresses are the same for both 64 bit and 32 bit ABIs.</li>
<li>1-1 mappings as configured by the application (Typically done in <a class="el" href="cvmx-access_8h.html#a22c7fb96aa0426a2a74f7ff47c153e64" title="This function performs some default initialization of the Octeon executive.">cvmx_user_app_init()</a>) These mappings are done to avoid having to set and clear the XKPHYS bit (bit 63) in the address. With these mappings in place, the application can use 'physical' addresses directly.</li>
</ul>
<h3><a class="anchor" id="memory_allocation_options">
2.2.5 Memory allocation methods</a></h3>
<ul>
<li>local variables: These are placed on the stack, which is private to each core. All cores have their stack mapped to the same virtual address, but each core's TLB entry maps this virtual address to a different physical address.</li>
<li>malloc(): This allocates from a core local heap. All cores have their heap mapped to the same virtual address, but each core's TLB entry maps this virtual address to a different physical address.</li>
<li><a class="el" href="cvmx-bootmem_8c.html#a4295ccfec5aeb9b415c92fbbb1f5873e" title="Allocate a block of memory from the free list that was passed to the application...">cvmx_bootmem_alloc()</a>: This returns a physical address from a global pool of available physical memory. This pool is set up by the bootloader, and at application start time contains all free memory that is not in use by the programs' stack/heap/code/data or in use by a named block that was allocated by the bootloader. Note that this function returns physical addresses, so either 1-1 TLB mappings must be set up, or the XKPHYS bit must be set in the address. Typically 1-1 TLB mappings will be used. <a class="el" href="cvmx-bootmem_8c.html#a4295ccfec5aeb9b415c92fbbb1f5873e" title="Allocate a block of memory from the free list that was passed to the application...">cvmx_bootmem_alloc()</a> does the required locking to be multi-core safe.</li>
<li><a class="el" href="cvmx-malloc_8h.html#ab8510bd4d8a3da987bb37e77e8f2fbda" title="allocate buffer from an arena list">cvmx_malloc()</a>: This returns an address from one of the arenas that it was populated with. The addresses returned will be of the type the arena was populated with. Typically the arenas will be populated with physical addresses from <a class="el" href="cvmx-bootmem_8c.html#a4295ccfec5aeb9b415c92fbbb1f5873e" title="Allocate a block of memory from the free list that was passed to the application...">cvmx_bootmem_alloc()</a> and 1-1 TLB mappings will be used to access this memory. This allows <a class="el" href="cvmx-malloc_8h.html#ab8510bd4d8a3da987bb37e77e8f2fbda" title="allocate buffer from an arena list">cvmx_malloc()</a> to be used as a shared memory allocater for multiple cores. <a class="el" href="cvmx-malloc_8h.html#ab8510bd4d8a3da987bb37e77e8f2fbda" title="allocate buffer from an arena list">cvmx_malloc()</a> does the required locking to be multi-core safe.</li>
</ul>
<h3><a class="anchor" id="bootloader_sec">
2.3 Bootloader</a></h3>
<p>The bootloader is responsible for loading the OCTEON application ELF file into DRAM from the boot bus (flash memory) and setting up the TLB mappings required for running the application. The bootloader passes a list of the available memory to the application, and this is available to the application in the cvmx_sysinfo_t structure. For more information on the bootloader and the physical memory map please refer to the <a href="bootloader.html">OCTEON Bootloader documentation</a>.</p>
<h2><a class="anchor" id="c_cpp_library">
3 C/C++ Runtime support</a></h2>
<h3><a class="anchor" id="c_library">
3.1 C library</a></h3>
<p>The executive provides a C library based on the newlib C library. Optimized versions of memset and memcpy are provided.</p>
<p>Standard Utility Functions (`stdlib.h'):</p>
<ul>
<li>abort, abs, assert, atof, atoff, atoi, atol, atoll, calloc, div, ecvt, ecvtf, fcvt, fcvtf, gvcvt, gcvtf, ecvtbuf, fcvtbuf, exit, labs, ldiv, llabs,lldiv, malloc, realloc, free, rand, srand, rand48, drand48, erand48, lrand48, nrand48, mrand48, jrand48, srand48, seed48, lcong48, strtod, strtof, strtol, strtoul</li>
</ul>
<p>Character Type Macros and Functions (`ctype.h'):</p>
<ul>
<li>isalnum, isalpha, isascii, iscntrl, isdigit, islower, isprint, isgraph, ispunct, isspace, isupper, isxdigit, toascii, tolower, toupper</li>
</ul>
<p>Input and Output (`stdio.h'):</p>
<ul>
<li>fflush, fgets, fiprintf, fputc, fputs, fread, freopen, ftell, ftello, fwrite, getc, getchar, gets, getw, iprintf, perror, putc, putchar, puts, putw, siprintf, printf, fprintf, asprintf, sprintf, snprintf, scanf, fscanf, sscanf, vprintf, vfprintf, vsprintf</li>
</ul>
<p>There is no filesystem support in the simple exec. Input from stdin and output to stdout and stderr are mapped to the OCTEON uart.</p>
<p>Strings and Memory (`string.h') :</p>
<ul>
<li>bcmp, bcopy, bzero, index, memccpy, memchr, memcmp, memcpy, memmove, abort, abs, assert, atof, atoff, atoi, atol, atoll, calloc, div, ecvt, ecvtf, fcvt,fcvtf, gvcvt, gcvtf, ecvtbuf, fcvtbuf, exit, labs, ldiv, llabs, lldiv, malloc, realloc, free</li>
</ul>
<p>Character Type Macros and Functions (`ctype.h'):</p>
<ul>
<li>isalnum, isalpha, isascii, iscntrl, isdigit, islower, isprint, isgraph, ispunct, isspace, isupper, isxdigit, toascii, tolower, toupper</li>
</ul>
<p>Variable Argument Lists:</p>
<ul>
<li>ANSI-standard macros, `stdarg.h'</li>
</ul>
<h3><a class="anchor" id="system_calls">
3.2 System calls</a></h3>
<p>The executive will provide a basic set of system calls to support the C library and applications. The executive is implemented as a library, so there is no trap/syscall overhead for system calls.</p>
<p>Summary of provided system calls:</p>
<ul>
<li>brk() - allocate memory for an applications heap. The heap size is determined at startup, and does not grow. This is for C-library support, and should not be used directly by the application.</li>
<li>read() / write() - provide basic I/O over the serial port.</li>
<li><a class="el" href="cvmx-coremask_8c.html#a2ef03f5387cceb31406fd014132ae800" title="variable to poll for exit condition">exit()</a> - allow graceful termination of program. OCTEON core is idle after <a class="el" href="cvmx-coremask_8c.html#a2ef03f5387cceb31406fd014132ae800" title="variable to poll for exit condition">exit()</a>.</li>
<li><a class="el" href="cvmx-access_8h.html#a04e4ae7583328b00067505d22e2953de" title="simprintf uses simulator tricks to speed up printouts.">simprintf()</a> - A simulator specific output routine similar to printf.</li>
</ul>
<h3><a class="anchor" id="backtrace">
3.3 Obtaining backtrace information programmatically</a></h3>
<p>The MIPS ABIs do not require the use of a frame pointer and the location of the saved return address within the stack frame is not fixed. One can only walk the frames by virtually unwinding them using auxiliary information describing the frames. In case of C++, this information is needed for exception handling and is generated by default. For C, it can be requested with -funwind-tables or -fasynchronous-unwind-tables.</p>
<p>The simple-execuctive toolchain is set up to generate frame information by default (-fasynchronous-unwind-tables is passed). This has no effect on the generated code -- it only ensures that the tables necessary for unwinding are generated by GCC and put into the the .eh_frame section.</p>
<p>The OCTEON-specific newlib header execinfo.h provides functions to access this information. Below is an example of how to print the trace using <b>__octeon_print_backtrace</b>. To change how the backtrace is printed one can pass a custom printf-style function to <b>__octeon_print_backtrace_func</b>. Finally, <b>backtrace</b>, similarly to function with the same name in glibc, returns the pc values in memory.</p>
<p>Here is an example with <b>__octeon_print_backtrace:</b> </p>
<div class="fragment"><pre class="fragment">
$ cat -n bt.c
     1  #include &lt;execinfo.h&gt;
     2
     3  int i;
     4
     5  __attribute__ ((noinline))
     6  void f ()
     7  {
     8    __octeon_print_backtrace ();
     9    i = 1;
    10  }
    11
    12  main ()
    13  {
    14    f ();
    15    return 0;
    16  }

$ mipsisa64-octeon-elf-gcc -O2 bt.c

$ oct-sim ./a.out -quiet  -noperf | grep CONSOLE
PP0:~CONSOLE-&gt;   #0  0x100002e8
PP0:~CONSOLE-&gt;   #1  0x10000310
PP0:~CONSOLE-&gt;   #2  0x100002b8
</pre></div><p>GCC has been extended to support unwinding through the first exception handler frame. This is how the backtrace printed in cvmx_interrupt_default_exception_handler() can trace back to the function causing the exception and continue the backtrace from there (see <a class="el" href="cvmx_overview.html#interrupt_exception">7.3 Exception Handling</a>).</p>
<p>With optimization on, GCC tries to turn the last function call of a function into a tail call. This means that the frame of the caller is removed before the callee is invoked. Note that if you backtrace from a tail-called function the backtrace information will have the caller frame omitted. For example in the code above without the assignment to the global 'i', the call __octeon_print_backtrace would qualify as a tail-call and the first frame printed would be 'main'.</p>
<p>If you compiled with -g you can even trace the pc values back to source line numbers using oct-debuginfo or mipsisa64-octeon-elf-addr2line:</p>
<div class="fragment"><pre class="fragment">
$ oct-debuginfo ./a.out 0x100002e8 0x10000310 0x100002b8

Reading line information
    vi +9 /tmp/bt.c
    vi +16 /tmp/bt.c
    vi +117 /home/anemet/octsw/toolchain/src/newlib/libc/sys/octeon/crt0.S
Reading dwarf information
Function Scope Information:
    f():
      PC range                           = 0x00000000100002d8 - 0x00000000100002fc
      Frame ptr                          = &lt;lowpc=0x0&gt;&lt;highpc=0x4&gt;sp

Function Scope Information:
    main():
      PC range                           = 0x0000000010000300 - 0x0000000010000320
      Frame ptr                          = &lt;lowpc=0x28&gt;&lt;highpc=0x2c&gt;sp

Function Scope Information:
</pre></div><p>Without debug info, you can disassemble the exectuable and see which function the address falls under:</p>
<div class="fragment"><pre class="fragment">
$ mipsisa64-octeon-elf-objdump --prefix-addresses -d a.out | grep 100002e8
100002e8 &lt;f+0x10&gt; li    v0,1
</pre></div><p>On bigger applications we measured an increase of about 4% in the size of the application due to the additional frame information required by backtrace.</p>
<p>As mentioned above by default the compiler will emit frame information. You can override the default behavior by compiling with -fno-asynchronous-unwind-tables or if you use the CVMX build system by defining the makefile variable <b>OCTEON_DISABLE_BACKTRACE</b> in your Makefile. Note that in this case upon machine exception the backtrace information will also be omitted (see <a class="el" href="cvmx_overview.html#interrupt_exception">7.3 Exception Handling</a>).</p>
<p>Frame information for system libraries (libc, etc.) will still be present in the final executable. To remove it, when stripping the executable besides the usual .comment section, also remove the .eh_frame section:</p>
<div class="fragment"><pre class="fragment">
mipsisa64-octeon-elf-strip -R .comment -R .eh_frame a.out
</pre></div><p>Note that the frame information in section .eh_frame is also used in C++ exception handling so if your application is in C++, by removing this section you will break exception handling functionality.</p>
<h3><a class="anchor" id="cpp_library">
3.4 C++ library</a></h3>
<p>The OCTEON toolchain includes the GCC standard C++ and template library.</p>
<h2><a class="anchor" id="hal">
4 Hardware Abstraction Layer (HAL)</a></h2>
<p>The details of communicating with the low level OCTEON hardware requires the programmer to generate specific bitfields and I/O addresses. These operations have been abstracted into a set of libraries and inline functions for faster software development. The header files cvmx-*.h each provide a simplified interface to hardware. Refer to the <a href="files.html">File List</a> for a brief description of each of these files.</p>
<h3><a class="anchor" id="basic_support">
4.1 Basic support</a></h3>
<ul>
<li>cvmx-config.h<ul>
<li>Overall system configuration is present in this file. Applications should customize as needed and include it before any other simple executive header. See the following section (Configuration) for more information about this file.</li>
</ul>
</li>
<li><a class="el" href="cvmx_8h.html">cvmx.h </a><ul>
<li>This provides common macros and inline functions required by all programs running on OCTEON. This file should be the second simple executive header file included, after "cvmx-config.h".</li>
</ul>
</li>
<li><a class="el" href="cvmx-asm_8h.html">cvmx-asm.h </a><ul>
<li>This file provides useful macros for inserting OCTEON specific assembly instructions into C source code. The assembly instructions provide various low level hardware optimizations available in OCTEON directly.</li>
</ul>
</li>
<li><a class="el" href="cvmx-csr_8h.html">cvmx-csr.h </a><ul>
<li>This file defines the hardware addresses used to reference the OCTEON control and status registers (CSRs). The format of each CSR and how to access it is provided in the "cvmx-*.h" file for the associated hardware unit.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="configuration">
4.2 Configuration</a></h3>
<p>Static configuration of the hardware resources are controlled by the include file "cvmx-config.h". This file is generated from the executive-config.h file and other files in the config directory of the application. Please refer to the configuration and build system page for more information. Applications can use this file to control how the global hardware resources are configured / allocated. The following resources are controlled by this file:</p>
<ul>
<li>Free Pool Unit (FPA) block sizes.</li>
<li>FPA pool usage by hardware unit.</li>
<li>Fetch and Add (FAU) register utilization.</li>
<li>Scratch Pad (Scratch) memory allocation.</li>
</ul>
<p>A default configuration file can be found in "cvmx-config.h". Applications needing to modify setting should make a local copy of this file and modify it as needed.</p>
<h3><a class="anchor" id="hal_fau">
4.3 Fetch and Add Unit (FAU) (cvmx-fau.h)</a></h3>
<p>For the CN78XX series the FAU has been replaced with a hardware atomic instruction implementation. For compatibility reasons an emulated FAU exists to support legacy software. See section titled Packet Descriptor Manipulation in <a class="el" href="cn78xx_native.html">CN7XXX native api reference</a> for more information on implementing the hardware counter decrement in the PKO3.</p>
<p>The Fetch and Add Unit (FAU) is a 2 KB register file supporting read, write, atomic fetch-and-add, and atomic update operations. The unit can be accessed from both the Cores and the centralized Packet Output (PKO) unit. The Cores use the FAU for general synchronization purposes, including applications like assigning unique positions for inserting items into shared queues.</p>
<ul>
<li><a class="el" href="cvmx-fau_8h.html#a7106a550071db7ef3d8863b1c024d49e" title="Perform an async atomic 16 bit add.">cvmx_fau_async_fetch_and_add16()</a></li>
<li><a class="el" href="cvmx-fau_8h.html#aba781ca21f14c6ae692798eea92ee58b" title="Perform an async atomic 32 bit add.">cvmx_fau_async_fetch_and_add32()</a></li>
<li><a class="el" href="cvmx-fau_8h.html#aea2f9d0935e8825f69f483dc84cd8c39" title="Perform an async atomic 64 bit add.">cvmx_fau_async_fetch_and_add64()</a></li>
<li><a class="el" href="cvmx-fau_8h.html#a1bbf770365f7a2b557d8d91ae978f4f6" title="Perform an async atomic 8 bit add.">cvmx_fau_async_fetch_and_add8()</a></li>
<li><a class="el" href="cvmx-fau_8h.html#ae8f37a6204791cdeb6e5c9c874c978c5" title="Perform an async atomic 16 bit add after the current tag switch completes.">cvmx_fau_async_tagwait_fetch_and_add16()</a></li>
<li><a class="el" href="cvmx-fau_8h.html#a04bb7bb9ca90ad66d322a6332a4561e0" title="Perform an async atomic 32 bit add after the current tag switch completes.">cvmx_fau_async_tagwait_fetch_and_add32()</a></li>
<li><a class="el" href="cvmx-fau_8h.html#aefb4092490b9fa3303e83145e9914e4e" title="Perform an async atomic 64 bit add after the current tag switch completes.">cvmx_fau_async_tagwait_fetch_and_add64()</a></li>
<li><a class="el" href="cvmx-fau_8h.html#a71626dda78af9c5fbae151249f86552d" title="Perform an async atomic 8 bit add after the current tag switch completes.">cvmx_fau_async_tagwait_fetch_and_add8()</a></li>
<li><a class="el" href="cvmx-fau_8h.html#acbe4ea7e27e029f412b1596d077af530" title="Perform an atomic 16 bit add.">cvmx_fau_atomic_add16()</a></li>
<li><a class="el" href="cvmx-fau_8h.html#a3e07130c3f15d5ef37c32da6176733fc" title="Perform an atomic 32 bit add.">cvmx_fau_atomic_add32()</a></li>
<li><a class="el" href="cvmx-fau_8h.html#a0e0e0eeee65ad4a931158727c2731300" title="Perform an atomic 64 bit add.">cvmx_fau_atomic_add64()</a></li>
<li><a class="el" href="cvmx-fau_8h.html#a266a049bc6b7bb8c9a85e4efc51036ec" title="Perform an atomic 8 bit add.">cvmx_fau_atomic_add8()</a></li>
<li><a class="el" href="cvmx-fau_8h.html#ae067cf7e1fdab38bbacf7f3ba42597b3" title="Perform an atomic 16 bit write.">cvmx_fau_atomic_write16()</a></li>
<li><a class="el" href="cvmx-fau_8h.html#a89d5b3785ca20f9a6a0eba88872b0bbf" title="Perform an atomic 32 bit write.">cvmx_fau_atomic_write32()</a></li>
<li><a class="el" href="cvmx-fau_8h.html#a0d75fae24a7c9e53f178c9ad22b8d004" title="Perform an atomic 64 bit write.">cvmx_fau_atomic_write64()</a></li>
<li><a class="el" href="cvmx-fau_8h.html#aa576a2f7e45e460010cdc33fd33740ff" title="Perform an atomic 8 bit write.">cvmx_fau_atomic_write8()</a></li>
<li><a class="el" href="cvmx-fau_8h.html#a997f7cf811b1497741dfb9ff275daf6a" title="Perform an atomic 16 bit add.">cvmx_fau_fetch_and_add16()</a></li>
<li><a class="el" href="cvmx-fau_8h.html#a9f330650e11946c3e7b24dbd7376cbfd" title="Perform an atomic 32 bit add.">cvmx_fau_fetch_and_add32()</a></li>
<li><a class="el" href="cvmx-fau_8h.html#ac24323aaa5195cacf101aff8adcf90dc" title="Perform an atomic 64 bit add.">cvmx_fau_fetch_and_add64()</a></li>
<li><a class="el" href="cvmx-fau_8h.html#a0aa67b543271608852f3893422183ab0" title="Perform an atomic 8 bit add.">cvmx_fau_fetch_and_add8()</a></li>
<li><a class="el" href="cvmx-fau_8h.html#a68bbb8ade8c948c1a7cca829e8893693" title="Perform an atomic 16 bit add after the current tag switch completes.">cvmx_fau_tagwait_fetch_and_add16()</a></li>
<li><a class="el" href="cvmx-fau_8h.html#a881ceb4bd28ef8106080b3f46d1bcf31" title="Perform an atomic 32 bit add after the current tag switch completes.">cvmx_fau_tagwait_fetch_and_add32()</a></li>
<li><a class="el" href="cvmx-fau_8h.html#a714a497618bc806521848c563f41311c" title="Perform an atomic 64 bit add after the current tag switch completes.">cvmx_fau_tagwait_fetch_and_add64()</a></li>
<li><a class="el" href="cvmx-fau_8h.html#a544dcb6d7883071d637b3e076403d2ce" title="Perform an atomic 8 bit add after the current tag switch completes.">cvmx_fau_tagwait_fetch_and_add8()</a></li>
</ul>
<h3><a class="anchor" id="hal_scratch">
4.4 CPU Cores (scratch) (cvmx-scratch.h)</a></h3>
<p>The L1 cache for each processor may be used for a fast access processor local scratch pad memory area. This area is partitioned off of the L1 cache at initialization time for user program usage. This area can be used for local variables and the results of IOBDMAs. Address offsets are in bytes.</p>
<ul>
<li><a class="el" href="cvmx-scratch_8h.html#a9e526d94cef9af74f163f0f2ca1ea26f" title="Reads an 8 bit value from the processor local scratchpad memory.">cvmx_scratch_read8()</a></li>
<li><a class="el" href="cvmx-scratch_8h.html#a0b1763e68163bd30f763190b487f0720" title="Reads a 16 bit value from the processor local scratchpad memory.">cvmx_scratch_read16()</a></li>
<li><a class="el" href="cvmx-scratch_8h.html#a5854390a9f21b0ac92539cf2fc476b72" title="Reads a 32 bit value from the processor local scratchpad memory.">cvmx_scratch_read32()</a></li>
<li><a class="el" href="cvmx-scratch_8h.html#a565c6efb178aa19efb6e0d52978c5bc2" title="Reads a 64 bit value from the processor local scratchpad memory.">cvmx_scratch_read64()</a></li>
<li><a class="el" href="cvmx-scratch_8h.html#aba280ebc12a08068080a9153dbf38abb" title="Writes an 8 bit value to the processor local scratchpad memory.">cvmx_scratch_write8()</a></li>
<li><a class="el" href="cvmx-scratch_8h.html#a2227253d96dcb3de230ece406dd1e4b5" title="Writes a 32 bit value to the processor local scratchpad memory.">cvmx_scratch_write16()</a></li>
<li><a class="el" href="cvmx-scratch_8h.html#a65f95e3d6f24e0e1f4e1698c28759bc7" title="Writes a 16 bit value to the processor local scratchpad memory.">cvmx_scratch_write32()</a></li>
<li><a class="el" href="cvmx-scratch_8h.html#a5b29a93454bcbe1ddb47fdb880e7706f" title="Writes a 64 bit value to the processor local scratchpad memory.">cvmx_scratch_write64()</a></li>
</ul>
<h3><a class="anchor" id="hal_pow">
4.5 Packet Order / Work Unit (POW) (cvmx-pow.h)</a></h3>
<p>The OCTEON Packet Order / Work Unit is an OCTEON co-processor that provides a number of important functions.</p>
<h3><a class="anchor" id="hal_pow_wq">
4.5.1 Work Queueing</a></h3>
<p>Work is described by an associated work queue entry and may be created by either HW units or Core SW. The OCTEON centralized Packet Input Processing and Input Packet Data Unit (PIP/IPD) hardware creates a work queue entry and submits work for each packet arrival. Core SW can create work queue entries and submit work as desired. The OCTEON packet output (PKO), PCI, Timer (TIM), and Deterministic Finite Automata (DFA) HW units can also submit work queue entries created by Core SW after completing an operation/instruction. POW implements eight input work queues. The different work queues can be used to provide different service levels.</p>
<p>The input work queues can be infinitely large, overflowing to DRAM when necessary.</p>
<h3><a class="anchor" id="hal_pow_ws">
4.5.2 Work Scheduling / Descheduling</a></h3>
<p>Core SW requests work from the POW. The POW selects (i.e. schedules) work for the Core and returns a pointer to the work queue entry that describes the work to Core SW. This off-loads much overhead from the Cores and the coherent memory bus.</p>
<p>All work is not equal since the POW HW supports (16) groups. Each piece of work has an associated group identifier. A configuration variable for each Core specifies the groups that the associated Core will accept when it requests work. This configuration variable is a 16 bit bitmask, one bit per group, so Core SW can specify all possible combinations of groups. The POW HW does not schedule a piece of work if the Core doesn't accept the group associated with the work.</p>
<p>Groups provide a means to execute different functions on different Cores, though all Cores share the same POW HW. For example, packet processing may be pipelined from one group of Cores to another group of Cores, with the first group performing the first stage of work and the next group performing the next stage of work.</p>
<p>A Core can deschedule a piece of work. Deschedule means that the SW running on this Core will not complete the work at this time, and the POW HW should reschedule it later. The POW HW reschedules previously descheduled work at higher priority than it schedules new work from an input queue. Deschedule can be useful in a number of circumstances:</p>
<ul>
<li>It can transfer work from one Core group to another. This is one mechanism to implement "work pipelining".</li>
<li>It can avoid consuming a Core for work that requires a large synchronization delay.</li>
<li>It can make work interruptible.</li>
</ul>
<h3><a class="anchor" id="hal_pow_os">
4.5.3 Ordering and Synchronization of Work</a></h3>
<p>The POW HW associates a 32 bit tag value and a tag type with each piece of work. The work queue entry and the request to add work to an input work queue contain the initial tag value. (This initial tag value may be created by either the centralized input packet processing HW or by Core SW.) Core SW can also later switch the tag/type as the work progresses through different phases of the application. If the same tag value sequences are used by two packets, the packets are ordered.</p>
<p>There are three different tag types:</p>
<ul>
<li>ORDERED - Ordering is guaranteed with this tag type. (Atomicity is not.)</li>
<li>ATOMIC - Ordering and atomicity are guaranteed with this tag type. Two pieces of work cannot simultaneously hold the same ATOMIC tag.</li>
<li>NULL - No ordering is guaranteed with this tag type, and work cannot be in- flight (with respect to the POW HW) with this tag type.</li>
</ul>
<p>The POW HW, in combination with Core SW, uses these tag/type values to order and synchronize related work, and allow unrelated work to be unordered and unsynchronized. This is essential for efficient multi-Core execution. Two pieces of work may be / are related and will be ordered and synchronized when they share the same tag value and tag type. Two pieces of work may be unrelated and will execute entirely in parallel when they have different tag or tag type values.</p>
<p>For example, the tag value may be a hash of the standard TCP five-tuple (IP source address, IP destination address, IP protocol, TCP source port, TCP destination port) defining a "flow". The same flow will have the same tag value, so it may be ordered and synchronized. Different flows will likely have different tag values, so will likely not be ordered and synchronized, and can be executed completely in parallel on different Cores.</p>
<p>At different code phases, Core SW can change the tag value via a tag switch transaction with separated switch request and switch completion wait operations. The POW HW completes a requested switch when the required ordering and atomicity constraints for the work are met. This separated switch transaction allows SW to overlap the switch request latency with other profitable work and also allows SW the option to deschedule the work while a tag switch is pending, thus avoiding long synchronization delays.</p>
<p><a class="el" href="cvmx-pow_8h.html">POW Consistency Checks </a> provide more debugging information.</p>
<h3><a class="anchor" id="hal_pow_fl">
4.5.4 cvmx-pow.h function list</a></h3>
<ul>
<li><a class="el" href="cvmx-pow_8h.html#a3dffdb3430e009aebf426ffa26280ee7" title="Descchedules the current work queue entry.">cvmx_pow_desched()</a></li>
<li><a class="el" href="cvmx-pow_8h.html#a7b9f77dee05f3edb929830e40a0a0ace" title="This function sets the group mask for a core.">cvmx_pow_set_group_mask()</a></li>
<li><a class="el" href="cvmx-pow_8h.html#a7ee758c45cbfbcb9afe7d3ebecea16b2" title="This function creates a 32 bit tag value from the two values provided.">cvmx_pow_tag_compose()</a></li>
<li><a class="el" href="cvmx-pow_8h.html#abe64d694f7cbf5d8f8f8d77229baf30e" title="Extracts the bits allocated for hardware use from the tag.">cvmx_pow_tag_get_hw_bits()</a></li>
<li><a class="el" href="cvmx-pow_8h.html#adeb42784c4007b00c9d2ecd8827f04fc" title="Extracts the bits allocated for software use from the tag.">cvmx_pow_tag_get_sw_bits()</a></li>
<li><a class="el" href="cvmx-pow_8h.html#add5b9784e9c8d6f7fda874963d1c958a" title="Starts a tag switch to the provided tag value and tag type.">cvmx_pow_tag_sw()</a></li>
<li><a class="el" href="cvmx-pow_8h.html#a8d7be99e09a7452658cc12c6cc320f60" title="Starts a tag switch to the provided tag value and tag type.">cvmx_pow_tag_sw_nocheck()</a></li>
<li><a class="el" href="cvmx-pow_8h.html#a5c0507e9aceb32eb26c04c08881a917f" title="Starts a tag switch to the provided tag value and tag type.">cvmx_pow_tag_sw_full()</a></li>
<li><a class="el" href="cvmx-pow_8h.html#ada0c34dfc5a7fcd0b819e3e151bc60d1" title="Starts a tag switch to the provided tag value and tag type.">cvmx_pow_tag_sw_full_nocheck()</a></li>
<li><a class="el" href="cvmx-pow_8h.html#a373ce7f3ed51f6a682828711cfe235ff" title="Performs a tag switch and then an immediate deschedule.">cvmx_pow_tag_sw_desched()</a></li>
<li><a class="el" href="cvmx-pow_8h.html#a081fe0f3083c2bff75a9b8d1b7429712" title="Performs a tag switch and then an immediate deschedule.">cvmx_pow_tag_sw_desched_nocheck()</a></li>
<li><a class="el" href="cvmx-pow_8h.html#a8948068d2bbabae2035789bbf82b9883" title="Switch to a NULL tag, which ends any ordering or synchronization provided by the...">cvmx_pow_tag_sw_null()</a></li>
<li><a class="el" href="cvmx-pow_8h.html#a0ad916abec85508425ed6d68b81ddec8" title="Switch to a NULL tag, which ends any ordering or synchronization provided by the...">cvmx_pow_tag_sw_null_nocheck()</a></li>
<li><a class="el" href="cvmx-pow_8h.html#a1ff579bf32ccc0cdbcef8c23eaa53090" title="Waits for a tag switch to complete by polling the completion bit.">cvmx_pow_tag_sw_wait()</a></li>
<li><a class="el" href="cvmx-pow_8h.html#a41ec9612ff526f63468c4e94ce03127b" title="Checks if a work queue entry pointer returned by a work request is valid.">cvmx_pow_work_invalid()</a></li>
<li><a class="el" href="cvmx-pow_8h.html#ab7f66e0dbe686746ec48dc25c7602645" title="Asynchronous work request.">cvmx_pow_work_request_async()</a></li>
<li><a class="el" href="cvmx-pow_8h.html#a0477e774db62c60e5b1ad2d04c44eedf" title="Asynchronous work request.">cvmx_pow_work_request_async_nocheck()</a></li>
<li><a class="el" href="cvmx-pow_8h.html#a663a32115088b6888949303edea06e5f" title="Synchronous work request.">cvmx_pow_work_request_sync()</a></li>
<li><a class="el" href="cvmx-pow_8h.html#acb89059e31f202c79fb282e7c3647153" title="Synchronous work request.">cvmx_pow_work_request_sync_nocheck()</a></li>
<li><a class="el" href="cvmx-pow_8h.html#a371aef3eb06e4a961607623fba6fd330" title="Gets result of asynchronous work request.">cvmx_pow_work_response_async()</a></li>
<li><a class="el" href="cvmx-pow_8h.html#a6e11dd31e57dce2059d4e653fa54f8ee" title="Synchronous null_rd request.">cvmx_pow_work_request_null_rd()</a></li>
<li><a class="el" href="cvmx-pow_8h.html#afa6ed62ed9357ec3c2b32c5534003aa3" title="Submits work to an input queue.">cvmx_pow_work_submit()</a></li>
</ul>
<h3><a class="anchor" id="hal_fpa">
4.6 Free Pool Unit (FPA) (cvmx-fpa.h)</a></h3>
<p>The FPA unit maintains eight infinite-size pools of pointers to free L2/DRAM memory. Both Core SW and other OCTEON HW units allocate and free pointers from/to the pools. Core SW and the centralized input packet processing HW units allocate memory from the pools. Core SW, the OCTEON centralized output packet processing, PCI, Deterministic Finite Automata (DFA), and Timer (TIM) HW units free memory to the pools.</p>
<p>The FPA HW implements a logical stack/LIFO for each free pointer pool. The FPA HW unit stores/caches the top of the stacks in the unit at all times. When a pool is too large to fit in the in-unit store, the FPA builds a list data structure in L2/ DRAM using the free memory in the pool to store the extra pointers. Each pool's size is unlimited due to this technique.</p>
<p>The only constraint required by the FPA HW is that pointers submitted to the free pools must be aligned on a 128 byte boundary and the free memory must be 128 bytes or more. The free memory size can be different in different pools and, in fact, can also be different within the same pool.</p>
<p>FPA support functions in "cvmx-fpa.h":</p>
<ul>
<li><a class="el" href="cvmx-fpa_8h.html#a862613eb44a7557a5daae94a2c1406c7" title="Get a new block from the FPA.">cvmx_fpa_alloc()</a></li>
<li><a class="el" href="cvmx-fpa_8h.html#a46dcab0f4db084075c39823c091e1344" title="Asynchronously get a new block from the FPA.">cvmx_fpa_async_alloc()</a></li>
<li><a class="el" href="cvmx-fpa_8h.html#a37d454b978e09493678d18062e644748" title="Retrieve the result of cvmx_fpa_async_alloc.">cvmx_fpa_async_alloc_finish()</a></li>
<li><a class="el" href="cvmx-fpa_8h.html#a00e0fc098e5aee9612a87982279d248c" title="Enable the FPA.">cvmx_fpa_enable()</a></li>
<li><a class="el" href="cvmx-fpa_8h.html#a953ef29fcfef0ca074e2cfc1c294e4bf" title="Free a block allocated with a FPA pool.">cvmx_fpa_free()</a></li>
<li><a class="el" href="cvmx-fpa_8h.html#a2996c6e5ed5a0e93f0ea28fd7940d5e9" title="Free a block allocated with a FPA pool.">cvmx_fpa_free_nosync()</a></li>
<li><a class="el" href="cvmx-fpa_8c.html#af10e81d923cb57c742f99b260be9fa35" title="Return the size of buffers held in a buffer pool.">cvmx_fpa_get_block_size()</a></li>
<li><a class="el" href="cvmx-fpa_8c.html#aa716a67e2dc7d2badf79b9c56d2c0a22" title="Return the name of an FPA pool.">cvmx_fpa_get_name()</a></li>
<li><a class="el" href="cvmx-fpa_8c.html#a611806f7fdb4a36b52ca0d5cfc326ce5" title="Setup an FPA pool with buffers.">cvmx_fpa_setup_pool()</a></li>
<li><a class="el" href="cvmx-fpa_8c.html#a575b6e9903d1ea75310bc2ddf897ed7f" title="Shutdown a Memory pool and validate that it had all of the buffers originally placed...">cvmx_fpa_shutdown_pool()</a></li>
</ul>
<h3><a class="anchor" id="hal_pip">
4.7 Packet Input Processing and Input Packet Data Unit (PIP/IPD) (cvmx-pip.h, cvmx-ipd.h, cvmx-wqe.h)</a></h3>
<p>Note: The CN78XX series has replaced the PIP/IPD units with the programmable PKI interface. For compatibility reasons most functions now wrap PKI functionality. Please see <a class="el" href="cn78xx_native.html">CN7XXX native api reference</a> for more information on native PKI programming and <a class="el" href="cvmx_backward.html">CN7XXX backward compatibility support</a> for information on compatibility mode considerations.</p>
<p>The OCTEON Centralized Packet Input Processing and Input Packet Data Unit (PIP/IPD) receives packet input data from any of the RGMII, SPI4.2, or PCI interfaces. It can have a combined total of up to 36 input ports for receiving packets between all these sources. This effectively means that PIP/IPD supports a total of up to 36 simultaneous in-flight packets. The packets arriving on the different ports share the same PIP/IPD HW resources, but logically the PIP/IPD HW treats the different in-flight packets independently.</p>
<p>The PIP/IPD units allocate and write packet data into buffers in a format that is convenient to higher-layer SW. The unit supports a programmable buffer size (with pads at the top and bottom for SW use), and can distribute packet data across multiple buffers to support large packet input sizes.</p>
<p>The PIP/IPD also allocates and creates a work queue entry for each packet. This work queue entry contains a pointer to the buffered packet, HW parsing results, and packet error checks. The unit performs many L2-L4 checks, including the TCP/UDP checksum check. The unit can skip over a programmable amount of user-defined input data before parsing the input packet. This is useful for user- defined headers passed with the packets.</p>
<p>PIP support functions in "cvmx-pip.h":</p>
<ul>
<li><a class="el" href="cvmx-pip_8h.html#a2fd246fbdebbbe7de057079c8aac452d" title="Configure the hardware CRC engine.">cvmx_pip_config_crc()</a></li>
<li><a class="el" href="cvmx-pip_8h.html#ae1dab1497fe2b16ad924912b514a791b" title="Configure the Diffserv to QoS queue mapping.">cvmx_pip_config_diffserv_qos()</a></li>
<li><a class="el" href="cvmx-pip_8h.html#a3ea0a3b94e416a0050898d5ce2d80d13" title="Configure an ethernet input port.">cvmx_pip_config_port()</a></li>
<li><a class="el" href="cvmx-pip_8h.html#a45f08a612f53311a019f720d3fd3b627" title="Configure the VLAN priority to QoS queue mapping.">cvmx_pip_config_vlan_qos()</a></li>
<li><a class="el" href="cvmx-pip_8h.html#a8aeb8823c52e2453e56f0e15c693261f" title="Get the status counters for a port.">cvmx_pip_get_port_status()</a></li>
</ul>
<p>IPD support functions in "cvmx-ipd.h":</p>
<ul>
<li><a class="el" href="cvmx-ipd_8c.html#a8905a24c5da8481f6c890f650e6bd688" title="Configure IPD.">cvmx_ipd_config()</a></li>
<li><a class="el" href="cvmx-ipd_8c.html#a8dd2366b7f821f3fd600446c79e74956" title="Enable IPD.">cvmx_ipd_enable()</a></li>
</ul>
<h3><a class="anchor" id="hal_pko">
4.8 Packet Output Unit (PKO) (cvmx-pko.h)</a></h3>
<p>The OCTEON Centralized Packet Output Processing (PKO) unit gathers packet data from L2/DRAM and sends it out on any of the RGMII, SPI4.2, or PCI interfaces. It can have a combined total of up to 36 output ports for sending packets between all these destinations. This effectively means that PKO supports a total of up to 36 simultaneous in-flight packets. The packets sent out to the different ports share some of the same PKO HW resources, but logically the PKO unit treats the different in-flight packets independently.</p>
<p>The <a class="el" href="cvmx-pko_8h.html">PKO Description </a> and <a class="el" href="cvmx-cmd-queue_8h.html">Common Command Queue Description </a> provide more information.</p>
<p>Note: The CN78XX series has replaced the PKO unit with the advanced PKO3 interface. For compatibility reasons most functions now wrap PKO functionality. Please see <a class="el" href="cn78xx_native.html">CN7XXX native api reference</a> for more information on native PKO3 programming and <a class="el" href="cvmx_backward.html">CN7XXX backward compatibility support</a> for information on compatibility mode considerations.</p>
<p>PKO support functions in "cvmx-pko.h":</p>
<ul>
<li><a class="el" href="cvmx-hwpko_8h.html#af5569b7891fa94378b14f0dac78587cd" title="Configure a output port and the associated queues for use.">cvmx_pko_config_port()</a></li>
<li><a class="el" href="cvmx-hwpko_8h.html#a66a1d85fe314d81d4594c9db513fa2f5" title="Disables the packet output.">cvmx_pko_disable()</a></li>
<li><a class="el" href="cvmx-hwpko_8h.html#a868163501dfa27203da4081e3befaae8" title="Ring the packet output doorbell.">cvmx_pko_doorbell()</a></li>
<li><a class="el" href="cvmx-hwpko_8h.html#a696746d06c04a8b7e4160ac28092b528" title="Enables the packet output hardware.">cvmx_pko_enable()</a></li>
<li><a class="el" href="cvmx-helper-pko_8h.html#a18ac15237a011ee8002745916674a542">cvmx_pko_initialize_local()</a></li>
<li>cvmx_pko_initialize_global()</li>
<li><a class="el" href="cvmx-hwpko_8h.html#ac3816ce23cea85ff80bef465ad700bf8" title="Prepare to send a packet.">cvmx_pko_send_packet_prepare()</a></li>
<li><a class="el" href="cvmx-pko_8h.html#a9417ad93d9e655b79e90456b2db5ab21" title="Complete packet output.">cvmx_pko_send_packet_finish()</a></li>
<li><a class="el" href="cvmx-pko_8h.html#ad01aab1e0d6ab87ce4bbe64a371934ce" title="Complete packet output.">cvmx_pko_send_packet_finish3()</a></li>
<li><a class="el" href="cvmx-hwpko_8h.html#aa702a8cdbe4458b25598fd821c50222d" title="Shutdown and free resources required by packet output.">cvmx_pko_shutdown()</a></li>
</ul>
<h3><a class="anchor" id="hal_llm">
4.9 Low-Latency Memory (LLM) (cvmx-llm.h)</a></h3>
<p>Cavium's OCTEON CN38XX/CN36XX processors support two dedicated low-latency memory channels (in addition to main DDR-II memory interface) for storing/walking DFA graphs. The OCTEON CN31XX processors support one channel of DDR2 SDRAM for DFA graphs and direct core access. The low latency memory may be accessed in two widths: narrow and wide. The use of LLM across the OCTEON family is very similar even though the widths do vary betwen the CN38XX/CN36XX and CN31XX. Please refer to the HRM for details on LLM access widths and data formats.</p>
<p>The OCTEON processor supports two modes of access to the dedicated low latency memory channels, namely:</p>
<ul>
<li>HW-Assist Mode: Each Cavium-MIPS (CM) core writes a predefined DFA macro- instruction to main memory which is then assigned to one (of 16) DFA hardware thread engines. A hardware thread engine will walk the DFA graph to completion and will also write search results to main memory. The initiating CAVIUM-MIPS can be alerted of the macro-instruction completion either by polling or by a work queue interrupt.</li>
</ul>
<ul>
<li>Direct-CAVIUM-MIPS Mode: Each CM core has direct read/write access to LLM memory over a dedicated low-latency bus using special Cavium MIPS coprocessor instructions.</li>
</ul>
<p>Both of these access modes can be used simultaneously to provide optimal flexibility and performance.</p>
<p>LLM support functions in "cvmx-llm.h":</p>
<ul>
<li><a class="el" href="cvmx-llm_8h.html#a8559b1511c7822b1a6904754eab4e4f3" title="Calculate the ECC needed for 36b LLM mode.">cvmx_llm_ecc()</a></li>
<li><a class="el" href="cvmx-llm_8h.html#aba9a8a6bd711dc2ad2e75ad6356a8427" title="Calculate the parity value of a number.">cvmx_llm_parity()</a></li>
<li><a class="el" href="cvmx-llm_8h.html#a55cee17cf98ad05d05b6271bfa8ed62a" title="Read from LLM memory - 36 bit.">cvmx_llm_read_narrow()</a></li>
<li><a class="el" href="cvmx-llm_8h.html#a94a1ba14fae6f47350d557e46f9e1866" title="Read from LLM memory - 64 bit.">cvmx_llm_read_wide()</a></li>
<li><a class="el" href="cvmx-llm_8h.html#ac8235504cf9d65da1dd0ff12f36b3abd" title="Write to LLM memory - 36 bit.">cvmx_llm_write_narrow()</a></li>
<li><a class="el" href="cvmx-llm_8h.html#ad8511c9827ab28c0e1936e0ed9921a90" title="Write to LLM memory - 64 bit.">cvmx_llm_write_wide()</a></li>
</ul>
<p>The following functions are deprecated, and have been replaced by the read/write narrow/wide functions. Compatability macros are provided ease the transition. The compatability macros are scheduled to be removed from the 1.4.0 SDK release.</p>
<ul>
<li><a class="el" href="cvmx-llm_8h.html#a703cb043cb1e727fe8797296814fd12f">cvmx_llm_read36()</a></li>
<li><a class="el" href="cvmx-llm_8h.html#a6c3dc181cb163ae0694d18e85b7322ed">cvmx_llm_read64()</a></li>
<li><a class="el" href="cvmx-llm_8h.html#ac64f14b84a0f2ac696d8cd0b043ef723">cvmx_llm_write36()</a></li>
<li><a class="el" href="cvmx-llm_8h.html#a3e1d7ff04cd81872e21088bd944469f2">cvmx_llm_write64()</a></li>
</ul>
<h3><a class="anchor" id="hal_dfa">
4.10 Deterministic Finite Automata Unit (DFA) (cvmx-dfa.h)</a></h3>
<p>The OCTEON processor contains multiple DFA hardware engines (threads), each capable of walking DFA graph(s) stored across two dedicated, low-latency memory channels. DFA graphs may be replicated across multiple internal banks and across both ports (if populated), to reduce the effects of bank conflicts caused by back to back accesses to the same bank. Each DFA graph can be redundantly stored within 1, 2, 4, or 8 internal banks and also across both channels. In this manner, DFA graph access can then be effectively `load balanced' across the `least used bank/channel' to provide extremely low and predictable DFA graph latencies and high aggregate throughput.</p>
<p>The DFA hardware engines are treated as a pool of co-processors available to all of the CM processors. To initiate a DFA walk, a CM core writes a fixed-size/format DFA macro-instruction (created by <a class="el" href="cvmx-dfa_8h.html#a78fcad577462392bd74bb58a39c9c91f" title="Submit work to the DFA units for processing.">cvmx_dfa_submit()</a>) into main memory which contains information for the hardware engine to perform the DFA graph walk. The DFA hardware engine starts its graph walk from the node specified by DFA graph base + starting node offset. Each node contains 256 arcs. The size of each arc in memory is defined by the graph type (2 Bytes in small mode or 4 Bytes in large mode).</p>
<p>The 8-bit character from the input packet data is used as an index into 1-of-256 arcs within the starting node. The DFA hardware engine then fetches the next-arc and uses it to determine the next node. The next 8-bit character from the input packet data is again used as an index into 1-of-256 arcs within this next node.</p>
<p>This process is repeated until either a) all the packet input data is exhausted or b) a terminal node is reached c) the specified match result buffer becomes full or d) a parity error is detected. A `match' is noted whenever a node marked as `match' is visited. During the DFA walk, for each match detected, intermediate results are written into a specified result buffer. The content of the intermediate results contains the character offset, and pointers to the previous and marked states of the DFA graph. If the input data is exhausted before a terminal node is reached, the DFA context is written to the result buffer and control is returned to the requesting packet processor through either an interrupt (work queue entry) or via software polling. The last entry in the result buffer will contain the DFA context which contains the input data length and also the current state of the DFA graph. This facilitates packets which span multiple input data segments, so that subsequent search requests may pick up where the previous search left off. The DFA engine also supports a packet gather mode, which allows a user to specify a gather-pointer list, which allows multi-segmented packets to be auto-traversed by the DFA hardware itself.</p>
<p>For simple strings (no wildcards) the size of a DFA graph will be bounded by the sum of the characters of all the strings, although there may be some slight overhead to distinguish the type of the node. The time complexity of a DFA search is one memory access per input byte. This is independent of the number of strings in the DFA graph. A single search is limited in performance by the round trip of presenting an address (to DRAM), reading the DRAM data, and computing the next address. This limitation is mitigated in two ways: using lower latency RLDRAMs and having many independent searches happening in parallel.</p>
<div class="fragment"><pre class="fragment">
DFA Performance Details with random data distribution (CN38XX)
  Replication       Threads      Max Nodes              Bandwidth
       1x              1             1M                  220Mb/s
       1x              16            1M                 2610Mb/s
       2x              16           512K                2690Mb/s
       4x              16           256K                2800Mb/s
       8x              16           128K                3070Mb/s
</pre></div><p>The above table shows performance for various configurations assuming a random bank distribution of the data. Replicating the graph increases performance but at a cost to maximum capacity. This is programmable per graph. A single thread typically requires ~20 cycles per byte of data searched. Increasing the number of threads increases the latency of an individual thread (through memory contention) and increases the aggregate performance (by having more parallelism.)</p>
<p>DFA support functions in "cvmx-dfa.h":</p>
<ul>
<li><a class="el" href="cvmx-dfa_8c.html#a4e442b9d2be96f738b83f6289abd4c4d" title="Initialize the DFA hardware before use Returns 0 on success, -1 on failure.">cvmx_dfa_initialize()</a></li>
<li><a class="el" href="cvmx-dfa_8h.html#a00f53c037b19ff2d219de62af51fcd82" title="Check if a DFA has completed processing.">cvmx_dfa_is_done()</a></li>
<li><a class="el" href="cvmx-dfa_8c.html#addadfcf85d6fdf0f6a3d964db0c2863e" title="Shutdown and cleanup resources used by the DFA.">cvmx_dfa_shutdown()</a></li>
<li><a class="el" href="cvmx-dfa_8h.html#a78fcad577462392bd74bb58a39c9c91f" title="Submit work to the DFA units for processing.">cvmx_dfa_submit()</a></li>
<li><a class="el" href="cvmx-dfa_8h.html#ad2b0f8d4a245eb80b0964b77149da5cc" title="Ring the DFA doorbell telling it that new commands are available.">cvmx_dfa_write_doorbell()</a></li>
<li><a class="el" href="cvmx-dfa_8h.html#adec302b5e5a42a5ad846d73f53f33130" title="Write a small node edge to LLM.">cvmx_dfa_write_edge_sm()</a></li>
<li><a class="el" href="cvmx-dfa_8h.html#a5866285a2122d9607955dbc603e007a8" title="Write a large node edge to LLM.">cvmx_dfa_write_node_lg()</a></li>
</ul>
<h3><a class="anchor" id="hal_pci">
4.11 PCI Unit (PCI) (cvmx-pci.h, cvmx-npi.h)</a></h3>
<p>The OCTEON supports three types of transfers over the PCI interface:</p>
<ul>
<li>Memory mapped: The OCTEON supports memory mapped PCI transactions as host or target and master or slave. It provides several Base Address Registers (BARs) each with configurable attributes.</li>
<li>Packet IO: Packet IO over the PCI bus goes through the PIP/IPD and packets can be processed in the same way by hardware as if they came in over ethernet or SPI interfaces. In addition, a 'raw' packet mode is supported that bypasses this processing and allows the host to provide a WQE for each packet.</li>
<li>DMA: OCTEON provides two general purpose bidirectional PCI&lt;-&gt;DRAM DMA engines. The DMA engines use <a class="el" href="structdescriptor.html">descriptor</a> rings to interface with the cnMIPS cores and external processors.</li>
</ul>
<p>For more information please refer to the hardware manual.</p>
<h3><a class="anchor" id="hal_tim">
4.12 Timer Unit (TIM) (cvmx-tim.h)</a></h3>
<p>The OCTEON Timer consists of 16 bucketed rings held in L2/DRAM.</p>
<ul>
<li>SW can program a separate ring per Core.</li>
<li>Each bucket corresponds to a different time slice.</li>
<li>Each ring has a programmable number of buckets.</li>
<li>Each ring has a programmable time interval between buckets. At each periodic bucket time expiration, HW processes the next bucket.</li>
<li>Each timer entry within a bucket may be a work queue entry pointer that HW submits.</li>
<li>A Bucket is a chunked list, and HW frees chunks (to a HW pool) after using them.</li>
<li>HW also resets the bucket data structure. The HW traverses up to 80 million timer entries per second.</li>
</ul>
<p>SW inserts work queue entries into the appropriate bucket.</p>
<ul>
<li>SW allocates bucket chunks as needed</li>
<li>SW can remove added entries from the bucket later by re-writing the entry to NULL (before the HW processes the bucket).</li>
</ul>
<div align="center">
<img src="inline_dotgraph_21.dot.png" alt="inline_dotgraph_21.dot" border="0" usemap="#inline_dotgraph_21.dot.map">
<map name="inline_dotgraph_21.dot.map" id="inline_dotgraph_21.dot.map"></map>
</div>
<p>The simple executive timer library provides a simplified interface to the hardware timers by hiding the low level details of chunk and bucket allocations. Each timer is assigned to a single core to limit contention and locking requirements. All timers are setup (using cvmx_tim_setup) with the same bucket interval (period_cycles) and number of buckets (CVMX_TIM_NUM_BUCKETS=2048). This limits the maximum timer duration to (CVMX_TIM_NUM_BUCKETS - 1) * period_cycles and minimum to 2 * period_cycles. Allocation of bucket chunks is hidden inside of <a class="el" href="cvmx-tim_8h.html#ae17b378539c0585c6bbc8e27bf88568b" title="Add a work queue entry to the timer.">cvmx_tim_add_entry()</a>.</p>
<p>Timer support functions in "cvmx-tim.h":</p>
<ul>
<li><a class="el" href="cvmx-tim_8h.html#ae17b378539c0585c6bbc8e27bf88568b" title="Add a work queue entry to the timer.">cvmx_tim_add_entry()</a></li>
<li><a class="el" href="cvmx-tim_8h.html#ac7a93ab86146c8742f6e413c0d55c222" title="Delete a timer entry scheduled using cvmx_tim_add_entry.">cvmx_tim_delete_entry()</a></li>
<li><a class="el" href="cvmx-tim_8c.html#ac07d6a9236b4809b8ee56ae3efc811c4" title="Setup a timer for use.">cvmx_tim_setup()</a></li>
<li><a class="el" href="cvmx-tim_8c.html#a7eb18ce633da47d952026a3a2ed0e691" title="Stop the timer.">cvmx_tim_shutdown()</a></li>
<li><a class="el" href="cvmx-tim_8c.html#a65b230b7a48c995d2585c356c25a9490" title="Start the hardware timer processing.">cvmx_tim_start()</a></li>
<li><a class="el" href="cvmx-tim_8c.html#ac769622414ae3622d884a97748146413" title="Stop the hardware timer processing.">cvmx_tim_stop()</a></li>
</ul>
<h3><a class="anchor" id="hal_uart">
4.13 UART Unit (UART) (cvmx-uart.h)</a></h3>
<p>The OCTEON supports two serial uarts based on the industry standard 16550 programatic interface. The two independent uarts are configured by the simple executive automatically. Uart 0 is used as a console for the boot loader and C libraries. Uart 1 is reserved for communications with the debugger. The simulator, by default, prints all uart output to stdout. If the "-uartX=port" argument is used with the simulator, it creates a listening port for incoming TCP connections. Serial input and output is then sent through this connection. For example, you can receive console output from the simulator in another window by connecting a telnet session to the simulator uart port.</p>
<div class="fragment"><pre class="fragment">        terminal 1: $ oct-sim hello -uart0=2020 -quiet -noperf
        terminal 2: $ telnet localhost 2020
</pre></div><p>Programming the uarts is performed using the CSRs beginning with "CVMX_MIO_UARTX_". Documentation for how each CSR is accessed is defined in "cvmx-uart.h". For interrupt based communications, it is also necessary to program the CIU to enable uart interrupts. Uart examples for both polled and interrupt driven communications can be found in "sdk/examples/uart".</p>
<h3><a class="anchor" id="hal_ciu">
4.14 Central Interrupt Unit (CIU)</a></h3>
<p>The Central Interrupt Unit (CIU) controls the routing of interrupt requests to the processing cores. Interrupts generated by the POW, UART, and other units may be routed to any of the available cores. Once interrupt signals are routed to a core, use cvmx-interrupt to register a handler. More information about interrupt processing can be found in the "Exception and Interrupt
    Handling" section.</p>
<h3><a class="anchor" id="hal_key">
4.15 Key Memory (KEY) (cvmx-key.h)</a></h3>
<p>Key memory is 8k on chip that is inaccessible from off chip. It can also be cleared using an external hardware pin.</p>
<ul>
<li><a class="el" href="cvmx-key_8h.html#a5d7a521bd78f016d7263beb2335af8c8" title="Read from KEY memory.">cvmx_key_read()</a></li>
<li><a class="el" href="cvmx-key_8h.html#ac66f33a5298ea5b99c5d94c0f4a050f3" title="Write to KEY memory.">cvmx_key_write()</a></li>
</ul>
<h3><a class="anchor" id="hal_rng">
4.16 Random Number Generator (RNG)</a></h3>
<ul>
<li><a class="el" href="cvmx-rng_8h.html#a95de36fc48fff33fb5e830800d39139e" title="Enables the random number generator.">cvmx_rng_enable()</a></li>
<li><a class="el" href="cvmx-rng_8h.html#a52b65d5eaaf792858bf0a34032b8c9d9" title="Reads 8 bits of random data from Random number generator.">cvmx_rng_get_random8()</a></li>
<li><a class="el" href="cvmx-rng_8h.html#ad913952c77a80e2bf0b65f6a2bb992d0" title="Reads 16 bits of random data from Random number generator.">cvmx_rng_get_random16()</a></li>
<li><a class="el" href="cvmx-rng_8h.html#a286b7e123f007636c57e3d8c68e6829a" title="Reads 32 bits of random data from Random number generator.">cvmx_rng_get_random32()</a></li>
<li><a class="el" href="cvmx-rng_8h.html#ac860e47d4767c525257cb32d6e143651" title="Reads 64 bits of random data from Random number generator.">cvmx_rng_get_random64()</a></li>
<li><a class="el" href="cvmx-rng_8h.html#a370659d5d8b05fc162d0bd96bda2aa5b" title="Requests random data from the RNG block asynchronously using and IOBDMA operation...">cvmx_rng_request_random_async()</a></li>
</ul>
<h3><a class="anchor" id="hal_tra">
4.17 Performance Trace Buffer (TRA)</a></h3>
<p>The performance trace buffer allows applications to collect detailed performance data of OCTEON during code execution.</p>
<p>Writing the trace buffer:</p>
<p>When the trace is enabled, commands are traced continuously (wrapping) or until the buffer is filled once (no wrapping). Additionally and independent of wrapping, tracing can be temporarily enabled and disabled by the tracing triggers. All XMC commands can be traced except for IDLE and IOBRSP. The subset of XMC commands that are traced is determined by the filter and the two triggers, each of which is comprised of masks for command, sid, did, and address). If triggers are disabled, then only those commands matching the filter are traced. If triggers are enabled, then only those commands matching the filter, the start trigger, or the stop trigger are traced during the time between a start trigger and a stop trigger.</p>
<p>For a given command, its XMC data is written immediately to the buffer. If the command has XMD data, then that data comes in-order at some later time. The XMD data is accumulated across all valid XMD cycles and written to the buffer or to a shallow fifo. Data from the fifo is written to the buffer as soon as it gets access to write the buffer (i.e. the buffer is not currently being written with XMC data). If the fifo overflows, it simply overwrites itself and the previous XMD data is lost.</p>
<p>Reading the trace buffer:</p>
<p>Each entry of the trace buffer is read by a CSR read command. The trace buffer services each read in order, as soon as it has access to the (single-ported) trace buffer.</p>
<p>Overflow, underflow and threshold events:</p>
<p>The trace buffer maintains a write pointer and a read pointer and detects both the overflow and underflow conditions. Each time a new trace is enabled, both pointers are reset to entry 0. Normally, each write (traced event) increments the write pointer and each read increments the read pointer. During the overflow condition, writing (tracing) is disabled. Tracing will continue as soon as the overflow condition is resolved. The first entry that is written immediately following the overflow condition may be marked to indicate that a tracing discontinuity has occurred before this entry. During the underflow condition, reading does not increment the read pointer and the read data is marked to indicate that no read data is available.</p>
<p>The full threshold events are defined to signal an interrupt a certain levels of "fullness" (1/2, 3/4, 4/4). "fullness" is defined as the relative distance between the write and read pointers (i.e. not defined as the absolute distance between the write pointer and entry 0). When enabled, the full threshold event occurs every time the desired level of "fullness" is achieved.</p>
<p>The data structures required to access the trace buffer are documented in "cvmx-tra.h".</p>
<h3><a class="anchor" id="hal_zip">
4.18 ZIP (deflate) compression/decompression block (cvmx-zip.h)</a></h3>
<p>This block provides a hardware implementation of the deflate compression algorithm. The <a class="el" href="cvmx-zip_8h.html" title="Header file for the zip (deflate) block.">cvmx-zip.h</a> header file provides structure defintions for zip block hardware structures and configuration registers. The zip block uses a chunked input queue for instructions that control the compression/decompression operations that it performs. Once all instructions from a chunk are processed, the zip block frees the chunk to configured free pool (much like the PKO unit does.) Each instruction specifies one compression or decompression operation that can operate on a gather list for input data and a scatter list for output data. On completion of an instruction, the zip block updates the result structure specified in the instruction.</p>
<h3><a class="anchor" id="hal_l2c">
4.19 Level 2 Cache  (cvmx-l2c.h)</a></h3>
<p>The level 2 cache controller supports locking and partitioning of the cache. Functions are provided to partition, lock, and unlock portions of the L2 cache. Please refer to the HRM for details on cache locking and partitioning. The L2 controller also offers 4 performance counters that can count a wide variety of events.</p>
<ul>
<li><a class="el" href="cvmx-l2c_8c.html#a99da46bd27c9ab9e3bbca2482deafed8">cvmx_l2c_config_perf()</a></li>
<li><a class="el" href="cvmx-l2c_8c.html#a26232788686ae9eef6ba052a28ed1072" title="Read the given L2 Cache performance counter.">cvmx_l2c_read_perf()</a></li>
<li><a class="el" href="cvmx-l2c_8c.html#aa59b0d0de27ea39f19eee6f6180600f8" title="Return the L2 Cache way partitioning for a given core.">cvmx_l2c_get_core_way_partition()</a></li>
<li><a class="el" href="cvmx-l2c_8c.html#acfe348d22f95e9399a7645d2495a914d" title="Partitions the L2 cache for a core.">cvmx_l2c_set_core_way_partition()</a></li>
<li><a class="el" href="cvmx-l2c_8c.html#abe33bf3c58e816363d8bfb496bc0730a" title="Return the L2 Cache way partitioning for the hw blocks.">cvmx_l2c_get_hw_way_partition()</a></li>
<li><a class="el" href="cvmx-l2c_8c.html#a2229bce8dad9aaf52a7645a8a7bbba01" title="Partitions the L2 cache for the hardware blocks.">cvmx_l2c_set_hw_way_partition()</a></li>
<li><a class="el" href="cvmx-l2c_8c.html#a26ea890e5d5f192ca5d3fa251d51813b" title="Locks a line in the L2 cache at the specified physical address.">cvmx_l2c_lock_line()</a></li>
<li><a class="el" href="cvmx-l2c_8c.html#a052ab548e1a5f54e4c57a7a9e6d71f8d" title="Locks a specified memory region in the L2 cache.">cvmx_l2c_lock_mem_region()</a></li>
<li><a class="el" href="cvmx-l2c_8c.html#ad40a8f486ddfbde89f5f898b8ac2177c" title="Unlock and flush a cache line from the L2 cache.">cvmx_l2c_unlock_line()</a></li>
<li><a class="el" href="cvmx-l2c_8c.html#a44e6ca56a6b43c3c86ea689fa49dda0f" title="Unlocks a region of memory that is locked in the L2 cache.">cvmx_l2c_unlock_mem_region()</a></li>
<li><a class="el" href="cvmx-l2c_8c.html#a7b32e404fbddda134f1236bdc05675fc" title="Flushes (and unlocks) the entire L2 cache.">cvmx_l2c_flush()</a></li>
<li><a class="el" href="cvmx-l2c_8c.html#ab5bebbe37a4a7134597983e8a4b01335" title="Set maxium number of Virtual IDs allowed in a machine.">cvmx_l2c_vrt_set_max_virtids()</a></li>
<li><a class="el" href="cvmx-l2c_8c.html#a6ea76d03c4b2a973e4c47a25e30fd543" title="Get maxium number of virtual IDs allowed in a machine.">cvmx_l2c_vrt_get_max_virtids()</a></li>
<li><a class="el" href="cvmx-l2c_8c.html#ae42e7736a4e21c9c696d15e3842878e8" title="Set the maxium size of memory space to be allocated for virtualization.">cvmx_l2c_vrt_set_max_memsz()</a></li>
<li><a class="el" href="cvmx-l2c_8c.html#a5ccda8d859ff4200337bfa18d5076b46" title="Set a Virtual ID to a set of cores.">cvmx_l2c_vrt_assign_virtid()</a></li>
<li><a class="el" href="cvmx-l2c_8c.html#a1417dbb398d437db42580246213cc840" title="Remove a virt id assigned to a set of cores.">cvmx_l2c_vrt_remove_virtid()</a></li>
<li><a class="el" href="cvmx-l2c_8c.html#a5687830322c3c4dc53016c7b356fb45b" title="Block a memory region to be updated for a given virtual id.">cvmx_l2c_vrt_memprotect()</a></li>
<li><a class="el" href="cvmx-l2c_8c.html#a15a33f262eb91c2f00634eeeab758d08" title="Enable virtualization.">cvmx_l2c_vrt_enable()</a></li>
<li><a class="el" href="cvmx-l2c_8c.html#a031082435f039868f34f097645dc1171" title="Disable virtualization.">cvmx_l2c_vrt_disable()</a></li>
</ul>
<h3><a class="anchor" id="hal_pth">
4.20 Power Throttle (cvmx-power-throttle.h)</a></h3>
<p>The Power Throttle feature is introduced in OCTEON II. It allows per-core power consumption tuning. The APIs set the power consumption limit to a percentage of the maximum allowed.</p>
<ul>
<li><a class="el" href="cvmx-power-throttle_8c.html#a16980f093db14fea549ac3abddc2cc86" title="Throttle power to percentage% of configured maximum (MAXPOW).">cvmx_power_throttle_self()</a></li>
<li><a class="el" href="cvmx-power-throttle_8c.html#a41d782fe24bfbcc65ead8de6cc906ad2" title="Throttle power to percentage% of configured maximum (MAXPOW) for the cores identified...">cvmx_power_throttle()</a></li>
</ul>
<h2><a class="anchor" id="memory">
5 Memory Management</a></h2>
<h3><a class="anchor" id="memory_local">
5.1 Core-local malloc()</a></h3>
<p>The malloc() and free() functions provided by the C library manage a heap that is private for each core. This memory is not shared with other cores, and other cores do not have a TLB mapping to access this memory.</p>
<h3><a class="anchor" id="memory_arena">
5.2 Arena-based shared malloc() (cvmx-malloc.h)</a></h3>
<p>The Executive provides an arena based shared memory allocator for applications that need to dynamically allocate variable sized shared memory regions. Multiple arenas can be added to the list and can be used to avoid contention since cores can operate on different arenas independently. Any core can allocate from or free to any arena.</p>
<ul>
<li><a class="el" href="cvmx-malloc_8h.html#a7efa881c73d4a45204d68ca1cbd50d56" title="Creates an arena from the memory region specified and adds it to the supplied arena...">cvmx_add_arena()</a></li>
<li><a class="el" href="cvmx-malloc_8h.html#ab8510bd4d8a3da987bb37e77e8f2fbda" title="allocate buffer from an arena list">cvmx_malloc()</a></li>
<li><a class="el" href="cvmx-malloc_8h.html#aa736dcadeb482ef0f19c368957af6640" title="Allocate zero initialized buffer.">cvmx_calloc()</a></li>
<li><a class="el" href="cvmx-malloc_8h.html#a2d3fdb53bfbf3a15e8e18f3991952dec" title="attempt to increase the size of an already allocated buffer This function may allocate...">cvmx_realloc()</a></li>
<li><a class="el" href="cvmx-malloc_8h.html#a8c4f9b4356ead870fe2f513c23ad9724" title="allocate a buffer with a specified alignment">cvmx_memalign()</a></li>
<li><a class="el" href="cvmx-malloc_8h.html#a96d893984fc29fe53e39c0c9c18025c0" title="free a previously allocated buffer">cvmx_free()</a></li>
</ul>
<h3><a class="anchor" id="memory_zone">
5.3 Zone allocator (cvmx-malloc.h)</a></h3>
<ul>
<li><a class="el" href="cvmx-malloc_8h.html#af396d392e235d7e10878daa30a6d4d4c" title="Allocate a buffer from a memory zone.">cvmx_zone_alloc()</a></li>
<li><a class="el" href="cvmx-malloc_8h.html#abba628ab8cb07dd405713c6dbab356eb" title="Creates a memory zone for efficient allocation/deallocation of fixed size memory...">cvmx_zone_create_from_addr()</a></li>
<li><a class="el" href="cvmx-malloc_8h.html#ac9584e78c083395a443e4e9369c24618" title="Creates a memory zone for efficient allocation/deallocation of fixed size memory...">cvmx_zone_create_from_arena()</a></li>
<li><a class="el" href="cvmx-malloc_8h.html#ae2d4163156fb2d6d7113de225d892742" title="Free a previously allocated buffer.">cvmx_zone_free()</a></li>
<li><a class="el" href="cvmx-malloc_8h.html#a1957453bdb89816df343431b83462522">cvmx_zone_name()</a></li>
<li><a class="el" href="cvmx-malloc_8h.html#a5ceba8a51ce7b1d73976467f7082fcf9">cvmx_zone_size()</a></li>
</ul>
<h3><a class="anchor" id="memory_fpa">
5.4 Hardware (FPA) allocator (cvmx-fpa.h)</a></h3>
<p>The hardware free page allocator can also be used for software memory allocation and deallocation. Each pool must be initialized before use. Pools can be shared between hardware and software.</p>
<ul>
<li><a class="el" href="cvmx-fpa_8c.html#af10e81d923cb57c742f99b260be9fa35" title="Return the size of buffers held in a buffer pool.">cvmx_fpa_get_block_size()</a></li>
<li><a class="el" href="cvmx-fpa_8h.html#a00e0fc098e5aee9612a87982279d248c" title="Enable the FPA.">cvmx_fpa_enable()</a></li>
<li><a class="el" href="cvmx-fpa_8h.html#a862613eb44a7557a5daae94a2c1406c7" title="Get a new block from the FPA.">cvmx_fpa_alloc()</a></li>
<li><a class="el" href="cvmx-fpa_8h.html#a46dcab0f4db084075c39823c091e1344" title="Asynchronously get a new block from the FPA.">cvmx_fpa_async_alloc()</a></li>
<li><a class="el" href="cvmx-fpa_8h.html#a37d454b978e09493678d18062e644748" title="Retrieve the result of cvmx_fpa_async_alloc.">cvmx_fpa_async_alloc_finish()</a></li>
<li><a class="el" href="cvmx-fpa_8h.html#a953ef29fcfef0ca074e2cfc1c294e4bf" title="Free a block allocated with a FPA pool.">cvmx_fpa_free()</a></li>
<li><a class="el" href="cvmx-fpa_8c.html#a611806f7fdb4a36b52ca0d5cfc326ce5" title="Setup an FPA pool with buffers.">cvmx_fpa_setup_pool()</a></li>
<li><a class="el" href="cvmx-fpa_8c.html#a575b6e9903d1ea75310bc2ddf897ed7f" title="Shutdown a Memory pool and validate that it had all of the buffers originally placed...">cvmx_fpa_shutdown_pool()</a></li>
</ul>
<h3><a class="anchor" id="memory_boot">
5.5 Physical memory allocator (cvmx-bootmem.h)</a></h3>
<p>This allocator is provided to allow applications to allocate blocks of free physical memory after boot. The free memory list is created by the bootloader, and is passed to the application(s). Locking is provided to allow for multiple cores to allocate from the free memory pool. This is an allocate only allocator, which allows for a zero overhead implementation (it is possible to allocate all of the free memory.) Allocated blocks can also be assigned names for sharing between applications and between the bootloader and applications. Named allocations can be freed, as the named block <a class="el" href="structdescriptor.html">descriptor</a> keeps track of the size of the allocation to allow this. Bootmem block names starting with '__' are reserved for internal use and should not be used by applications.</p>
<ul>
<li><a class="el" href="cvmx-bootmem_8c.html#a4295ccfec5aeb9b415c92fbbb1f5873e" title="Allocate a block of memory from the free list that was passed to the application...">cvmx_bootmem_alloc()</a></li>
<li><a class="el" href="cvmx-bootmem_8c.html#a1aeeabcff132e8b9152bf5fa69068b87" title="Allocate a block of memory from the free list that was passed to the application...">cvmx_bootmem_alloc_address()</a></li>
<li><a class="el" href="cvmx-bootmem_8c.html#ab787a63a038bd4e79d3b80f832b361f9" title="Allocate a block of memory from the free list that was passed to the application...">cvmx_bootmem_alloc_named()</a></li>
<li><a class="el" href="cvmx-bootmem_8c.html#a30d21e76d1041d8ffbc92858e4008379" title="Allocate a block of memory from the free list that was passed to the application...">cvmx_bootmem_alloc_named_address()</a></li>
<li><a class="el" href="cvmx-bootmem_8c.html#aad826d085ebf8a452e6120be2579c8bb" title="Frees a previously allocated named bootmem block.">cvmx_bootmem_free_named()</a></li>
<li><a class="el" href="cvmx-bootmem_8c.html#aad826d085ebf8a452e6120be2579c8bb" title="Frees a previously allocated named bootmem block.">cvmx_bootmem_free_named()</a></li>
</ul>
<h2><a class="anchor" id="synchronization">
6 Synchronization</a></h2>
<h3><a class="anchor" id="synchronization_spinlocks">
6.1 Basic Spinlocks (cvmx-spinlock.h)</a></h3>
<ul>
<li>cvmx_spinlock_init()</li>
<li>cvmx_spinlock_locked()</li>
<li><a class="el" href="cvmx-spinlock_8h.html#a9df9b10ad14176698a45a281db4856f6">cvmx_spinlock_unlock()</a></li>
<li>cvmx_spinlock_trylock()</li>
<li><a class="el" href="cvmx-spinlock_8h.html#a2239106e7cd3f236c0e8e2bc7ece145c">cvmx_spinlock_lock()</a></li>
</ul>
<h3><a class="anchor" id="synchronization_recursive">
6.2 Recursive Spinlocks (cvmx-spinlock.h)</a></h3>
<ul>
<li>cvmx_spinlock_rec_init()</li>
<li>cvmx_spinlock_rec_locked()</li>
<li>cvmx_spinlock_rec_unlock()</li>
<li>cvmx_spinlock_rec_lock()</li>
</ul>
<h3><a class="anchor" id="synchronization_atomic">
6.3 Atomic operations (cvmx-atomic.h)</a></h3>
<ul>
<li><a class="el" href="cvmx-atomic_8h.html#a3425368e55465016bdc2ffab87ce193d" title="Atomically sets a 32 bit (aligned) memory location to a value.">cvmx_atomic_set32()</a></li>
<li><a class="el" href="cvmx-atomic_8h.html#a226d03216f99f4902c523214c9cc2ff8" title="Atomically adds a signed value to a 32 bit (aligned) memory location.">cvmx_atomic_add32()</a></li>
<li><a class="el" href="cvmx-atomic_8h.html#a0bffa06176a6d60b51e6b418add7b8a9" title="Atomically sets a 64 bit (aligned) memory location to a value.">cvmx_atomic_set64()</a></li>
<li><a class="el" href="cvmx-atomic_8h.html#a844232114ff475f27b7527534fc086a5" title="Atomically adds a signed value to a 64 bit (aligned) memory location.">cvmx_atomic_add64()</a></li>
<li><a class="el" href="cvmx-atomic_8h.html#a2cc2a03fa87ea299014a88b86da4ac3d" title="Atomically compares the old value with the value at ptr, and if they match, stores...">cvmx_atomic_compare_and_store32()</a></li>
<li><a class="el" href="cvmx-atomic_8h.html#a9aa93efa06c486b86224ab7f600e8d67" title="Atomically compares the old value with the value at ptr, and if they match, stores...">cvmx_atomic_compare_and_store64()</a></li>
</ul>
<h3><a class="anchor" id="synchronization_rw_locks">
6.4 Reader/writer locks (cvmx-rwlock.h)</a></h3>
<p>Provides reader/writer locks with writer preference. Multiple cores may hold read locks, while write locks are exclusive. Writers have preference, so writers can starve readers.</p>
<ul>
<li><a class="el" href="cvmx-rwlock_8h.html#a961b0ce9785f29d38a223807db6930e8" title="Initialize a reader/writer lock.">cvmx_rwlock_wp_init()</a></li>
<li><a class="el" href="cvmx-rwlock_8h.html#ae266d9cbcbfd717d657d7509b8df61eb" title="Perform a reader lock.">cvmx_rwlock_wp_read_lock()</a></li>
<li><a class="el" href="cvmx-rwlock_8h.html#a6e95fc32210ed4f359307a5d0bcc73a1" title="Perform a reader unlock.">cvmx_rwlock_wp_read_unlock()</a></li>
<li><a class="el" href="cvmx-rwlock_8h.html#a9a07a65518dbca919c22aa8204814b67" title="Perform a writer lock.">cvmx_rwlock_wp_write_lock()</a></li>
<li><a class="el" href="cvmx-rwlock_8h.html#a2e7cd4b83e74569b51d892889a1a6d0b" title="Perform a writer unlock.">cvmx_rwlock_wp_write_unlock()</a></li>
</ul>
<h3><a class="anchor" id="synchronization_coremask">
6.5 Coremask (cvmx-coremask.h)</a></h3>
<p>"cvmx-coremask.h" provides syncronization and membership operations on 'coremask' values. A coremask is an integer that has a bit set for each core that is a member of the mask. The coremask 0xffff contains all 16 cores, while the coremask 0x0 contains none.</p>
<ul>
<li><a class="el" href="cvmx-sysinfo_8h.html#aa1e3d8b3037fd16c9574c2ab4eca439a">cvmx_is_init_core()</a></li>
<li><a class="el" href="cvmx-coremask_8c.html#a41dc86d56858aa146f100b60c5ae1aae" title="Wait (stall) until all cores in the given coremask has reached this point in the...">cvmx_coremask_barrier_sync()</a></li>
<li><a class="el" href="cvmx-coremask_8c.html#a08bd2def7d84926ee9beab4aad3f9a88">cvmx_coremask_str2bmp()</a></li>
<li><a class="el" href="cvmx-coremask_8c.html#a39d623d31734d8c2940dd96a52d9ddcd">cvmx_coremask_bmp2str()</a></li>
</ul>
<h2><a class="anchor" id="interrupts">
7 Exceptions and Interrupt Handling</a></h2>
<p>Exceptions and interrupts are handled by cvmx-interrupt. As part of application initialization before <a class="el" href="cvmx-app-init-linux_8c.html#ac0f2228420376f4db7e1274f2b41667c" title="Main entrypoint of the application.">main()</a>, <a class="el" href="cvmx-app-init_8c.html#a18a1220d505e52ec2b6cd92a4659f0ea" title="1.">cvmx_interrupt_initialize()</a> installs a trap handler at each of the possible Mips entry points (0x80, 0x100, 0x180, and 0x200). The low level assembly handlers are located in cvmx-interrupt-handler.S. Upon an exception or interrupt, the following sequence is followed:</p>
<ol type="1">
<li>The Mips core jumps to the appropriate entry point for the trap (0x80, 0x100, 0x180, or 0x200).</li>
<li>cvmx_interrupt_stage1, which was installed by <a class="el" href="cvmx-app-init_8c.html#a18a1220d505e52ec2b6cd92a4659f0ea" title="1.">cvmx_interrupt_initialize()</a> at the trap location, Loads the address of cvmx_interrupt_stage2 into register <b>k0</b> and jumps to it. <b>k0</b> will be corrupted when a trap occurs.</li>
<li>cvmx_interrupt_stage2 saves all of the general purpose registers to the application stack frame.</li>
<li><a class="el" href="cvmx-interrupt_8c.html#a854db9d2da05848717c7ffad0a6de8ef" title="Process an interrupt request.">cvmx_interrupt_do_irq()</a> is called with a parameter pointing to an array of all 32 registers. This is the first C function called.</li>
</ol>
<p>From this point on <a class="el" href="cvmx-interrupt_8c.html#a854db9d2da05848717c7ffad0a6de8ef" title="Process an interrupt request.">cvmx_interrupt_do_irq()</a> performs processing based on the type of event that occurred.</p>
<h3><a class="anchor" id="interrupt_interrupt">
7.1 Interrupt Handling</a></h3>
<p>If the cause of the trap event is determined to not be an exception (COP0 status register exception bits are zero), the interrupt status bits are iterated through looking for interrupts. The interrupts are sequentially searched from 0 to 7. The first bit set causes the interrupt handler for that interrupt to be called. Interrupt handlers are registered using <a class="el" href="cvmx-interrupt_8c.html#a23cc2a930ee9f88fbfff7c4fa11c3dba" title="Register an interrupt handler for the specified interrupt number.">cvmx_interrupt_register()</a>. The default interrupt handler cvmx_interrupt_default() simply displays a message and the contents of all registers. The exception to this is interrupt lines 2 and 3. The handler for these lines (cvmx_interrupt_ciu()) decodes the CIU interrupt status lines.</p>
<p>cvmx_interrupt_ciu() decodes the CIU status lines into interrupts 8-71 for line 2 and 72-135 for line 3.</p>
<p>The following functions can be used to control interrupts:</p>
<ul>
<li><a class="el" href="cvmx-interrupt_8c.html#a23cc2a930ee9f88fbfff7c4fa11c3dba" title="Register an interrupt handler for the specified interrupt number.">cvmx_interrupt_register()</a></li>
<li><a class="el" href="cvmx-interrupt_8c.html#ad4567ac840d76c13704e4068bbbf75c1">cvmx_interrupt_map()</a></li>
</ul>
<p>As part of initialization, cvmx-interrupt registers handlers for ECC errors from DRAM and the L2 controller.</p>
<h3><a class="anchor" id="interrupt_timer">
7.2 Timer Interrupts</a></h3>
<p>The simple executive does not configure any timers or watchdogs by default. Applications wishing to use these features need to register an appropriate interrupt handler, then configure the OCTEON hardware to deliver the specified timer / watchdog. Some of the possible interrupt sources are:</p>
<ol type="1">
<li>Mips count and compare registers (interrupt 7)</li>
<li>CIU watchdog timers (interrupt 52)</li>
<li>CIU timers (interrupt 60-63)</li>
</ol>
<h3><a class="anchor" id="interrupt_exception">
7.3 Exception Handling</a></h3>
<p>If the cause of the trap event is determined to be an exception (COP0 status register exception bits are set), <a class="el" href="cvmx-interrupt_8c.html#a854db9d2da05848717c7ffad0a6de8ef" title="Process an interrupt request.">cvmx_interrupt_do_irq()</a> calls the exception handler cvmx_interrupt_default_exception_handler(). This handler prints the cause of the exception, the current register state and the backtrace of current function calls. This will be incomplete if the application was not compiled with -fasynchronous-unwind-tables (see <a class="el" href="cvmx_overview.html#backtrace">3.3 Obtaining backtrace information programmatically</a>). It then halts the core that had the exception. The default exception handler can be replaced using <a class="el" href="cvmx-interrupt_8c.html#aa2d3d7e835e6a34a64337db6126f75f3" title="Set the exception handler for all non interrupt sources.">cvmx_interrupt_set_exception()</a>. See the Mips 64v2 specification for more details about exception processing.</p>
<h2><a class="anchor" id="hotplug">
8 Simple Executive Hotplug</a></h2>
<p>The hotplug APIs allow an application to register itself for hotplug. The application needs to register a callback routine, which will be invoked when the application is requested to shutdown.</p>
<p>Refer to the SDK example program hotplug-app for an illustration of how to use these APIs. Please note that these APIs only take care of cleaning up the execution image of the application. All application specific cleanup, including hardare state, needs to be done by the application's own callback routine.</p>
<ul>
<li><a class="el" href="cvmx-app-hotplug_8c.html#afcd8a217a6a041b0c03c4bb37ca98cf2" title="This routine registers an application for hotplug.">cvmx_app_hotplug_register()</a></li>
<li><a class="el" href="cvmx-app-hotplug_8c.html#afaaa4181d926b3729fbbfa146f4a24e8" title="Activate the current application core for receiving hotplug shutdown requests.">cvmx_app_hotplug_activate()</a></li>
<li><a class="el" href="cvmx-app-hotplug_8c.html#a9d320250c7067703815311feb1222930" title="This routine is only required if cvmx_app_hotplug_shutdown_request() was called with...">cvmx_app_hotplug_shutdown_complete()</a></li>
<li><a class="el" href="cvmx-app-hotplug_8c.html#a195033e478170ddaafea5ec9d4f15f12" title="Disable recognition of any incoming shutdown request.">cvmx_app_hotplug_shutdown_disable()</a></li>
<li><a class="el" href="cvmx-app-hotplug_8c.html#a21caa2e9ae2a1ac71e7cf58187a4e675" title="Re-enable recognition of incoming shutdown requests.">cvmx_app_hotplug_shutdown_enable()</a></li>
<li><a class="el" href="cvmx-app-hotplug_8c.html#afdedbe2d3bf7d5c48cdb94d332b37eb9" title="This routine sends a shutdown request to a running target application.">cvmx_app_hotplug_shutdown_request()</a></li>
</ul>
<h2><a class="anchor" id="models">
9 Supporting multiple OCTEON models</a></h2>
<p>(Runtime model checking is the preferred method of model checking.) Code can be written to easily support multiple OCTEON models using the <a class="el" href="octeon-model_8h.html#a9234ac9e9f35fafd7fe5eedd37c9b552">OCTEON_IS_MODEL()</a> macro/function. Both runtime and compile time checking are supported. The runtime model checking is enabled by default, same as passing --runtime argument to the env-setup script. Pass --noruntime-model to compile for a particular model to env-setup script. The argument to <a class="el" href="octeon-model_8h.html#a9234ac9e9f35fafd7fe5eedd37c9b552">OCTEON_IS_MODEL()</a> is one of the OCTEON model defines in <a class="el" href="octeon-model_8h.html" title="File defining different Octeon model IDs and macros to compare them.">octeon-model.h</a>, and <a class="el" href="octeon-model_8h.html#a9234ac9e9f35fafd7fe5eedd37c9b552">OCTEON_IS_MODEL()</a> returns true if the model that the code is running on matches the argument. If no revision checking is required, then the argument should not include a revision - <a class="el" href="octeon-model_8h.html#a9234ac9e9f35fafd7fe5eedd37c9b552">OCTEON_IS_MODEL(OCTEON_CN38XX)</a> will return true for all revisions of OCTEON_CN38XX chips. <a class="el" href="octeon-model_8h.html#a9234ac9e9f35fafd7fe5eedd37c9b552">OCTEON_IS_MODEL(OCTEON_CN3020_PASS1_1)</a> will only match pass 1.1 CN3020 chips. Please note that some 'family' defines (OCTEON_CN31XX, OCTEON_CN30XX, etc.) may include or exclude some specific models that seem like they should match. Please refer to <a class="el" href="octeon-model_8h.html" title="File defining different Octeon model IDs and macros to compare them.">octeon-model.h</a> for a more detailed description.</p>
<p>In order to use compile time checking and <a class="el" href="octeon-model_8h.html#a9234ac9e9f35fafd7fe5eedd37c9b552">OCTEON_IS_MODEL()</a>, the <a class="el" href="octeon-model_8h.html#a7bd45039e39c6d26b17b84ff19d2e9fd">OCTEON_IS_COMMON_BINARY()</a> macro must be checked first. The <a class="el" href="octeon-model_8h.html#a7bd45039e39c6d26b17b84ff19d2e9fd">OCTEON_IS_COMMON_BINARY()</a> macro will be defined to 1 when runtime checking is used, and 0 when compile time is used. Since <a class="el" href="octeon-model_8h.html#a9234ac9e9f35fafd7fe5eedd37c9b552">OCTEON_IS_MODEL()</a> is a function when runtime checking is used, it cannot be used in a preprocessor directive (#if.) when runtime checking is enabled. To use <a class="el" href="octeon-model_8h.html#a9234ac9e9f35fafd7fe5eedd37c9b552">OCTEON_IS_MODEL()</a> in a preprocessor directive, it must be protected by a check of <a class="el" href="octeon-model_8h.html#a7bd45039e39c6d26b17b84ff19d2e9fd">OCTEON_IS_COMMON_BINARY()</a>.</p>
<div class="fragment"><pre class="fragment">

	#if !OCTEON_IS_COMMON_BINARY()
	#if OCTEON_MATCH_MODEL(OCTEON_CN38XX)
        /* Do OCTEON model specific compile time stuff here... */
	#endif
	#endif

</pre></div><p>Most of the time this is not necessary as the compiler does a good job of eliminating dead code when conditionals are based on <a class="el" href="octeon-model_8h.html#a9234ac9e9f35fafd7fe5eedd37c9b552">OCTEON_IS_MODEL()</a> and compile time checking is used. If compile time checking is used, the generated program will only run on the model it was compiled for. Since all checks are compiled out, all code except the startup code which validates the model assumes that it is running on the model it was compiled for. </p>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Oct 2017 for Octeon Software Development Kit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
