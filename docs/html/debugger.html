<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Octeon Software Development Kit: Simple Executive Debugger</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="debugger">Simple Executive Debugger </a></h1><h2><a class="anchor" id="debugger_contents">
Contents</a></h2>
<ul>
<li><a class="el" href="debugger.html#introduction_debugger">1 Introduction</a></li>
<li><a class="el" href="debugger.html#building_debugger">2 Building Code for the Debugger</a></li>
<li><a class="el" href="debugger.html#hw_debugger">3 Running the Debugger on Octeon Hardware</a></li>
<li><a class="el" href="debugger.html#terminalserver_debugger">4 Debugging via a terminal server</a></li>
<li><a class="el" href="debugger.html#sim_debugger">5 Running the Debugger on OCTEON Simulator</a></li>
<li><a class="el" href="debugger.html#multicore_debugger">6 Cavium Specific GDB Variables for Multicore Debugging</a></li>
<li><a class="el" href="debugger.html#debugger_variables">7 Other Cavium Specific GDB Variables</a></li>
<li><a class="el" href="debugger.html#breakpoints_debugger">8 Multicore Breakpoints</a></li>
<li><a class="el" href="debugger.html#hwbreakpoints_debugger">9 Multicore Hardware Breakpoints</a></li>
<li><a class="el" href="debugger.html#watchpoints_debugger">10 Hardware watchpoints</a></li>
<li><a class="el" href="debugger.html#perfcounters_debugger">11 Multicore Performance Counters</a></li>
<li><a class="el" href="debugger.html#backtrace_on_exception_debugger">12 Finding the cause of an exception with the debugger</a></li>
<li><a class="el" href="debugger.html#termination_debugger">13 Program Termination with Multiple Cores</a></li>
<li><a class="el" href="debugger.html#ddd_debugger">14 The DDD Graphical Debugger</a></li>
<li><a class="el" href="debugger.html#manual_debugger">15 Running the Debugger - The manual way</a></li>
<li><a class="el" href="debugger.html#intercore_debugger">16 Running the inter-core Debugger</a></li>
</ul>
<h2><a class="anchor" id="introduction_debugger">
1 Introduction</a></h2>
<p>The OCTEON Debugger (mipsisa64-octeon-elf-gdb) supports interactive control of programs running in the OCTEON Simulator and in OCTEON hardware. Any number of cores from 1 to 16 can be controlled through one interface.</p>
<h2><a class="anchor" id="building_debugger">
2 Building Code for the Debugger</a></h2>
<p>To debug a program, build the executable by passing "-O0 -g" options.</p>
<div class="fragment"><pre class="fragment">
    $ cd examples/debugger
    $ make
</pre></div><p>Although you can debug programs compiled with optimization (-O?), results will be problematic. Since the majority of the Octeon support code is implemented in inline functions, the compiler optimizations will make it just about impossible to determine the current stack frame and line number.</p>
<h2><a class="anchor" id="hw_debugger">
3 Running the Debugger on Octeon Hardware</a></h2>
<p>The debugger communicates with Octeon Hardware through a serial port or over PCI or while running Linux. Refer <a class="el" href="octeon_remote.html#pci_target_gdb">17. Debugging using GDB</a> on how to debug application over PCI and <a class="el" href="debugger.html#intercore_debugger">16 Running the inter-core Debugger</a> for how to debug applications while running Linux.</p>
<p>A serial cable must be connected from Octeon board to your host machine for debugging.</p>
<p>Before invoking the debugger, the program should be loaded into Octeon memory. Run the program by passing <b>debug</b> option to "bootoct" command. The <b>debug=?</b> option will make the program enter into the debug exception handler where the cores keep waiting for the command from the debugger. <b>debug=</b> should be followed by the number of the Octeon uart to use for debugging. If it isn't supplied, the default is uart 1 (the second uart).</p>
<div class="fragment"><pre class="fragment">
   octeon ebt3000# bootoct 100000 coremask=3 debug=1
</pre></div><p>Now invoke the debugger using oct-debug (a shell wrapper function) on your host machine to debug the program.</p>
<div class="fragment"><pre class="fragment">
   # oct-debug test.out /dev/ttyS0
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>When using a single uart for debugging and console, make sure you close any terminal programs before starting the debugger.</dd></dl>
<p>Description of the options:</p>
<div class="fragment"><pre class="fragment">
    test.out    The program to be debugged.
    /dev/ttyS0  The host device name for the serial port that is connected
                to uart1 of the OCTEON board. This is configured as 115200,8,N.
</pre></div><p>When using the OCTEON debugger directly, invoke the commands following the example below:</p>
<div class="fragment"><pre class="fragment">
  # mipsisa64-octeon-elf-gdb
      GNU gdb 6.3
    Copyright 2004 Free Software Foundation, Inc.
    GDB is free software, covered by the GNU General Public License, and you are
    welcome to change it and/or distribute copies of it under certain conditions.
    Type "show copying" to see the conditions.
    There is absolutely no warranty for GDB.  Type "show warranty" for details.
    This GDB was configured as "--host=i686-pc-linux-gnu --target=mipsisa64-octeon-elf".
  (Core#0-gdb) file test.out
    Reading symbols from /usr/local/Cavium_Networks/OCTEON-SDK/examples/debugger/test.out...done.
  (Core#0-gdb) target octeon /dev/ttyS0
    Remote target octeon connected to /dev/ttyS0
  (Core#0-gdb) load
</pre></div><h2><a class="anchor" id="terminalserver_debugger">
4 Debugging via a terminal server</a></h2>
<p>Connecting to the serial port through a terminal server is supported in GDB. When invoking the target command instead of specifying the serial device use the hostname of the terminal server and the port that routes to the debugger port on the board. For example:</p>
<div class="fragment"><pre class="fragment">
  (Core#0-gdb) target octeon tcp:terminal-server:3001
    Remote target octeon connected to tcp:terminal-server:3001
</pre></div><p>On some terminal servers there is no way to fully disable telnet negotiations. In this case the initial characters sent by GDB can be misinterpreted and taken for a negotiation response.</p>
<p>GDB prints the characters that cannot be interpreted according to the protocol. So the symptom is that instead of the above message there will be some garbage printed as a response to the target command and then nothing further will be printed.</p>
<p>In this case it can help to insert a delay before GDB sends the first packet. The variable <b>transmit-delay</b> holds the seconds how much time GDB should wait before sending the first packet:</p>
<div class="fragment"><pre class="fragment">
  (Core#0-gdb) set transmit-delay 2
  (Core#0-gdb) target octeon tcp:terminal-server:3001
  {{}}Remote target octeon connected to tcp:terminal-server:3001
  (Core#0-gdb)
</pre></div><h2><a class="anchor" id="sim_debugger">
5 Running the Debugger on OCTEON Simulator</a></h2>
<p>A shell wrapper script (oct-debug) has been supplied to simplify the starting of the debugger. This scripts is a drop in replacement for oct-sim. For example, to start the debugger example execute:</p>
<div class="fragment"><pre class="fragment">
    $ oct-debug test.out -quiet -noperf -numcores=2
</pre></div><p>Descriptions of the options:</p>
<div class="fragment"><pre class="fragment">
    test.out    The program to be debugged.
    -quiet      Tell the simulator not to trace assembler instructions.
    -noperf     Don't perform cycle accurate timing. This isn't
                strictly necessary, but greatly speeds up debugging
                with large numbers of cores.
    -numcores=2 Specify the number of cores to simulate.
</pre></div><p>All other standard simulator options are supported. For a complete list execute oct-sim without any arguments.</p>
<h2><a class="anchor" id="multicore_debugger">
6 Cavium Specific GDB Variables for Multicore Debugging</a></h2>
<p>Three GDB state variables control support for multicore debugging. These variables are "active-cores", "focus", and "step-all". The standard GDB set and show commands access these variables. A description of each variable's affect on the debugging environment is listed below:</p>
<ul>
<li>active-cores: This is a comma separated list of cores under active control of the debugger. Cores in this list will stop if any other core hits a breakpoint. Cores not in this list will only stop if they hit a breakpoint. Note that although cores not in active-cores do not stop when other cores hit a breakpoint, they do suffer a performance hit. As a convenience, setting the active cores to an empty string (set active-cores) is interpreted as setting all cores active.</li>
</ul>
<div class="fragment"><pre class="fragment">
        (Core#0-gdb) set active-cores 0,1
        (Core#0-gdb) show active-cores
        The cores stopped on execution of a breakpoint by another core is "0,1".
        (Core#0-gdb) set active-cores
        (Core#0-gdb) show active-cores
        The cores stopped on execution of a breakpoint by another core is
        "0,1,2,3,4,6,7,8,9,10,11,12,13,14,15".
        (Core#0-gdb)
    </pre></div><ul>
<li>focus: This is the index (0-15) of the core directly interacting with the debugger. Data operations (r/w memory, registers) are performed in the focus cores context. Only cores currently stopped in a debug exception may become the focus core. This means making a non-active core the focus generally requires a breakpoint or changing the active-cores to include it. The GDB prompt will show the current focus core. Note that the focus core may change if another core hits a breakpoint. The core to hit a breakpoint first automatically becomes the focus core.</li>
</ul>
<div class="fragment"><pre class="fragment">
        (Core#0-gdb) show focus
        The focus core of debugger operations is 0.
        (Core#0-gdb) set focus 5

        Breakpoint 1, main () at test.c:62
        (Core#5-gdb) show focus
        The focus core of debugger operations is 5.
        (Core#5-gdb)
    </pre></div><ul>
<li>step-all: This GDB variable controls the cores action when the commands step, step instruction, and continue are executed. By default (step-all off) only the focus core performs the operations. Execution of other cores occurs only if step-all is on. Note that cores not in the active-cores list currently stopped will continue execution under any step command with step-all enabled.</li>
</ul>
<div class="fragment"><pre class="fragment">
        (Core#5-gdb) show step-all
        Step commands affect all cores is off.
        (Core#5-gdb) set step-all on
        (Core#5-gdb) show step-all
        Step commands affect all cores is on.
        (Core#5-gdb)
    </pre></div><p>Commonly, sets of cores perform various program tasks. When debugging, it can be helpful to stop only cores performing a specific task. These cores would be set in the active-cores list, allowing this task to be debugged while the other cores continue to operate normally.</p>
<h2><a class="anchor" id="debugger_variables">
7 Other Cavium Specific GDB Variables</a></h2>
<ul>
<li>spawn-sim: With the OCTEON target, GDB can internally spawn the simulator and run the program inside the simulator automatically. The simulator is spawned in a new terminal so that you can inspect its output. This mode is enabled by setting spawn-sim:</li>
</ul>
<div class="fragment"><pre class="fragment">
        (Core#0-gdb) file test.out
        (Core#0-gdb) set spawn-sim 1
        (Core#0-gdb) target octeon tcp::65259
        // new terminal is launched with the simulator
        Remote target octeon connected to tcp::1234
        (Core#0-gdb)
      </pre></div><h2><a class="anchor" id="breakpoints_debugger">
8 Multicore Breakpoints</a></h2>
<p>Break point inserted into the program using the GDB "break" command are implemented using Mips software break instructions. The instruction at the breakpoint is replaced with a "sdbbp" instruction. Once execution reaches this point, GDB will replace the "sdbbp" with the original program instruction. The breakpoint will not be reinserted until the core that hit the "sdbbp" steps past the breakpoint. This leaves a window where other cores may bypass the breakpoint without stopping. In order to avoid this hazard, the focus core must be stepped at least once with step-all off before any other cores are allowed to execute.</p>
<p>It is possible to have two or more cores hit a breakpoint on the same instruction cycle. If step-all doesn't appear to be working as you'd expect, make sure another core isn't continually hitting a breakpoint. A core cannot proceed past a breakpoint until it is stepped as the focus processor.</p>
<h2><a class="anchor" id="hwbreakpoints_debugger">
9 Multicore Hardware Breakpoints</a></h2>
<p>Hardware breakpoints are inserted into the program using the GDB "hbreak" command. Each core can have maximum of four hardware breakpoints. When "hbreak" command is issued at the debugger prompt, the hardware breakpoints is applied to the focused core.</p>
<h2><a class="anchor" id="watchpoints_debugger">
10 Hardware watchpoints</a></h2>
<p>OCTEON supports both read and write hardware watchpoints. Hardware watchpoints are inserted into the program using the GDB "watch", "rwatch" and "awatch" commands. There are maximum of four hardware watchpoints available per debugging section.</p>
<h2><a class="anchor" id="perfcounters_debugger">
11 Multicore Performance Counters</a></h2>
<p>OCTEON supports two performance counter registers. Each performance counter can be enabled by specifying an event. To see the events supported for OCTEON, invoke "set perf-event[0|1]" at the GDB prompt.</p>
<p>To initialize an event invoke "set perf-event[0|1] &lt;event&gt;" at GDB prompt.</p>
<p>At any point performance counter register values can be checked by invoking "show perf-event[0|1]" command at GDB prompt. When the performance counters are not initialized the counter is reset to zero.</p>
<p>The performance counter events are applied to the focused core.</p>
<h2><a class="anchor" id="backtrace_on_exception_debugger">
12 Finding the cause of an exception with the debugger</a></h2>
<p>GDB can unwind the exception handler frame to the frame that has caused the exception. If you set a breakpoint on the default exception handler (__cvmx_interrupt_default_exception_handler) or on the custom handler you installed you can backtrace to the frame causing the exception.</p>
<p>On hardware you can do this even without setting a breakpoint upfront. In the default exception handler that CVMX provides -- after dumping the register context and printing backtrace information -- the program enters an infinite loop. You can stop the program in this loop by hitting Ctrl-C on the GDB console and then examine the cause of the exception in detail.</p>
<p>Here is an example when a breakpoint is set on __cvmx_interrupt_default_exception_handler.</p>
<div class="fragment"><pre class="fragment">
test.c:

#include &lt;cvmx.h&gt;
#include &lt;unistd.h&gt;

int *i = 0;  // causes exception

void foo (void)
{
  *i = 0;
}

void (*p) (void) = foo;

main ()
{
  cvmx_user_app_init ();
  p ();
  return 0;
}
</pre></div><p>Compile the above simple executive program and invoke the debugger for debugging. </p>
<div class="fragment"><pre class="fragment">
mipsisa64-octeon-elf-gdb -q test.out
(Core#0-gdb) target octeon tcp::65258
Remote target octeon connected to tcp::65258
(Core#0-gdb) b __cvmx_interrupt_default_exception_handler
Breakpoint 1 at 0x10005d18: file /usr/local/Cavium_Networks/OCTEON-SDK/executive/cvmx-interrupt.c, line 549.
(Core#0-gdb) break main
Breakpoint 2 at 0x100002f0: file test.c, line 15.
(Core#0-gdb) run
Starting program: /home/cchavva/work/sdk-base/sdk/examples/debugger/test.out

Breakpoint 2, main () at test.c:15
15        cvmx_user_app_init ();
(Core#0-gdb) continue
Continuing.

Breakpoint 1, __cvmx_interrupt_default_exception_handler (registers=0x160ffed8)
    at /home/cchavva/work/sdk-base/sdk/executive/cvmx-interrupt.c:321
321         ebt3000_str_write("Trap");
(Core#0-gdb) backtrace
#0  __cvmx_interrupt_default_exception_handler (registers=0x160ffed8)
    at /home/cchavva/work/sdk-base/sdk/executive/cvmx-interrupt.c:321
#1  0x100075b0 in cvmx_interrupt_stage2 ()
    at /usr/local/Cavium_Networks/OCTEON-SDK/executive/cvmx-interrupt-handler.S:266
#2  0x100002dc in foo () at test.c:8
#3  0x10000304 in main () at test.c:16
(Core#0-gdb) up
#1  0x10007528 in cvmx_interrupt_stage2 ()
    at /usr/local/Cavium_Networks/OCTEON-SDK/executive/cvmx-interrupt-handler.S:266
266             dadd    a0, sp, 0       // First argument is array of registers
Current language:  auto; currently asm
(Core#0-gdb) up
#2  0x100002dc in foo () at test.c:8
8         *i = 0;
Current language:  auto; currently c
(Core#0-gdb) print i
$1 = (int *) 0x0
</pre></div><h2><a class="anchor" id="termination_debugger">
13 Program Termination with Multiple Cores</a></h2>
<p>As far as the debugger is concerned, program termination occurs when all cores complete execution and returns control to the debugger. Any shutdown synchronization desired must be implemented as part of the program.</p>
<h2><a class="anchor" id="ddd_debugger">
14 The DDD Graphical Debugger</a></h2>
<p>The OCTEON SDK provides a multicore capable version of DDD (mipsisa64-octeon-elf-ddd). It is executed automatically by oct-debug to provide a graphical interface for debugging. The default setup provides new command buttons for quick focus and step-all changes. Documentation for DDD can be found at:</p>
<p><a href="http://www.gnu.org/software/ddd/">http://www.gnu.org/software/ddd/</a></p>
<h2><a class="anchor" id="manual_debugger">
15 Running the Debugger - The manual way</a></h2>
<p>As is the nature of debugging, sometimes you need something unsupported by the oct-debug wrapper script. Here are the minimal steps to start the OCTEON debugger.</p>
<p>1) Startup two terminal interfaces to the machine. One will be the debugger terminal, the other will be the simulator terminal. The simulator terminal will only be used to see output from the program under debug control while the debugger terminal will require interactive input.</p>
<p>2) In the simulator terminal: Start the program as normal except for an additional two arguments. The parameter "-uart1=65258" will allow communications through TCP port 65258. The second parameter "-debug" tells the simulator to stop before starting main and wait for the debugger. The program should then pause with all processors stopped. Here is the example output for reference: </p>
<div class="fragment"><pre class="fragment">
$ oct-sim  test.out -quiet -noperf -numcores=2 -uart1=65258 -debug
No -memsize argument provided, using default of 128 Megabytes
mem size is 128
Using simulator: pp
Loading test.out to boot bus address 0x1000000
Starting simulator....
Executing command: pp -ld=0x10000000:test.out -ld=0x0:0x8000000 -ld=0x1fe00000:0x1000 -modes=fastboot -ld=0x1fc00000:0x40000 -ld=0x1fc00000:/home/build/octsw/sdk/target/bin/u-boot.bin /home/build/octsw/sdk/target/bin/sim-magic-elf -ld=0x1ffffff0:/tmp/fileykZ0bG -ld=0x1ffffff8:/tmp/fileio660z -quiet -noperf -numcores=2 -uart1=65258
command line: pp -ld=0x10000000:test.out -ld=0x0:0x8000000 -ld=0x1fe00000:0x1000 -modes=fastboot -ld=0x1fc00000:0x40000 -ld=0x1fc00000:/home/build/octsw/sdk/target/bin/u-boot.bin /home/build/octsw/sdk/target/bin/sim-magic-elf -ld=0x1ffffff0:/tmp/fileykZ0bG -ld=0x1ffffff8:/tmp/fileio660z -quiet -noperf -numcores=2 -uart1=65258
Loading binary file test.out to address 0x10000000
Added 184 symbols from binary file: test.out
loading 240258 bytes
loaded 240258 bytes
Loading 134217728 bytes of zeroes to address 0x0
Loading 4096 bytes of zeroes to address 0x1fe00000
Loading 262144 bytes of zeroes to address 0x1fc00000
Loading binary file /home/build/octsw/sdk/target/bin/u-boot.bin to address 0x1fc00000
loading 105620 bytes
loaded 105620 bytes
Loading binary file /tmp/fileykZ0bG to address 0x1ffffff0
loading 8 bytes
loaded 8 bytes
Loading binary file /tmp/fileio660z to address 0x1ffffff8
loading 8 bytes
loaded 8 bytes
Loading executable file /home/build/octsw/sdk/target/bin/sim-magic-elf
Simulator magic DRAM at address 0xfeffe0000; not supported on hardware.
Loading 132 bytes to address FEFFE0000
Simulating with 2 pps
Found a sim_magic_trap thunk, setting address to 0x8000000feffe0000
Uart listening at localhost.localdomain, 127.0.0.1, port 65258 (0xfeea)


U-Boot 1.1.1 (Mar 14 2005 - 18:39:22)

DRAM:  128 MB
Using default environment


Bootloader: Booting Octeon Executive application at 0x10000000, core mask: 0x3, stack size: 0x100000, heap size: 0x300000
Bootloader: Done loading app on coremask: 0x3
waiting for a connection to uart 1 1
...
</pre></div><p>3) In the debugger terminal: Start mipsisa64-octeon-elf-gdb. </p>
<div class="fragment"><pre class="fragment">
$ mipsisa64-octeon-elf-gdb
GNU gdb 6.3
Copyright 2004 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "--host=i686-pc-linux-gnu --target=mipsisa64-octeon-elf".
(Core#0-gdb)
</pre></div><p>4) Select the file for debug and connect to the simulator. </p>
<div class="fragment"><pre class="fragment">
(Core#0-gdb) file test.out
Reading symbols from /home/build/octsw/sdk/examples/debugger/test.out...done.
(Core#0-gdb) target octeon tcp::65258 -noperf -quiet -numcores=2
Remote target octeon connected to tcp::65258
(Core#0-gdb) load
Loading section .init, size 0x24 lma 0x10000018
Loading section .text, size 0xa370 lma 0x10000040
Loading section .fini, size 0x1c lma 0x1000a3b0
Loading section .rodata, size 0x628 lma 0x1000a3d0
Loading section .data, size 0xe70 lma 0x12000000
Loading section .eh_frame, size 0x4 lma 0x12000e70
Loading section .ctors, size 0x10 lma 0x12000e78
Loading section .dtors, size 0x10 lma 0x12000e88
Loading section .jcr, size 0x8 lma 0x12000e98
Loading section .sdata, size 0xb8 lma 0x12000ea0
Loading section .cvmx_shared, size 0x8 lma 0x14000000
Start address 0x10000148, load size 47412
Transfer rate: 379296 bits in &lt;1 sec, 464 bytes/write.
(Core#0-gdb)
</pre></div><p>5) Debugging multicore works only on simple executive applications. The multicore debugging requires CIU interrupts that are defined in simple execute library. Just link the simple execute library to your applications, refer to debugger example for more details. To run the initialization code, set step-all to on. Also make sure the focused core is set to core 0. </p>
<div class="fragment"><pre class="fragment">
(Core#0-gdb) set step-all on
</pre></div><p>6) Place a break point on main and run. </p>
<div class="fragment"><pre class="fragment">
(Core#0-gdb) break main
Breakpoint 1 at 0x20000378: file test.c, line 67.
(Core#0-gdb) continue
Continuing.

Breakpoint 1, main () at test.c:62
62        int iNbr = 1;
(Core#0-gdb)
</pre></div><p>7) Disable step-all to debug the focused core. </p>
<div class="fragment"><pre class="fragment">
(Core#0-gdb) set step-all off
</pre></div><p>8) You can now issue normal gdb commands. Some useful ones are step, next, print, set variable, break, and continue.</p>
<h2><a class="anchor" id="intercore_debugger">
16 Running the inter-core Debugger</a></h2>
<p>The debugger can be run under Linux on the OCTEON Hardware and be able to debug other applications on other cores.</p>
<p>Before invoking the debugger, the program has to be running. See linux_user_bootoct for how to run a program while under Linux. Make sure the "debug" option is passed to the bootoct command.</p>
<p>Now invoke the debugger using mipsisa64-octeon-elf-gdb command.</p>
<div class="fragment"><pre class="fragment">
  # mipsisa64-octeon-elf-gdb -q test.out
@end_verbatim

This will provide you with a "(Core#0-gdb)" prompt just like the standard OCTEON debugger.
Connect to the inter-core target using:
@verbatim
  (Core#0-gdb) target octeon LINUX
    Remote target octeon connected to tcp::3001
</pre></div><p>This will provide you with a debugger that is able to do the standard OCTEON multicore debugger.</p>
<p>Note this connects to a oct-debug-agent program running on the Linux via tcp. The oct-debug-agent program can be added to the embedded_rootfs using "make menuconfig" under the linux/embedded_rootfs directory and the simple executive debugger for Linux as <b>Simple exec gdb</b>. If doing "target octeon LINUX" fails saying localhost does not exist, try moving aside /etc/resolv.conf. </p>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Oct 2017 for Octeon Software Development Kit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
