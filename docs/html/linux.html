<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Octeon Software Development Kit: Linux on the OCTEON</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="linux">Linux on the OCTEON </a></h1><h2><a class="anchor" id="linux_intro">
1. Introduction</a></h2>
<p>Since the OCTEON cnMIPS cores are fully MIPS64r2 compliant processor cores, each cnMIPS is capable of executing any of a variety of standard operating system. This document provides details of executing Linux on one or more cnMIPS cores. Although this document is Linux specific, the general principals cover should apply to any operating system ported to OCTEON.</p>
<p>This document provides detailed information on the following aspects of Linux on the Cavium Inc. OCTEON processor:</p>
<ul>
<li><a class="el" href="linux.html#linux_intro">1. Introduction</a></li>
<li><a class="el" href="linux.html#linux_kernel">2. The Kernel</a></li>
<li><a class="el" href="linux.html#linux_userspace">3. Embedded User Environment</a></li>
<li><a class="el" href="linux.html#linux_filesystem">4. Loading The Filesystem</a></li>
<li><a class="el" href="linux.html#linux_running_sim">5. Running Linux on the Simulator</a></li>
<li><a class="el" href="linux.html#linux_running_ebb6800">6. Running Linux on the EBB68XX Hardware</a></li>
<li><a class="el" href="linux.html#linux_cop2">7. Process Context and Coprocessor 2</a></li>
<li><a class="el" href="linux.html#linux_cvmseg">8. Process Context and CVMSEG (Local Scratch Memory)</a></li>
<li><a class="el" href="linux.html#linux_mul">9. Process Context and the Multiply Unit</a></li>
<li><a class="el" href="linux.html#linux_tls">10. Accelerated Thread Local Storage (TLS) Access</a></li>
<li><a class="el" href="linux.html#linux_mapped_kernel">11. Running the Linux kernel in mapped memory.</a></li>
<li><a class="el" href="linux.html#linux_per_process_xkphys_access">12. Per-process access control for XKPHYS</a></li>
<li><a class="el" href="linux.html#linux_cvmx">13. Co-existing with Simple Executive Applications</a></li>
<li><a class="el" href="linux.html#linux_hotplug_cpu">14. Linux Hot-Plug CPU.</a></li>
<li><a class="el" href="linux.html#linux_ethernet">15. Kernel Ethernet Drivers</a></li>
<li><a class="el" href="linux.html#linux_usb">16. Kernel USB Drivers</a></li>
<li><a class="el" href="linux.html#linux_rng">17. Kernel Random Number Generator (RNG) Driver</a></li>
<li><a class="el" href="linux.html#linux_nfs_root">18. Configuring NFS Root Filesystem</a></li>
<li><a class="el" href="linux.html#linux_initrd_root">19. Configuring a separate initrd or initramfs Root Filesystem</a></li>
<li><a class="el" href="linux.html#linux_performance_counters">20. OCTEON Performance Counters</a></li>
<li><a class="el" href="linux.html#linux_kernel_debugging">21. Debugging the Kernel</a></li>
<li><a class="el" href="linux.html#linux_kernel_debugging_kgdb">22. Debugging the Kernel with KGDB</a></li>
<li><a class="el" href="linux.html#linux_kernel_boot2">23. Booting Two Separate Kernels on an EBB68XX</a></li>
<li><a class="el" href="linux.html#linux_kernel_boot2_pow_ethernet">24. Ethernet between two booted kernels using the POW</a></li>
<li><a class="el" href="linux.html#linux_kernel_watchdog">26. OCTEON Watchdog Driver</a></li>
<li><a class="el" href="linux.html#linux_user_changes">27. OCTEON Specific Changes in Userspace</a></li>
<li><a class="el" href="linux.html#linux_config_options">28. OCTEON Specific Kernel Config Options</a></li>
<li><a class="el" href="linux.html#linux_octeon2">29. OCTEON II specific kernel considerations.</a></li>
<li><a class="el" href="linux.html#linux_ftrace">30. Kernel tracing with ftrace</a></li>
<li><a class="el" href="linux.html#linux_randomize_va_space">31. Address Space Randomization</a></li>
<li><a class="el" href="linux.html#linux_kexec">32. Kernel KEXEC support</a></li>
<li><a class="el" href="linux.html#linux_kdump">33. Kernel KDUMP support</a></li>
<li><a class="el" href="linux.html#linux_sample_log">34. Sample Boot Log</a></li>
</ul>
<h2><a class="anchor" id="linux_kernel">
2. The Kernel</a></h2>
<p>The Linux kernel, as configured for OCTEON, supports up to 32 way SMP with 32 bit and 64 bit userspace support. In order to allow application developers the most flexibility, the base kernel only uses a bare minimum of OCTEON hardware units. Optional Linux kernel drivers are available for many OCTEON hardware units. All units not controlled by the base kernel or optional kernel drivers, are available for application use. The following is a list of hardware resources reserved for Linux:</p>
<ol type="1">
<li>Console UART + Linux uses the UART number passed from the bootloader to determine which serial port is used for the console. Which UART, and how many UARTs, are assigned Linux devices is dependent on several factors:<ul>
<li>The Linux kernel will install drivers for all UARTs unless they are explicitly disabled by passing 'uartdisable=x,y' on the kernel command line, where x an y are replaced with the numbers of the UARTs to disable. The UART devices will be assigned in order to as many of /dev/ttyS0, /dev/ttyS1 and /dev/ttyS2 as are required.</li>
<li>If CONFIG_CAVIUM_GDB is selected, UART 1 will not have a kernel driver enabled so that it can be used by the debugger. This has the same effect as passing 'uartdisable=1' on the kernel command line.</li>
<li>If the bootloader passes 0 or 1 as the console UART and no other console is specified on the kernel command line, the kernel will use the corresponding device as its console.</li>
<li>Note that ttyS numbers change based on which OCTEON UARTs are assigned ttyS devices.</li>
</ul>
</li>
<li>CIU and Interrupts 2, 3 and 4 + The Linux kernel automatically retrieves the information about interrupt lines 2, 3 and 4 from the CIU/CIU2. These interrupts are passed onto the kernel using the symbolic names in the arch/mips/include/asm/mach-cavium-octeon/irq.h file. These map to the bits in the CIU/CIU2 interrupt summary registers.</li>
<li>Mailboxes + The CIU mailbox registers are used for inter core SMP scheduling messages. Cores not under Linux control are free to use mailboxes, but care should be taken not to modify the mailbox registers of cores in use by the Linux kernel.</li>
<li>TLB + All cores running Linux assume the TLB is under the complete control of the kernel. Applications may modify the TLB for cores not running Linux, but never of those actively running the kernel.</li>
<li>Interrupts and Exceptions Locations + The Cavium Inc. <a class="el" href="bootloader.html">OCTEON Bootloader</a> provides a unique exception vector base address to each application image. Applications must read and use the MIPS exception base address here in order to insure core vectors don't overlap.</li>
</ol>
<h3><a class="anchor" id="linux_kernel_building">
Building the Linux Kernel</a></h3>
<p>The Cavium SDK provides a high level Makefile to simplify building the Linux Kernel for different targets.</p>
<p>Invoking make under linux directory without a target provides a help message.</p>
<div class="fragment"><pre class="fragment">
Supply the build target:
    kernel               - Build the Linux kernel supporting all Cavium OCTEON reference boards
    kernel-deb           - Linux kernel without the rootfs
    sim                  - OCTEON simulation environment
    setup-octeon2        - Enable config options for running on OCTEON II hardware
    setup-octeon2-sim    - Enable config options for running on OCTEON II simulation
    flash                - Copy kernel onto compact flash at mount /mnt/cf1
    strip                - Strip symbols out of the kernel image
    tftp                 - Copy a stripped kernel to /tftpboot
    test                 - Test an existing simulator build
    clean                - Remove all generated files and the KERNEL CONFIG
 
    link-kernel-se-files - Create links of all necessary files from simple
                           executive directory, required for building kernel
</pre></div><p>To build the kernel to run on OCTEON II models first invoke 'make setup-octeon2/setup-octeon2-sim', to enable the proper config options.</p>
<p>Invoke 'make kernel|sim' to build the Linux kernel image.</p>
<h2><a class="anchor" id="linux_userspace">
3. Embedded User Environment</a></h2>
<p>Embedded Linux systems require a small root filesystem that can be put inside of the kernel or a flash device. A standard Linux distribution, Debian for example, takes hundreds of megabytes for a basic system. This can't be used with devices that only have 8-16MB of boot flash. Cavium Inc. supplies embedded_rootfs to fill this need. This filesystem build system has the following features to support small systems:</p>
<ul>
<li>Full cross compile of packages. + A standard x86 PC is used to build the filesystem. This can then be downloaded to the embedded target.</li>
<li>Small size. + Each package provided by Cavium Inc. has been tailored to minimize the space required for the package. Executables and shared libraries are stripped of debugging symbols. Busybox replaces most command line utilities with smaller equivalents.</li>
<li>Pluggable packages. + All packages can be added and removed using a GUI menuing system. Dependencies between packages are respected. If you install a package requiring 64bit libraries, the 64bit libraries are automatically selected. No existing files need to be modified to add packages.</li>
<li>Simplified init scripts. + A desktop Linux system using System V init uses a large number of programs that are unneeded in an embedded device. This complicated system has been replaced with a single, simple <b>rc</b> script.</li>
<li>Multiple filesystem formats. + The build system supports creating a initramfs, cramfs, squashfs, ext3, ext2, and a NFS based root filesystem.</li>
<li>OCTEON II libraries. + OCTEON II has additional instructions and requires separate library. It is configurable through GUI menuing system to unselect installing these libraries for a specific ABI.</li>
</ul>
<h3><a class="anchor" id="linux_userspace_build_rootfs">
Building the Filesystem</a></h3>
<p>The top level Linux makefile automatically build the embedded root filesystem when you invoke the <b>kernel</b> and <b>sim</b> targets. If you would like to build the filesystem independently from the kernel, execute make in the linux/embedded_rootfs directory. Make without a target provides a help message.</p>
<div class="fragment"><pre class="fragment">
    $ make

    menuconfig        - Configure the packages for the filesystem (GUI)
    config            - Configure the packages for the filesystem (Command line)
    oldconfig         - Check the existing config file
    all               - Build the filesystem
    squashfs          - Package the filesystem into Squashfs
    cramfs            - Package the filesystem into Cramfs
    ext3              - Package the filesystem into Ext3
    ext2              - Package the filesystem into Ext2
    initramfs         - Use the CPIO archive as an initramfs
    clean             - Delete the builds and all filesystem files
    clean-root        - Delete the filesystem files leaving the builds
    distclean         - Delete all generated files, including the config

    Currently configured packages:
    kernel-modules device-files busybox init-scripts module-init-tools libpcap
    octeon-libraries-n32 octeon2-libraries-n32 octeon-libraries-64
    octeon2-libraries-64 readline openssl zlib popt lzo bridge-utils
    ethtool mii-tool net-tools tcpdump iproute2 iputils strace schedtool
    oprofile bootoct oct-linux-identify oct-linux-mdio
    oct-linux-jtg load-llm octeon-remote-utils htlbremap toolchain-utils gdb
    mtd-tools sdk-examples intercept-example iozone rsync lockstat pciutils
    libhugetlbfs testsuite final-cleanup
</pre></div><p>For reference, the top level Linux <b>kernel</b> target performs a "make -s all initramfs". This creates a kernel with the filesystem inside the ELF file with the kernel. Having the filesystem inside the kernel works well with TFTP and compact flash in a development style environment. The top level Linux <b>sim</b> target performs "make -s all ext2". The simulator uses an ext2 filesystem directly loaded into simulator memory.</p>
<h3><a class="anchor" id="linux_userspace_force_build">
Forcing a Filesystem Build</a></h3>
<p>When a build of the root filesystem completes, it creates a file <b>.root_complete</b>. This is used as an optimization to prevent kernel builds from building the filesystem repeatedly. The build system attempts to check for makefile or configuration changes, but sometimes it misses changes that have occurred in packages. If this happens, simply delete the <b>.root_complete</b> file to force a filesystem to rebuild on the next make.</p>
<h3><a class="anchor" id="linux_userspace_shrink_rootfs">
Tips to shrink size</a></h3>
<p>This sections has moved to <a class="el" href="linux_small.html">Linux on Small OCTEON Systems</a> - <a class="el" href="linux_small.html#linux_small_shrink_rootfs">8. Tips to shrink the root filesystem size</a>.</p>
<h3><a class="anchor" id="linux_userspace_install_rootfs">
Installing in Flash</a></h3>
<p>This sections has moved to <a class="el" href="linux_small.html">Linux on Small OCTEON Systems</a> - <a class="el" href="linux_small.html#linux_small_flash_layout">3. Setting up the boot flash</a>.</p>
<h3><a class="anchor" id="linux_userspace_add_pkg">
How to Add a Package</a></h3>
<p>The embedded rootfs make system is designed to allow packages to be added easily. By adding two files to the package directories, the new package will appear in the configuration menu and be built as part of the filesystem. Under pkg_kconfig, you need to add a menu entry for the package. You then add the package's makefile under pkg_makefiles. As an example, the files below are for strace.</p>
<p><b>pkg_kconfig/70-strace.kconfig</b> </p>
<div class="fragment"><pre class="fragment">
    config CONFIG_strace
    	bool "strace"
    	default y
    	help
    		From the strace homepage:
    		Strace is a system call trace, i.e. a debugging tool which
    		prints out a trace of all the system calls made by a another
    		process/program. The program to be traced need not be recompiled
    		for this, so you can use it on binaries for which you don't have
    		source.

    		System calls and signals are events that happen at the
    		user/kernel interface. A close examination of this boundary is
    		very useful for bug isolation, sanity checking and attempting
    		to capture race conditions
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>The sort order of the files in pkg_kconfig control the order they appear in the menu. For simplicity we use a number prefex to control ordering.</dd></dl>
<p><b>pkg_makefiles/strace.mk</b> </p>
<div class="fragment"><pre class="fragment">
PKG:=strace
VERSION:=4.5.14
DIR:=${PKG}-${VERSION}

.PHONY: all
all: build install

.PHONY: build
build: ${DIR} ${DIR}/Makefile
	${MAKE} -C ${DIR}

${DIR}/Makefile:
	cd ${DIR} &amp;&amp; ./configure --host=${CROSS} CFLAGS="${CFLAGS}" LDFLAGS="${TOOLCHAIN_ABI}"

.PHONY: install
install: ${DIR}
	mkdir -p ${ROOT}/usr/bin
	${STRIP} -o ${ROOT}/usr/bin/strace ${DIR}/strace

${DIR}:
	tar -jxf ${STORAGE}/${PKG}-${VERSION}.tar.bz2
	cd ${DIR} &amp;&amp; patch -p0 &lt; ${STORAGE}/strace.patch
</pre></div><p><b>Notes on makefiles for packages</b></p>
<ol type="1">
<li>The make file is run in <b>linux/embedded_rootfs/build</b></li>
<li>Libraries need to be place in /usr/lib32 or /usr/lib64. The directory /usr/lib is not searched since it is for Mips O32 libraries.</li>
<li>Use strip on all executables and libraries to save space.</li>
<li>The following variables are export to the makefile: + ROOT = The directory where the filesystem is being created. + STORAGE = linux/embedded_rootfs/storage + SOURCE_DIR = linux/embedded_rootfs/source + ETC_FILES = linux/embedded_rootfs/etc-files + KERNEL_DIR = The location of the kernel source + CROSS = mips64-octeon-linux-gnu + CC = mips64-octeon-linux-gnu-gcc + CXX = mips64-octeon-linux-gnu-g++ + LD = mips64-octeon-linux-gnu-ld + AR = mips64-octeon-linux-gnu-ar + RANLIB = mips64-octeon-linux-gnu-ranlib + STRIP = mips64-octeon-linux-gnu-strip + CFLAGS = Recommended C flags + CXXFLAGS = Recommended C++ flags + TOOLCHAIN_ABI = The current build ABI. Can be either <b>-mabi=n32</b> or <b>-mabi=64</b>. + LDFLAGS = -melf32btsmipn32 or -melf64btsmip + OCTEON_EXTRA_CFLAGS = The current build instruction set. Can be either <b>-march=octeon</b> or <b>-march=octeon2</b>. + LIBDIR = The directory to install libraries</li>
</ol>
<h3><a class="anchor" id="linux_userspace_init_seq">
Userspace init Sequence</a></h3>
<p>In order to simplify embedded Linux development, the userspace initialization scripts have been simplified down into one shell script. The userspace initialization process is as follows:</p>
<ol type="1">
<li>Linux kernel mounts the root filesystem.</li>
<li>The kernel starts the first user process <b>/sbin/init</b> provided by Busybox.</li>
<li><b>/sbin/init</b> reads <b>/etc/inittab</b> (From the SDK: <b>linux/embedded_rootfs/etc-files/inittab</b>).</li>
<li><b>/etc/inittab</b> starts the shell script <b>/sbin/rc</b> (From the SDK: <b>linux/embedded_rootfs/etc-files/rc</b>).</li>
<li><b>/sbin/rc</b> mounts the kernel pseudo filesystems <b>/proc</b>, <b>/dev/shm</b>, and <b>/dev/pts</b>.</li>
<li><b>/sbin/rc</b> brings up the loopback network device with the IP address 127.0.0.1.</li>
<li><b>/sbin/rc</b> starts <b>syslogd</b> provided by Busybox.</li>
<li><b>/sbin/rc</b> starts <b>telnetd</b> provided by Busybox.</li>
<li><b>/sbin/rc</b> exits returning control in <b>/sbin/init</b>.</li>
<li><b>/etc/inittab</b> tells <b>/sbin/init</b> to spawn an interactive shell.</li>
<li>The user interactive shell prompt appears.</li>
</ol>
<h2><a class="anchor" id="linux_filesystem">
4. Loading The Filesystem</a></h2>
<p><b>OCTEON</b> <b>Simulator</b> </p>
<p>Since OCTEON simulation environment does not provide a virtual disk device, the root filesystem is loaded from a fixed address (<b>0x40000000</b>) in simulated ram. The linux kernel configures a MTD block device (<b>/dev/mtdblock0</b>) and mounts the filesystem from memory. The default configuration limits the in memory filesystem to 1GB.</p>
<p><b>EBB68XX</b> <b>Hardware</b> <b>Reference</b> <b>Board</b> </p>
<p>The filesystem is built directly into the kernel as an initramfs image. After the kernel boot, the initial contents of the filesystem are extracted into a memory based filesystem (tmpfs). Once the extraction is complete, /init is called.</p>
<p><b>Contents</b> <b>of</b> <b>the</b> <b>Filesystem</b> </p>
<p>The default filesystem is built from scratch under <b>linux/embedded_rootfs</b>. Performing a <b>make</b> <b>ext2</b> in this directory will build the filesystem.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Performing a couple of the commands needed to build the root filesystem requires root privileges. The Makefile uses the <b>sudo</b> command to perform these steps. Insure that <b>sudo</b> is configured properly for your user. For example, <b>sudo</b> <b>ls</b> should work.</dd></dl>
<p>The Makefile copies each of the simple executive examples supporting Linux is copied into <b>/examples</b> in the filesystem. See the documentation for each example for directions on how to run it.</p>
<h2><a class="anchor" id="linux_running_sim">
5. Running Linux on the Simulator</a></h2>
<p>The SDK provides the shell script <b>oct-linux</b> to simplify the execution of Linux on the simulator. It is simply a convenience wrapper around <b>oct-sim</b>. In most case you will start linux with the following command line:</p>
<div class="fragment"><pre class="fragment">$ oct-linux -quiet -noperf -numcores=#
</pre></div><p>The options "-quiet" and "-noperf" are not strictly needed, but greatly increase the simulation speed. The number of cores running Linux can be controlled by the "-numcores" argument. Here is a listing of the <b>oct-linux</b> script and a description of each of its parts.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#!/bin/bash</span>
<span class="preprocessor"></span>
memory=384
uart=2020
packet_port=2000

oct-sim linux/vmlinux.64 -envfile=u-boot-env -memsize=${memory} \
    -uart0=${uart} -serve=${packet_port} \
    -ld0x40000000:embedded_rootfs/rootfs.ext2 $*
</pre></div><ul>
<li>oct-sim + The SDK script for executing the OCTEON simulator</li>
<li>linux/vmlinux.64 + The Linux kernel packaged as a 64 bit elf binary.</li>
<li>-envfile=u-boot-env + <a class="el" href="bootloader.html">OCTEON Bootloader</a> environment to automatically start Linux. It contains the single line: bootcmd=bootoctlinux 0x10000000</li>
<li>-memsize=${memory} + Set the amount of simulated memory</li>
<li>-uart0=${uart} + The TCP/IP port the simulator will listen on for uart connections</li>
<li>-serve=${packet_port} + The TCP/IP port the simulator will listen for <b>oct-packet-io</b> to connect to.</li>
<li>-ld0x40000000:embedded_rootfs/rootfs.ext2 + Load the filesystem binary into simulated ram at the expected MTD address.</li>
<li>$* + Any arguments supplied by the user.</li>
</ul>
<p>Once Linux is running in the simulator you will start seeing the following messages from the simulator:</p>
<div class="fragment"><pre class="fragment">
waiting for a connection to uart 0 1
waiting for a connection to uart 0 2
waiting for a connection to uart 0 3
waiting for a connection to uart 0 4
</pre></div><p>At this time you need to connect to the simulator using TCP to get the uart data. The standard program <b>telnet</b> works well for this. In another terminal issue the following command:</p>
<div class="fragment"><pre class="fragment">$ telnet localhost 2020
</pre></div><p>You should now see the Linux boot messages followed by userspace initialization. After all this is complete, an interactive shell will appear.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Once Linux boots to a shell prompt, it can be useful to change telnet to character mode instead of line mode. In the telnet session press <b>Control-]</b> and enter <b>mode</b> <b>char</b> at the prompt. Then hit enter a few times. Shell tab completion, Control-C, and other interactive aspects should now work.</dd></dl>
<h2><a class="anchor" id="linux_running_ebb6800">
6. Running Linux on the EBB68XX Hardware</a></h2>
<p>Build Linux for the EBB68XX. </p>
<div class="fragment"><pre class="fragment">
$ cd $(OCTEON_ROOT)/linux
$ make -s clean
$ make -s kernel
</pre></div><p>Copy the Linux kernel to a compact flash. </p>
<div class="fragment"><pre class="fragment">
$ mkdir -p /mnt/usb
$ fdisk -l /dev/sda         # Only needed on some Kernel 2.6 systems
$ mount /dev/sda1 /mnt/usb
$ mips64-octeon-linux-gnu-strip -o /mnt/usb/vmlinux.64 kernel/linux/vmlinux.64
$ umount /mnt/usb
</pre></div><p>Put the compact flash into the EBB68XX and reset the board. At the bootloader prompt load linux. </p>
<div class="fragment"><pre class="fragment">
Octeon ebb6800# fatload ide 0 $(loadaddr) vmlinux.64
Octeon ebb6800# bootoctlinux $(fileaddr)
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>Most bootloaders have an alias for this: run linux_cf</dd></dl>
<p>All arguments on the <b>bootoctlinux</b> command are passed to the Linux kernel. Two options are used frequently: <b>mem=</b> and <b>root=</b>.</p>
<ul>
<li><b>mem=</b> is used to set how much memory the Linux kernel uses in megabytes. Setting it to 0 will use all available memory.</li>
<li><b>root=</b> is used to set the device for the root filesystem. This is used with Debian to set the filesystem to the compact flash. (root=/dev/sda2).</li>
</ul>
<h2><a class="anchor" id="linux_cop2">
7. Process Context and Coprocessor 2</a></h2>
<p>Linux on the OCTEON saves and restores coprocessor 2 (COP2) so that it may be used freely by userspace applications.</p>
<p>In order to improve performance, Linux disables COP2 by default. COP2 is only enabled when a task attempts to perform a COP2 operation. At this time, the kernel enables COP2 and restores any saved state. Here is a description of kernel COP2 processing:</p>
<ol type="1">
<li>COP2 is disabled using COP0 Status[CU2].</li>
<li>Application runs and executes a COP2 instruction.</li>
<li>Kernel receives an illegal COP2 access exception.</li>
<li>Kernel enables COP2 and initializes its state.</li>
<li>Kernel returns control to the application.</li>
<li>Application continues processing, performing any number of COP2 instructions.</li>
<li>Application stops processing and returns to kernel context. This can occur through a interrupt, exception, or syscall.</li>
<li>Kernel performs a context switch by calling <b>resume</b>.</li>
<li>The assembly function <b>resume</b> checks if COP0 Status[CU2] has enabled COP2. If so, it calls <b>octeon_cop2_save</b> to save COP2 state.</li>
<li>COP2 is again disabled using COP0 Status[CU2].</li>
<li>Normal kernel processing continues.</li>
<li>Control returns to the application. Note that COP2 is still disabled.</li>
<li>Application continues processing until reaching a COP2 instruction.</li>
<li>Kernel receives an illegal COP2 access exception.</li>
<li>Kernel enables COP2 and restores its state.</li>
<li>Kernel returns control to the application.</li>
</ol>
<p>Kernel use of COP2 is normally disabled since it can corrupt the userspace state. In order to access COP2 from inside the kernel, you must wrap your COP2 code with calls to the functions <b>octeon_crypto_enable()</b> and <b>octeon_crypto_disable()</b>. The following is a simplified example: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #include &lt;asm/octeon/octeon-crypto.h&gt;</span>

    <span class="keywordtype">void</span> do_kernel_crypto(...)
    {
        <span class="keyword">struct </span>octeon_cop2_state <a class="code" href="cvmx-coremask_8c.html#a011fd79dedb753c38d0be337369be477" title="This structure defines the private state maintained by coremask module.">state</a>;
        <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags;

        flags = octeon_crypto_enable(&amp;<a class="code" href="cvmx-coremask_8c.html#a011fd79dedb753c38d0be337369be477" title="This structure defines the private state maintained by coremask module.">state</a>);

        COP2 accesses

        octeon_crypto_disable(&amp;<a class="code" href="cvmx-coremask_8c.html#a011fd79dedb753c38d0be337369be477" title="This structure defines the private state maintained by coremask module.">state</a>, flags);
    }
</pre></div><p>The key issues to remember with kernel level COP2 access are:</p>
<ol type="1">
<li>The structure octeon_cop2_state normally must be store on the stack. Most functions in the kernel are reentrant as they can be called on behalf of a process, in softirq, and from an interrupt.</li>
<li>The "flags" parameter must be passed unchanged to octeon_crypto_disable(). This "flags" is independent of local_irq_save() and local_irq_restore() which also tend to use a "flags" parameter. If you need interrupts disabled you must call these independent of the COP2 enable / disable.</li>
<li>It is possible for COP2 to be enabled outside of regions surrounded by these functions. It is unsafe to use COP2 in this instance. All kernel COP2 must be surrounded by these calls.</li>
<li>COP2 will only be saved if necessary. Sometimes calls to these functions will not update the state parameter.</li>
<li>octeon_crypto_enable() and octeon_crypto_disable() are only available if you configure your kernel with CONFIG_CAVIUM_OCTEON_KERNEL_CRYPTO.</li>
</ol>
<h2><a class="anchor" id="linux_cvmseg">
8. Process Context and CVMSEG (Local Scratch Memory)</a></h2>
<p>Userspace state in CVMSEG is saved and restored on context switch. This allows any application to use the CVMSEG memory. Here is a description of kernel CVMSEG processing:</p>
<ol type="1">
<li>On boot CVMSEG size is set using CvmMemCtl[LMEMSZ] = CONFIG_CAVIUM_OCTEON_EXTRA_CVMSEG + lines used by kernel.</li>
<li>Kernel access to CVMSEG is enabled using CvmMemCtl[CVMSEGENAK] = 1.</li>
<li>User access to CVMSEG is disabled using CvmMemCtl[CVMSEGENAU] = 0.</li>
<li>Applications runs and executes an access to CVMSEG. This could be a load, store, or an asynchronous IOBDMA.</li>
<li>Kernel receives an invalid memory reference exception.</li>
<li>In <b>do_ade()</b>, the kernel determines the address is in CVMSEG.</li>
<li>The kernel enables user access to CVMSEG using CvmMemCtl[CVMSEGENAU] = 1.</li>
<li>Kernel returns control to the application.</li>
<li>Application continues processing, performing any number of CVMSEG accesses.</li>
<li>Application stops processing and returns to kernel context. This can occur through a interrupt, exception, or syscall.</li>
<li>Kernel performs a context switch by calling <b>resume</b>.</li>
<li>The assembly function <b>resume</b> checks if COP0 CvmMemCtl[CVMSEGENAU] has enabled CVMSEG. If so, it saves CVMSEG state.</li>
<li>CVMSEG is again disabled using COP0 CvmMemCtl[CVMSEGENAU].</li>
<li>Normal kernel processing continues.</li>
<li>Control returns to the application. Note that CVMSEG is still disabled.</li>
<li>Application continues processing until reaching a CVMSEG access.</li>
<li>Kernel receives an invalid memory reference exception.</li>
<li>In <b>do_ade()</b>, the kernel determines the address is in CVMSEG.</li>
<li>The kernel restore CVMSEG context and enables user access to CVMSEG using CvmMemCtl[CVMSEGENAU] = 1.</li>
<li>Kernel returns control to the application.</li>
</ol>
<p>Kernel use of CVMSEG must always save and restore any changes that it makes. It must issue a SYNCIOBDMA to make sure all asynchronous operations are complete before the save and before the restore.</p>
<h2><a class="anchor" id="linux_mul">
9. Process Context and the Multiply Unit</a></h2>
<p>The extended multiply unit context is saved in SAVE_SOME and restore in RESTORE_SOME(stackframe.h). This occurs every time the processor switches from user to kernel context due to an interrupt, exception, or syscall. The multiply unit may be freely used from user and kernel space.</p>
<h2><a class="anchor" id="linux_tls">
10. Accelerated Thread Local Storage (TLS) Access</a></h2>
<p>On the Mips architecture, Linux implements thread local storage (TLS) using hardware register 29. GCC and Glibc use the instruction <b>rdhwr v1, $29</b> to get the current value of the thread pointer. Since hardware register 29 doesn't exist on most Mips processors (including OCTEON and OCTEON Plus), the kernel traps this instruction with a Reserved Instruction Exception. The exception handler emulates the rdhwr instruction and places the current thread pointer in "v1". The overhead in emulating this non existent hardware register is very high. Because OCTEON II processor does implement hardware register 29, there is no added overhead for it to execute the <b>rdhwr v1, $29</b> instructions.</p>
<p>On OCTEON, use of k0 and CVMSEG provide a much faster access to the thread pointer. Using a combination of the two, OCTEON Linux accesses the thread pointer using a single dual issueable instruction. Applications heavily using TLS and threads will receive a major performance boost. The normal Mips instruction emulation, talking many hundreds of cycles, is replaced with a single cycle local access. Support for the improved access is part of the Cavium supplied toolchain.</p>
<p>If you are using a non Cavium toolchain, or a toolchain prior to SDK 1.5, the kernel supports dynamically replacing instructions in userspace with the faster access method. Instruction replacement is disabled on boot. It can be controlled by writing a mode to <b>/sys/module/traps/parameters/thread_pointer_mode</b>. The supported modes are:</p>
<ul>
<li>0 - Use the normal kernel emulation without any changes.</li>
<li>1 - Replace emulated instructions with direct accesses to the thread register.</li>
<li>2 - Replace emulated instructions and log the replacement PC.</li>
<li>3 - Replace emulated instructions with break instructions. This will cause programs to fail, but makes it easy to stop gdb on the instruction.</li>
</ul>
<p>In implementing fast TLS access, OCTEON uses the k0 register in userspace and the highest allocated CVMSEG address. It is normally not valid to use the k0 register in userspace, so this will not affect userspace programs. The CVMSEG usage will cause problems for applications that use the same address as the kernel. In the case of a conflict, TLS will continue to function properly, but any data the application has placed in the last CVMSEG address will be corrupted.</p>
<p>Starting with SDK 2.0, if the Cavium toolchain is generating code for OCTEON II processors (by passing -march=octeon2 to the compiler), the standard TLS access using <b>rdhwr v1, $29</b> is generated. However by default, when generating code for OCTEON and OCTEON Plus processors, the accelerated TLS access using k0 is used.</p>
<h2><a class="anchor" id="linux_mapped_kernel">
11. Running the Linux kernel in mapped memory.</a></h2>
<p>The default configuration of the Linux kernel places the kernel in unmapped memory, and any loadable kernel modules are in a mapped memory region. This separation of the kernel and modules requires that a less efficient function calling mechanism be used in the kernel modules than in the kernel itself, resulting in a decrease in performance for some code.</p>
<p>The optional CONFIG_MAPPED_KERNEL kernel configuration parameter causes the kernel to be run in the mapped memory region. It also builds the kernel modules with the same efficient function calling mechanism used in the main kernel. The result can be increased performance, however one TLB entry on each core is used for the kernel mapping, thus reducing the number of TLB entries available for normal use. Reducing the number of available TLB entries in this manner, might cause a reduction in performance, so benchmarking of the intended workload should be done to determine if CONFIG_MAPPED_KERNEL actually improves performance for the case in question.</p>
<h3><a class="anchor" id="Booting">
Two separate mapped kernels.</a></h3>
<p>OCTEON Linux can be configured to run two separate mapped kernels with each kernel using separate uart for their respective consoles. The procedure for building two separate kernels is the same as mentioned in <a class="el" href="linux.html#linux_kernel_boot2">23. Booting Two Separate Kernels on an EBB68XX</a> section. Also enable CONFIG_MAPPED_KERNEL config option, while building both the kernels.</p>
<p>Both the images are linked at the same virtual address, and the bootloader makes sure it allocates separate physical memory while loading them.</p>
<h2><a class="anchor" id="linux_per_process_xkphys_access">
12. Per-process access control for XKPHYS</a></h2>
<p>There are certain applications (like Simple Executive applications running in Linux userspace) that require direct access to XKPHYS memory and IO spaces. By default access to XKPHYS segments is disabled for all applications. Applications which need to access these segments need to call sysmips() system call to enable access.</p>
<p>To enable access to XKPHYS memory space the application needs to call sysmips as follows:</p>
<div class="fragment"><pre class="fragment">sysmips(MIPS_CAVIUM_XKPHYS_WRITE, getpid(), 1, 0);
</pre></div><p>To enable access to XKPHYS IO space:</p>
<div class="fragment"><pre class="fragment">sysmips(MIPS_CAVIUM_XKPHYS_WRITE, getpid(), 2, 0);
</pre></div><p>To enable access to both XKPHYS memory and IO space:</p>
<div class="fragment"><pre class="fragment">sysmips(MIPS_CAVIUM_XKPHYS_WRITE, getpid(), 3, 0);
</pre></div><p>The kernel also provides config options for enabling XKPHYS access for all processes without requiring them to call sysmips(). Using these config options is not recommended. See section 23 below for a complete list of OCTEON specific config options.</p>
<h2><a class="anchor" id="linux_cvmx">
13. Co-existing with Simple Executive Applications</a></h2>
<p>If Linux is running on a subset of the OCTEON cores, it can co-exist with other operating systems and simple executive applications. Internally Linux uses the simple executive libraries for memory management, synchronization, and hardware access. For example, all memory used by Linux is allocated using the simple executive function <a class="el" href="cvmx-bootmem_8c.html#a4295ccfec5aeb9b415c92fbbb1f5873e" title="Allocate a block of memory from the free list that was passed to the application...">cvmx_bootmem_alloc()</a>. So long as each application / operating system uses the appropriate CVMX library calls for memory management and synchronization, each core can perform a completely independent task. All cores must cooperate for all shared hardware configuration. The <a class="el" href="bootloader.html">OCTEON Bootloader</a> documentation provides details about loading and starting multiple operating systems / applications. Here is a list of general guidelines:</p>
<ol type="1">
<li>Allocate shared memory using <a class="el" href="cvmx-bootmem_8c.html#a4295ccfec5aeb9b415c92fbbb1f5873e" title="Allocate a block of memory from the free list that was passed to the application...">cvmx_bootmem_alloc()</a>. This function provides the needed synchronization so that no applications get overlapping memory.</li>
<li>Keep core dependencies generic. Instead of allocating cores by core ID, use <a class="el" href="cvmx-sysinfo_8c.html#accfd43a83b0d1a8af4fe2728880e3e56" title="This function returns the application information as obtained by the bootloader.">cvmx_sysinfo_get()</a> to get the bitmask of cores actually running your application. Use <a class="el" href="structcvmx__sysinfo.html#a0cd062a7fe9a42bb966db22bc318d9db" title="coremask defining cores running application">cvmx_sysinfo_t::core_mask</a> to determine how many cores are running your application, and use <a class="el" href="cvmx-sysinfo_8h.html#aa1e3d8b3037fd16c9574c2ab4eca439a">cvmx_is_init_core()</a> to select the core for initialization tasks.</li>
<li>Choose a single application to perform hardware initialization. Many initialization tasks must only be performed once.</li>
<li>Use OCTEON hardware for inter application communication. The POW with groups and the FAU unit provide fast hardware based messaging.</li>
</ol>
<h2><a class="anchor" id="linux_hotplug_cpu">
14. Linux Hot-Plug CPU.</a></h2>
<p>If the kernel is built with the CONFIG_HOTPLUG_CPU kernel configuration parameter, OCTEON CPU cores can be removed from the set of cores used by the Linux kernel. This also allows adding new cores to the existing set of cores.</p>
<p>See <b>linux/kernel/linux/Documentation/cpu-hotplug.txt</b> for details.</p>
<p>Cores removed from Linux can then be used to run Simple Executive applications (linux_user_bootoct).</p>
<h2><a class="anchor" id="linux_ethernet">
15. Kernel Ethernet Drivers</a></h2>
<h3><a class="anchor" id="octeon_ethernet_driver">
PIP/IPD/PKO driver for OCTEON and OCTEON II</a></h3>
<p>An ethernet driver module is available in the kernel to support OCTEON using the SGMII interfaces or SPI4 with a SPI4000 daughter card or XAUI interfaces. SGMII ports show up as ethernet devices <b>eth0</b> through <b>eth4</b>, SPI4000 ports are devices <b>spi0</b> through <b>spi9</b> and XAUI port show up as ethernet device <b>xaui0</b>. The interfaces vary based on which OCTEON model is being used.</p>
<p>In order to configure different modes of operation, the ethernet driver module supports a number of module parameters for controlling its configuration. These are set when you <b>modprobe</b> the ethernet driver.</p>
<div class="fragment"><pre class="fragment">
	$ modprobe octeon-ethernet [param=value ...]
</pre></div><ul>
<li>num_packet_buffers + Number of packet buffers to allocate and store in the FPA. By default, 1024 packet buffers are used.</li>
<li>pow_receive_group + POW group to receive packets from. All ethernet hardware will be configured to send incoming packets to this POW group. Also any other software can submit packets to this group for the kernel to process.</li>
<li>disable_core_queueing + When set the networking core's tx_queue_len is set to zero. This allows packets to be sent without lock contention in the packet scheduler resulting in some cases in improved throughput.</li>
<li>max_rx_cpus + The maximum number of CPUs to use for packet reception. Use -1 to use all available CPUs.</li>
<li>rx_napi_weight + The NAPI WEIGHT parameter.</li>
</ul>
<p>The ethernet module assumes the OCTEON hardware needs to be initialized before use. It configures the POW, FPA, CIU, PIP, IPD, PKO, and the FAU. It uses a configuration very similar to the one supplied by <a class="el" href="cvmx-helper-fpa_8c.html#a8098f73c9416fd2d41990cb47f45301a" title="Allocate memory and initialize the FPA pools using memory from cvmx-bootmem.">cvmx_helper_initialize_fpa()</a> and <a class="el" href="cvmx-helper_8c.html#adaa60dd58f62673e28802e1ddacfccf5" title="Initialize the PIP, IPD, and PKO hardware to support simple priority based queues...">cvmx_helper_initialize_packet_io_global()</a>.</p>
<p>When the driver is in use, applications must not reconfigure the hardware. All packets in POW group <b>15</b> will be processed by the kernel. Applications running in user mode or in the simple executive standalone environment may use this group to forward packets to the kernel for processing.</p>
<p>The ethernet driver, along with <b>oct-packet-io</b>, can be used to connect the OCTEON simulator onto a real ethernet device. This allows the simulator virtual machine to appear on a network just like real hardware. Here are the steps required:</p>
<ol type="1">
<li>In the simulated Linux, use ifconfig to set the MAC address to match the address of the ethernet card used for a bridge. If you're willing to run the ethernet card in promiscuous mode this isn't necessary. <div class="fragment"><pre class="fragment">    simulator$ ifconfig eth0 hw ether XX:XX:XX:XX:XX:XX
</pre></div></li>
<li>Make sure the ethernet device is up. It doesn't have to have an IP address. You may also want to put it in promiscuous mode. <div class="fragment"><pre class="fragment">    host$ ifconfig ??? up
</pre></div></li>
<li>Use <b>oct-packet-io</b> to bridge ethernet packets into the simulator. Specify "-o /dev/null" to disable the logging of all packets coming out of the simulator. Note that bridging requires <b>root</b> <b>privileges</b>. <div class="fragment"><pre class="fragment">    host$ sudo oct-packet-io -p 2000 -b 0:???
</pre></div></li>
<li>In the simulator assign the ethernet a valid IP address. If you have a DHCP server, you may be able to use <b>udhcpc</b> to get an address. For <b>udhcpc</b> to work the interface must be <b>up</b>. <div class="fragment"><pre class="fragment">    simulator$ ifconfig eth0 192.168.1.100

    or

    simulator$ ifconfig eth0 up
    simulator$ udhcpc -n -q -i eth0
</pre></div></li>
<li>Ping the simulator. it should now be possible to ping the simulator from another host. <div class="fragment"><pre class="fragment">    host2$ ping 192.168.1.100
</pre></div></li>
<li>Telnet to the simulator. Assuming everything is working, you should be able to telnet to the simulator and get a shell prompt. <div class="fragment"><pre class="fragment">    host2$ telnet 192.168.1.100
</pre></div></li>
</ol>
<dl class="note"><dt><b>Note:</b></dt><dd>Since the packet interface used for bridging bypasses routing, the local host cannot reach the simulator. In order for the localhost to be able to reach the simulator, it must have two ethernet cards. The second card can then be dedicated to the simulator.</dd></dl>
<p>The simulated environment is much slower than real hardware. Some protocols may not function correctly due to timeouts and slow data transfer. NFS, HTTP, telnet, and ssh have all been successfully tested.</p>
<h3><a class="anchor" id="octeon3_ethernet_driver">
PKI/PKO driver for OCTEON III</a></h3>
<p>cn78xx, cn76xx, cn73xx and cnf75xx OCTEON III processors use a separate driver to support Ethernet interfaces. Each port will show up as <b>eth0</b> through <b>ethX</b>.</p>
<p>There are several module parameters that may be changed, although the default values should give good performance.</p>
<div class="fragment"><pre class="fragment">
	$ modprobe octeon3-ethernet [param=value ...]
</pre></div><ul>
<li>recycle_skbs + When set, allow hardware assisted reuse of packet buffers when forwarding packets.</li>
<li>use_tx_queues + When clear, the networking core's tx_queue_len is set to zero. This allows packets to be sent without lock contention in the packet scheduler resulting in some cases in improved throughput.</li>
<li>wait_pko_response + Wait for response after each pko command.</li>
<li>num_packet_buffers + Number of packet buffers to allocate per port.</li>
<li>packet_buffer_size + Size of each RX packet buffer.</li>
<li>rx_contexts + Number of RX threads per port.</li>
</ul>
<h3><a class="anchor" id="linux_mgmt">
Management port Ethernet drivers</a></h3>
<p>In addition to the main Ethernet ports mentioned above, all OCTEON/OCTEON II/OCTEON III processors have additional MII or RGMII Ethernet ports. These are controlled by the octeon_mgmt Ethernet driver and will be named mgmt0 and mgmt1 (if present). The driver is selected with the CONFIG_OCTEON_MGMT_ETHERNET kernel configuration parameter. There are no user settable parameters for this driver.</p>
<h3><a class="anchor" id="octeon_pow_ethernet">
POW Ethernet drivers</a></h3>
<p>The octeon_pow_ethernet creates network devices that send and receive packets to and from POW/SSO groups. These can be used for communicating with CVMX applications as well as other Linux kernel instances.</p>
<div class="fragment"><pre class="fragment">
	$ modprobe octeon-pow-ethernet [param=value ...]
</pre></div><ol type="1">
<li>receive_group + POW group from which to receive packets on the oct0 interface.</li>
<li>broadcast_groups + POW group mask to send broadcasts to.</li>
<li>ptp_rx_group (optional) + POW group from which to receive packets on for the pow0 interface. This a a Point-to-Point mode interface that always sends and receives from exactly the POW groups specified.</li>
<li>ptp_tx_group (optional) + POW group to send packets to for the pow0 interface.</li>
<li>reverse_endian + If a mix of big/little-endian code is running, set reverse_endian=1 on one side only. CN7XXX only:</li>
<li>pki_packet_pool + On CN7XXX devices this specifies the fpa pool to use for packet allocation. This argument should be supplied by the remote executable for SE applications. See sdk/examples/linux-filter/README.txt for more information.</li>
</ol>
<h2><a class="anchor" id="linux_usb">
16. Kernel USB Drivers</a></h2>
<p>Some OCTEON processors have Universal Serial Bus (USB) ports. The cn3XXX and cn5XXX OCTEON processors with USB use the octeon-hcd driver, cn6XXX OCTEON processors use standard ehci/ohci drivers, and cn7xxx OCTEON processors use standard xhci driver.</p>
<h3><a class="anchor" id="linux_usb_dwc_otg">
cn3XXX and cn5XXX USB</a></h3>
<p>The octeon-hcd driver is selected with the CONFIG_USB_OCTEON_HCD kernel configuration parameter.</p>
<h3><a class="anchor" id="linux_usb_ehci">
cn6XXX USB</a></h3>
<p>The ehci/ohci USB blocks on cn6XXX OCTEON processors use the standard Linux EHCI and OHCI drivers, however additional OCTEON specific interface options must also be selected to enable these drivers to work with OCTEON II processors. To enable these drivers, first select the CONFIG_USB_EHCI_HCD and CONFIG_USB_OHCI_HCD options, then select CONFIG_USB_OCTEON_EHCI and CONFIG_USB_OCTEON_OHCI.</p>
<h3><a class="anchor" id="linux_usb_xhci">
cn7XXX USB</a></h3>
<p>The xhci USB blocks on cn7XXX OCTEON processors use the standard Linux XHCI driver, however additional OCTEON specific interface option must also be selected to enable this driver to work with OCTEON III processors. To enable these drivers, first select the CONFIG_USB_XHCI_HCD option, then select CONFIG_USB_XHCI_HCD_OCTEON.</p>
<h2><a class="anchor" id="linux_rng">
17. Kernel Random Number Generator (RNG) Driver</a></h2>
<p>The octeon-rng driver ties the OCTEON processor's hardware random number generator into the standard Linux kernel RNG framework. This driver is selected with the CONFIG_HW_RANDOM_OCTEON kernel configuration parameter.</p>
<h2><a class="anchor" id="linux_nfs_root">
18. Configuring NFS Root Filesystem</a></h2>
<p>Configuring the OCTEON Linux kernel to use NFS as the root filesystem can be more complicated than normal since the ethernet driver is a module. In order to use a NFS root filesystem, you must have an initramfs that loads the ethernet module and does a pivot root. The embedded rootfs supplied with the SDK already has all the setup required to do this. In order to enable it, you must enable NFS in the configuration system.</p>
<div class="fragment"><pre class="fragment">
    $ cd linux/embedded_rootfs
    $ make menuconfig
    NFS Root filesystem  ---&gt;
    [*] Change root to a NFS filesystem
    (eth0) Network device
    [*]   Use DHCP to get the IP address, gateway, and DNS server
    (10.0.0.1:/home/debian_rootfs) NFS server path
    (nolock,rw) NFS mount options
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>Long delays when logging in are normally caused by the reverse lookup of your host name. Make sure it will succeed or it doesn't have a DNS server.</dd></dl>
<h2><a class="anchor" id="linux_initrd_root">
19. Configuring a separate initrd or initramfs Root Filesystem</a></h2>
<p>The default Linux kernel when you invoke 'make <b>kernel'</b> will contain an embedded root filesystem. It is also possible to package this filesystem separately from the kernel image. It is then loaded into a separate memory region from the kernel.</p>
<p>First build the kernel, and copy it to the tftp directory.</p>
<div class="fragment"><pre class="fragment">
    $ cd linux
    $ make kernel-deb
    .
    .
    .
    $ cp kernel/linux/vmlinux.64 /var/lib/tftpboot/
</pre></div><p>Then built the root filesystem image and copy it to the tftp directory. We also need to calculate the size of the memory area needed to hold the</p>
<div class="fragment"><pre class="fragment">
    $ cd linux/embedded_rootfs
    $ make all ext3
    .
    .
    .
    $ ls -l rootfs.ext3 | gawk -- '{printf "%x\n", ($5 + 0x10000) - ($5 % 0x10000)}'
    b110000
    $ cp rootfs.ext3 /tftpboot/
</pre></div><p>Now we are ready to boot the board. This part takes some manual calculations. We need to find a free memory region in the lower 4GB of memory that can hold the initramfs. The block should be aligned on a 64KB boundary. Looking at the results of the 'freeprint' command, we see that it will fit at 0x81d0000, so we create a named block called 'my_initrd' at that location with the proper size (0xb110000 from above). Then we load the initramfs image into this named block with the tftpboot command specifying the address of the named block. The bootloader prints a WARNING message, but we can disregard it, because we know we are loading data to our named block.</p>
<p>We pass the kernel command line argument 'rd_name=my_initrd' to indicate the name of the memory block to the kernel.</p>
<div class="fragment"><pre class="fragment">

Octeon ebb6800# dhcp   
Node 0 Interface 0 has 1 ports (RXAUI)
    Node 0 Interface 1 has 1 ports (RXAUI)
    Node 0 Interface 2 has 4 ports (SGMII)
    Node 0 Interface 7 has 32 ports (NPI)
    Node 0 Interface 8 has 8 ports (LOOP)
    BOOTP broadcast 1
    octeth4: Up 1000 Mbps Full duplex (port 2592) (SGMII)
    DHCP client bound to address 10.91.205.222

Octeon ebb6800# freeprint



Printing bootmem block list, descriptor: 0x6c108, head is 0xf100000
Descriptor version: 3.0
Block address: 0x0f100000, size: 0x00e2ac90, next: 0x0ffeb640
Block address: 0x0ffeb640, size: 0x00000020, next: 0x0ffebed0
Block address: 0x0ffebed0, size: 0x00000010, next: 0x30000000
Block address: 0x30000000, size: 0x1df000000, next: 0x00000000

Octeon ebb6800# namedalloc myinitrd 0xb110000 0x30000000 
Allocated 0xb110000 bytes at address: 0x30000000, name: myinitrd


Octeon ebb6800# tftp 0x30000000 rootfs.ext3
Node 0 Interface 0 has 1 ports (RXAUI)
Node 0 Interface 1 has 1 ports (RXAUI)
Node 0 Interface 2 has 4 ports (SGMII)
Node 0 Interface 8 has 8 ports (LOOP)
Using octeth4 device
TFTP from server 10.91.205.197; our IP address is 10.91.205.222
Filename 'rootfs.ext3'.
Load address: 0x30000000
Loading: octeth4: Down (port 2592) (SGMII)
T T octeth4: Up 1000 Mbps Full duplex (port 2592) (SGMII)
T #################################################################
        #####################################
         3.2 MiB/s
done
Bytes transferred = 185597952 (b100000 hex)


Octeon ebb6800# tftp $(loadaddr) vm_deb.64
Using octeth4 device
TFTP from server 10.91.205.197; our IP address is 10.91.205.222
Filename 'vm_deb.64'.
Load address: 0x20000000
Loading: #################################################################
   #################################################################
         #################################################################
         #################################################################
         #################################################################
         ###########################################################
         4.3 MiB/s
done
Bytes transferred = 129914968 (7be5858 hex)


Octeon ebb6800# bootoctl $(loadaddr) numcores=$(numcores) endbootargs rw mem=0 rd_name=myinitrd
argv[2]: numcores=32
argv[3]: endbootargs
Allocating memory for ELF segment: addr: 0xffffffff80800000 (adjusted to: 0x800000), size 0xc6f730
## Loading big-endian Linux kernel with entry point: 0xffffffff80f79310 ...
Bootloader: Done loading app on coremask:
 0xffffffff
Starting cores:
 0xffffffff
Linux version 4.9.52-Cavium-Octeon+ (root@gshankar-OptiPlex-3046) (gcc version 4.7.0 (Cavium Inc. Version: SDK_BUILD build 51) ) #6 SMP Tue Oct 17 12:22:52 IST 2017
CVMSEG size: 2 cache lines (256 bytes)
Cavium Inc. SDK-5.1.0-prerelease
bootconsole [early0] enabled
CPU0 revision is: 000d910a (Cavium Octeon II)
Checking for the multiply/shift bug... no.
Checking for the daddiu bug... no.
Determined physical RAM map:
 memory: 000000000b110000 @ 0000000030000000 (usable after init)
 memory: 000000000feff000 @ 00000000f0001000 (usable)
 memory: 000000006fd00000 @ 0000000080300000 (usable)
 memory: 000000010efff000 @ 0000000100001000 (usable)
 memory: 0000000044c00000 @ 000000003b300000 (usable)
 memory: 0000000010000000 @ 0000000020000000 (usable)
 memory: 000000000e400000 @ 0000000001800000 (usable)
 memory: 0000000000400000 @ 0000000000400000 (usable)
 memory: 0000000000a89000 @ 0000000000800000 (kernel data and code)
 memory: 0000000000140000 @ 0000000001330000 (kernel data and code)
 memory: 00000000000a7000 @ 0000000001289000 (usable after init)
Initial ramdisk at: 0x8000000030000000 (185663488 bytes)
Using passed Device Tree &lt;800000000fce4800&gt;.
Using passed Device Tree.
software IO TLB [mem 0x08823000-0x0c823000] (64MB) mapped at [8000000008823000-800000000c822fff]
Primary instruction cache 37kB, virtually tagged, 37 way, 8 sets, linesize 128 bytes.
.
.
.
</pre></div><h2><a class="anchor" id="linux_performance_counters">
20. OCTEON Performance Counters</a></h2>
<p>The OCTEON performance counters are available through <b>/proc/octeon_perf</b>. Through this interface you can control the two performance counters per core and the four performance counters available in the L2 controller. Here is some sample output from /proc/octeon/perf</p>
<div class="fragment"><pre class="fragment">
octeon:~# cat /proc/octeon_perf
                 sissue           dissue
CPU 0:        211717427        180982164
CPU 1:        211487633        180958893
CPU 2:        211465061        180883863
CPU 3:        211412737        180907337
CPU 4:        211456437        180956208
CPU 5:        211416750        180913876
CPU 6:        211500423        180923920
CPU 7:        211452287        180942579
CPU 8:        211397832        180903745
CPU 9:        211441735        180934627
CPU10:        211487240        180979999
CPU11:        211439250        180933492
CPU12:        211441315        180941196
CPU13:        211435641        180931735
CPU14:        211469154        180958894

imiss: 3634
ihit: 98044
dmiss: 7570
dhit: 786474

Configuration of the performance counters is controller by writing
one of the following values to:
    /sys/module/perf_counters/parameters/counter{0,1}
    /sys/module/perf_counters/parameters/l2counter{0-3}

Possible CPU counters:
    none clk issue ret nissue sissue dissue ifi
    br brmis j jmis replay iuna trap
    uuload uustore uload ustore ec mc cc csrc
    cfetch cpref ica ii ip cimiss
    wbuf wdat wbufld wbuffl wbuftr badd baddl2 bfill
    ddids idids didna lds lmlds iolds dmlds
    sts lmsts iosts iobdma dtlb dtlbad itlb
    sync synciob syncw

Possible L2 counters:
    cycles imiss ihit dmiss
    dhit miss hit victim-buffer-hit
    lfb-nq-index-conflict tag-probe tag-update tag-probe-completed
    tag-dirty-victim data-store-nop data-store-read data-store-write
    memory-fill-data-valid memory-write-request memory-read-request memory-write-data-valid
    xmc-nop xmc-ldt xmc-ldi xmc-ldd
    xmc-stf xmc-stt xmc-stp xmc-stc
    xmc-dwb xmc-pl2 xmc-psl1 xmc-iobld
    xmc-iobst xmc-iobdma xmc-iobrsp xmd-bus-valid
    xmd-bus-valid-dst-l2c xmd-bus-valid-dst-iob xmd-bus-valid-dst-pp rsc-nop
    rsc-stdn rsc-fill rsc-refl rsc-stin
    rsc-scin rsc-scfl rsc-scdn rsd-data-valid
    rsd-data-valid-fill rsd-data-valid-strsp rsd-data-valid-refl lrf-req
    dt-rd-alloc dt-wr-inva
Warning: Counter configuration doesn't update till you access /proc/octeon_perf.
</pre></div><p>NOTE: The L2 performance counter events are different in OCTEON II chips. See below for a list of supported events.</p>
<p>Configuration of the performance counters is controller by writing the desired counter name to the /sys parameter for each counter. The possible counter types are:</p>
<p>Counter Control Files</p>
<ul>
<li>/sys/module/perf_counters/parameters/counter{0,1}</li>
<li>/sys/module/perf_counters/parameters/l2counter{0-3}</li>
</ul>
<p>Core Counters</p>
<ul>
<li>none - Turn off the performance counter</li>
<li>clk - Conditionally clocked cycles (as opposed to count/cvm_count which count even with no clocks)</li>
<li>issue - Instructions issued but not retired</li>
<li>ret - Instructions retired</li>
<li>nissue - Cycles no issue</li>
<li>sissue - Cycles single issue</li>
<li>dissue - Cycles dual issue</li>
<li>ifi - Cycle ifetch issued (but not necessarily commit to pp_mem)</li>
<li>br - Branches retired</li>
<li>brmis - Branch mispredicts</li>
<li>j - Jumps retired</li>
<li>jmis - Jumps mispredicted</li>
<li>replay - Mem Replays</li>
<li>iuna - Cycles idle due to unaligned_replays</li>
<li>trap - trap_6a signal</li>
<li>uuload - Unexpected unaligned loads (REPUN=1)</li>
<li>uustore - Unexpected unaligned store (REPUN=1)</li>
<li>uload - Unaligned loads (REPUN=1 or USEUN=1)</li>
<li>ustore - Unaligned store (REPUN=1 or USEUN=1)</li>
<li>ec - Exec clocks(must set CvmCtl[DISCE] for accurate timing)</li>
<li>mc - Mul clocks(must set CvmCtl[DISCE] for accurate timing)</li>
<li>cc - Crypto clocks(must set CvmCtl[DISCE] for accurate timing)</li>
<li>csrc - Issue_csr clocks(must set CvmCtl[DISCE] for accurate timing)</li>
<li>cfetch - Icache committed fetches (demand+prefetch)</li>
<li>cpref - Icache committed prefetches</li>
<li>ica - Icache aliases</li>
<li>ii - Icache invalidates</li>
<li>ip - Icache parity error</li>
<li>cimiss - Cycles idle due to imiss (must set CvmCtl[DISCE] for accurate timing)</li>
<li>wbuf - Number of write buffer entries created</li>
<li>wdat - Number of write buffer data cycles used (may need to set CvmCtl[DISCE] for accurate counts)</li>
<li>wbufld - Number of write buffer entries forced out by loads</li>
<li>wbuffl - Number of cycles that there was no available write buffer entry (may need to set CvmCtl[DISCE] and CvmMemCtl[MCLK] for accurate counts)</li>
<li>wbuftr - Number of stores that found no available write buffer entries</li>
<li>badd - Number of address bus cycles used (may need to set CvmCtl[DISCE] for accurate counts)</li>
<li>baddl2 - Number of address bus cycles not reflected (i.e. destined for L2) (may need to set CvmCtl[DISCE] for accurate counts)</li>
<li>bfill - Number of fill bus cycles used (may need to set CvmCtl[DISCE] for accurate counts)</li>
<li>ddids - Number of Dstream DIDs created</li>
<li>idids - Number of Istream DIDs created</li>
<li>didna - Number of cycles that no DIDs were available (may need to set CvmCtl[DISCE] and CvmMemCtl[MCLK] for accurate counts)</li>
<li>lds - Number of load issues</li>
<li>lmlds - Number of local memory load</li>
<li>iolds - Number of I/O load issues</li>
<li>dmlds - Number of loads that were not prefetches and missed in the cache</li>
<li>sts - Number of store issues</li>
<li>lmsts - Number of local memory store issues</li>
<li>iosts - Number of I/O store issues</li>
<li>iobdma - Number of IOBDMAs</li>
<li>dtlb - Number of dstream TLB refill, invalid, or modified exceptions</li>
<li>dtlbad - Number of dstream TLB address errors</li>
<li>itlb - Number of istream TLB refill, invalid, or address error exceptions</li>
<li>sync - Number of SYNC stall cycles (may need to set CvmCtl[DISCE] for accurate counts)</li>
<li>synciob - Number of SYNCIOBDMA stall cycles (may need to set CvmCtl[DISCE] for accurate counts)</li>
<li>syncw - Number of SYNCWs</li>
</ul>
<p>Available in OCTEON II and OCTEON III</p>
<ul>
<li>eretmis - D/eret mispredicts</li>
<li>likmis - Branch likely mispredicts</li>
<li>hazard-trap - Hazard traps due to *MTC0 to CvmCtl, Perf counter control, EntryHi, or CvmMemCtl registers</li>
</ul>
<p>L2 Counters</p>
<ul>
<li>cycles - Cycles</li>
<li>imiss - L2 Instruction Miss</li>
<li>ihit - L2 Instruction Hit</li>
<li>dmiss - L2 Data Miss</li>
<li>dhit - L2 Data Hit</li>
<li>miss - L2 Miss (I/D)</li>
<li>hit - L2 Hit (I/D)</li>
<li>victim-buffer-hit - L2 Victim Buffer Hit (Retry Probe)</li>
<li>lfb-nq-index-conflict - LFB-NQ Index Conflict</li>
<li>tag-probe - L2 Tag Probe (issued - could be VB-Retried)</li>
<li>tag-update - L2 Tag Update (completed). Note: Some CMD types do not update</li>
<li>tag-probe-completed - L2 Tag Probe Completed (beyond VB-RTY window)</li>
<li>tag-dirty-victim - L2 Tag Dirty Victim</li>
<li>data-store-nop - L2 Data Store NOP</li>
<li>data-store-read - L2 Data Store READ</li>
<li>data-store-write - L2 Data Store WRITE</li>
<li>memory-fill-data-valid - Memory Fill Data valid</li>
<li>memory-write-request - Memory Write Request</li>
<li>memory-read-request - Memory Read Request</li>
<li>memory-write-data-valid - Memory Write Data valid</li>
<li>xmc-nop - XMC NOP</li>
<li>xmc-ldt - XMC LDT</li>
<li>xmc-ldi - XMC LDI</li>
<li>xmc-ldd - XMC LDD</li>
<li>xmc-stf - XMC STF</li>
<li>xmc-stt - XMC STT</li>
<li>xmc-stp - XMC STP</li>
<li>xmc-stc - XMC STC</li>
<li>xmc-dwb - XMC DWB</li>
<li>xmc-pl2 - XMC PL2</li>
<li>xmc-psl1 - XMC PSL1</li>
<li>xmc-iobld - XMC IOBLD</li>
<li>xmc-iobst - XMC IOBST</li>
<li>xmc-iobdma - XMC IOBDMA</li>
<li>xmc-iobrsp - XMC IOBRSP</li>
<li>xmd-bus-valid - XMD Bus valid (all)</li>
<li>xmd-bus-valid-dst-l2c - XMD Bus valid (DST=L2C) Memory</li>
<li>xmd-bus-valid-dst-iob - XMD Bus valid (DST=IOB) REFL Data</li>
<li>xmd-bus-valid-dst-pp - XMD Bus valid (DST=PP) IOBRSP Data</li>
<li>rsc-nop - RSC NOP</li>
<li>rsc-stdn - RSC STDN</li>
<li>rsc-fill - RSC FILL</li>
<li>rsc-refl - RSC REFL</li>
<li>rsc-stin - RSC STIN</li>
<li>rsc-scin - RSC SCIN</li>
<li>rsc-scfl - RSC SCFL</li>
<li>rsc-scdn - RSC SCDN</li>
<li>rsd-data-valid - RSD Data Valid</li>
<li>rsd-data-valid-fill - RSD Data Valid (FILL)</li>
<li>rsd-data-valid-strsp - RSD Data Valid (STRSP)</li>
<li>rsd-data-valid-refl - RSD Data Valid (REFL)</li>
<li>lrf-req - LRF-REQ (LFB-NQ)</li>
<li>dt-rd-alloc - DT RD-ALLOC</li>
<li>dt-wr-inva - DT WR-INVA</li>
</ul>
<p>L2 Counters in OCTEON II chips</p>
<ul>
<li>none - None</li>
<li>hit - L2 Tag Hit</li>
<li>miss - L2 Tag Miss</li>
<li>no-alloc - L2 Tag NoAlloc (forced no-allocate)</li>
<li>victim - L2 Tag Victim</li>
<li>sc-fail - SC Fail</li>
<li>sc-pass - SC Pass</li>
<li>lfb-valid - LFB Occupancy (each cycle adds # of LFBs valid)</li>
<li>lfb-wait-lfb - LFB Wait LFB (each cycle adds # of LFBs waiting for other LFBs)</li>
<li>lfb-wait-vab - LFB Wait VAB (each cycle adds # of LFBs waiting for VAB)</li>
<li>quad0-index - Quad 0 index bus inuse</li>
<li>quad0-read - Quad 0 read data bus inuse</li>
<li>quad0-bank - Quad 0 # banks inuse (0-4/cycle)</li>
<li>quad0-wdat - Quad 0 wdat flops inuse (0-4/cycle)</li>
<li>quad1-index - Quad 1 index bus inuse</li>
<li>quad1-read - Quad 1 read data bus inuse</li>
<li>quad1-bank - Quad 1 # banks inuse (0-4/cycle)</li>
<li>quad1-wdat - Quad 1 wdat flops inuse (0-4/cycle)</li>
<li>quad2-index - Quad 2 index bus inuse</li>
<li>quad2-read - Quad 2 read data bus inuse</li>
<li>quad2-bank - Quad 2 # banks inuse (0-4/cycle)</li>
<li>quad2-wdat - Quad 2 wdat flops inuse (0-4/cycle)</li>
<li>quad3-index - Quad 3 index bus inuse</li>
<li>quad3-read - Quad 3 read data bus inuse</li>
<li>quad3-bank - Quad 3 # banks inuse (0-4/cycle)</li>
<li>quad3-wdat - Quad 3 wdat flops inuse (0-4/cycle)</li>
</ul>
<p>After you change which counter that is displayed, you need to cat /proc/octeon_perf twice to make sure the new value is used. The first one show the results from the old counter and sets the new counter to zero. The second one displays the new counter.</p>
<p>Here is an example setting up the L2 control to count cache missies:</p>
<div class="fragment"><pre class="fragment">
octeon:~# echo imiss &gt; /sys/module/perf_counters/parameters/l2counter0
octeon:~# echo ihit &gt; /sys/module/perf_counters/parameters/l2counter1
octeon:~# echo dmiss &gt; /sys/module/perf_counters/parameters/l2counter2
octeon:~# echo dhit &gt; /sys/module/perf_counters/parameters/l2counter3
</pre></div><h2><a class="anchor" id="linux_kernel_debugging">
21. Debugging the Kernel</a></h2>
<p>The OCTEON Multicore debugger <b>mipsisa64-octeon-elf-gdb</b> may be used to debug the Linux kernel. The standalone simple executive debugging extensions provide improved debugging over standard KGDB.</p>
<p>Three GDB state variables control support for multicore debugging. These variables are <b>active-cores</b>, <b>focus</b>, and <b>step-all</b>. The standard GDB set and show commands access these variables. A description of each variable's affect on the debugging environment is listed below:</p>
<ul>
<li>active-cores: This is a comma separated list of cores under active control of the debugger. Cores in this list will stop if any other core hits a breakpoint. Cores not in this list will only stop if they hit a breakpoint. Note that although cores not in active-cores do not stop when other cores hit a breakpoint, they do suffer a performance hit. As a convenience, setting the active cores to an empty string with <b>"set active-cores"</b> is interpreted as setting all cores active.</li>
</ul>
<div class="fragment"><pre class="fragment">(Core#0-gdb) <span class="keyword">set</span> active-cores 0,1
(Core#0-gdb) show active-cores
The cores stopped on execution of a breakpoint by another core is <span class="stringliteral">&quot;0,1&quot;</span>.
(Core#0-gdb) <span class="keyword">set</span> active-cores
(Core#0-gdb) show active-cores
The cores stopped on execution of a breakpoint by another core is
&quot;0,1,2,3,4,6,7,8,9,10,11,12,13,14,15&quot;.
(Core<span class="preprocessor">#0-gdb)</span>
</pre></div><ul>
<li>focus: This is the index (0-15) of the core directly interacting with the debugger. Data operations (r/w memory, registers) are performed in the focus core's context. Only cores currently stopped in a debug exception may become the focus core. This means making a non-active core the focus generally requires a breakpoint or changing the active-cores to include it. The GDB prompt will show the current focus core. Note that the focus core may change if another core hits a breakpoint. The core to hit a breakpoint first automatically becomes the focus core.</li>
</ul>
<div class="fragment"><pre class="fragment">(Core#0-gdb) show focus
The focus core of debugger operations is 0.
(Core#0-gdb) <span class="keyword">set</span> focus 5
(Core#5-gdb) show focus
The focus core of debugger operations is 5.
(Core#5-gdb)
</pre></div><ul>
<li>step-all: This GDB variable controls the cores action when the commands step, step instruction, and continue are executed. By default (step-all off) only the focus core performs the operations. Execution of other cores occurs only if step-all is on. Note that cores not in the active-cores list currently stopped will continue execution under any step command with step-all enabled.</li>
</ul>
<div class="fragment"><pre class="fragment">(Core#5-gdb) show step-all
Step commands affect all cores is off.
(Core#5-gdb) set step-all on
(Core<span class="preprocessor">#5-gdb) show step-all</span>
<span class="preprocessor"></span>Step commands affect all cores is on.
(Core#5-gdb)
</pre></div><p>In order to debug the Linux kernel, the following steps are required:</p>
<ol type="1">
<li>For the EBB68XX, you will need two serial port connections to the board. Connect the two serial ports by the LED display to the host PC using null modem cables. The first should already be hooked up for use with Minicom as a console. The second will be used for the debugger traffic.</li>
<li>Build the kernel with debugging support. <div class="fragment"><pre class="fragment">
    $ cd linux
    $ make -s [sim|kernel]-config
    $ cd kernel/linux
    $ make menuconfig
    Device Drivers  ---&gt;
        [*] Watchdog Timer Support ---&gt;
            &lt; &gt; Cavium OCTEON SOC family Watchdog Timer
    Kernel hacking  ---&gt;
        [ ] Remote GDB kernel debugging
        [*] Remote GDB debugging using the Cavium Inc. Multicore GDB
    $ cd ../..
    $ make -s [sim|kernel]
    </pre></div> NOTE: When debugging kernel on CN6XXX OCTEON model, disable CONFIG_I2C kernel config option, as the kernel should not be interrupted while scanning TWSI bus. <div class="fragment"><pre class="fragment">
   $ cd kernel/linux
   $ make menuconfig
   Device Driver   ---&gt;
       &lt; &gt; I2C Support ---&gt;
   </pre></div></li>
<li>Start the Linux kernel. + OCTEON Simulator <div class="fragment"><pre class="fragment">
   $ cd kernel/linux
   $ ./oct-linux -quiet -noperf -uart1=2021
   terminal 2 $ telnet localhost 2020
   </pre></div> + EBB68XX Hardware Reference Board Copy the Linux kernel to a compact flash. <div class="fragment"><pre class="fragment">
   $ mkdir -p /mnt/usb
   $ fdisk -l /dev/sda         # Only needed on some Kernel 2.6 systems
   $ mount /dev/sda1 /mnt/usb
   $ mips64-octeon-linux-gnu-strip -o /mnt/usb/vmlinux.64 kernel/linux/vmlinux.64
   $ umount /mnt/usb
   </pre></div> Put the compact flash into the EBB68XX and reset the board. At the bootloader prompt load linux. <div class="fragment"><pre class="fragment">
   Octeon ebb6800# fatload ide 0 $(loadaddr) vmlinux.64
   Octeon ebb6800# bootoctlinux $(fileaddr)
   </pre></div></li>
<li>Startup and connect the debugger + OCTEON Simulator <div class="fragment"><pre class="fragment">
   $ cd linux/kernel/linux
   $ mipsisa64-octeon-elf-ddd --debugger mipsisa64-octeon-elf-gdb vmlinux.64
   gdb&gt; target octeon tcp::2021
   gdb&gt; load
   gdb&gt; stepi
   </pre></div> + EBB68XX Hardware Reference Board<ul>
<li>For debugging over serial port <div class="fragment"><pre class="fragment">
    $ cd linux/kernel/linux
    $ mipsisa64-octeon-elf-ddd --debugger mipsisa64-octeon-elf-gdb vmlinux.64
    gdb&gt; target octeon /dev/ttyS1
    gdb&gt; load
    gdb&gt; stepi
    </pre></div></li>
<li>For debugging over PCI <div class="fragment"><pre class="fragment">
    # cd linux/kernel/linux
    # mipsisa64-octeon-elf-ddd --debugger mipsisa64-octeon-elf-gdb vmlinux.64
    gdb&gt; set pci_bootcmd oct-pci-boot    // this is required only for 
                                         // PCIBOOT mode
    gdb&gt; target octeonpci bootoctlinux $(loadaddr)
    gdb&gt; load
    gdb&gt; stepi
    </pre></div></li>
</ul>
</li>
</ol>
<p>NOTE: The bootoctlinux command will load the kernel and run on OCTEON, or with GDB:</p>
<div class="fragment"><pre class="fragment">
/usr/local/Cavium_Networks/OCTEON-SDK mipsisa64-octeon-elf-gdb -q linux/kernel/linux/vmlinux.64
(Core#0-gdb) target octeon /dev/ttyS0
Remote target octeon connected to /dev/ttyS0
(Core#0-gdb) b r4k_wait
Breakpoint 1 at 0xffffffff8110a434: file arch/mips/kernel/cpu-probe.c, line 51.
(Core#0-gdb) c
Continuing.
Breakpoint 1, r4k_wait () at arch/mips/kernel/cpu-probe.c:51
51__asm__(".set\tmips3\n\t"
(Core#0-gdb)
</pre></div><p>Control-C interrupt handling is handled in the kernel inside do_IRQ in arch/mips/kernel/irq.c. Whenever interrupt 2 occurs, the debug uart is polled. If there is any data available, the MCD0 signal is pulsed. This causes all cores to enter the interrupt handler. A side effect of this is that any Control-C interrupt, or initial debug entry will always stop in do_IRQ under exception context.</p>
<p>Commonly the kernel uses smp_call_function to synchronize operations across all cores. This will hang forever if a core is currently stopped in the debug exception. Make sure <b>step-all</b> is <b>on</b> whenever SMP operations are expected.</p>
<h2><a class="anchor" id="linux_kernel_debugging_kgdb">
22. Debugging the Kernel with KGDB</a></h2>
<p>The standard Linux kernel debugger, KGDB, is also available on OCTEON. The setup for KGDB is very similar to the Cavium Inc. Multicore GDB. Here are the steps:</p>
<ol type="1">
<li>For the EBB68XX, you will need two serial port connections to the board. Connect the two serial ports by the LED display to the host PC using null modem cables. The first should already be hooked up for use with Minicom as a console. The second will be used for the debugger traffic. Optionally, a single uart can be used if "Console
   output to GDB" is enabled. This is not recommended since it breaks output for userspace applications.</li>
</ol>
<ol type="1">
<li>Build the kernel with debugging support and without the OCTEON watchdog driver. <div class="fragment"><pre class="fragment">
    $ cd linux
    $ make -s [sim|kernel]-config
    $ cd kernel/linux
    $ make menuconfig
    Machine selection  ---&gt;
        &lt; &gt; OCTEON watchdog driver
    Kernel hacking  ---&gt;
        [*] KGDB: kernel debugging with remote gdb  ---&gt;
              &lt;*&gt;   8250/16550 and compatible serial support

    $ cd ../..
    $ make -s [sim|kernel]
   </pre></div></li>
<li>Start the Linux kernel. + OCTEON Simulator <div class="fragment"><pre class="fragment">
    $ cd linux/kernel
    $ ./oct-linux -quiet -noperf -uart1=2021
    terminal 2 $ telnet localhost 2020
   </pre></div> + EBB68XX Hardware Reference Board Copy the Linux kernel to a compact flash. <div class="fragment"><pre class="fragment">
    $ mkdir -p /mnt/usb
    $ fdisk -l /dev/sda         # Only needed on some Kernel 2.6 systems
    $ mount /dev/sda1 /mnt/usb
    $ mips64-octeon-linux-gnu-strip -o /mnt/usb/vmlinux.64 kernel/linux/vmlinux.64
    $ umount /mnt/usb
   </pre></div> Put the compact flash into the EBB68XX and reset the board. At the bootloader prompt load linux. <div class="fragment"><pre class="fragment">
    Octeon ebb6800# fatload ide 0 $(loadaddr) vmlinux.64
    Octeon ebb6800# bootoctlinux $(fileaddr) kgdbwait kgdboc=ttyS1,38400
   </pre></div></li>
<li>Startup and connect the debugger + OCTEON Simulator <div class="fragment"><pre class="fragment">
    $ cd linux/kernel/linux
    $ mips64-octeon-linux-gnu-gdb vmlinux.64
    (gdb) target remote tcp::2021
    (gdb) stepi
   </pre></div> + EBB68XX Hardware Reference Board <div class="fragment"><pre class="fragment">
    $ cd linux/kernel/linux
    $ mips64-octeon-linux-gnu-gdb vmlinux.64
    (gdb) set remotebaud 38400
    (gdb) target remote /dev/ttyS1
    (gdb) stepi
   </pre></div></li>
</ol>
<h2><a class="anchor" id="linux_kernel_boot2">
23. Booting Two Separate Kernels on an EBB68XX</a></h2>
<p>OCTEON Linux can be configured to run two separate kernels with each kernel using a separate uart for the console. Below is the procedure to boot same kernel on all the even cores with all the IOs support and another on all the odd cores without any IOs.</p>
<p>-1 Configure the kernel to mapped kernel </p>
<div class="fragment"><pre class="fragment">
$ cd ${OCTEON_ROOT}/linux
$ cd kernel/linux
$ cp ../kernel.config .config
$ make menuconfig
  kernel_type ---&gt;
      [*] Mapped kernel

$ cd ../../
</pre></div><p> NOTE: Configure the kernel to disable the early console, as this might cause early boot messages to appear on the wrong UART. </p>
<div class="fragment"><pre class="fragment">
      make menuconfig
      [ ] Early printk
</pre></div><p>-2 Build a Linux kernel.</p>
<div class="fragment"><pre class="fragment">
$ make -s [kernel|kernel-deb] strip
</pre></div><p>-3 Prepare compact flash with kernel image</p>
<p>For embedded_rootfs kernel:</p>
<div class="fragment"><pre class="fragment">
$ mount /mnt/cf1
$ cp kernel/linux/vmlinux.64 /mnt/cf1/vmlinux-mapped.64
$ umount /mnt/cf1
</pre></div><p>For debian rootfs kernel: </p>
<div class="fragment"><pre class="fragment">
# cd debian
# make DISK=/dev/ttyDISK compact-flash
# cd ..
</pre></div><p>-4 Choose which IOs to be used by kernel instance. Linux kernel enables Packet I/O, serial port, I2C, GPIOs etc through device tree.</p>
<p>a. Print the device tree from bootloader prompt (this is from ebb6800 board):</p>
<div class="fragment"><pre class="fragment">
fdt print
   .....
        aliases {
         mix0 = "/soc@0/ethernet@1070000100000";
         pip = "/soc@0/pip@11800a0000000";
         smi0 = "/soc@0/mdio@1180000003800";
         smi1 = "/soc@0/mdio@1180000003880";
         smi2 = "/soc@0/mdio@1180000003900";
         smi3 = "/soc@0/mdio@1180000003980";
         twsi0 = "/soc@0/i2c@1180000001000";
         twsi1 = "/soc@0/i2c@1180000001200";
         uart0 = "/soc@0/serial@1180000000800";
         uart1 = "/soc@0/serial@1180000000c00";
         flash0 = "/soc@0/bootbus@1180000000000/nor@0,0";
        };
</pre></div><p>Note down all the information that is mentioned in aliases.</p>
<p>b. Gather information about device tree.</p>
<p>Get the size of the device tree:</p>
<div class="fragment"><pre class="fragment">
   fdt header
   magic:                  0xd00dfeed
   totalsize:              0x423d (16957)
   off_dt_struct:          0x38
   off_dt_strings:         0x3f50
   off_mem_rsvmap:         0x28
   version:                17
   last_comp_version:      16
   boot_cpuid_phys:        0x0
   size_dt_strings:        0x2ed
   size_dt_struct:         0x3f18
   number mem_rsv:         0x0                        
   </pre></div><p>Round totalsize to the nearest 100s, which will be 0x5000 bytes.</p>
<p>Get the address of the device tree:</p>
<div class="fragment"><pre class="fragment">
   fdt addr -c
   The address of the fdt is 00080000
   </pre></div><p>c. Create named block to save device tree information and enable only the needed devices</p>
<p>Check the available memory for creating the named block</p>
<div class="fragment"><pre class="fragment">
   freeprint

   Printing bootmem block list, descriptor: 0x6c108, head is 0xf100000
   Descriptor version: 3.0
   Block address: 0x0f100000, size: 0x00e2ac90, next: 0x0ffeb640
   Block address: 0x0ffeb640, size: 0x00000020, next: 0x0ffebed0
   Block address: 0x0ffebed0, size: 0x00000010, next: 0x30000000
   Block address: 0x30000000, size: 0x1df000000, next: 0x00000000


   </pre></div><p>First entry has enough memory to create named block of 0x5000 bytes.</p>
<div class="fragment"><pre class="fragment">
   namedalloc dd_fdt 0x5000 0x0f100000
   </pre></div><p>Verify the named block by invoking 'namedprint'.</p>
<p>d. Copy device tree to the newly created named block</p>
<div class="fragment"><pre class="fragment">
   fdt move 0x00080000 0x0f100000
   </pre></div><p>This command changes device tree's address to 0x0f1000a0, where the named block is created.</p>
<p>e. Load the mapped kernel.</p>
<div class="fragment"><pre class="fragment">
   fatload ide 0 $(loadaddr) vmlinux.64
   </pre></div><p>f. Keep all the devices that are needed for booting on 2nd kernel. Generally recommended to have IOs in the main kernel, only need to keep device tree information for uart1 for kernel stdout/stderr messages.</p>
<div class="fragment"><pre class="fragment">
   fdt rm /soc@0/ethernet@1070000100000
   fdt rm /soc@0/pip@11800a0000000
   fdt rm /soc@0/mdio@1180000003800
   fdt rm /soc@0/mdio@1180000003880
   fdt rm /soc@0/mdio@1180000003900
   fdt rm /soc@0/mdio@1180000003980
   fdt rm /soc@0/i2c@1180000001000
   fdt rm /soc@0/i2c@1180000001200
   fdt rm /soc@0/serial@1180000000800
   fdt rm /soc@0/bootbus@1180000000000
   fdt rm /soc@0/mmc@1180000002000
   </pre></div><p>These values are examples only. Real values for your board should be taken from 'fdt print' command.</p>
<p>g. Boot the 2nd kernel</p>
<p>For embedded_rootfs kernel:</p>
<div class="fragment"><pre class="fragment">
   bootoctlinux $(loadaddr) coremask=0xaaaa endbootargs nousb pcie-octeon.pcie_disable=1 octeon_error_tree.disable=1
   </pre></div><p>For debian rootfs kernel: </p>
<div class="fragment"><pre class="fragment">
   bootoctlinux $(loadaddr) coremask=0xaaaa endbootargs root=/dev/sda2 mem=1024M nousb pcie-octeon.pcie_disable=1
   </pre></div><p>h. Prepare to boot main kernel</p>
<p>Switch device tree address to point to the original address</p>
<div class="fragment"><pre class="fragment">
   fdt addr 0x00080000
   </pre></div><p>Remove device tree for uart1</p>
<div class="fragment"><pre class="fragment">
   fdt rm /soc@0/serial@1180000000c00
   </pre></div><p>i. Boot the main kernel</p>
<p>For embedded_rootfs kernel:</p>
<div class="fragment"><pre class="fragment">
   bootoctlinux $(loadaddr) coremask=0x5555 endbootargs
   </pre></div><p>For debian rootfs kernel: </p>
<div class="fragment"><pre class="fragment">
   bootoctlinux $(loadaddr) coremask=0x5555 endbootargs root=/dev/sda2 mem=1024M
   </pre></div><p>j. You should get kernel boot messages out of both uarts.</p>
<h2><a class="anchor" id="linux_kernel_boot2_pow_ethernet">
24. Ethernet between two booted kernels using the POW</a></h2>
<p>When running multiple kernels on OCTEON, ethernet traffic between the kernels gets more complicated than with a normal ethernet driver. Only one kernel is allowed to run the Cavium ethernet driver. The other kernels communicate ethernet traffic using the <b>octeon-pow-ethernet</b> device driver. This driver uses the OCTEON POW to route network traffic between different kernels using a group per kernel. The octeon-pow-ethernet module takes two parameters:</p>
<ul>
<li><b>receive_group</b>: 0-15 POW group to receive packets from. This must be unique in the system. If you don't specify a value, the hardware core ID will be used of the CPU that loads the module. If this is not specified, it is <b>strongly</b> advised that you always use "schedtool -a 0 -e modprobe octeon-pow-ethernet ..." to load the module. This way the default value of this parameter is deterministic.</li>
</ul>
<ul>
<li><b>broadcast_groups</b>: Bitmask of groups to send broadcasts to. This <b>must be specified</b>. Be careful to not send broadcasts to groups that aren't read otherwise you may fill the POW and stop receiving packets. The value of this parameter is exceedingly important. It should have a bit set for the first core of each kernel that is running. By "first core", I mean the core that loads the octeon-pow-ethernet driver. If you followed the suggestion under receive_group, this should be set to virtual core zero under each kernel by schedtool. An error in specifying this parameter may cause some kernels to not be able to communicate or loss of packet buffers to unread POW groups.</li>
</ul>
<ul>
<li><b>reverse_endian</b>: If a mix of big/little-endian code is running, set reverse_endian=1 on one side only.</li>
</ul>
<ul>
<li><b>pki_packet_pool</b>: CN78XX devices only. Specify the buffer pool to be used for packets. Unlike previous devices the CN78XX uses a dynamic memory mechanism to handle port-based packet memory. After the modprobe octeon3-ethernet command check dmesg for a line that begins: rx sso grp:[grp_nums] aura:[aura_id] pknd:[pknd_id] pko_queue:[pko_queue] The argument aura_id is used as the pki_packet_pool argument for both kernels.</li>
</ul>
<p>In order to use this driver you must:</p>
<ol type="1">
<li>Enable the driver under menuconfig <div class="fragment"><pre class="fragment">
make menuconfig
    Device Drivers ---&gt;
        Networking Device Support ---&gt;
            Ethernet (1000 Mbit) ---&gt;
			&lt;M&gt; POW based internal only ethernet driver
</pre></div></li>
<li>Under kernel one, modprobe the octeon-pow-ethernet device driver. It is <b>very important</b> that the broadcast_groups be set correctly. If the parameter isn't set properly, you will leak packet buffers into unused POW groups, causing a lockup of networking. <div class="fragment"><pre class="fragment">
		$ schedtool -a 0 -e modprobe octeon-pow-ethernet broadcast_groups=3
</pre></div></li>
<li>Under kernel two, modprobe the octeon-pow-ethernet device driver. <div class="fragment"><pre class="fragment">
		$ schedtool -a 0 -e modprobe octeon-pow-ethernet broadcast_groups=3
</pre></div> For CN78XX devices use the following line on both kernels (pool 1021 used as example) <div class="fragment"><pre class="fragment">
		$ schedtool -a 0 -e modprobe octeon-pow-ethernet broadcast_groups=3 pki_packet_pool=1021
</pre></div></li>
<li>If desired, setup kernel one to bridge traffic between the main network and the POW network. <div class="fragment"><pre class="fragment">
		$ brctl addbr br0
		$ brctl addif br0 eth0
		$ brctl addif br0 oct0
		$ ifconfig eth0 up promisc
		$ ifconfig oct0 up promisc
		$ ifconfig br0 up
		Wait for the bridge to begin forwarding.
</pre></div></li>
<li>Either use ifconfig or dhcp to assign IP addresses to kernel one. <div class="fragment"><pre class="fragment">
	    $ ifconfig br0 10.0.0.1
		or
    $ udhcpc -i br0
</pre></div></li>
<li>Either use ifconfig or dhcp to assign IP addresses to kernel two. <div class="fragment"><pre class="fragment">
    $ ifconfig oct0 10.0.0.2
		or
    $ udhcpc -i oct0
</pre></div></li>
</ol>
<h2><a class="anchor" id="linux_mixed_endian">
25. Mixing Big-Endian &amp; Litte-Endian Kernels</a></h2>
<ul>
<li><b>pow-ethernet-bi-endian:</b> Example demonstrating mixed big-/little-endian kernels on one chip, communicating via POW ethernet. This covers building &amp; booting two kernels on one Octeon, and networking between them. <a href="../../docs/pow-ethernet-bi-endian/README.txt">docs/pow-ethernet-bi-endian/README.txt</a> Sometimes different CPUs must run a mix of big-endian &amp; little-endian code. For example, Simple Executive is only defined for big-endian, and Android is only defined for little-endian. The octeon-pow-ethernet can still be used to network between the two flavors, but one species must specify the reverse_endian=1 parameter to the octeon-pow-ethernet driver. See <a href="../../docs/pow-ethernet-bi-endian/pow-setup">docs/pow-ethernet-bi-endian/pow-setup</a> for details of module parameters &amp; network setup.</li>
</ul>
<p>As an example, here's how to TFTP-boot two kernels, identical except for endian-ness. A real-world case would surely have more difference between the two kernel+rootfs images than just the byte-ordering, but this serves as a demontration of what's possible.</p>
<p>To build a second, little-endian kernel, begin by following <a class="el" href="linux.html#linux_kernel_boot2">23. Booting Two Separate Kernels on an EBB68XX</a> to create a mapped big-endian embedded_rootfs kernel. Then save it by </p>
<div class="fragment"><pre class="fragment">
    $ cp kernel/linux/vmlinux.64 /tftpboot/vmlinux.64be
    </pre></div><p> Then change kernel &amp; rootfs to little-endian by </p>
<div class="fragment"><pre class="fragment">
    $ pushd ../sdk
    $ . env-setup OCTEON_CN66XX --little-endian  # or whichever model, but force endian
    $ popd
    $ sed -i \
	-e 's/# CONFIG_CPU_LITTLE_ENDIAN is not set/CONFIG_CPU_LITTLE_ENDIAN=y/g' \
	-e 's/# TOOLCHAIN_LITTLE_ENDIAN is not set/TOOLCHAIN_LITTLE_ENDIAN=y/g' \
	-e 's/CONFIG_CPU_BIG_ENDIAN=y/# CONFIG_CPU_BIG_ENDIAN is not set/g' \
	-e 's/TOOLCHAIN_BIG_ENDIAN=y/# TOOLCHAIN_BIG_ENDIAN is not set/g' \
	kernel/linux/.config embedded_rootfs/.config
    </pre></div><p> Now build this kernel, and save result: </p>
<div class="fragment"><pre class="fragment">
    $ make kernel strip
    $ cp kernel/linux/vmlinux.64 /tftpboot/vmlinux.64le
    </pre></div><p> The two kernels can be loaded &amp; booted by a script like <a href="../../docs/pow-ethernet-bi-endian/bootscript.in">bootscript.in</a> (the addresses here are cn66XX-specific, but can be simply altered for any hardware)</p>
<h2><a class="anchor" id="linux_kernel_watchdog">
26. OCTEON Watchdog Driver</a></h2>
<p>OCTEON Linux includes a watchdog driver for monitoring all cores running Linux. The watchdog driver is controlled by the kernel config option CONFIG_OCTEON_WDT. The driver consists of the two files <b>octeon-wdt-main.c</b> and <b>octeon-wdt-nmi.S</b> located under the "drivers/watchdog" directory. The driver supports three parameters: <b>heartbeat=s</b> the watchdog timeout in seconds. <b>nowayout=x</b> keep the watchdog active even if userspace monitoring app dies. <b>disable&gt;=v</b> to disable watchdog entirely. Here is an overview of the processing of watchdogs.</p>
<ol type="1">
<li>Every core that is "online" under Linux is configured to receive the interrupt for the watchdog with its same number.</li>
<li>Each of the watchdogs is configured to generate an interrupt, followed by a NMI, followed finally by a chip soft reset. Each progression occurs every "timeout".</li>
<li>The interrupt handler pokes the watchdog for the associated core reseting it to the first state.</li>
<li>If for some reason the interrupt handler doesn't poke the watchdog, a NMI is sent to the core after another timeout.</li>
<li>The NMI handler prints a message to UART0 and then sits in a spin loop until chip reset.</li>
<li>Since the NMI doesn't stop the watchdog, it will perform a chip wide soft reset after another timeout.</li>
<li>If a userspace application opens /dev/watchdog, the driver quits poking the watchdog from the interrupt handler. The poking is instead done when a userspace application writes to the device.</li>
</ol>
<p>When programming the watchdogs, keep these notes in mind:</p>
<ol type="1">
<li>A soft reset does not stop the watchdog counters. It is possible to continue to get NMI and soft resets after a chip reboot. For this reason the Linux kernel disables the watchdogs before rebooting the system with a soft reset.</li>
<li>Once a watchdog has expired it must be poked before it can operate again. It is not sufficient to disable/enable the watchdog. It is advised that you always poke the watchdog once during watchdog initialization.</li>
<li>Bit 44 of CIU_INTX_SUM0 is the logical OR of all watchdog signals enabled in CIU_INTX_EN1. Since CIU_INTX_EN0 bit 44 isn't implemented, you must mask watchdog interrupts using CIU_INTX_EN1 instead of the usual CIU_INTX_EN0.</li>
<li>The bootloader reset vector and the NMI interrupt handler are at the same location in flash. In order to install a NMI handler you must use one of the bootbus moveable regions to shadow the reset vector. Also keep in mind that the NMI vector is only 128 bytes.</li>
<li>It is not possible to program the watchdogs to cause a soft reset without a NMI. This means you almost always require a NMI handler.</li>
<li>In many cases, interrupts can continue to be processed even though the system appears "dead". For example, after a halt of the kernel using the "poweroff" command, the kernel continues to process interrupts. This means the watchdogs may continue to be poked even though the system is unusable. However, if a userspace application has opened /dev/watchdog, the watchdogs are no longer poked in the interrupt handlers, and the system <b>will</b> reset.</li>
</ol>
<h2><a class="anchor" id="linux_user_changes">
27. OCTEON Specific Changes in Userspace</a></h2>
<ol type="1">
<li>Enable userspace access to XKPHYS addresses only for OCTEON hardware IO addresses.</li>
<li>GLIBC patches for abi=n32 and abi=n64.</li>
<li>/proc/octeon_info contains OCTEON board specific information.</li>
<li>/proc/octeon_perf contains OCTEON specific performance counters.</li>
</ol>
<h2><a class="anchor" id="linux_config_options">
28. OCTEON Specific Kernel Config Options</a></h2>
<ul>
<li><b>CONFIG_CAVIUM_OCTEON2:</b> This option enables the generation of OCTEON II specific instructions by the compiler, resulting in a kernel that is more efficient, but that will not run on OCTEON and OCTEON Plus processor cores.</li>
</ul>
<ul>
<li><b>CONFIG_CAVIUM_OCTEON_CHK_CVMX_PARAMETER:</b> Compile the kernel with CVMX parameter checking enabled. This might catch some programming errors, but will result in a slower kernel.</li>
</ul>
<ul>
<li><b>CONFIG_CAVIUM_OCTEON_CHK_CVMX_ADDRESS:</b> Compile the kernel with CVMX CSR address checking enabled. This might catch some programming errors, but will result in a slower kernel.</li>
</ul>
<ul>
<li><b>CONFIG_CAVIUM_OCTEON_CHK_CVMX_POW:</b> Compile the kernel with CVMX CSR POW checking enabled. This might catch some programming errors, but will result in a slower kernel.</li>
</ul>
<ul>
<li><b>CONFIG_FAST_ACCESS_TO_THREAD_POINTER:</b> For Mips, normally the TLS thread pointer is accessed by the userspace program executing a "rdhwr" from register $29. This register doesn't exist, so the kernel emulates the instruction assigning the thread pointer to the value register. This option supplies an alternate, faster access to the thread pointer. A side effect of this option is that the highest 8 bytes of CVMSEG is used by the kernel to save and restore the thread pointer during the TLB fault handlers. This CVMSEG address isn't available to user applications.</li>
</ul>
<ul>
<li><b>CONFIG_CAVIUM_OCTEON_EXTRA_CVMSEG:</b> CVMSEG LM is a segment that accesses portions of the dcache as a local memory; the larger CVMSEG is, the smaller the cache is. This selects the size of CVMSEG LM, which is in cache blocks. The legally range is from zero to 54 cache blocks (i.e. CVMSEG LM is between zero and 6192 bytes). The kernel and its driver require several lines of CVMSEG LM (three on OCTEON III, two on other OCTEON models) Also see section 8 for additional information.</li>
</ul>
<ul>
<li><b>CONFIG_OCTEON_WDT:</b> This option enables a watchdog driver for all cores running Linux. It installs a NMI handler and pokes the watchdog based on an interrupt. On first expiration of the watchdog, the interrupt handler pokes it. The second expiration causes an NMI that prints a message and resets the chip. The third expiration causes a global soft reset. Also see section 19 for additional information.</li>
</ul>
<ul>
<li><b>CONFIG_CAVIUM_OCTEON_LOCK_L2:</b> Enable locking parts of the kernel into the L2 cache.</li>
</ul>
<ul>
<li><b>CONFIG_CAVIUM_OCTEON_LOCK_L2_TLB:</b> Lock the low level TLB fast path into L2.</li>
</ul>
<ul>
<li><b>CONFIG_CAVIUM_OCTEON_LOCK_L2_EXCEPTION:</b> Lock the low level exception handler into L2.</li>
</ul>
<ul>
<li><b>CONFIG_CAVIUM_OCTEON_LOCK_L2_LOW_LEVEL_INTERRUPT:</b> Lock the low level interrupt handler into L2.</li>
</ul>
<ul>
<li><b>CONFIG_CAVIUM_OCTEON_LOCK_L2_INTERRUPT:</b> Lock the 2nd level interrupt handler in L2.</li>
</ul>
<ul>
<li><b>CONFIG_CAVIUM_OCTEON_LOCK_L2_MEMCPY:</b> Lock the kernel's implementation of memcpy() into L2.</li>
</ul>
<ul>
<li><b>CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS:</b> Allows user applications to use XKPHYS addresses directly to access IO space. This option dynamically enable/disable with sysmips syscall, by a process with root privilege. Without root privilege you can only remove access.</li>
</ul>
<ul>
<li><b>CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS:</b> Allows user applications to use XKPHYS addresses directly to memory. This option dynamically enable/disable with sysmips syscall, Without root privilege you can only remove access.</li>
</ul>
<ul>
<li><b>CONFIG_CAVIUM_OCTEON_USER_IO:</b> Allows all user applications to directly access the OCTEON hardware IO addresses (0x1000000000000 - 0x1ffffffffffff). This allows high performance networking applications to run in user space with minimal performance penalties. This also means a user application can bring down the entire system. Only use this option on embedded devices where all user applications are strictly controlled.</li>
</ul>
<ul>
<li><b>CONFIG_CAVIUM_OCTEON_USER_MEM:</b> Allows all user applications to use XKPHYS addresses directly to memory. This allows user space direct access to shared memory not in use by Linux. This memory is suitable for use with the OCTEON hardware. Cavium simple executive applications also share this memory. Since this bypass all of the Linux memory protection, only use this option on embedded devices where all user applications are strictly controlled.</li>
</ul>
<ul>
<li><b>CONFIG_CAVIUM_RESERVE32:</b> Reserve a shared memory region for user processes to use for hardware memory buffers. This is required for 32bit applications to be able to send and receive packets directly. Applications access this memory by memory mapping /dev/mem for the addresses in /proc/octeon_info. When this option is configured the Octeon ethernet driver will allocate its buffers from this shared memory region.</li>
</ul>
<ul>
<li><b>CONFIG_OCTEON_ETHERNET:</b> This driver supports the builtin ethernet ports on Cavium Inc.'s products in the OCTEON family. This driver supports the CN3XXX, CN5XXX, CN6XXX, CN70XX and CN71XX OCTEON processors.</li>
</ul>
<ul>
<li><b>CONFIG_OCTEON3_ETHERNET:</b> This driver supports the builtin ethernet ports on CN7XXX processors.</li>
</ul>
<ul>
<li><b>CONFIG_OCTEON_POW_ONLY_ETHERNET:</b> This option enables a very simple ethernet driver for internal core to core traffic. It relies on another driver, Octeon ethernet driver, to perform all hardware setup. This driver's purpose is to supply basic networking between different Linux images running on the same chip. A single core loads the Octeon ethernet driver module, all other cores load this driver. On load, the driver waits for some other core to perform hardware setup.</li>
</ul>
<ul>
<li><b>CONFIG_OCTEON_MGMT_ETHERNET:</b> This option enables the ethernet driver for the management port on Cavium Inc. OCTEON CN57XX, CN56XX, CN55XX, CN54XX, CN52XX, and CN6XXX chips.</li>
</ul>
<ul>
<li><b>CONFIG_USB_OCTEON_HCD:</b> The OCTEON DWC_OTG USB host controller. All CN3XXX and CN5XXX based chips with USB are supported.</li>
</ul>
<ul>
<li><b>CONFIG_USB_OCTEON_EHCI:</b> Enable support for the OCTEON II SOC's on-chip EHCI controller. It is needed for high-speed (480Mbit/sec) USB 2.0 device support. All CN6XXX based chips with USB are supported.</li>
</ul>
<ul>
<li><b>CONFIG_USB_OCTEON_OHCI:</b> Enable support for the OCTEON II SOC's on-chip OHCI controller. It is needed for low-speed USB 1.0 device support. All CN6XXX based chips with USB are supported.</li>
</ul>
<ul>
<li><b>CONFIG_CAVIUM_OCTEON_RAPIDIO:</b> Connect the SRIO interfaces available in the OCTEON II series of processors to the kernel's RapidIO subsystem. The existence of the SRIO ports is automatically detected and configured as either a host or device. Bus enumeration will be performed on host interfaces as appropriate. After configuring this option, you will likely want to enable the RapidIO network adapter under the devices menu.</li>
</ul>
<ul>
<li><b>CONFIG_CAVIUM_OCTEON_ERROR_TREE:</b> Install handlers for error signals from many on-SoC devices.</li>
</ul>
<ul>
<li><b>CONFIG_CAVIUM_KERNEL_CRYPTO:</b> Use of OCTEON crypto instructions from kernel code requires great care, and if done improperly, can corrupt userspace crypto state. If OCTEON crypto instruction support is needed, select this option.</li>
</ul>
<h2><a class="anchor" id="linux_octeon2">
29. OCTEON II specific kernel considerations.</a></h2>
<p>The default configuration of the OCTEON Linux kernel will run on all OCTEON chips. However, the OCTEON II processor (CN6XXX) has several new machine instructions available that allow for more efficient code that cannot be used in a Linux kernel intended for general purpose use on the entire OCTEON family. If it is known that the kernel will be run only on OCTEON II processors, several optimizations can be enabled, yielding an increase in performance.</p>
<p>Many of the most performance critical portions of the kernel automatically select the most efficient machine instructions for the actual processor being used. OCTEON II specific instructions are already used in these places even with the default configuration.</p>
<ul>
<li><b>CONFIG_CAVIUM_OCTEON2:</b> As mentioned above, this option enables the generation of OCTEON II specific instructions by the compiler, resulting in a kernel that is more efficient, but that will not run on OCTEON and OCTEON Plus processor cores. Note that the use of this option has <b>no</b> affect on the ability of the kernel to run OCTEON and OCTEON Plus programs.</li>
</ul>
<ul>
<li><b>CONFIG_USB_OCTEON_HCD:</b> Because the OCTEON II has EHCI/OHCI compatible USB hardware, there is no need to include the DWC_OTG USB driver. Disabling this driver will reduce the size of the kernel, thus saving memory.</li>
</ul>
<h2><a class="anchor" id="linux_ftrace">
30. Kernel tracing with ftrace</a></h2>
<p>The Linux kernel has a built-in tracing system that allows many aspects of the kernel to be recorded and then played back for analysis. This is called the <b>ftrace</b> system.</p>
<p>The tracing infrastructure is disabled by default, because even when inactive, it adds a small overhead to many kernel operations. It can be enabled from menuconfig:</p>
<div class="fragment"><pre class="fragment">
Kernel hacking  ---&gt;
    [*] Tracers  ---&gt;
        [*]   Kernel Function Tracer
        [*]     Kernel Function Graph Tracer
        [*]   Interrupts-off Latency Tracer
        [*]   Scheduling Latency Tracer
        [*]   Trace syscalls
        [*]   Trace max stack
        [*]   Support for tracing block io actions
        [*]   enable/disable ftrace tracepoints dynamically
        [*]   Kernel function profiler
        &lt;*&gt;   Ring buffer benchmark stress tester
</pre></div><p>Once the tracing enabled kernel is running, the tracing can be controlled as described in the kernel's tracing documentation in the <b>linux/kernel/linux/Documentation/trace</b> directory. The <b>ftrace.txt</b> file is a good place to start.</p>
<p>The embedded_rootfs contains the optional program <b>trace-cmd</b> which can be used to facilitate tracing. It has the ability to transmit trace data over a network port or save it to a file for off-line analysis. Please see the trace-cmd manual pages for more information.</p>
<p><b>trace-cmd</b> and its graphical companion tool <b>kernelshark</b> can also be used on a development workstation to analyze trace data obtained from the OCTEON Linux target board.</p>
<h2><a class="anchor" id="linux_randomize_va_space">
31. Address Space Randomization</a></h2>
<p>In order to make the system more secure, the addresses of program stacks, shared libraries and heap are randomized. This is normally desired, however, it can make debugging a program more difficult because each run of the program will have a different address space layout.</p>
<p>The randomization may be disable at boot time by passing <b>norandmaps</b> on the kernel command line. It can also be controlled at runtime.</p>
<p>To diable randomization: </p>
<div class="fragment"><pre class="fragment">
~ # echo 0 &gt; /proc/sys/kernel/randomize_va_space
</pre></div><p>To enable randomization: </p>
<div class="fragment"><pre class="fragment">
~ # echo 2 &gt; /proc/sys/kernel/randomize_va_space
</pre></div><h2><a class="anchor" id="linux_kexec">
32. Kernel KEXEC support</a></h2>
<p>kexec, kernel execution, is a mechanism to launch a new kernel over currently running linux kernel image. kexec skips the bootloader stage (hardware initialization phase by the firmware or BIOS) and directly loads the new kernel into memory, where it starts executing immediately. This is to avoid long time associated with a full reboot and can help systems to meet high-availability requirements by minimizing downtime.</p>
<p>To use kexec feature, need to enable the following kernel configurations</p>
<div class="fragment"><pre class="fragment">
make menuconfig
  Kernel Type ---&gt;
    [*] Kexec system call
  File System ---&gt;
	Pseudo filesystems ---&gt;
	   [*] /proc file system support
	   [*] /proc/kcore support
</pre></div><p>Invoke 'make kernel-deb' to build Linux kernel image. Prepare compact flash with debian rootfs.</p>
<p>Or invoke 'make kernel' to build embedded rootfs Linux kernel image. Enable kexec-tools in embedded_rootfs. Adjust the parameters passed for booting linux kernel image.</p>
<p>NOTE: The example is assuming the kernels are build with embedded_rootfs by enabling kexec-tools.</p>
<p>Create 2 named blocks, one for first kernel and another for kexec kernel. Boot the kernel from a named block. Create a named block at bootloader prompt</p>
<div class="fragment"><pre class="fragment">
Octeon ebb6800# namedprint
List of currently allocated named bootmem blocks:
Name: __uboot_code_data, address: 0x10f000000, size: 0x01000000, index: 0
Name: __fdt, address: 0x00080000, size: 0x00020000, index: 1
Name: __tmp_uboot_exception, address: 0x000ff000, size: 0x00000500, index: 2
Name: __nand_buffer, address: 0x0fff9a00, size: 0x00004200, index: 3
Name: __tmp_nand_dma_buf, address: 0x0fff5800, size: 0x00004200, index: 4
Name: __boot_vector1__, address: 0x0ffed800, size: 0x00008000, index: 5
Name: idle-core-loop, address: 0x000ffff0, size: 0x00000010, index: 6
Name: __tmp_load, address: 0x20000000, size: 0x10000000, index: 7
Name: __tmp_reserved_linux, address: 0x00100000, size: 0x0f000000, index: 8
Name: __low_reserved_000000000000_0, address: 0x000a0000, size: 0x0005f000, index: 9
Name: __low_reserved_000000000000_1, address: 0x000ff500, size: 0x00000af0, index: 10
Name: cvmx_qlm_jtag, address: 0x0ffebf00, size: 0x00001900, index: 11
Name: __pci_console, address: 0x0ffeb680, size: 0x00000850, index: 12
Name: cvmx_mgmt_port, address: 0x0ff2ad00, size: 0x000c0940, index: 13
Name: __mac_meminfo, address: 0x0ff2ac90, size: 0x00000070, index: 14

</pre></div><p>Lets reuse the memory that is in __tmp_load and __tmp_reserved_linux blocks.</p>
<p>Free the memory and create a named block 'ddblock0' and 'ddblock1'.</p>
<div class="fragment"><pre class="fragment">
namedfree __tmp_load
namedfree __tmp_reserved_linux
namedalloc ddblock0 0x0f000000 0x00100000
namedalloc ddblock1 0x10000000 0x20000000
</pre></div><p>Now load the kernel and use the memory that was allocated.</p>
<div class="fragment"><pre class="fragment">
tftp ${loadaddr} vmlinux.64
bootoctlinux $(loadaddr) numcores=$(numcores) namedblock=ddblock0 endbootargs mem=block:ddblock0,ddblock1 root=/dev/sda2 rootwait rw
</pre></div><p>namedblock=ddblock0 : the bootoctlinux will locate the kernel image in ddblock0 named block instead of allocating anonymous memory.</p>
<p>mem=block:ddblock0,ddblock1 : kernel gets memory only from these named blocks.</p>
<p>After kernel boots up, get the kernel to boot using kexec command.</p>
<div class="fragment"><pre class="fragment">

~ # dhclient mgmt0

// get the kernel image
~ # tftp -g -r vmlinux.64 192.168.162.57

// Inform kexec about the kernel to start.
// disable error interrupts in the kexeced kernel, its already enabled
~ # kexec --command-line='mem=block:ddblock0,ddblock1 root=/dev/sda2 rootwait rw' -l vmlinux.64

// Start the kernel
~ # kexec -e
</pre></div><h2><a class="anchor" id="linux_kdump">
33. Kernel KDUMP support</a></h2>
<p>kexec can also be used for collecting and analysing Linux kernel crashes. Linux kernel is a stable entity, at some times it can crash. The '-p' option to 'kexec' utility is used to capture the crashed kernel core file which later can be passed to gdb for debugging the cause of the crash.</p>
<p>To collect crashed kernel statistics, need to build two linux kernel images, build the first kernel as per steps mentioned in <a class="el" href="linux.html#linux_kexec">32. Kernel KEXEC support</a> section. And build the second kernel by configuring as below:</p>
<p>Enable the following kernel configurations for building the first kernel:</p>
<div class="fragment"><pre class="fragment">
make menuconfig
  Kernel Type ---&gt;
    [*] Kexec system call
  File System ---&gt;
	Pseudo filesystems ---&gt;
	   [*] /proc file system support
	   [*] /proc/kcore support
</pre></div><p>After configuring the kernel, build the kernel and lets rename linux kernel image as vmlinux-1.64.</p>
<p>Enable the following kernel configurations for building the second kernel:</p>
<div class="fragment"><pre class="fragment">
make menuconfig
  Kernel Type ---&gt;
	[ ] Multi-Processing support
    [*] Kexec system call
    [*] kernel crash dumps
    (0xffffffff84000000) Physical address where the kernel is loaded (NEW)
  File System ---&gt;
	Pseudo filesystems ---&gt;
	   [*] /proc file system support
	   [*] /proc/kcore support
</pre></div><p>After configuring the kernel, build the kernel and lets rename linux kernel image as vmlinux-2.64.</p>
<p>NOTE: The example is assuming the kernels are build with embedded_rootfs by enabling kexec-tools.</p>
<p>Create 3 named blocks, ddblock0 and ddblock1 are for first kernel. ddump1 is for second kernel. Boot the kernel from a named block. Create a named block at bootloader prompt</p>
<p>We reuse __tmp_load and __tmp_reserved_linux and create new blocks for loading second kernel.</p>
<div class="fragment"><pre class="fragment">
namedfree __tmp_load
namedfree __tmp_reserved_linux
namedalloc ddblock0 0x03f00000 0x00100000
namedalloc ddump1 0x0b000000 0x04000000
namedalloc ddblock1 0x30000000 0x20000000
</pre></div><p>Load the first kernel with crashkernel parameter that takes the size of the linux kernel, followed by starting address, these should match the ddump1 named block created above.</p>
<p>According to ddump1 named block, crashkernel size will be 176 Mbytes (0x0b000000) and craskernel address will be 64 Mbytes (0x04000000).</p>
<div class="fragment"><pre class="fragment">
tftp $(loadaddr) vmlinux-1.64
bootoctl 0 numcores=$(numcores) namedblock=ddblock0 endbootargs mem=block:ddblock0,ddblock1,ddump1 root=/dev/sda2 rootwait rw crashkernel=176M@64M
</pre></div><p>After the first kernel boots up and load second kernel to capture panic status.</p>
<div class="fragment"><pre class="fragment">
~ # dhclient mgmt0

// get the kernel image
~ # tftp -g -r vmlinux-2.64 192.168.162.57

// Load second kernel by passing '-p' option to kexec, to be booted in
// case of crash
~ # kexec --debug --command-line='mem=block:ddump1 root=/dev/sda2 rootwait rw' -p vmlinux-2.64

// simulate crash on current kernel
~ # echo 'c' &gt; /proc/sysrq-trigger
</pre></div><p>To debug the cause of the linux kernel crash, load the core file into debugger once the crashed kernel boots up.</p>
<div class="fragment"><pre class="fragment">
~ # gdb
        GNU gdb (Cavium Inc. Version: SDK_3_1_0 build 29) 7.6
        Copyright (C) 2013 Free Software Foundation, Inc.
        License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
        This is free software: you are free to change and redistribute it.
        There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
        and "show warranty" for details.
        This GDB was configured as "mips64-octeon-linux-gnu".
        For bug reporting instructions, please see:
        &lt;http://www.cavium.com/support.html&gt;.
    --&gt; (gdb) core-file /proc/vmcore
        [New LWP 1033]
        #0  0xffffffff801ac968 in ?? ()
        (gdb) symbol-file /tmp/vmlinux.64
        Reading symbols from /tmp/vmlinux.64...done.
    --&gt; (gdb) bt
        #0  prepare_frametrace (regs=0x800000004e4436c0,
        at /home/pmallappa/sdk-base/sdk/linux/kernel/linux/arch/mips/include/asm/stacktrace.h:32
        #1  crash_setup_regs (oldregs=0xf2, newregs=0x800000004e4436c0)
        at /home/pmallappa/sdk-base/sdk/linux/kernel/linux/arch/mips/include/asm/kexec.h:33
        #2  crash_kexec (regs=0xf2) at kernel/kexec.c:1091
    --&gt; (gdb)
</pre></div><h2><a class="anchor" id="linux_sample_log">
34. Sample Boot Log</a></h2>
<p>Here is a sample boot of Linux with 32 cores on an EBB68XX. The kernel is loaded through TFP from a host at 10.91.205.197. DHCP is used to get the network IP address. </p>
<div class="fragment"><pre class="fragment">
Looking for valid bootloader image....
Jumping to start of image at address 0xbfd90000


U-Boot 2013.07 (Development build, svnversion: u-boot:167210, exec:)-svn167207 (Build time: Oct 18 2017 - 11:27:35)

Octeon unique ID: 00000246440075c00000
Skipping PCIe port 0 BIST, reset not done. (port not configured)
Skipping PCIe port 1 BIST, reset not done. (port not configured)
BIST check passed.
N0.LMC0 Configuration Completed: 2048 MB
N0.LMC1 Configuration Completed: 2048 MB
N0.LMC2 Configuration Completed: 2048 MB
N0.LMC3 Configuration Completed: 2048 MB
EBB6800 board revision major:2, minor:0, serial #: 2015-2.0-00563
OCTEON CN6880-AAP pass 2.2, Core clock: 800 MHz, IO clock: 800 MHz, DDR clock: 667 MHz (1334 Mhz DDR)
Base DRAM address used by u-boot: 0x20f000000, size: 0x1000000
DRAM: 8 GiB
Clearing DRAM...... done
NAND:  4096 MiB
Registered IDE device 0 from IDE bus:dev 0:0
Flash: 8 MiB
USB0:   USB EHCI 1.00
scanning bus 0 for devices... 2 USB Device(s) found
0:PCIe: Port 0 is unknown, skipping.
PCIe: Link timeout on port 1, probably the slot is empty
PCI console init succeeded, 1 consoles, 1024 bytes each
Bus 0: not available  
Net:   octmgmt0, octeth0, octeth1, octeth2, octeth3, octeth4 [PRIME], octeth5
Type the command 'usb start' to scan for USB storage devices.

Octeon ebb6800# dhcp 
Node 0 Interface 0 has 1 ports (RXAUI)
Node 0 Interface 1 has 1 ports (RXAUI)
Node 0 Interface 2 has 4 ports (SGMII)
Node 0 Interface 7 has 32 ports (NPI)
Node 0 Interface 8 has 8 ports (LOOP)
BOOTP broadcast 1
octeth4: Up 1000 Mbps Full duplex (port 2592) (SGMII)
DHCP client bound to address 10.91.205.222
Octeon ebb6800# setenv serverip 10.91.205.197
Octeon ebb6800# saveenv
Saving Environment to Flash...
. done
Un-Protected 1 sectors
Erasing Flash...
. done
Erased 1 sectors
Writing to Flash... done
. done
Protected 1 sectors
Octeon ebb6800# tftp $(loadaddr) vmlinux.64
Using octeth4 device
TFTP from server 10.91.205.197; our IP address is 10.91.205.222
Filename 'vmlinux.64'.
Load address: 0x20000000
Loading: T #################################################################
             #################################################################
             #################################################################
             #################################################################
             #################################################################
             #################################################################
             #################################################################
             #################################################################
             #################################################################
             #################################################################
             #################################################################
             #################################################################
             #################################################################
             #################################################################
             #################################################################
             #################################################################
             #################################################################
             #################################################################
             #################################################################
             #################################################################
             #################################################################
             #################################################################
             #################################################################
             #################################################################
             #################################################################
             #############################################
             3.6 MiB/s
             done
             Bytes transferred = 196287428 (bb31bc4 hex)
    Octeon ebb6800# bootoctl $(loadaddr) numcores=$(numcores) endbootargs mem=0
    Allocating memory for ELF segment: addr: 0xffffffff80800000 (adjusted to: 0x800000), size 0x541cb10
## Loading big-endian Linux kernel with entry point: 0xffffffff80e9a1b0 ...
    ERROR: cvmx_fpa1_shutdown_pool: POOL 0 not empty, 308/1000.
    ERROR: cvmx_fpa1_shutdown_pool: POOL 1 not empty, 308/1000.
    Bootloader: Done loading app on coremask:
     0xffffffff
     Starting cores:
      0xffffffff
      Linux version 4.9.43-Cavium-Octeon+ (root@gshankar-OptiPlex-3046) (gcc version 4.7.0 (Cavium Inc. Version: SDK_BUILD build 51) ) #1 SMP Tue Aug 29 137
      CVMSEG size: 2 cache lines (256 bytes)
    Cavium Inc. SDK-5.1.0-prerelease
    bootconsole [early0] enabled
    CPU0 revision is: 000d910a (Cavium Octeon II)
    Checking for the multiply/shift bug... no.
    Checking for the daddiu bug... no.
    Determined physical RAM map:
     memory: 000000000feff000 @ 00000000f0001000 (usable)
     memory: 000000006fd00000 @ 0000000080300000 (usable)
     memory: 000000010efff000 @ 0000000100001000 (usable)
     memory: 000000005fc00000 @ 0000000020300000 (usable)
     memory: 0000000009c00000 @ 0000000006000000 (usable)
     memory: 0000000000400000 @ 0000000000400000 (usable)
     memory: 00000000008ff000 @ 0000000000800000 (kernel data and code)
     memory: 000000000013d000 @ 0000000005ae0000 (kernel data and code)
     memory: 00000000049e1000 @ 00000000010ff000 (usable after init)
    Initrd not found or empty - disabling initrd
    Using passed Device Tree &lt;800000000fce4700&gt;.
    Using passed Device Tree.
    software IO TLB [mem 0x20300000-0x24300000] (64MB) mapped at [8000000020300000-80000000242fffff]
    Primary instruction cache 37kB, virtually tagged, 37 way, 8 sets, linesize 128 bytes.
    Primary data cache 32kB, 32-way, 8 sets, linesize 128 bytes.
    Secondary unified cache 4096kB, 16-way, 2048 sets, linesize 128 bytes.
    Secondary unified cache 4096kB, 16-way, 2048 sets, linesize 128 bytes.
    Zone ranges:
    DMA32    [mem 0x0000000000400000-0x00000000efffffff]
    Normal   [mem 0x00000000f0000000-0x000000020effffff]
    Movable zone start for each node
    Early memory node ranges
      node   0: [mem 0x0000000000400000-0x0000000005c1cfff]
      node   0: [mem 0x0000000006000000-0x000000000fbfffff]
      node   0: [mem 0x0000000020300000-0x000000007fefffff]
      node   0: [mem 0x0000000080300000-0x00000000efffffff]
      node   0: [mem 0x00000000f0001000-0x00000000ffefffff]
      node   0: [mem 0x0000000100001000-0x000000020effffff]
    Initmem setup node 0 [mem 0x0000000000400000-0x000000020effffff]
    percpu: Embedded 17 pages/cpu @800000002436b000 s31744 r8192 d29696 u69632
    Built 1 zonelists in Node order, mobility grouping on.  Total pages: 2059413
    Policy zone: Normal
    Kernel command line:  console=ttyS0,115200
    log_buf_len individual max cpu contribution: 4096 bytes
    log_buf_len total cpu_extra contributions: 126976 bytes
    log_buf_len min size: 65536 bytes
    log_buf_len: 262144 bytes
    early log buf free: 61552(93%)
    PID hash table entries: 4096 (order: 3, 32768 bytes)
    Memory: 8082516k/24430756k available (6795k kernel code, 16348240k reserved, 2416k data, 75652k init)
    SLUB: HWalign=128, Order=0-3, MinObjects=0, CPUs=32, Nodes=2
    Hierarchical RCU implementation.
      Build-time adjustment of leaf fanout to 64.
      RCU restricting CPUs from NR_CPUS=48 to nr_cpu_ids=32.
    RCU: Adjusting geometry for rcu_fanout_leaf=64, nr_cpu_ids=32
    NR_IRQS:767 nr_irqs:767 9
    clocksource: OCTEON_CVMCOUNT: mask: 0xffffffffffffffff max_cycles: 0xb881274fa3, max_idle_ns: 440795210636 ns
    Calibrating delay loop (skipped) preset value.. 1600.00 BogoMIPS (lpj=8000000)
    pid_max: default: 32768 minimum: 301
    Security Framework initialized
    Dentry cache hash table entries: 1048576 (order: 11, 8388608 bytes)
    Inode-cache hash table entries: 524288 (order: 10, 4194304 bytes)
    Mount-cache hash table entries: 16384 (order: 5, 131072 bytes)
    Mountpoint-cache hash table entries: 16384 (order: 5, 131072 bytes)
    Checking for the daddi bug... no.
    Performance counters: octeon PMU enabled, 2 64-bit counters available to each CPU, irq 7
    SMP: Booting CPU01 (CoreId  1)...
    CPU1 revision is: 000d910a (Cavium Octeon II)
    Cpu 1 online
    SMP: Booting CPU02 (CoreId  2)...
    CPU2 revision is: 000d910a (Cavium Octeon II)
    Cpu 2 online
    SMP: Booting CPU03 (CoreId  3)...
    CPU3 revision is: 000d910a (Cavium Octeon II)
    Cpu 3 online
    SMP: Booting CPU04 (CoreId  4)...
    CPU4 revision is: 000d910a (Cavium Octeon II)
    Cpu 4 online
    SMP: Booting CPU05 (CoreId  5)...
    CPU5 revision is: 000d910a (Cavium Octeon II)
    Cpu 5 online
    SMP: Booting CPU06 (CoreId  6)...
    CPU6 revision is: 000d910a (Cavium Octeon II)
    Cpu 6 online
    SMP: Booting CPU07 (CoreId  7)...
    CPU7 revision is: 000d910a (Cavium Octeon II)
    Cpu 7 online
    SMP: Booting CPU08 (CoreId  8)...
    CPU8 revision is: 000d910a (Cavium Octeon II)
    Cpu 8 online
    SMP: Booting CPU09 (CoreId  9)...
    CPU9 revision is: 000d910a (Cavium Octeon II)
    Cpu 9 online
    SMP: Booting CPU10 (CoreId 10)...
    CPU10 revision is: 000d910a (Cavium Octeon II)
    Cpu 10 online
    SMP: Booting CPU11 (CoreId 11)...
    CPU11 revision is: 000d910a (Cavium Octeon II)
    Cpu 11 online
    SMP: Booting CPU12 (CoreId 12)...
    CPU12 revision is: 000d910a (Cavium Octeon II)
    Cpu 12 online
    SMP: Booting CPU13 (CoreId 13)...
    CPU13 revision is: 000d910a (Cavium Octeon II)
    Cpu 13 online
    SMP: Booting CPU14 (CoreId 14)...
    CPU14 revision is: 000d910a (Cavium Octeon II)
    Cpu 14 online
    SMP: Booting CPU15 (CoreId 15)...
    CPU15 revision is: 000d910a (Cavium Octeon II)
    Cpu 15 online
    SMP: Booting CPU16 (CoreId 16)...
    CPU16 revision is: 000d910a (Cavium Octeon II)
    Cpu 16 online
    SMP: Booting CPU17 (CoreId 17)...
    CPU17 revision is: 000d910a (Cavium Octeon II)
    Cpu 17 online
    SMP: Booting CPU18 (CoreId 18)...
    CPU18 revision is: 000d910a (Cavium Octeon II)
    Cpu 18 online
    SMP: Booting CPU19 (CoreId 19)...
    CPU19 revision is: 000d910a (Cavium Octeon II)
    Cpu 19 online
    SMP: Booting CPU20 (CoreId 20)...
    CPU20 revision is: 000d910a (Cavium Octeon II)
    Cpu 20 online
    SMP: Booting CPU21 (CoreId 21)...
    CPU21 revision is: 000d910a (Cavium Octeon II)
    Cpu 21 online
    SMP: Booting CPU22 (CoreId 22)...
    CPU22 revision is: 000d910a (Cavium Octeon II)
    Cpu 22 online
    SMP: Booting CPU23 (CoreId 23)...
    CPU23 revision is: 000d910a (Cavium Octeon II)
    Cpu 23 online
    SMP: Booting CPU24 (CoreId 24)...
    CPU24 revision is: 000d910a (Cavium Octeon II)
    Cpu 24 online
    SMP: Booting CPU25 (CoreId 25)...
    CPU25 revision is: 000d910a (Cavium Octeon II)
    Cpu 25 online
    SMP: Booting CPU26 (CoreId 26)...
    CPU26 revision is: 000d910a (Cavium Octeon II)
    Cpu 26 online
    SMP: Booting CPU27 (CoreId 27)...
    CPU27 revision is: 000d910a (Cavium Octeon II)
    Cpu 27 online
    SMP: Booting CPU28 (CoreId 28)...
    CPU28 revision is: 000d910a (Cavium Octeon II)
    Cpu 28 online
    SMP: Booting CPU29 (CoreId 29)...
    CPU29 revision is: 000d910a (Cavium Octeon II)
    Cpu 29 online
    SMP: Booting CPU30 (CoreId 30)...
    CPU30 revision is: 000d910a (Cavium Octeon II)
    Cpu 30 online
    SMP: Booting CPU31 (CoreId 31)...
    CPU31 revision is: 000d910a (Cavium Octeon II)
    Cpu 31 online
    Brought up 32 CPUs
    devtmpfs: initialized
    clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 19112604462750000 ns
    futex hash table entries: 8192 (order: 8, 1048576 bytes)
    NET: Registered protocol family 16
    PTP Clock: Using sclk reference at 800000000 Hz
    PCIe: Initializing port 0:0
    0:PCIe: Port 0 is unknown, skipping.
    PCIe: Initializing port 0:1
    random: fast init done
    PCIe: Link timeout on port 1, probably the slot is empty
    HugeTLB registered 2 MB page size, pre-allocated 0 pages
    vgaarb: loaded
    SCSI subsystem initialized
    usbcore: registered new interface driver usbfs
    usbcore: registered new interface driver hub
    usbcore: registered new device driver usb
    pps_core: LinuxPPS API ver. 1 registered
    pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti &lt;giometti@linux.it&gt;
    PTP clock support registered
    EDAC MC: Ver: 3.0.0
    PCI host bridge to bus 0000:00
    pci_bus 0000:00: root bus resource [mem 0x1000000000000]
    pci_bus 0000:00: root bus resource [io  0x0000]
    pci_bus 0000:00: root bus resource [??? 0x00000000 flags 0x0]
    pci_bus 0000:00: No busn resource found for root bus, will use [bus 00-ff]
    clocksource: Switched to clocksource OCTEON_CVMCOUNT
    NET: Registered protocol family 2
    TCP established hash table entries: 65536 (order: 7, 524288 bytes)
    TCP bind hash table entries: 65536 (order: 8, 1048576 bytes)
    TCP: Hash tables configured (established 65536 bind 65536)
    UDP hash table entries: 4096 (order: 5, 131072 bytes)
    UDP-Lite hash table entries: 4096 (order: 5, 131072 bytes)
    NET: Registered protocol family 1
    RPC: Registered named UNIX socket transport module.
    RPC: Registered udp transport module.
    RPC: Registered tcp transport module.
    RPC: Registered tcp NFSv4.1 backchannel transport module.
    random: crng init done
    octeon_pci_console: Initialized.
    /proc/octeon_perf: Octeon performance counter interface loaded
    workingset: timestamp_bits=61 max_order=23 bucket_order=0
    squashfs: version 4.0 (2009/01/31) Phillip Lougher
    NFS: Registering the id_resolver key type
    Key type id_resolver registered
    Key type id_legacy registered
    io scheduler noop registered
    io scheduler deadline registered
    io scheduler cfq registered (default)
    octeon_gpio 1070000000800.gpio-controller: OCTEON GPIO: base = 0
    Serial: 8250/16550 driver, 6 ports, IRQ sharing disabled
    console [ttyS0] disabled
    1180000000800.serial: ttyS0 at MMIO 0x1180000000800 (irq = 228, base_baud = 50000000) is a OCTEON
    console [ttyS0] enabled
    console [ttyS0] enabled
    bootconsole [early0] disabled
    bootconsole [early0] disabled
    1180000000c00.serial: ttyS1 at MMIO 0x1180000000c00 (irq = 229, base_baud = 50000000) is a OCTEON
    brd: module loaded
    loop: module loaded
    pata_octeon_cf 1d040000.compact-flash: version 2.2 16 bit, True IDE.
    scsi host0: pata_octeon_cf
    ata1: PATA max PIO6 cmd 800000001d040000 ctl 800000001d05000d irq 210
    slram: not enough parameters.
    libphy: mdio_octeon: probed
    mdio_octeon 1180000003800.mdio: Probed
    libphy: mdio_octeon: probed
    mdio_octeon 1180000003880.mdio: Probed
    libphy: mdio_octeon: probed
    mdio_octeon 1180000003900.mdio: Probed
    libphy: mdio_octeon: probed
    mdio_octeon 1180000003980.mdio: Probed
    libphy: Fixed MDIO Bus: probed
    octeon_mgmt 1070000100000.ethernet: Version 2.0
    octeon-pow-ethernet ERROR: You must specify a broadcast group mask.
    octeon-ethernet 2.0
    Node 0 Interface 0 has 1 ports (RXAUI)
    Node 0 Interface 1 has 1 ports (RXAUI)
    Node 0 Interface 2 has 4 ports (SGMII)
    Node 0 Interface 7 has 32 ports (NPI)
    Node 0 Interface 8 has 8 ports (LOOP)
    e1000: Intel(R) PRO/1000 Network Driver - version 7.3.21-k8-NAPI
    e1000: Copyright (c) 1999-2006 Intel Corporation.
    e1000e: Intel(R) PRO/1000 Network Driver - 3.2.6-k
    e1000e: Copyright(c) 1999 - 2015 Intel Corporation.
    igb: Intel(R) Gigabit Ethernet Network Driver - version 5.4.0-k
    igb: Copyright (c) 2007-2014 Intel Corporation.
    ehci_hcd: USB 2.0 'Enhanced' Host Controller (EHCI) Driver
    ehci-pci: EHCI PCI platform driver
    ehci-platform: EHCI generic platform driver
    ehci-platform 16f0000000000.ehci: EHCI Host Controller
    ehci-platform 16f0000000000.ehci: new USB bus registered, assigned bus number 1
    ehci-platform 16f0000000000.ehci: irq 236, io mem 0x16f0000000000
    ehci-platform 16f0000000000.ehci: USB 2.0 started, EHCI 1.00
    hub 1-0:1.0: USB hub found
    hub 1-0:1.0: 2 ports detected
    ohci_hcd: USB 1.1 'Open' Host Controller (OHCI) Driver
    ohci-pci: OHCI PCI platform driver
    ohci-platform: OHCI generic platform driver
    ohci-platform 16f0000000400.ohci: Generic Platform OHCI controller
    ohci-platform 16f0000000400.ohci: new USB bus registered, assigned bus number 2
    ohci-platform 16f0000000400.ohci: irq 236, io mem 0x16f0000000400
    hub 2-0:1.0: USB hub found
    hub 2-0:1.0: 2 ports detected
    usbcore: registered new interface driver usb-storage
    i2c /dev entries driver
    rtc-ds1307 0-0068: rtc core: registered ds1337 as rtc0
    i2c-octeon 1180000001000.i2c: probed
    i2c-octeon 1180000001200.i2c: probed
    i2c i2c-0: Added multiplexed i2c bus 2
    i2c i2c-0: Added multiplexed i2c bus 3
    i2c i2c-0: Added multiplexed i2c bus 4
    i2c i2c-0: Added multiplexed i2c bus 5
    pcf857x 6-003e: probed
    pcf857x 6-003f: probed
    i2c i2c-0: Added multiplexed i2c bus 6
    i2c i2c-0: Added multiplexed i2c bus 7
    i2c i2c-0: Added multiplexed i2c bus 8
    i2c i2c-0: Added multiplexed i2c bus 9
    pca954x 0-0070: registered 8 multiplexed busses for I2C switch pca9548
    octeon_wdt: Initial granularity 5 Sec
    EDAC DEVICE0: Giving out device to module octeon-cpu controller cache: DEV octeon_pc_edac (INTERRUPT)
    EDAC DEVICE1: Giving out device to module octeon-l2c controller octeon_l2c_err: DEV octeon_l2c_edac (POLLED)
    EDAC MC0: Giving out device to module octeon-lmc controller co_lmc_err: DEV octeon_lmc_edac.0 (POLLED)
    octeon_lmc_edac octeon_lmc_edac.1: Disabled (ECC not enabled)
    octeon_lmc_edac octeon_lmc_edac.2: Disabled (ECC not enabled)
    EDAC MC3: Giving out device to module octeon-lmc controller co_lmc_err: DEV octeon_lmc_edac.3 (POLLED)
    NET: Registered protocol family 17
    Key type dns_resolver registered
    L2 lock: TLB refill 256 bytes
    L2 lock: General exception 128 bytes
    L2 lock: low-level interrupt 128 bytes
    L2 lock: interrupt 640 bytes
    L2 lock: memcpy 1152 bytes
    Bootbus flash: Setting flash for 8MB flash at 0x1f400000
    phys_mapped_flash: Found 1 x16 devices at 0x0 in 8-bit bank. Manufacturer ID 0x000001 Chip ID 0x001001
    Amd/Fujitsu Extended Query Table at 0x0040
      Amd/Fujitsu Extended Query version 1.3.
      phys_mapped_flash: Swapping erase regions for top-boot CFI table.
      number of CFI chips: 1
      rtc-ds1307 0-0068: setting system clock to 2017-10-18 05:16:32 UTC (1508303792)
    OF: fdt:not creating '/sys/firmware/fdt': CRC check failed
    Freeing unused kernel memory: 75652K
    This architecture does not have kernel memory protection.
    /sbin/rc starting
    Mounting file systems
    mount: mounting none on /proc/bus/usb failed: No such file or directory
    Setting up loopback
    Starting syslogd
    Starting telnetd
    Oct 18 05:16:32 (none) syslog.info syslogd started: BusyBox v1.26.2
    /sbin/rc complete
    Oct 18 05:16:32 (none) daemon.info nit: starting pid 1517, tty '': '-/bin/cav_sh /bin/sh'


    BusyBox v1.26.2 (2017-08-29 13:14:34 IST) built-in shell (ash)
    Enter 'help' for a list of built-in commands.

    ~ # usb 1-1: new high-speed USB device number 2 using ehci-platform
    usb-storage 1-1:1.0: USB Mass Storage device detected
    scsi host1: usb-storage 1-1:1.0
    scsi 1:0:0:0: Direct-Access     SanDisk  Cruzer Blade     1.00 PQ: 0 ANSI: 6
    sd 1:0:0:0: [sda] 30464000 512-byte logical blocks: (15.6 GB/14.5 GiB)
    sd 1:0:0:0: [sda] Write Protect is off
    sd 1:0:0:0: [sda] Write cache: disabled, read cache: enabled, doesn't support DPO or FUA
     sda: sda1 sda2
     sd 1:0:0:0: [sda] Attached SCSI removable disk


     ~ # udhcpc -i eth0
     udhcpc: started, v1.26.2
     udhcpc: sending discover
     udhcpc: sending select for 10.91.207.201
     udhcpc: lease of 10.91.207.201 obtained, lease time 691200
     deleting routers
     SIOCDELRT: No such process
     adding dns 10.89.12.27
     adding dns 10.90.4.10
     ~ # ping 10.91.205.197
     PING 10.91.205.197 (10.91.205.197) 56(84) bytes of data.
     64 bytes from 10.91.205.197: icmp_seq=1 ttl=64 time=0.155 ms
     64 bytes from 10.91.205.197: icmp_seq=2 ttl=64 time=0.119 ms
     64 bytes from 10.91.205.197: icmp_seq=3 ttl=64 time=0.230 ms
     ^C
     --- 10.91.205.197 ping statistics ---
     3 packets transmitted, 3 received, 0% packet loss, time 2096ms
     rtt min/avg/max/mdev = 0.119/0.168/0.230/0.046 ms
     ~ # ping -c 3 www.google.com
     PING www.google.com (216.58.197.36) 56(84) bytes of data.
     64 bytes from maa03s20-in-f36.1e100.net (216.58.197.36): icmp_seq=1 ttl=55 time=13.7 ms
     64 bytes from maa03s20-in-f36.1e100.net (216.58.197.36): icmp_seq=2 ttl=55 time=14.8 ms
     64 bytes from maa03s20-in-f4.1e100.net (216.58.197.36): icmp_seq=3 ttl=55 time=14.9 ms
                                                                                                                                                       --- www.google.com ping statistics --- 
     3 packets transmitted, 3 received, 0% packet loss, time 7416ms
     rtt min/avg/max/mdev = 13.785/14.535/14.952/0.549 ms
     ~#

</pre></div> </div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Oct 2017 for Octeon Software Development Kit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
