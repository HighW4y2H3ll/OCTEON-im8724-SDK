<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Octeon Software Development Kit: Linux on Small OCTEON Systems</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="linux_small">Linux on Small OCTEON Systems </a></h1><h2><a class="anchor" id="linux_small_intro">
1. Introduction</a></h2>
<p>Running Linux on OCTEON systems with 256MB of memory or less may require a slightly different setup than the SDK provides. In these systems, the normal kernel configuration wastes memory on options normally not used in these systems. Smaller systems can gain access to this memory using a different kernel setup.</p>
<ul>
<li><a class="el" href="linux_small.html#linux_small_intro">1. Introduction</a></li>
<li><a class="el" href="linux_small.html#linux_small_kernel_memory_saving_tips">2. Kernel memory saving tips</a></li>
<li><a class="el" href="linux_small.html#linux_small_flash_layout">3. Setting up the boot flash</a></li>
<li><a class="el" href="linux_small.html#linux_small_kernel_in_flash">4. Putting the kernel into flash</a></li>
<li><a class="el" href="linux_small.html#linux_small_rootfs">5. Handling the root filesystem</a></li>
<li><a class="el" href="linux_small.html#linux_small_cramfs_rootfs">6. Using CRAMFS in flash for a root filesystem</a></li>
<li><a class="el" href="linux_small.html#linux_small_usb_rootfs">7. Using USB for a root filesystem</a></li>
<li><a class="el" href="linux_small.html#linux_small_shrink_rootfs">8. Tips to shrink the root filesystem size</a></li>
<li><a class="el" href="linux_small.html#linux_small_final_boot">9. Booting Example</a></li>
</ul>
<h2><a class="anchor" id="linux_small_kernel_memory_saving_tips">
2. Kernel memory saving tips</a></h2>
<p>Here are some simple tips to save memory in the Linux kernel.</p>
<ul>
<li>Disable SMP support on single CPU systems (Saves 512KB)<ul>
<li>Kernel type -&gt; [ ] Multi-Processing support</li>
</ul>
</li>
<li>Use FLATMEM instead of SPARSEMEM (Saves 40KB)<ul>
<li>Kernel type -&gt; Memory model -&gt; Flat Memory</li>
</ul>
</li>
<li>Disable unneeded drivers</li>
<li>Disable unneeded network options</li>
<li>Disable kernel debug information<ul>
<li>Kernel hacking -&gt; [ ] Kernel debugging</li>
</ul>
</li>
<li>Disable kernel symbols (Saves 20KB)<ul>
<li>General setup -&gt; Configure standard kernel features (for small systems) -&gt; [ ] Load all symbols for debugging/kksymoops</li>
</ul>
</li>
<li>Reduce the number of packet buffers allcoated by the etherent driver. Due to alignment constraints, these buffers are very large and consume memory quickly. The default is 1024 buffers.<ul>
<li>Device Drivers ---&gt; [*] Network device support ---&gt; [*] Ethernet (1000 Mbit) ---&gt; (1024) Number of packet buffers (and work queue entries) for the Ethernet driver</li>
</ul>
</li>
<li>Disable Octeon specific drivers<ul>
<li>Machine selection ---&gt; [ ] Octeon NAND driver [ ] Enable support for Octeon Serial Rapid IO [ ] Decode RSL interrupt conditions.</li>
</ul>
</li>
<li>Disable profiling support<ul>
<li>General setup ---&gt; Configure standard kernel features (for small systems) -&gt; [ ] Profiling support (EXPERIMENTAL)</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="linux_small_flash_layout">
3. Setting up the boot flash</a></h2>
<p>Using the standard OCTEON bootloader, the first 2048KB of flash is reserved for the bootloader. The last flash region is used for the bootloader environment. This leaves all flash in between available. Normal systems divide this area into separate partitions for each major system component. For example, you may wish to divide an 8MB flash into multiple partitions.</p>
<div class="fragment"><pre class="fragment">
	2048KB		Failsafe bootloader+Normal bootloader
	2MB		Compressed kernel
	3.5MB		cramfs root filesystem
	256KB		JFFS2 filesystem
	256KB		Bootloader environment
</pre></div><p>The kernel needs to know the flash layout. This is controlled with the kernel <b>mtdparts</b> command line option. Here is the mtdparts option for the above flash layout. Note that the bootloader partitions are marked read only for safety.</p>
<div class="fragment"><pre class="fragment">
bootoctlinux &lt;address&gt; mtdparts=phys_mapped_flash:2048k(bootloader)ro,2048k(kernel),3072k(cramfs),256k(jffs2),256k(bootloader_env)ro

Check your partitioning:
	$ cat /proc/mtd
	dev:    size   erasesize  name
	mtd0: 00200000 00010000 "bootloader"
	mtd1: 00200000 00010000 "kernel"
	mtd2: 00300000 00010000 "cramfs"
	mtd3: 00040000 00010000 "jffs2"
	mtd4: 00040000 00010000 "bootloader_env"
</pre></div><h2><a class="anchor" id="linux_small_kernel_in_flash">
4. Putting the kernel into flash</a></h2>
<p>In the previous section we setup a flash region for storing the kernel. This region started at 2048KB and extended for 4MB. Since this region is smaller than a normal kernel, lzma will be used to compress the kernel. The final compressed image must be less than 2.0MB.</p>
<div class="fragment"><pre class="fragment">
	lzma -9 vmlinux.64
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>This is the kernel only, without any filesystem. This should have been built using <b>make kernel-deb</b> in the top level linux directory.</dd></dl>
<p>As an example of how to get the kernel into flash, we are going to TFTP it from a remote server. Here are the commands to TFTP the file from the server 192.168.16.39</p>
<p><b>Bootloader commands:</b> </p>
<div class="fragment"><pre class="fragment">
dhcp
setenv serverip 192.168.16.39
setenv autoload no
tftpboot $(loadaddr) vmlinux.64.lzma
</pre></div><p>The next step is to burn the kernel to flash. Be careful here, you can mistakenly destroy the contents of the entire flash. First thing to do is figure out the correct addresses and sizes for flash commands.</p>
<ul>
<li>For an 8MB flash, the start address is 0x1f400000. This should always be 0x1fc00000 minus the size of the flash.</li>
<li>The kernel region starts 2048KB into the flash, 0x1f400000+2048KB = 0x1f600000</li>
<li>The kernel size is 2MB, 0x200000</li>
<li>The kernel region ends 4MB into the flash, 0x1f400000+2048KB+2MB-1 = 0x1f7fffff</li>
<li>We loaded the kernel image into memory at </li>
</ul>
<p><b>Bootloader commands:</b> </p>
<div class="fragment"><pre class="fragment">
erase 0x1f600000 0x1f7fffff erase &lt;kernel flash start&gt; &lt;kernel flash end&gt;
cp.b $(fileaddr) 0x1f600000 0x200000  # cp.b &lt;memory image&gt; &lt;kernel flash start&gt; &lt;size&gt;
</pre></div><h2><a class="anchor" id="linux_small_rootfs">
5. Handling the root filesystem</a></h2>
<p>You have a number of options for where the Linux root filesystem goes. The SDK <b>make kernel</b> target creates a kernel with the root filesystem embedded inside the kernel. While this works well in development, production systems need to store the filesystem separately from the kernel. Below, there are two examples for you to build upon. One puts the filesystem in flash using cramfs, the other puts it on a USB device. There are many other possibilities, these are just two of the common choices.</p>
<h2><a class="anchor" id="linux_small_cramfs_rootfs">
6. Using CRAMFS in flash for a root filesystem</a></h2>
<p>Before attempting to put a cramfs into flash, you will first need to build the image. The embedded rootfs make system supports generating a cramfs for you.</p>
<p><b>Building the cramfs:</b> </p>
<div class="fragment"><pre class="fragment">
	cd linux/embedded_rootfs
	make -s cramfs
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>Invoke 'make menuconfig' to disable unneeded packages to reduce the size of the file system to fit in 3.5 MB.</dd></dl>
<p>To load the resulting image, <b>rootfs.cramfs</b>, into flash, we will use TFTP just like we did for the kernel.</p>
<p><b>Bootloader commands:</b> </p>
<div class="fragment"><pre class="fragment">
dhcp
setenv serverip 192.168.16.39
setenv autoload no
tftpboot $(loadaddr) rootfs.cramfs
</pre></div><p>Now we update our address calculations for the rootfs flash area (4.0MB to 7.5MB).</p>
<p><b>Bootloader commands:</b> </p>
<div class="fragment"><pre class="fragment">
erase 0x1f800000 0x1fb7ffff # erase &lt;rootfs flash start&gt; &lt;rootfs flash end&gt;
cp.b $(fileaddr) 0x1f800000 0x380000 # cp.b &lt;memory image&gt; &lt;rootfs flash start&gt; &lt;size&gt;
</pre></div><p>When booting, specify <b>root=/dev/mtdblock2</b> on the kernel command line.</p>
<h2><a class="anchor" id="linux_small_usb_rootfs">
7. Using USB for a root filesystem</a></h2>
<p>You can also put the root filesystem on a USB device. There are a number of ways to configure a USB device, below shows simple sample to get you started. When using USB as the filesystem, keep in mind you will need to pass the option <b>rootdelay=5</b> to the kernel. This tells the kernel to wait 5 seconds for USB to stabilize before attempting to mount the filesystem. You may need to tweak the delay for your system.</p>
<p>First, use FDISK to partition the device. Here is the partition setup used in this example.</p>
<p><b>The partition layout: fdisk -l /dev/sdb</b> </p>
<div class="fragment"><pre class="fragment">
Disk /dev/sdb: 259 MB, 259522560 bytes
8 heads, 62 sectors/track, 1021 cylinders
Units = cylinders of 496 * 512 = 253952 bytes

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1               1        1021      253177   83  Linux
</pre></div><p>Create an EXT3 filesystem for the USB device using the embedded rootfs make system.</p>
<p><b>Building the ext3:</b> </p>
<div class="fragment"><pre class="fragment">
	cd linux/embedded_rootfs
	make -s ext3
</pre></div><p><b>Copy the filesystem to the USB device:</b> </p>
<div class="fragment"><pre class="fragment">
	cp rootfs.ext3 /dev/sdb1 # Copy the filesystem
	fsck -f /dev/sdb1        # Perform a full filesystem check
	resize2fs /dev/sdb1      # Resize to use the full partition
</pre></div><p>When booting, specify <b>rootdelay=5 root=/dev/sda1</b> on the kernel command line.</p>
<h2><a class="anchor" id="linux_small_shrink_rootfs">
8. Tips to shrink the root filesystem size</a></h2>
<p>The absolute minimum packages required for a bootable OCTEON system are:</p>
<ul>
<li>device-files + This creates all the /dev files.</li>
<li>busybox + Busybox provides many command line utilities. It also supplies init.</li>
<li>init-scripts + These are the minimum init and etc scripts needed to boot.</li>
<li>libraries-* + Depending on the ABI chosen, you must have the appropriate shared libraries to support Busybox.</li>
<li>final-cleanup + This sets the file ownership for the filesystem. It also strips all binaries and libraries.</li>
</ul>
<p>Below are the sizes for different formats of this minimal system. These minimal systems will fit inside of 8MB of flash.</p>
<div class="fragment"><pre class="fragment">
	initramfs kernel ELF		7.1M
	Gzipped initramfs kernel ELF	4.0M
	cramfs				2.6M
	squashfs			2.2M
</pre></div><p>The default configuration from Cavium Inc. includes all packages into the root filesystem. These will fit in 16MB of flash. Here are the resulting sizes for reference.</p>
<div class="fragment"><pre class="fragment">
	initramfs kernel ELF		16M
	Gzipped initramfs kernel ELF	12M
	cramfs				12M
	squashfs			11M
</pre></div><h2><a class="anchor" id="linux_small_final_boot">
9. Booting Example</a></h2>
<p>The following boot commands boot a lzma zipped kernel located 2MB into flash. The filesystem is read from a cramfs in flash starting at 3.5MB.</p>
<div class="fragment"><pre class="fragment">
unlzma 0x1f600000 c00000
bootoctlinux c000000 root=/dev/mtdblock2 mtdparts=phys_mapped_flash:2048k(bootloader)ro,2048k(kernel),3584k(cramfs),256k(jffs2),256k(bootloader_env)ro
</pre></div> </div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Oct 2017 for Octeon Software Development Kit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
