<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Octeon Software Development Kit: Linux Userspace on the OCTEON</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="linux_user">Linux Userspace on the OCTEON </a></h1><h2><a class="anchor" id="linux_user_intro">
1. Introduction</a></h2>
<p>Userspace applications on OCTEON have some added options compared to other processors running Linux. This document contains an overview of these options for both 32 and 64 bit applications. Along with this document, the <a class="el" href="linux.html">Linux on the OCTEON</a> document adds additional reference material.</p>
<p>This document provides detailed information on the following aspects of userspace on the Cavium Inc. OCTEON processor:</p>
<ul>
<li><a class="el" href="linux_user.html#linux_user_intro">1. Introduction</a></li>
<li><a class="el" href="linux_user.html#linux_user_abi">2. Userspace ABIs</a></li>
<li><a class="el" href="linux_user.html#linux_user_memory_map">3. Userspace Memory Map</a></li>
<li><a class="el" href="linux_user.html#linux_user_unaligned">4. Unaligned memory access</a></li>
<li><a class="el" href="linux_user.html#linux_user_building">5. Building Applications</a></li>
<li><a class="el" href="linux_user.html#linux_user_building_cvmx">6. Building Simple Executive Applications</a></li>
<li><a class="el" href="linux_user.html#linux_user_cvmx">7. Running Simple Executive Applications under Linux</a></li>
<li><a class="el" href="linux_user.html#linux_user_checklist">8. Checklist for Simple Executive Programming</a></li>
<li><a class="el" href="linux_user.html#linux_user_passthrough">9. A detailed Simple Executive Port - Passthrough</a></li>
<li><a class="el" href="linux_user.html#linux_user_files">10. Getting Files into the Filesystem</a></li>
<li><a class="el" href="linux_user.html#linux_user_bootmem">11. Allocating Non-virtual Memory</a></li>
<li><a class="el" href="linux_user.html#linux_user_debugging">12. Debugging Tools</a></li>
<li><a class="el" href="linux_user.html#linux_user_flash">13. Flash Access</a></li>
<li><a class="el" href="linux_user.html#linux_user_mass_storage_flash">14. Mass Storage Flash Devices</a></li>
<li><a class="el" href="linux_user.html#linux_user_serial">15. Serial Ports</a></li>
<li><a class="el" href="linux_user.html#linux_user_hugetlb">16. Optimizing virtual memory with HugeTLB support</a></li>
<li><a class="el" href="linux_user.html#linux_user_htlbremap">17. Using Htlbremap to optimize application memory</a></li>
<li><a class="el" href="linux_user.html#linux_user_schedtool">18. Controlling core affinity with schedtool</a></li>
</ul>
<h2><a class="anchor" id="linux_user_abi">
2. Userspace ABIs</a></h2>
<p>The Linux kernel supports three different application binary interfaces (ABIs) for Mips64 and above processors. These ABIs provide different tradeoffs for applications. Here is a short summary of the three types:</p>
<ul>
<li>O32 ABI supports all Mips processors. The resulting program binary is in ELF32 format whose symbol table is in .mdebug format. Up to four registers ($a0..$a3) can be used for passing integer arguments. All registers are treated as 32 bits. 64 bit types are split into two separate registers.</li>
</ul>
<ul>
<li>N64 ABI supports the Mips4 and higher processors. The resulting program binary is in ELF64 format whose symbol table is in DWARF format. Up to eight registers ($a0..$a7) can be used for passing integer arguments. All registers are 64 bits wide and full 64 bit operations are supported.</li>
</ul>
<ul>
<li>N32 ABI supports the Mips4 and higher processors. The resulting program binary is in ELF32 format whose symbol table is in DWARF format. The N32 calling convention is the same as the N64 calling convention. Register are 64 bits wide and full 64 bit operations are supported.</li>
</ul>
<p>Historically, the most heavily used ABI is O32. O32 is used by most Mips Linux distributions including Gentoo, Debian, and the Redhat Mips port. The newer ABIs (N64, N32) are used primarily by SGI. These newer ABIs provide many performance benefits over the older O32 ABI. The following table highlights some of the differences as they relate to OCTEON.</p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><p></p>
</td><td><p>O32 </p>
</td><td><p>N32 </p>
</td><td><p>N64 </p>
</td></tr>
<tr>
<td><p>int </p>
</td><td><p>32bits </p>
</td><td><p>32bits </p>
</td><td><p>32bits </p>
</td></tr>
<tr>
<td><p>long </p>
</td><td><p>32bits </p>
</td><td><p>32bits </p>
</td><td><p>64bits </p>
</td></tr>
<tr>
<td><p>long long </p>
</td><td><p>64bits </p>
</td><td><p>64bits </p>
</td><td><p>64bits </p>
</td></tr>
<tr>
<td><p>pointer </p>
</td><td><p>32bits </p>
</td><td><p>32bits </p>
</td><td><p>64bits </p>
</td></tr>
<tr>
<td><p>regsiter </p>
</td><td><p>32bits </p>
</td><td><p>64bits </p>
</td><td><p>64bits </p>
</td></tr>
</table>
<p>Code requiring more than 2GB of memory or direct access to OCTEON hardware should use the N64 ABI. Code requiring many data structures dealing with pointers, but requiring only occasional hardware access should use the N32 ABI. Some older applications and binaries may still use the O32 ABI, but it is recommended that they be upgraded to the N32 ABI.</p>
<p>The Linux cross compiler shipped as part of the OCTEON SDK supports building code for both the N32 and N64 ABI. If the <b>-mabi=n32</b> option is not specified, the default is N64 (<b>-mabi=64</b>).</p>
<h2><a class="anchor" id="linux_user_memory_map">
3. Userspace Memory Map</a></h2>
<p>The userspace memory map is configurable through the Linux config interface to support multiple option for different types of user environments. Here is a list of the relevant kernel config options:</p>
<div class="fragment"><pre class="fragment">
    Machine selection  ---&gt;
        (0) Number of extra L1 cache lines reserved for CVMSEG memory
            Allow User space to access hardware IO directly (Per process)  ---&gt;
                 ( ) Allowed
                 (X) Per process
                 ( ) Disabled
            Allow User space to access memory directly (Per process)  ---&gt;
                 ( ) Allowed
                 (X) Per process
                 ( ) Disabled
        (512)   Memory to reserve for user processes shared region (MB)
</pre></div><ul>
<li>Number of extra L1 cache lines reserved for CVMSEG memory (CONFIG_CAVIUM_OCTEON_EXTRA_CVMSEG)<br/>
 CVMSEG LM is a segment that accesses portions of the dcache as a local memory; the larger CVMSEG is, the smaller the cache is. This selects the size of CVMSEG LM in cache blocks. The legal range is from zero to 54 cache blocks (i.e. CVMSEG LM is between zero and 6192 bytes). The kernel will automatically reserve several cache lines of CVMSEG LM, this option is used to request additional lines beyond what is normally required for the kernel to function.</li>
</ul>
<ul>
<li>Per-process access control for user programs to access hardware IO directly (CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS)<br/>
 This option provides the ability to dynamically enable/disable access to the OCTEON hardware IO addresses (0x8001000000000000 - 0x8001ffffffffffff) with sysmips() system call. sysmips() only enables this access for the calling process.</li>
</ul>
<ul>
<li>Allow all user space processes to access hardware IO directly (CONFIG_CAVIUM_OCTEON_USER_IO)<br/>
 Allows all user applications to directly access the OCTEON hardware IO addresses (0x8001000000000000 - 0x8001ffffffffffff). This allows high performance networking applications to run in user space with minimal performance penalties. This also means a user application can bring down the entire system. Only use this option on embedded devices where all user applications are strictly controlled.</li>
</ul>
<ul>
<li>Per-process access control for user programs to access memory directly (CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS)<br/>
 This option provides the ability to dynamically enable/disable access to the XKPHYS addresses corresponding to memory, with sysmips() system call. sysmips() only enables this access for the calling process.</li>
</ul>
<ul>
<li>Allow all User space to access memory directly (CONFIG_CAVIUM_OCTEON_USER_MEM)<br/>
 Allows user applications to use XKPHYS addresses directly to memory. This allows user space direct access to shared memory not in use by Linux. This memory is suitable for use with the OCTEON hardware. Cavium simple executive applications also share this memory. Since this bypass all of the Linux memory protection, only use this option on embedded devices where all user applications are strictly controlled.</li>
</ul>
<ul>
<li>Memory to reserve for user processes shared region (MB) (CONFIG_CAVIUM_RESERVE32)<br/>
 Reserve a shared memory region for user processes to use for hardware memory buffers. This is required for 32bit applications to be able to send and receive packets directly. Applications access this memory by memory mapping /dev/mem for the addresses in /proc/octeon_info. For optimal performance, keep this size a power of 2.</li>
</ul>
<p><b>Process</b> <b>Memory</b> <b>Map</b> </p>
<p>The following table shows an example memory map.</p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><p><code>0x8001ffffffffffff<br/>
0x8001000000000000</code> </p>
</td><td><p>64bit </p>
</td><td><p>Hardware IO addresses. Only accessible if CONFIG_CAVIUM_OCTEON_USER_IO.  </p>
</td></tr>
<tr>
<td><p><code>0x8000ffffffffffff<br/>
0x8000000000000000</code> </p>
</td><td><p>64bit </p>
</td><td><p>64bit XKPHYS address bypassing TLB. Only accessible if CONFIG_CAVIUM_OCTEON_USER_MEM.  </p>
</td></tr>
<tr>
<td><p><code>0xffffffffffffffff<br/>
0xffffffff80000000</code> </p>
</td><td><p>32bit </p>
</td><td><p>Kernel mode addresses only - Not available to userspace.  </p>
</td></tr>
<tr>
<td><p><code>0x3fffffffffffffff<br/>
0x0000000000000000</code> </p>
</td><td><p>64bit </p>
</td><td><p>Normal 64bit application address space.  </p>
</td></tr>
<tr>
<td><p><code>linux_mem32_max<br/>
linux_mem32_min</code> </p>
</td><td><p>32bit </p>
</td><td><p>Shared memory area reserved by calling cvmx_bootmem_alloc. Only accessible if CONFIG_CAVIUM_RESERVE32.  </p>
</td></tr>
<tr>
<td><p><code>0x000000007fff8000<br/>
0x0000000000000000</code> </p>
</td><td><p>32bit </p>
</td><td><p>Normal application address space.  </p>
</td></tr>
</table>
<h2><a class="anchor" id="linux_user_unaligned">
4. Unaligned memory access</a></h2>
<p>OCTEON supports three ways of handling unaligned accesses to memory.</p>
<ul>
<li>Address Exception - In default Mips compatibility mode, an unaligned access causes an address alignment exception. The Linux kernel then fixes the offending access in software and returns from the exception. This can take in the order of 1us per access exception.</li>
</ul>
<ul>
<li>Special unaligned instructions - OCTEON can support additional instructions (ulw, usw, uld, usd) specifically handling unaligned accesses. Since the opcodes for these instructions replace the Mips standard lwl and lwr instructions, they are disable under Linux to maintain full Mips userspace compatibility.</li>
</ul>
<ul>
<li>Hardware fixups of unaligned access - OCTEON also supports automatic fixups for unaligned accesses by the hardware. These fixups add an additional 6 cycles to the load/store, but are far faster than the standard Mips exception handling.</li>
</ul>
<p>OCTEON automatic hardware fixups under Linux userspace is controlled by a kernel configuration option. By default this option is on. You may need to disable this option if you're running old Mips code that assumes unaligned accesses cause exceptions. The kernel option is under:</p>
<div class="fragment"><pre class="fragment">
    Machine selection  ---&gt;
    [*] Enable hardware fixups of unaligned loads and stores
</pre></div><h2><a class="anchor" id="linux_user_building">
5. Building Applications</a></h2>
<h3><a class="anchor" id="building_using_cross_tools">
5.1 Building Applications Using OCTEON Cross toolchain</a></h3>
<p>The OCTEON SDK supplies a i686 to OCTEON cross compiler. The compiler supports glibc, pthreads, and c++. Here is an example to compile hello world.</p>
<p>hello_world.c </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #include &lt;stdio.h&gt;</span>
    <span class="keywordtype">int</span> <a class="code" href="cvmx-app-init-linux_8c.html#ac0f2228420376f4db7e1274f2b41667c" title="Main entrypoint of the application.">main</a>(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> *argv[])
    {
        printf(<span class="stringliteral">&quot;Hello world!\n&quot;</span>);
        <span class="keywordflow">return</span> 0;
    }
</pre></div><p>Compile: </p>
<div class="fragment"><pre class="fragment">
    mips64-octeon-linux-gnu-gcc -mabi=64 -o hello_world hello_world.c
or
    mips64-octeon-linux-gnu-gcc -mabi=n32 -o hello_world hello_world.c
</pre></div><p>Here is a list of the support commands: </p>
<div class="fragment"><pre class="fragment">
    mips64-octeon-linux-gnu-addr2line
    mips64-octeon-linux-gnu-ar
    mips64-octeon-linux-gnu-as
    mips64-octeon-linux-gnu-c++
    mips64-octeon-linux-gnu-c++filt
    mips64-octeon-linux-gnu-cpp
    mips64-octeon-linux-gnu-g++
    mips64-octeon-linux-gnu-gcc
    mips64-octeon-linux-gnu-gcov
    mips64-octeon-linux-gnu-ld
    mips64-octeon-linux-gnu-nm
    mips64-octeon-linux-gnu-objcopy
    mips64-octeon-linux-gnu-objdump
    mips64-octeon-linux-gnu-ranlib
    mips64-octeon-linux-gnu-readelf
    mips64-octeon-linux-gnu-size
    mips64-octeon-linux-gnu-strings
    mips64-octeon-linux-gnu-strip
</pre></div><h3><a class="anchor" id="building_using_native_tools">
5.2 Building Applications Using OCTEON Native Tools</a></h3>
<p>The OCTEON SDK provides Linux Native tools to build user space applications on OCTEON. The Linux Native tools are under OCTEON-SDK/tools/mips64-octeon-linux-gnu/sys-root directory. These tools are available in Debian under /usr/local/Cavium_Networks/OCTEON-SDK/tools directory. Only gdb, gdbserver, gprof are included when Kernel is built with busybox.</p>
<p>To use Linux native tools when Kernel is built with busybox mount OCTEON-SDK/tools/mips64-octeon-linux-gnu/sys-root directory as mentioned below.</p>
<p>On your host export the file system</p>
<div class="fragment"><pre class="fragment">
# /etc/init.d/nfs start
# exportfs -o rw,no_root_squash *:/usr/local/Cavium_Networks/OCTEON-SDK/tools/mips64-octeon-linux-gnu/sys-root
</pre></div><p>On OCTEON after booting Linux Kernel</p>
<div class="fragment"><pre class="fragment">
# modprobe octeon-ethernet
# ifconfig eth0 &lt;ip_address&gt;
# mount -o nolock host_ip_address:/usr/local/Cavium_Networks/OCTEON-SDK/tools/mips64-octeon-linux-gnu/sys-root /mnt
# ln -s /mnt/usr/include /usr
# ln -s /mnt/usr/lib /usr
# cd /usr/lib32; ln -s /mnt/usr/lib32/*.a .
# cd /usr/lib32; ln -s /mnt/usr/lib32/*.o .
# cd /usr/lib64; ln -s /mnt/usr/lib64/*.a .
# cd /usr/lib64; ln -s /mnt/usr/lib64/*.o .
# cd /usr/bin; ln -s /mnt/usr/bin/* .
</pre></div><p>To compile and run the user space applications for the hello_world.c example, mentioned in section 5.1</p>
<div class="fragment"><pre class="fragment">
    gcc -mabi=64 -o hello_world hello_world.c
	./hello_world
	Hello World!
or
    gcc -mabi=n32 -o hello_world hello_world.c
	./hello_world
	Hello World!
</pre></div><h3><a class="anchor" id="building_for_octeon2">
5.3 Optimizing Applications for OCTEON II and OCTEON III</a></h3>
<p>The OCTEON II processor has several new machine instructions, that if utilized, can improve the performance of an application. If it is known that an application binary will only be used on an OCTEON II processor, there are several compilation and system configuration changes that can be made to take advantage of these new instructions. The OCTEON III processor adds hardware floating point instructions, that if utilized, can improve the performance of applications that use a lot of floating point math.</p>
<h4><a class="anchor" id="use_octeon2_dynamic_libs">
5.3.1 Use OCTEON II optimized runtime libraries.</a></h4>
<p>The glibc dynamic linker will automatically select OCTEON II optimized libraries, if they are present, when running on a compatible system. When running on an OCTEON II system, the directories /lib32/octeon2, /lib64/octeon2, /usr/lib32/octeon2, and /usr/lib64/octeon2 will be searched for runtime libraries first. If a needed library is present in one of these places it will be used in preference to the standard OCTEON/OCTEON Plus libraries in /lib32, /lib64, /usr/lib32 and /usr/lib64.</p>
<p>From the embedded_rootfs directory these can be selected:</p>
<div class="fragment"><pre class="fragment">
    [*] octeon-libraries-n32
    [*] octeon2-libraries-n32
    [*] octeon3-libraries-n32
    --- octeon-libraries-64
    [*] octeon2-libraries-64
    [*] octeon3-libraries-64 
</pre></div><h4><a class="anchor" id="use_octeon2_code_generation">
5.3.2 Cause GCC to generate OCTEON II machine instructions.</a></h4>
<p>Compile: </p>
<div class="fragment"><pre class="fragment">
    mips64-octeon-linux-gnu-gcc -march=octeon2 -mabi=64 -O3 -o hello_world hello_world.c
or
    mips64-octeon-linux-gnu-gcc -march=octeon2 -mabi=n32 -O3 -o hello_world hello_world.c
</pre></div><p>Note: Applications built in this manner will not work on OCTEON and OCTEON Plus processors. Any attempt to do this will likely result in the application being killed by the kernel with an illegal instruction exception (SIGILL).</p>
<h4><a class="anchor" id="use_octeon3_code_generation">
5.3.3 Cause GCC to generate OCTEON III machine instructions and use hardware floating point.</a></h4>
<p>Compile: </p>
<div class="fragment"><pre class="fragment">
    mips64-octeon-linux-gnu-gcc -march=octeon3 -mabi=64 -O3 -o hello_world hello_world.c
or
    mips64-octeon-linux-gnu-gcc -march=octeon3 -mabi=n32 -O3 -o hello_world hello_world.c
</pre></div><p>The runtime libraries for programs build this way are located in /lib64-fp and /usr/lib64-fp, or /lib32-fp and /usr/lib32-fp</p>
<p>Note: Applications built in this manner will not work on OCTEON and OCTEON Plus processors. Any attempt to do this will likely result in the application being killed by the kernel with an illegal instruction exception (SIGILL). Also when run on OCTEON II processors, any floating point instructions will have to be emulated by the operating system kernel, which is slow.</p>
<h2><a class="anchor" id="linux_user_building_cvmx">
6. Building Simple Executive Applications</a></h2>
<p>The make system for simple executive applications supports building N64 Linux userspace applications in addition to the normal standalone applications. In order to build for Linux, the "make" variable <b>OCTEON_TARGET</b> must be defined to the ABI to use. The valid options are <b>linux_64</b>.</p>
<div class="fragment"><pre class="fragment">
    $ make OCTEON_TARGET=linux_64
</pre></div><h2><a class="anchor" id="linux_user_cvmx">
7. Running Simple Executive Applications under Linux</a></h2>
<p>The CVMX library provides the same shared memory and process model under Linux as found in standalone applications. Before the main application starts executing, the simple executive sets up the CVMX_SHARED region and forks processes for each core.</p>
<p>In detail, CVMX_SHARED is implemented as shared memory region mapped over the CVMX_SHARED variables. First, <b>shm_open()</b> is used to create a shared memory region of the same size as the CVMX_SHARED section. The contents of CVMX_SHARED is then copied into the shared region. Finally the shared region is memory mapped over the existing CVMX_SHARED variables using <b>mmap()</b>. In order for <b>shm_open()</b> to work, the Linux <b>tmpfs</b> filesystem must be mounted at <b>/dev/shm</b>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Linux simple executive applications must be statically linked. All CVMX_SHARED variables must be resolved into a single section. This can only be guaranteed to happen for statically linked applications.</dd></dl>
<p>After the shared region is setup, <b>fork()</b> is used to create a copy of the process for each SMP core. Each forked process is then tied to a specific core using <b>sched_setaffinity()</b>. Once all processes are ready and synchronized using <a class="el" href="cvmx-coremask_8c.html#a41dc86d56858aa146f100b60c5ae1aae" title="Wait (stall) until all cores in the given coremask has reached this point in the...">cvmx_coremask_barrier_sync()</a>, control transfers to <b>appmain</b>(int argc, const char *argv[]).</p>
<p>The Linux userspace startup code can be found in "cvmx-app-init-linux.c".</p>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="cvmx-access_8h.html#a04e4ae7583328b00067505d22e2953de" title="simprintf uses simulator tricks to speed up printouts.">simprintf()</a> performs quite differently under Linux. Instead of using a simulator specific trap to print the message, it uses the standard C library. In order to enforce some ordering, each <a class="el" href="cvmx-access_8h.html#a04e4ae7583328b00067505d22e2953de" title="simprintf uses simulator tricks to speed up printouts.">simprintf()</a> is locked using a <a class="el" href="structcvmx__spinlock__t.html">cvmx_spinlock_t</a>. <a class="el" href="cvmx-access_8h.html#a04e4ae7583328b00067505d22e2953de" title="simprintf uses simulator tricks to speed up printouts.">simprintf()</a> may be removed in the future and should be considered <b>deprecated</b>.</dd></dl>
<p>Linux simple executive application must be linked with simple executive and use the cvmx-shared-linux.ld linker script. See the crypto example for a Makefile to use as a template.</p>
<div class="fragment"><pre class="fragment">    $ cd examples/crypto
    $ make OCTEON_TARGET=linux_64
</pre></div><h2><a class="anchor" id="linux_user_checklist">
8. Checklist for Simple Executive Programming</a></h2>
<ol type="1">
<li>Pointers and Hardware Addresses + In standalone simple executive applications, the underlying 1:1 TLB mapping allows applications to use hardware addresses and memory pointers interchangeably. This isn't true under Linux. Be sure to use <a class="el" href="cvmx-access_8h.html#a76ed79b4650d01f82f1f517be07fe7c5" title="Convert a memory pointer (void*) into a hardware compatable memory address (uint64_t)...">cvmx_ptr_to_phys()</a> and <a class="el" href="cvmx-access_8h.html#a9adf20d6b29145111460ecbc6fbca3dd" title="Convert a hardware physical address (uint64_t) into a memory pointer (void *).">cvmx_phys_to_ptr()</a> on addresses to/from hardware.</li>
<li>POW + Be aware that getting work from the POW releases any atomic tag you currently have. If more than one thread of execution uses the POW, one may be expecting an atomic tag that was given away by the other thread. For example, if you are using the OCTEON kernel ethernet driver, it uses cores for packet processing. Any userspace app may find the POW state changing without notice. The ethernet driver will get work when a new packet interrupt is received. This interrupt has higher priority than user applications and forces a context switch. <b>POW TAG switches and deschedules cannot be used in userspace if the ethernet driver is loaded.</b></li>
<li><a class="el" href="cvmx-app-init-linux_8c.html#ac0f2228420376f4db7e1274f2b41667c" title="Main entrypoint of the application.">main()</a> versus <a class="el" href="cvmx-app-init-linux_8c.html#af88aff83363a7c5942eb39122a0c99a4">appmain()</a> + Simple executive applications under Linux require the main entry point to be called <b>appmain</b> instead of <b>main</b>. The SDK examples use a <b>-D</b> compile directive to define main as an alias for appmain.</li>
<li>Hardware initialization + Most hardware units can only be initialized once. Unless you carefully control initialization in your application, this means your userspace program can only be run once. For example, the SDK crypto example doesn't use much hardware and can run any number of times. On the other hand, the passthrough example reinitializes hardware on every run. It can only be run once.</li>
<li>cvmx-interrupt, cvmx-uart + Userspace programs currently cannot use interrupts. Direct uart access is unwise. You should just use standard IO instead.</li>
<li>Performance penalties + Although the OCTEON hardware has been configure to allow access to both hardware and memory without performance penalties, your application may still have a noticeable performance hit running under Linux. Due to larger amounts of code and data, cache misses and bus contention are more likely. The Linux scheduler timer interrupt also periodically transfers focus to other tasks. In real world usage, a simple executive application should have virtually the same performance characteristics as the standalone version.</li>
</ol>
<h2><a class="anchor" id="linux_user_passthrough">
9. A detailed Simple Executive Port - Passthrough</a></h2>
<p>The process of porting a standalone simple executive application to Linux userspace should be fairly painless. Here we're going to highlight parts of the passthrough example specifically added for portability. Passthrough uses many of the OCTEON hardware widgets and still can run either standalone or under Linux.</p>
<p>To start with, here is a list of headers used by passthrough: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;string.h&gt;</span>

<span class="preprocessor">#include &quot;cvmx-config.h&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="cvmx_8h.html" title="Main Octeon executive header file (This should be the second header file included...">cvmx.h</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="cvmx-spinlock_8h.html" title="Implementation of spinlocks.">cvmx-spinlock.h</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="cvmx-fpa_8h.html" title="Interface to the hardware Free Pool Allocator.">cvmx-fpa.h</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="cvmx-pip_8h.html" title="Interface to the hardware Packet Input Processing unit.">cvmx-pip.h</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="cvmx-ipd_8h.html" title="Interface to the hardware Input Packet Data unit.">cvmx-ipd.h</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="cvmx-pko_8h.html">cvmx-pko.h</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="cvmx-dfa_8h.html" title="Interface to the CN31XX, CN38XX, and CN58XX hardware DFA engine.">cvmx-dfa.h</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="cvmx-pow_8h.html" title="Interface to the hardware Scheduling unit.">cvmx-pow.h</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="cvmx-gmx_8h.html" title="Interface to the GMX hardware.">cvmx-gmx.h</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="cvmx-sysinfo_8h.html" title="This module provides system/board information obtained by the bootloader.">cvmx-sysinfo.h</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="cvmx-coremask_8h.html" title="Module to support operations on bitmap of cores.">cvmx-coremask.h</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="cvmx-bootmem_8h.html" title="Simple allocate only memory allocator.">cvmx-bootmem.h</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="cvmx-helper_8h.html" title="Helper functions for common, but complicated tasks.">cvmx-helper.h</a>&quot;</span>
</pre></div><p>From this list you can imply that passthrough relies on the C library for IO and string / memory library functions. All other interfaces are supplied by the simple executive.</p>
<p>A little further down in the code a few global shared variables are defined using CVMX_SHARED. Nothing special here, both Linux and standalone provide the CVMX_SHARED attribute for declaring variables shared between all cores running the application.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> <a class="code" href="cvmx-platform_8h.html#a845de1642e5d22d87bd00b994bdcd82e">CVMX_SHARED</a> uint64_t start_cycle;
<span class="keyword">static</span> <a class="code" href="cvmx-platform_8h.html#a845de1642e5d22d87bd00b994bdcd82e">CVMX_SHARED</a> uint64_t stop_cycle;
</pre></div><p>In application_main_loop passthrough loop receiving work. Here is the loop core with some extraneous code removed:</p>
<div class="fragment"><pre class="fragment">    <span class="comment">// get the next packet/work to process from the POW unit.</span>
    work = <a class="code" href="cvmx-pow_8h.html#a663a32115088b6888949303edea06e5f" title="Synchronous work request.">cvmx_pow_work_request_sync</a>(0);
    <span class="comment">// Begin packet output by requesting a tag switch to atomic.</span>
    <span class="comment">// Writing to a packet output queue must be synchronized across cores.</span>
    <a class="code" href="cvmx-pow_8h.html#add5b9784e9c8d6f7fda874963d1c958a" title="Starts a tag switch to the provided tag value and tag type.">cvmx_pow_tag_sw</a>(work, work-&gt;ipprt, <a class="code" href="cvmx-csr-enums_8h.html#a556896ab26554db9f539b17e5dbc749baa623178b89156a99c7512c8641f9d6d2" title="Tag ordering is maintained, and at most one PP has the tag.">CVMX_POW_TAG_TYPE_ATOMIC</a>);

    <span class="comment">// Increment the total packet counts</span>
    <a class="code" href="cvmx-fau_8h.html#a0e0e0eeee65ad4a931158727c2731300" title="Perform an atomic 64 bit add.">cvmx_fau_atomic_add64</a>(FAU_PACKETS, 1);
    <a class="code" href="cvmx-fau_8h.html#a0e0e0eeee65ad4a931158727c2731300" title="Perform an atomic 64 bit add.">cvmx_fau_atomic_add64</a>(FAU_OUTSTANDING, 1);

    <span class="comment">// Build a PKO pointer to this packet</span>
    pko_command.s.total_bytes = work-&gt;len;
    port = work-&gt;ipprt;
    packet_ptr = work-&gt;packet_ptr;

    <a class="code" href="cvmx-fpa_8h.html#a953ef29fcfef0ca074e2cfc1c294e4bf" title="Free a block allocated with a FPA pool.">cvmx_fpa_free</a>(work, CVMX_FPA_WQE_POOL, 0);

    <span class="comment">// Send the packet and wait for the tag switch to complete before</span>
    <span class="comment">// accessing the output queue. This ensures the locking required</span>
    <span class="comment">// for the queue.</span>
    cvmx_pko_send_packet2(port, port, pko_command, packet_ptr);
</pre></div><p>In this section of code all of the hardware to pointer conversions are performed automatically by the CVMX library. However, say we wanted to look at the data in the packet. <b>packet_ptr-&gt;addr</b> contains the hardware address of the first bytes of the packet. In the standalone case you might perform the following to get the first byte:</p>
<div class="fragment"><pre class="fragment">uint8_t *ptr = (uint8_t *)packet_ptr-&gt;addr;
uint8_t packet_byte = *ptr;
</pre></div><p>This will fail under Linux. This is what should have been done:</p>
<div class="fragment"><pre class="fragment">uint8_t *ptr = <a class="code" href="cvmx-access-native_8h.html#aec8db4dab167c988728b2913a43d7665" title="Convert a hardware physical address (uint64_t) into a memory pointer (void *).">cvmx_phys_to_ptr</a>(packet_ptr-&gt;addr);
uint8_t packet_byte = *ptr;
</pre></div><p>In order to produce statistics, passthrough needs to know how many cores ran the test. In the standalone simple executive case, you might assume all core are running the test. Instead passthrough uses the OCTEON instruction <b>pop</b> to count the bits in the sysinfo structure element core_mask.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="cvmx-sysinfo_8c.html#ae30ec70c2a125268ea859ac58f891b02" title="system information">sysinfo</a> = <a class="code" href="cvmx-sysinfo_8c.html#accfd43a83b0d1a8af4fe2728880e3e56" title="This function returns the application information as obtained by the bootloader.">cvmx_sysinfo_get</a>();
coremask_passthrough = <a class="code" href="cvmx-sysinfo_8c.html#ae30ec70c2a125268ea859ac58f891b02" title="system information">sysinfo</a>-&gt;<a class="code" href="structcvmx__sysinfo.html#a0cd062a7fe9a42bb966db22bc318d9db" title="coremask defining cores running application">core_mask</a>;
...
int num_processors;
<a class="code" href="cvmx-asm_8h.html#a6dad0c50d97db476087d793782730625">CVMX_POP</a>(num_processors, coremask_passthrough);
</pre></div><p>Building passthrough for Linux requires a different library and linker script that the standalone case. Here is an example for each type of build:</p>
<p>Standalone </p>
<div class="fragment"><pre class="fragment">$ make
</pre></div><p>Linux </p>
<div class="fragment"><pre class="fragment">$ make OCTEON_TARGET=linux_64
</pre></div><h2><a class="anchor" id="linux_user_files">
10. Getting Files into the Filesystem</a></h2>
<p>Adding additional files to the embedded root filesystem can be accomplished in one of two ways. The first method is to add a config and makefile for it by following <a class="el" href="linux.html#linux_userspace_add_pkg">How to Add a Package</a>. For quick testing purposes any files put in a directory can be added to the filesystem. Using "make menuconfig" in linux/embedded_rootfs, set <b>"Directory to copy extra files from"</b>.</p>
<h2><a class="anchor" id="linux_user_bootmem">
11. Allocating Non-virtual Memory</a></h2>
<p>Applications needing memory for direct use by hardware, or needing to bypass the virtual memory overhead of Linux may allocate memory using <a class="el" href="cvmx-bootmem_8c.html#a4295ccfec5aeb9b415c92fbbb1f5873e" title="Allocate a block of memory from the free list that was passed to the application...">cvmx_bootmem_alloc()</a>. This memory is global shareable and outside of the control of Linux. 64 bit applications can allocate large amounts of memory through this interface. 32 bit applications are limited to the amount set aside by CONFIG_CAVIUM_RESERVE32 in the Linux kernel config.</p>
<h2><a class="anchor" id="linux_user_debugging">
12. Debugging Tools</a></h2>
<p>The OCTEON Linux userspace environment includes GDB. See <a class="el" href="linuxdebugger.html">Linux Userspace Debugging</a> for more information.</p>
<p>Kernel debugging can be accomplished using either KGDB or the Cavium Multicore debugger. See <a class="el" href="linux.html#linux_kernel_debugging">21. Debugging the Kernel</a> for more information.</p>
<p>Simple executive applications can be debugged while under Linux. This is called inter-core debugging. See <a class="el" href="debugger.html#intercore_debugger">16 Running the inter-core Debugger</a> for more information. Using "make menuconfig" in linux/embedded_rootfs, set <b>octeon-debug-agent</b> and <b>Simple exec gdb</b>.</p>
<h2><a class="anchor" id="linux_user_flash">
13. Flash Access</a></h2>
<p>The flash chip soldered onto the EBT58XX development boards may be accessed using the /dev/mtd0 device. /dev/mtdblock0 supplies a standard block interface to this device. Be very careful when using this device, as it is capable of erasing the entire flash, including both the normal bootloader and the failsafe bootloader.</p>
<h2><a class="anchor" id="linux_user_mass_storage_flash">
14. Mass Storage Flash Devices</a></h2>
<h3><a class="anchor" id="linux_user_cf">
Compact Flash Access</a></h3>
<p>The EBT58XX compact flash interface can be accessed through /dev/sda*. Compact flashes should be mounted with:</p>
<div class="fragment"><pre class="fragment">
    mount -t vfat /dev/sda1 /mnt
</pre></div><h3><a class="anchor" id="linux_user_mmc">
Multi-Media Card and Secure Digital (MMC/SD)</a></h3>
<p>The EBB6100, and some other boards, have MMC/SD interfaces that can be accessed through /dev/mmcblk*. MMC/SD can be mounted with: with:</p>
<div class="fragment"><pre class="fragment">
    mount /dev/mmcblk0p1 /mnt
</pre></div><h3><a class="anchor" id="linux_user_usb_ms">
USB Mass Storage Devices</a></h3>
<p>On systems with USB, standard USB mass storage devices are mounted in the usual manner. The may be accessed through /dev/sd?*:</p>
<div class="fragment"><pre class="fragment">
    mount /dev/sda1 /mnt
</pre></div><h2><a class="anchor" id="linux_user_serial">
15. Serial Ports</a></h2>
<p>The two OCTEON serial ports are available as /dev/ttyS0 and /dev/ttyS1 following the standard naming convention. The standard Linux <b>stty</b> can used to configure these ports.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>/dev/ttyS1 will not be available if debugging the kernel is enabled. Both KGDB and the OCTEON debugger reserve this port for kernel debugging when they are configured.</dd></dl>
<h2><a class="anchor" id="linux_user_hugetlb">
16. Optimizing virtual memory with HugeTLB support</a></h2>
<p>The OCTEON Linux kernel supports the HugeTLB extension and the hugetlbfs virtual filesystem. Applications needing large amounts of memory should use the HugeTLB extensions to improve TLB efficiency. Each HugeTLB can map large amounts of memory in a single entry. This can dramatically speedup applications using large amount of virtual memory. The following table shows the HugeTLB entry sizes for various kernel page sizes.</p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<th><p>Kernel Pagesize</p>
</th><th><p>Huge TLB Pagesize</p>
</th><th><p>Number of normal pages saved </p>
</th></tr>
<tr>
<td><p>4KB</p>
</td><td><p>2MB</p>
</td><td><p>512 </p>
</td></tr>
<tr>
<td><p>8KB</p>
</td><td><p>8MB</p>
</td><td><p>1024 </p>
</td></tr>
<tr>
<td><p>16KB</p>
</td><td><p>32MB</p>
</td><td><p>2048 </p>
</td></tr>
<tr>
<td><p>32KB</p>
</td><td><p>128MB</p>
</td><td><p>4096 </p>
</td></tr>
<tr>
<td><p>64KB</p>
</td><td><p>512MB</p>
</td><td><p>8192 </p>
</td></tr>
</table>
<dl class="note"><dt><b>Note:</b></dt><dd>For 64bit applications, memory allocated using <a class="el" href="cvmx-bootmem_8c.html#a4295ccfec5aeb9b415c92fbbb1f5873e" title="Allocate a block of memory from the free list that was passed to the application...">cvmx_bootmem_alloc()</a> bypasses the kernel virtual memory system. This memory doesn't require any dynamic TLB entries. Use <a class="el" href="cvmx-bootmem_8c.html#a4295ccfec5aeb9b415c92fbbb1f5873e" title="Allocate a block of memory from the free list that was passed to the application...">cvmx_bootmem_alloc()</a> for large blocks of memory not accessed using Linux system calls.</dd></dl>
<p>In order to use HugeTLB support, you need to pass an additional parameter to the Linux kernel on boot. The parameter <b>hugepages=XXX</b> tells Linux how many HugeTLB entries to support. Note that HugeTLB memory blocks are allocated at boot and may not be used for other purposes. Once the kernel is booted with HugeTLB support, there are two different ways to allocate memory.</p>
<p>The preferred method of allocating HugeTLB memory is with <b>shmget()</b>. Here is an example:</p>
<div class="fragment"><pre class="fragment">
    /*
       Example of using hugepage memory in a user application using Sys V shared
       memory system calls.  In this example the app is requesting 2MB of
       memory that is backed by huge pages.  The application uses the flag
       SHM_HUGETLB in the shmget system call to inform the kernel that it is
       requesting hugepages.

       For the ia64 architecture, the Linux kernel reserves Region number 4 for
       hugepages.  That means the addresses starting with 0x800000... will need
       to be specified.  Specifying a fixed address is not required on mip64,
       ppc64, i386 or x86_64.

       Note: The default shared memory limit is quite low on many kernels,
       you may need to increase it via:

       echo 268435456 &gt; /proc/sys/kernel/shmmax

       This will increase the maximum size per shared memory segment to 256MB.
       The other limit that you will hit eventually is shmall which is the
       total amount of shared memory in pages. To set it to 16GB on a system
       with a 4kB pagesize do:

       echo 4194304 &gt; /proc/sys/kernel/shmall
     */
    #include &lt;stdlib.h&gt;
    #include &lt;stdio.h&gt;
    #include &lt;sys/types.h&gt;
    #include &lt;sys/ipc.h&gt;
    #include &lt;sys/shm.h&gt;
    #include &lt;sys/mman.h&gt;

    #ifndef SHM_HUGETLB
    #define SHM_HUGETLB 04000
    #endif

    #define LENGTH (2UL*1024*1024) FIXME: Change this to match your Huge TLB Pagesize

    #define dprintf(x)  printf(x)

    /* Only ia64 requires this */
    #ifdef __ia64__
    #define ADDR (void *)(0x8000000000000000UL)
    #define SHMAT_FLAGS (SHM_RND)
    #else
    #define ADDR (void *)(0x0UL)
    #define SHMAT_FLAGS (0)
    #endif

    int main(void)
    {
    	int shmid;
    	unsigned long i;
    	char *shmaddr;

    	if ((shmid = shmget(2, LENGTH,
    			    SHM_HUGETLB | IPC_CREAT | SHM_R | SHM_W)) &lt; 0) {
    		perror("shmget");
    		exit(1);
    	}
    	printf("shmid: 0x%x\n", shmid);

    	shmaddr = shmat(shmid, ADDR, SHMAT_FLAGS);
    	if (shmaddr == (char *)-1) {
    		perror("Shared memory attach failure");
    		shmctl(shmid, IPC_RMID, NULL);
    		exit(2);
    	}
    	printf("shmaddr: %p\n", shmaddr);

    	dprintf("Starting the writes:\n");
    	for (i = 0; i &lt; LENGTH; i++) {
    		shmaddr[i] = (char)(i);
    		if (!(i % (1024 * 1024)))
    			dprintf(".");
    	}
    	dprintf("\n");

    	dprintf("Starting the Check...");
    	for (i = 0; i &lt; LENGTH; i++)
    		if (shmaddr[i] != (char)i)
    			printf("\nIndex %lu mismatched\n", i);
    	dprintf("Done.\n");

    	if (shmdt((const void *)shmaddr) != 0) {
    		perror("Detach failure");
    		shmctl(shmid, IPC_RMID, NULL);
    		exit(3);
    	}

    	shmctl(shmid, IPC_RMID, NULL);

    	return 0;
    }
</pre></div><p>The older method of accessing HugeTLB memory is through the <b>mmap</b> interface of a file in the hugetlbfs filesystem. Below is an example using this method.</p>
<div class="fragment"><pre class="fragment">
    $ mount -t hugetlbfs none /mnt
</pre></div><div class="fragment"><pre class="fragment">
    /*
       Example of using hugepage memory in a user application using the mmap
       system call.  Before running this application, make sure that the
       administrator has mounted the hugetlbfs filesystem (on some directory
       like /mnt) using the command mount -t hugetlbfs nodev /mnt. In this
       example, the app is requesting memory of size 2MB that is backed by
       huge pages.

       For ia64 architecture, Linux kernel reserves Region number 4 for hugepages.
       That means the addresses starting with 0x800000... will need to be
       specified.  Specifying a fixed address is not required on mips64, ppc64,
       i386, or x86_64.
     */
    #include &lt;stdlib.h&gt;
    #include &lt;stdio.h&gt;
    #include &lt;unistd.h&gt;
    #include &lt;sys/mman.h&gt;
    #include &lt;fcntl.h&gt;

    #define FILE_NAME "/mnt/hugepagefile"
    #define LENGTH (2UL*1024*1024) FIXME: Change this to match your Huge TLB Pagesize
    #define PROTECTION (PROT_READ | PROT_WRITE)

    /* Only ia64 requires this */
    #ifdef __ia64__
    #define ADDR (void *)(0x8000000000000000UL)
    #define FLAGS (MAP_SHARED | MAP_FIXED)
    #else
    #define ADDR (void *)(0x0UL)
    #define FLAGS (MAP_SHARED)
    #endif

    void check_bytes(char *addr)
    {
    	printf("First hex is %x\n", *((unsigned int *)addr));
    }

    void write_bytes(char *addr)
    {
    	unsigned long i;

    	for (i = 0; i &lt; LENGTH; i++)
    		*(addr + i) = (char)i;
    }

    void read_bytes(char *addr)
    {
    	unsigned long i;

    	check_bytes(addr);
    	for (i = 0; i &lt; LENGTH; i++)
    		if (*(addr + i) != (char)i) {
    			printf("Mismatch at %lu\n", i);
    			break;
    		}
    }

    int main(void)
    {
    	void *addr;
    	int fd;

    	fd = open(FILE_NAME, O_CREAT | O_RDWR, 0755);
    	if (fd &lt; 0) {
    		perror("Open failed");
    		exit(1);
    	}

    	addr = mmap(ADDR, LENGTH, PROTECTION, FLAGS, fd, 0);
    	if (addr == MAP_FAILED) {
    		perror("mmap");
    		unlink(FILE_NAME);
    		exit(1);
    	}

    	printf("Returned address is %p\n", addr);
    	check_bytes(addr);
    	write_bytes(addr);
    	read_bytes(addr);

    	munmap(addr, LENGTH);
    	close(fd);
    	unlink(FILE_NAME);

    	return 0;
    }
</pre></div><h2><a class="anchor" id="linux_user_htlbremap">
17. Using Htlbremap to optimize application memory</a></h2>
<h3><a class="anchor" id="linux_user_htlbremap_overview">
Overview</a></h3>
<p><b>libhtlbremap.so</b> is a shared library that you can use to remap an application (text, data, heap and stack) into huge TLB pages. This will significantly reduce the number of pages used by the application and thus the number of TLB refills needed.</p>
<p>There is no need to rebuild the application. You can use the Linux dynamic linkers LD_PRELOAD mechanism to load the shared library before your application would start.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This approach only works with dynamicly linked applications.</dd></dl>
<p>The library is part of the embedded root filesystem (<a class="el" href="linux.html#linux_userspace">3. Embedded User Environment</a>). To invoke it run the application as usual except set the environment variable LD_PRELOAD to point to the libhtlibremap.so:</p>
<div class="fragment"><pre class="fragment">
    LD_PRELOAD=libhtlbremap.so application arg1 arg2 ...
</pre></div><p>or</p>
<div class="fragment"><pre class="fragment">
    export LD_PRELOAD=libhtlbremap.so
    application arg1 arg2 ...
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>The library is <b>not</b> part of the Debian file system. To use it on Debian you can build it under $OCTEON_ROOT/linux/embedded_rootfs/source/htlbremap with a <b>make</b>. And then use the ABI-matching library with your program. E.g. for the N64/default ABI:</dd></dl>
<div class="fragment"><pre class="fragment">
   export LD_PRELOAD=/path/to/libhtlbremap.so
   n64-appliation arg1 arg2 ...
</pre></div><p>or for the N32 ABI (if your applicatoin builds with -mabi=n32):</p>
<div class="fragment"><pre class="fragment">
   export LD_PRELOAD=/path/to/libhtlbremap-n32.so
   n32-appliation arg1 arg2 ...
</pre></div><p>When remapping the stack, htlbremap allocates memory for the stack. The value set by ulimit -s is used if that provides a limit. If the value is unlimited 8MB of stack is allocated and beyond that the stack is grown using regular pages.</p>
<h3><a class="anchor" id="linux_user_htlbremap_setup">
Setting up</a></h3>
<ol type="1">
<li>To set up huge TLB pages, first make sure hugetlbfs is mounted to /mnth. <div class="fragment"><pre class="fragment">
	mount -t hugetlbfs none /mnth
	</pre></div> <dl class="note"><dt><b>Note:</b></dt><dd>If you use a different mount point, adjust the macro HTLB_FS_DIR in linux/embedded_rootfs/source/htlbremap/htlbremap.c accordingly.</dd></dl>
</li>
<li>Set the contents of /proc/sys/vm/nr_hugepages to the maximum number of huge TLB pages. Now /proc/meminfo should show to available number of huge TLB pages. <div class="fragment"><pre class="fragment">
	echo 50 &gt; /proc/sys/vm/nr_hugepages
	</pre></div></li>
<li>Run your application. <div class="fragment"><pre class="fragment">
	LD_PRELOAD=libhtlbremap.so application arg1 arg2 ...
	</pre></div> <dl class="note"><dt><b>Note:</b></dt><dd>Set the environment variable HTLBREMAP_DEBUG to a nonzero value to get debug messages.</dd></dl>
</li>
</ol>
<h3><a class="anchor" id="linux_user_htlbremap_options">
Controlling how htlbremap is run</a></h3>
<p>Through setting environment variables you can change some aspects of how htlbremap works.</p>
<ul>
<li>HTLBREMAP_DEBUG: Set this if you want to see debug messages from htlbremap.</li>
</ul>
<ul>
<li>HTLBREMAP_DISABLE: Disable remapping of certain parts of memory. This variable contains a list of strings: executable, heap, stack, or shlibs.</li>
</ul>
<h3><a class="anchor" id="linux_user_htlbremap_caveats">
Caveats</a></h3>
<ol type="1">
<li>When portions of an application's memory space are remapped with huge pages, all the remapped memory is made writable and executable. This may be less memory protection than it had before the remapping.</li>
<li>The libc default FILE buffers allocated by fopen() bypass the heap, and are allocated using direct calls to mmap() with the standard page size, thus bypassing the huge pages in the heap. Applications can override this behavior by calling setbuf() or setvbuf().</li>
<li>If a process using libhtlbremap calls fork(), the system may have to allocate additional huge page to handle page copy-on-write requests. This can lead to Out Of Memory (OOM) errors if the value of /proc/sys/vm/nr_hugepages is set too low.</li>
<li>After remapping, /proc/NNN/maps will show the hugetlbfs file as the file for the executable and not the original. This confuses oprofile as it assigns the PCs from the executable to the hugetlb file and it fails to map them to symbols producing incomplete data. The script htlb-fix-oprofile can help to fix up oprofile's internal representation to include the real executable rather than the hugetlbfs file.</li>
</ol>
<h2><a class="anchor" id="linux_user_schedtool">
18. Controlling core affinity with schedtool</a></h2>
<p>Sometimes it is desirable to control which cpu core, or set of cores, an application can be scheduled to. The Linux system call <b>sched_setaffinity</b> allows you to do this from code. To make this generically easy from the command line, Cavium supplies the standard Linux utility <b>schedtool</b> which allows any shell command or currently executing process to be executed on any core or set of cores.</p>
<div class="fragment"><pre class="fragment">
Usage: schedtool -a &lt;cpu&gt; -e &lt;command&gt;
       schedtool -a &lt;mask&gt; -e &lt;command&gt;
</pre></div><p><b>schedtool</b> starts the supplied command on a specific cpu or limits the command to running on the cpu's in the mask. "&lt;cpu&gt;" must be a decimal integer from 0..CPUS-1. "&lt;mask&gt;" must be a hexadecimal number specified as 0xXXXX. In both forms schedtool uses kernel virtual cpu numbering instead of the hardware physical numbers. schedtool also allows process scheduling parameters to be set. Consult schedtool's standard Linux man page for a full description of all the options.</p>
<p>Here is an example: </p>
<div class="fragment"><pre class="fragment">
schedtool -a 0 -e modprobe ethernet-pow
</pre></div> </div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Oct 2017 for Octeon Software Development Kit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
