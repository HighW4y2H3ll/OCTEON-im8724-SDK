<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Octeon Software Development Kit: Remotely Controlling an OCTEON through PCI, PCIe, or EJTAG.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="octeon_remote">Remotely Controlling an OCTEON through PCI, PCIe, or EJTAG. </a></h1><h2><a class="anchor" id="octeon_remote_intro">
1. Introduction</a></h2>
<p>In development, and production, it may be useful to access and control OCTEON from a remote host or other communication path. For example, a PC may need to boot OCTEON through PCI/PCIe. At other times you may want to read registers through EJTAG. In order to support these conditions, Cavium Inc has developed a remote protocol library and a number of special purpose command line utilities. These utilities allow common operations like register dumps, read and write of CSRs, and profiling to be done outside of OCTEON.</p>
<p>This document provides detailed information on the following aspects of controlling OCTEON remotely:</p>
<ul>
<li><a class="el" href="octeon_remote.html#octeon_remote_intro">1. Introduction</a></li>
<li><a class="el" href="octeon_remote.html#octeon_remote_protocols">2. Supported Remote Protocols</a></li>
<li><a class="el" href="octeon_remote.html#octeon_remote_backwards">3. Backwards Compatibility with Previous Utilities</a></li>
<li><a class="el" href="octeon_remote.html#octeon_remote_boot">4. Booting over PCI or EJTAG (oct-remote-boot)</a></li>
<li><a class="el" href="octeon_remote.html#octeon_remote_bootcmd">5. Remote Bootloader Commands (oct-remote-bootcmd)</a></li>
<li><a class="el" href="octeon_remote.html#octeon_remote_console">6. Remote Console (oct-remote-console)</a></li>
<li><a class="el" href="octeon_remote.html#octeon_remote_core">7. Read CPU Core State (oct-remote-core)</a></li>
<li><a class="el" href="octeon_remote.html#octeon_remote_csr">8. CSR Access (oct-remote-csr)</a></li>
<li><a class="el" href="octeon_remote.html#octeon_remote_ddr">9. Quickly Test Memory (oct-remote-ddr)</a></li>
<li><a class="el" href="octeon_remote.html#octeon_remote_load">10. Loading Files into Memory (oct-remote-load)</a></li>
<li><a class="el" href="octeon_remote.html#octeon_remote_memory">11. Read / Write a 64 bit Memory Location (oct-remote-memory)</a></li>
<li><a class="el" href="octeon_remote.html#octeon_remote_pow">12. Displaying OCTEON POW state (oct-remote-pow)</a></li>
<li><a class="el" href="octeon_remote.html#octeon_remote_reset">14. Resetting OCTEON (oct-remote-reset)</a></li>
<li><a class="el" href="octeon_remote.html#octeon_remote_save">15. Saving Memory to a file (oct-remote-save)</a></li>
<li><a class="el" href="octeon_remote.html#octeon_remote_tra">16. Tracing using the OCTEON Trace Buffer (oct-remote-tra)</a></li>
<li><a class="el" href="octeon_remote.html#pci_target_gdb">17. Debugging using GDB</a></li>
<li><a class="el" href="octeon_remote.html#oct-remote-app-ctl">18. Remote controlling hotplugable SE applications.</a></li>
</ul>
<h2><a class="anchor" id="octeon_remote_protocols">
2. Supported Remote Protocols</a></h2>
<p>The OCTEON remote library supports a number of possible protocols for connecting to OCTEON. The choice of which protocol to use is controlled by the environment variable <b>OCTEON_REMOTE_PROTOCOL</b>. If this environment variable isn't set, the utilities will display a message showing the possible supported protocols. Here is a list of some of the support protocols:</p>
<ul>
<li>OCTEON_REMOTE_PROTOCOL = PCI[:device]<ul>
<li>Use PCI/PCIe to access OCTEON from the host or root complex. If multiple OCTEON's are present, the optional "device" number specifies which one to use. The first device is number 0.</li>
</ul>
</li>
<li>OCTEON_REMOTE_PROTOCOL = PCIHOST<ul>
<li>Use PCI/PCIe to connect to the host OCTEON from a target. This is normally only used during development for profiling and register dumps. This allows an OCTEON PCI/PCIe target to access the host's (or root complex's) registers.</li>
</ul>
</li>
<li>OCTEON_REMOTE_PROTOCOL = MACRAIGOR:name,tcp_port<ul>
<li>Use a Macraigor mpDemon to access OCTEON through EJTAG. "name" is either the host name or IP address of the mpDemon probe. "tcp_port" is the TCP port of the probe (normally 1000).</li>
</ul>
</li>
<li>OCTEON_REMOTE_PROTOCOL = GDB:name,tcp_port<ul>
<li>Use the GDB remote protocol to access OCTEON. Many brands of EJTAG probes supply GDB remote stubs for debugging. The remote utilities can use this protocol directly. Abatron, Mentor Graphics, and Macraigor are all known to work with this protocol. "name" is either the host name or IP address of the GDB stub. "tcp_port" is the TCP port of the first core. Each additional core increments the TCP port by one. The README.txt files in the sdk/ejtag directory have more information about specific probes.</li>
</ul>
</li>
<li>OCTEON_REMOTE_PROTOCOL = LINUX<ul>
<li>Assume the utility is running under Linux userspace native on the OCTEON. mmap() and debug exception handlers are used to access the local OCTEON without modifying the kernel.</li>
</ul>
</li>
</ul>
<p>In the event of problems, the environment variable OCTEON_REMOTE_DEBUG can be used to enable detailed diagnostic information. Increasing numbers, show more detail:</p>
<ul>
<li>OCTEON_REMOTE_DEBUG = 0<ul>
<li>Disables all diagnostic output.</li>
</ul>
</li>
<li>OCTEON_REMOTE_DEBUG = 1<ul>
<li>Enables a small amount of informational data.</li>
</ul>
</li>
<li>OCTEON_REMOTE_DEBUG = 2<ul>
<li>More diagnostic data is generated.</li>
</ul>
</li>
<li>OCTEON_REMOTE_DEBUG = 3<ul>
<li>Call traces of octeon-remote are generated.</li>
</ul>
</li>
<li>OCTEON_REMOTE_DEBUG = ...</li>
<li>OCTEON_REMOTE_DEBUG = 9<ul>
<li>All possible output is enabled.</li>
</ul>
</li>
</ul>
<p>Normally debug output from the remote library is color coded based on the diagnostic level. If you wish to turn the color off, add 256 to the debug level.</p>
<h2><a class="anchor" id="octeon_remote_backwards">
3. Backwards Compatibility with Previous Utilities</a></h2>
<p>The OCTEON SDK contains a number of trivial shell scripts to allow the oct-remote-* utilities to act as a drop in replacement for the oct-pci-* and oct-linux-* utilities provided in previous SDKs. The functionality of the older utilities is implemented in the remote utilities when the OCTEON_REMOTE_PROTOCOL is set appropriately.</p>
<ul>
<li>The scripts for oct-pci-* set OCTEON_REMOTE_PROTOCOL=pci.</li>
<li>The scripts for oct-linux-* set OCTEON_REMOTE_PROTOCOL=linux.</li>
</ul>
<h2><a class="anchor" id="octeon_remote_boot">
4. Booting over PCI or EJTAG (oct-remote-boot)</a></h2>
<p>OCTEON can be booted from a remote host without the need for a boot flash on the OCTEON board. For PCI targets, the OCTEON board must be configured for PCI boot mode. This keeps all cores in reset after the chip is taken out of reset. For EJTAG boot, the board must _not_ be configured for PCI boot mode, as core 0 must be running for the EJTAG probe to use. The oct-remote-boot program configures the memory controller, copies the bootloader to DRAM, and then boots the bootloader. By default the provided bootloader (target/bin/u-boot-pci.bin) for the detected board is used. A different bootloader image can be specified on the command line. oct-remote-boot also supports a 'generic' board type and bootloader that should support most OCTEON boards. In order to use the generic board mode, certain board configuration parameters must be passed on the command line so that oct-remote-boot can configure the memory controller properly. (The SPD addresses for the DIMMS are required in all cases.)</p>
<p>For this command to not report an error, stdin must include bootcmd. This will likely change in the future to requiring stdin to contain PCI. By default, both of these are enabled on boards that support it.</p>
<div class="fragment"><pre class="fragment">
Usage: ./oct-remote-boot [--memonly] [--board=board_name] [bootloader filename]
    Boot OCTEON and load bootloader over remote connection (PCI or EJTAG).
    --help: Show this usage.
    --memonly: If specified only the memory controller is configured.
    --board=board_name:  Force a particular board type to be used.
    --envfile=&lt;environment filename&gt;: Reads the u-boot environment data from
              the specified file, loads it into DRAM for u-boot to use.  The u-boot
              image must be configured to use this environment.  The format of the file
              is one environment variable per line:
              env_var=env_val\n
              each line must be ended with a single '\n'
    --scantwsi: Scan twsi bus and exit.
    --dumpspd: Dump SPD contents when scanning twsi bus.

    The following options are to support booting the generic ram based u-boot image, and
    are not used for normal operation.
    --ddr0spd=&lt;twsi_addr[,twsi_addr]|filename[,filename]&gt;: SPD addresses or files for DIMMS on interface 0.  Specify multiple times
               if multiple dimms are present.  For 128 bit wide DDR interaces (CN38XX/CN58XX)
               comma separated pairs off addresses must be used.(only required for generic board type.)
    --ddr1spd=&lt;twsi_addr|filename&gt;: SPD addresses or files for DIMMS on DDR interface 1.  Only valid for Chips
               with 2 DDR controllers.  Specify multiple times for multiple DIMMS.(only required for generic board type.)
    --ddr0spd=&lt;twsi addrs&gt;: SPD addresses for DIMMS on interface 0.  Specify multiple times
               if multiple dimms are present.  For 128 bit wide DDR interaces (CN38XX/CN58XX)
               comma separated pairs off addresses must be used. (only required for generic board type.)
    --ddr1spd=&lt;twsi addrs&gt;: SPD addresses for DIMMS on DDR interface 1.  Only valid for Chips
               with 2 DDR controllers, such as CN56XX.  Specify multiple times for multiple DIMMS.

    --cpu_ref_hz=&lt;NNN&gt;: CPU reference clock in Hz.  (only requried for generic board type.)
    --ddr_ref_hz=&lt;NNN&gt;: DDR reference clock in Hz.  (only requried for generic board type.)
    --ddr_clock_hz=&lt;NNN&gt;: DDR clock in Hz.  (only requried for generic board type.)
    --board_delay=&lt;NNN&gt;: board delay, in picoseconds. (only required for generic board type.)
    --readlevel:  Enable read leveling (auto board delay), CN52XX/CN56XX only.
    The bootloader (optionally) supplied must be built for
     booting from DRAM.  If no bootloader is specified the standard one
     for the detected or supplied board type will be chosen.

For boards without SPD eeproms, filenames rather than SPD addresses may be specified.  The files
must contain SPD values with 1 hex value per line, and a minimum of 64 values.
</pre></div><p> Usage examples: </p>
<div class="fragment"><pre class="fragment">
    $ sudo oct-remote-boot
    All cores in reset, skipping soft reset.
    Using bootloader image: ..../sdk/target/bin/u-boot-octeon_thunder.bin
    Initialized 2048 MBytes of DRAM
    $
</pre></div><div class="fragment"><pre class="fragment">
    $ sudo oct-remote-boot my-bootloader-image.bin
    Found OCTEON on bus 0 in slot 5. BAR0=0xf8000000, BAR1=0xf0000000
    $
</pre></div><div class="fragment"><pre class="fragment">
    $ sudo oct-remote-boot --scantwsi
    Scanning twsi bus...
    Twsi addr 81 (0x51) responded, DIMM SPD
    Twsi addr 82 (0x52) responded, DIMM SPD
    Twsi addr 83 (0x53) responded
    Twsi addr 104 (0x68) responded
    $
</pre></div><div class="fragment"><pre class="fragment">
    $ sudo oct-remote-boot --ddr0spd=0x51,0x52 --board_delay=5000 --board=generic
    Using user supplied DDR 0 spd address(es): 0x51,0x52
    Using user supplied board delay: 5000
    Using user supplied board name: generic, number: 28
    WARNING: detected board type THUNDER (6) does no match supplied board type GENERIC (28).
    NOTICE: using default 50000000 Hz DDR reference clock.
    NOTICE: using default 50000000 Hz CPU reference clock.
    Using bootloader image: ..../sdk/target/bin/u-boot-octeon_generic_ram.bin
    Initialized 2048 MBytes of DRAM
    $
</pre></div><h2><a class="anchor" id="octeon_remote_bootcmd">
5. Remote Bootloader Commands (oct-remote-bootcmd)</a></h2>
<p>The bootloader can accept commands remotely. Note that the command must be quoted if it contains whitespace. Also, any u-boot environment variables that are referenced must be escaped so that the shell does not expand them.</p>
<p>For this command to work, stdin must include bootcmd. This will likely change in the future to requiring stdin to contain PCI. By default, both of these are enabled on boards that support it.</p>
<div class="fragment"><pre class="fragment">
    $ sudo oct-remote-bootcmd "bootoct \$(fileaddr) coremask=ffff"
    Found OCTEON on bus 0 in slot 5. BAR0=0xf8000000, BAR1=0xf0000000
    $
</pre></div><h2><a class="anchor" id="octeon_remote_console">
6. Remote Console (oct-remote-console)</a></h2>
<p>The bootloader, simple executive applications, and Linux can direct their consoles over remote protocols to the oct-remote-console utility. This allows interaction with programs running on OCTEON without a serial connection. Multiple separate consoles can be used, so for example each core could have its own console if it is running linux.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Applications that do not link against this simple executive library cannot use the remote console. </dd>
<dd>
U-boot, and many of the CVMX APIs refer to remote consoles support as "PCI Console". Historically, PCI was the first protocol supported. Later PCIe and EJTAG were added.</dd></dl>
<p>Bootloader usage:</p>
<p>By default on boards that support it, stdin will support the remote console but stdout and stderr will not. If a remote console is connected and output is desired to the console then issue the command:</p>
<div class="fragment"><pre class="fragment">
$ sudo oct-remote-bootcmd "setenv stdout serial,pci; setenv stderr serial,pci"
</pre></div><p>Adding serial is optional but enables simultaneous output to the serial console.</p>
<p>Additionally, the above command may be typed in blind into the remote console and once entered correctly output should appear.</p>
<p>The console data structures are initialized by the bootloader at boot time if configured. If the bootloader does not initialize the data structures, console functionality will not be available. The 'pci_console_count' and 'pci_console_size' are used to control the number of consoles and the size of each console's buffers. By default the console structures are not initialized. Setting the 'pci_console_count' to a non-zero value will cause the data structures to be initialized. If this variable is saved in the environment, then the data structures will be initialized at boot time as well. The console data structures will be configured, but the remote console will not be used by the bootloader unless the 'pci_console_active' environment variable is set. If only the 'pci_console_active' variable is set, then the default of 1 console with 1024 byte buffers will be used. The bootloader always uses remote console 0, so the following command (run as root) will connect to it:</p>
<div class="fragment"><pre class="fragment">
    $ oct-remote-console 0
    Found OCTEON on bus 3 in slot 2. BAR0=0xe7fff000, BAR1=0xd8000000
    Connecting to PCI console 0
    Using raw terminal mode, escape character is ^A, use ^A D  to exit, ^A A to send ^A
    $
</pre></div><p>Simple Executive usage:</p>
<p>If the bootloader is configured to use the remote console, the simple executive applications will also use console 0.</p>
<p>Linux usage:</p>
<p>Linux uses a command line argument to select a remote console. The argument 'console=pciN' should be added to the command line, with N being replaced with the number of the console to be used.</p>
<p>oct-remote-console utility usage: </p>
<div class="fragment"><pre class="fragment">
    Usage: oct-remote-console [--noraw] &lt;CONSOLE_NUMBER&gt;
</pre></div><p>The oct-remote-console utility takes the console number to connect to as an argument. By default it put the terminal in raw mode so that control characters are passed through to OCTEON. The escape character is ^A, and to exit type ^A D. The utility can also be invoked with the '--noraw' mode in which case control characters like ^C and ^Z are not passed through, but cause signals to be sent to the oct-remote-console utility. In 'noraw' mode, ^C causes the utility to exit.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Because the oct-remote-console utility polls OCTEON, if OCTEON is reset while the console is connected there is a good chance that the entire machine will lock up. (The lockup is due to OCTEON being non-responsive to the PCI accesses while it is in reset.) The oct-remote-console utility should be exited before reseting the OCTEON. The one exception to this is that oct-remote-reset and oct-remote-boot can be used while the pci console is active since they coordinate with oct-remote-console to ensure that no accesses happen while the OCTEON is non-responsive.</dd></dl>
<h2><a class="anchor" id="octeon_remote_core">
7. Read CPU Core State (oct-remote-core)</a></h2>
<p>The general purpose registers, coprocessor 0 state, and TLB can be read remotely using oct-remote-core. A single argument specifies the OCTEON core number to read.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Some registers are not available through some remote protocols. These registers will show as 0x0bad0bad0bad0bad.</dd></dl>
<div class="fragment"><pre class="fragment">
Usage: ./oct-remote-core &lt;core&gt;
    Display the state of an OCTEON core.

    core - OCTEON core to display.
</pre></div><p>Sample output from core 0 in U-boot </p>
<div class="fragment"><pre class="fragment">
Core 0
CPU registers:
   zero (r0)    0x0000000000000000         s0 (r0)      0x0000000000000001
     at (r1)    0x0000000000000000         s1 (r1)      0xffffffff800bfa48
     v0 (r2)    0x0000000000000000         s2 (r2)      0xffffffff800a50a8
     v1 (r3)    0x8001180000000828         s3 (r3)      0x0000000000000010
     a0 (r4)    0x0000000000000001         s4 (r4)      0xffffffff800a0000
     a1 (r5)    0xffffffff800b06e0         s5 (r5)      0xffffffff8005ff24
     a2 (r6)    0x0000000000000000         s6 (r6)      0x0000000000024108
     a3 (r7)    0xffffffff800b06e0         s7 (r7)      0x6f513832dea27065
     a4 (r8)    0x0000000000000000         t8 (r8)      0x0000000000000000
     a5 (r9)    0xffffffffffffffd0         t9 (r9)      0xffffffff8008542c
     a6 (r10)   0x0000000000000002         k0 (r10)     0xffffffff8005ff24
     a7 (r11)   0xffffffff800b05a0         k1 (r11)     0xfffffffffffffffe
     t0 (r12)   0xffffffff800b06e0         gp (r12)     0xffffffff800b06e0
     t1 (r13)   0xffffffff800ad3b0         sp (r13)     0xffffffff8005bd10
     t2 (r14)   0x0000000000000020      s8/fp (r14)     0xa89c196f513832de
     t3 (r15)   0xffffffff800b06e0         ra (r15)     0xffffffff80075584
     lo         0x0000000000000ea6         hi           0x0000000000000000
Coprocessor 0 registers:
  ($ 0,0) Index     0xffffffff80000000  ($18,1) WatchLo1       0x0bad0bad0bad0bad
  ($ 1,0) Random    0x000000000000003f  ($19,0) WatchHi0       0xffffffff80000000
  ($ 2,0) EntryLo0  0x0000000000000000  ($19,1) WatchHi1       0x0bad0bad0bad0bad
  ($ 3,0) EntryLo1  0x0000000000000000  ($20,0) XContext       0x0000000000000000
  ($ 4,0) Context   0x0000000000000000  ($23,0) Debug          0x000000004011fc20
  ($ 5,0) PageMask  0x0000000000000000  ($25,0) PerfControl0   0xffffffffc0000000
  ($ 5,1) PageGrain 0x0000000020000000  ($25,2) PerfControl1   0x0000000040000000
  ($ 6,0) Wired     0x0000000000000000  ($24,0) DEPC           0xffffffff80075560
  ($ 7,0) HWREna    0xffffffffc000000f  ($25,1) PerfCount0     0x0000000000000000
  ($ 8,0) BadVAddr  0x0000000000000000  ($25,3) PerfCount0     0x0000000000000000
  ($ 9,0) Count     0xffffffffee38d00c  ($27,0) IcacheError    0x007f7f0000001850
  ($10,0) EntryHi   0xc001ffff9007e000  ($27,1) DcacheError    0x00000000000019d0
  ($11,0) Compare   0x0000000000000000  ($28,0) IcacheTagLo    0xcff1ffffe1f81281
  ($12,0) Status    0x00000000504000e5  ($28,1) IcacheDataLo   0x5f7c42f1cb820613
  ($12,1) IntCtl    0xfffffffffc000000  ($28,2) DcacheTagLo    0x0000000000000000
  ($12,2) SRSCtl    0x0000000000000000  ($28,3) DcacheDataLo   0x0000000000000060
  ($13,0) Cause     0x0000000040008000  ($29,1) IcacheDataHi   0x0000000000000000
  ($14,0) EPC       0x27178f42b6d265de  ($29,2) DcacheTagHi    0x0000000000000000
  ($15,0) PRId      0x00000000000d0708  ($29,3) DcacheDataHi   0x0000000000000000
  ($15,1) Ebase     0xffffffff80000000  ($30,0) ErrorEPC       0xffffffffff200e3c
  ($16,0) Config    0xffffffff8000c48a  ($31,0) DESAVE         0x0000000000000000
  ($16,1) Config1   0xfffffffffe3303da  ($ 9,7) CvmCtl         0x00000000b00043f0
  ($16,2) Config2   0xffffffff80000367  ($11,7) CvmMemCt       0x0000000000046104
  ($16,3) Config3   0x0000000000001080  ($ 9,6) CvmCount       0x000000015d5c0520
  ($18,0) WatchLo0  0x0000000000000000  ($22,0) MultiCoreDebug 0x0bad0bad0bad0bad
TLB:
 0: Virtual=0xffffffff9007e000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
 1: Virtual=0xffffffff9007c000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
 2: Virtual=0xffffffff9007a000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
 3: Virtual=0xffffffff90078000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
 4: Virtual=0xffffffff90076000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
 5: Virtual=0xffffffff90074000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
 6: Virtual=0xffffffff90072000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
 7: Virtual=0xffffffff90070000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
 8: Virtual=0xffffffff9006e000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
 9: Virtual=0xffffffff9006c000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
10: Virtual=0xffffffff9006a000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
11: Virtual=0xffffffff90068000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
12: Virtual=0xffffffff90066000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
13: Virtual=0xffffffff90064000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
14: Virtual=0xffffffff90062000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
15: Virtual=0xffffffff90060000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
16: Virtual=0xffffffff9005e000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
17: Virtual=0xffffffff9005c000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
18: Virtual=0xffffffff9005a000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
19: Virtual=0xffffffff90058000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
20: Virtual=0xffffffff90056000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
21: Virtual=0xffffffff90054000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
22: Virtual=0xffffffff90052000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
23: Virtual=0xffffffff90050000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
24: Virtual=0xffffffff9004e000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
25: Virtual=0xffffffff9004c000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
26: Virtual=0xffffffff9004a000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
27: Virtual=0xffffffff90048000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
28: Virtual=0xffffffff90046000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
29: Virtual=0xffffffff90044000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
30: Virtual=0xffffffff90042000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
31: Virtual=0xffffffff90040000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
32: Virtual=0xffffffff9003e000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
33: Virtual=0xffffffff9003c000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
34: Virtual=0xffffffff9003a000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
35: Virtual=0xffffffff90038000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
36: Virtual=0xffffffff90036000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
37: Virtual=0xffffffff90034000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
38: Virtual=0xffffffff90032000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
39: Virtual=0xffffffff90030000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
40: Virtual=0xffffffff9002e000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
41: Virtual=0xffffffff9002c000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
42: Virtual=0xffffffff9002a000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
43: Virtual=0xffffffff90028000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
44: Virtual=0xffffffff90026000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
45: Virtual=0xffffffff90024000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
46: Virtual=0xffffffff90022000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
47: Virtual=0xffffffff90020000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
48: Virtual=0xffffffff9001e000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
49: Virtual=0xffffffff9001c000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
50: Virtual=0xffffffff9001a000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
51: Virtual=0xffffffff90018000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
52: Virtual=0xffffffff90016000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
53: Virtual=0xffffffff90014000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
54: Virtual=0xffffffff90012000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
55: Virtual=0xffffffff90010000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
56: Virtual=0xffffffff9000e000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
57: Virtual=0xffffffff9000c000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
58: Virtual=0xffffffff9000a000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
59: Virtual=0xffffffff90008000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
60: Virtual=0xffffffff90006000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
61: Virtual=0xffffffff90004000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
62: Virtual=0xffffffff90002000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
63: Virtual=0xffffffff90000000 Page0=0x00000000,C=0,D=0,V=0,G=0 Page1=0x00000000,C=0,D=0,V=0,G=0 ASID=  0 Size=4KB
</pre></div><h2><a class="anchor" id="octeon_remote_csr">
8. CSR Access (oct-remote-csr)</a></h2>
<p>OCTEON CSRs may be read or written directly from a remote host. The utility <b>oct-remote-csr</b> may be used to access any 64bit CSR available on OCTEON.</p>
<div class="fragment"><pre class="fragment">
Usage: ./oct-remote-csr CSR [value] [CSR [value] ...]
    Read or write a CSR by name.

    CSR     Name of CSR to read or write. Case is ignored.
    value   If present, write this value to the CSR. Otherwise do a read.
            The value can be in decimal of hex (0x...).

    If CSR is a partial name, the list of CSRs starting with it are displayed.
</pre></div><p>Here is an example of reading the CIU enable register for Core 0 interrupt line 2:</p>
<div class="fragment"><pre class="fragment">
$ ./oct-remote-csr CIU_INT0_EN0
CIU_INT0_EN0(0x0001070000000200) = 0x4100410300000000
  [   63] BOOTDMA              =          0 (0x0)
  [   62] MII                  =          1 (0x1)
  [   61] IPDPPTHR             =          0 (0x0)
  [   60] POWIQ                =          0 (0x0)
  [   59] TWSI2                =          0 (0x0)
  [58:57] RESERVED_57_58       =          0 (0x0)
  [   56] USB                  =          1 (0x1)
  [55:52] TIMER                =          0 (0x0)
  [   51] RESERVED_51_51       =          0 (0x0)
  [   50] IPD_DRP              =          0 (0x0)
  [   49] RESERVED_49_49       =          0 (0x0)
  [   48] GMX_DRP              =          0 (0x0)
  [   47] TRACE                =          0 (0x0)
  [   46] RML                  =          1 (0x1)
  [   45] TWSI                 =          0 (0x0)
  [   44] RESERVED_44_44       =          0 (0x0)
  [43:40] PCI_MSI              =          1 (0x1)
  [39:36] PCI_INT              =          0 (0x0)
  [35:34] UART                 =          0 (0x0)
  [33:32] MBOX                 =          3 (0x3)
  [31:16] GPIO                 =          0 (0x0)
  [15: 0] WORKQ                =          0 (0x0)
</pre></div><h2><a class="anchor" id="octeon_remote_ddr">
9. Quickly Test Memory (oct-remote-ddr)</a></h2>
<p>A very simple, and not thorough, memory test can be run remotely using oct-remote-ddr. This utility should only be used as a basic alive test. The DRAM controller on OCTEON must be already configured before this test can be run.</p>
<div class="fragment"><pre class="fragment">
$ oct-remote-ddr -h
OCTEON DDR2 memory test over a remote interface
Note: Requires use of oct-*-boot to configure memory controller
Usage:
    ./oct-remote-ddr  &lt;Mbytes to test&gt;
</pre></div><h2><a class="anchor" id="octeon_remote_load">
10. Loading Files into Memory (oct-remote-load)</a></h2>
<p>Any file may be loaded into OCTEON memory using the oct-remote-load utility. This utility makes a great alternative to Kermit or the compact flash for loading programs. The example below loads the passthrough example into OCTEON memory. The address of 0 causes the oct-remote-load utility to determine the address of memory reserved for loading by the bootloader and use that address for loading the file. A fixed (non 0) address may also be given.</p>
<p>For this command to work, stdin must include bootcmd. This will likely change in the future to requiring stdin to contain PCI. By default, both of these are enabled on boards that support it.</p>
<div class="fragment"><pre class="fragment">
    $ sudo oct-remote-load 0 passthrough
    Found OCTEON on bus 0 in slot 5. BAR0=0xf8000000, BAR1=0xf0000000
    $
</pre></div><p>At this point you can start passthrough with the bootloader command:</p>
<div class="fragment"><pre class="fragment">
    $ sudo oct-remote-bootcmd "bootoct 0 numcores=16"
</pre></div><h2><a class="anchor" id="octeon_remote_memory">
11. Read / Write a 64 bit Memory Location (oct-remote-memory)</a></h2>
<p>Read or write a single 64bit value from OCTEON's memory.</p>
<div class="fragment"><pre class="fragment">
$ ./oct-remote-memory
Usage: ./oct-remote-memory address [value]
    Read or write 8 bytes at a  memory address.

    address Address of memory to read or write.
    value   If present, write this value to the address. Otherwise do a read.
</pre></div><h2><a class="anchor" id="octeon_remote_pow">
12. Displaying OCTEON POW state (oct-remote-pow)</a></h2>
<p>The state of the OCTEON POW can be captured and displayed through the</p>
<p>remote interface. <b>oct-remote-pow</b> captures the state of all the input queues, de-schedue lists, no-schedule lists, the external memory queue pointers, and the complete state of each core. Without any arguments <b>oct-remote-pow</b> attempts to capture the state without disturbing the running system. This can cause the resulting capture state to be inconsistent due to changes while the capture was running. The <b>-s,--stop-cores</b> option tells the utility to temporarily stop the cores during the capture. By placing the OCTEON cores into debug mode the captured state is normally consistent for the time required to make the capture. Here is a list of the important items shown in the state capture:</p>
<ul>
<li>The POW internal freelist head and tail pointers</li>
<li>The tag state of each core including any pending tag switches and work requests. Each core also has the previous and next pointer for tags in ordered and atomic lists.</li>
<li>The queue head and tail pointers for each group's no-schedule list.</li>
<li>The queue head and tail pointers for each group's de-schedule list.</li>
<li>The queue head and tail pointers for each of the 8 input queues.</li>
<li>The queue head and tail pointers for each of the 8 input queue memory lists. Each input queue has two memory lists (a/b).</li>
<li>The current tag type, tag, group, work queue pointer, and next link pointer for every internal POW entry. Also each entry is marked with the queue it is currently in. Entries on the no-schedule and de-schedule lists also contain pending tag switch information.</li>
</ul>
<h2><a class="anchor" id="octeon_remote_reset">
14. Resetting OCTEON (oct-remote-reset)</a></h2>
<p>A soft reset of OCTEON can be performed remotely using the <b>oct-remote-reset</b> utility. Here is an example:</p>
<div class="fragment"><pre class="fragment">
    $ sudo oct-remote-reset
    Found Octeon on bus 0 in slot 5. BAR0=0xf8000000, BAR1=0xf0000000
    $
</pre></div><h2><a class="anchor" id="octeon_remote_save">
15. Saving Memory to a file (oct-remote-save)</a></h2>
<p>A contiguous region of DDR may be saved to a file using the oct-remote-save utility. The example below saves the low 8 Mbytes of DDR to a file.</p>
<div class="fragment"><pre class="fragment">
    $ sudo oct-remote-save 0x0 0x800000 low-mem.bin
    Found Octeon on bus 0 in slot 5. BAR0=0xf8000000, BAR1=0xf0000000
    $
</pre></div><h2><a class="anchor" id="octeon_remote_tra">
16. Tracing using the OCTEON Trace Buffer (oct-remote-tra)</a></h2>
<p>L2 transactions and CSR accesses can be traced using oct-remote-tra.</p>
<div class="fragment"><pre class="fragment">
$ ./oct-remote-tra -H

Cavium OCTEON TRA Analyzer

Usage:
    ./oct-remote-tra [options]

Supported Options:
    -h --help
    -H --long-help
    -f --filter=&lt;match&gt;
        Set the filter for the events to record. The default
        records nothing.
    -w --wrap
        Overwrite old samples when buffer overflows. When
        samples are written faster than we can read them, the
        new samples will overwrite old samples.
    -m --trig-mode=[none|start|stop|both]
        Set the mode of how triggers are used.
        none = Triggers are ignored. This is the default.
        start = Both triggers signal when TRA should start.
        stop = Both triggers signal when TRA should stop.
        both = Trigger 1 starts tracing, trigger 2 stops it.
    -0 --trig0=&lt;match&gt;
    -1 --trig1=&lt;match&gt;
    -d --mcd0
        Pulse MCD0 to stop cores when the TRA is full. This
        gives this program a change to catch up. Once the TRA
        buffer is emptied, the cores will be restarted.
    -o --output=name
        Write TRA output to binary file "name". This file can
        be read later using the "-i" option.
    -i --input=name
        Read from binary file "name" instead of the hardware.
        This should be used to read a file created with the "-o"
        option.
    -t --tra=&lt;No. of Trace Control Unit&gt;
        Enter the TRA no. to display the output from a specific
        TRA buffer.

&lt;match&gt;=&lt;commands&gt;,&lt;sources&gt;,&lt;destinations&gt;,&lt;address&gt;,&lt;mask&gt;
&lt;commands&gt; is a list of the following separated by '+':
    dwb, pl2, psl1, ldd, ldi, ldt, stc, stf, stp, stt, iobld8,
    iobld16, iobld32, iobld64, iobst, iobdma, or all
&lt;sources&gt; is a list of the following separated by '+':
    dwb, iobreq, pko, pki, pp0-pp15, or all
&lt;destinations&gt; is a list of the following separated by '+':
    pow, rng, zip, dfa, fpa, key, pci, mio, or all
&lt;address&gt; is a physical address to match
&lt;mask&gt; Each bits set is a bit that is checked in &lt;address&gt;

Brief description of the &lt;commands&gt;:
    dwb     - Don't-Write-Back: Clear the dirty bit in the L2
              tags if the cache block is present in the L2
              cache. This is an ADD-only transaction on the CMB.
    pl2     - Prefetch Into L2: The cache block will be put
              into the L2 cache. This is an ADD-only
              transaction on the CMB. These transactions are
              only issued by cores.
    psl1    - Data Cache Fill-Through: The cache block is filled
              from L2/DRAM. The block will be filled into the
              dcache of the requesting core. A subsequent store
              from another core or IOB will cause an invalidate.
              The block will not be put into the L2 cache. These
              transactions can only be issued by cores.
    ldd     - Data Cache Fill: The cache block is filled from
              L2/DRAM. The block will be filled into the dcache
              of the requesting core. A subsequent store from
              another core or IOB will cause an invalidate. The
              block is put into the L2 cache. These transactions
              can only be issued by cores.
    ldi     - Instruction Cache / IO Fill: The cache block is
              filled from L2/DRAM. The block is put into the L2
              cache. These transactions can be issued either by
              cores or by the IOB. A subsequent store from
              another core or IOB will NOT cause an invalidate.
    ldt     - Instruction Cache / IO Fill-Through: The cache
              block is filled from L2/DRAM. The block will not
              be put into the L2 cache. These transactions can
              be issued either by cores or by the IOB.
    stc     - Store-Conditional: Store to either 32 or 64-bits
              if the block is currently held in the data cache
              of the requesting core. If the block is in the
              data cache of the requesting core, the store
              happens and a commit indication is returned. All
              data cache copies of the block will be invalidated
              in the other cores. If the block is not in the
              data cache of the requesting core, a failure
              indication is returned, no invalidate occurs,
              neither does the store. The cache block will be
              put into the L2 cache. These transactions are
              only issued by cores.
    stf     - Store-Full: Store to all bytes in the cache block.
              The value of the bytes in the cache block that are
              not transferred on the STORE bus or are masked off
              will be written to zero. All data cache copies of
              the block will be invalidated, except for the data
              cache of an initiating core. The cache block will
              be put into the L2 cache. These transactions are
              issued either by cores or by the IOB.
    stp     - Store-Partial: Some of the bytes in the cache
              block will be stored. The value of the bytes in
              the cache block that are not transferred on the
              STORE bus or are masked off are not modified. All
              data cache copies of the block will be invalidated,
              except for the data cache of an initiating core.
              The cache block will be put into the L2 cache.
              These transactions are issued either by cores or
              by the IOB.
    stt     - Store-Through: Store to all bytes in the cache
              block. The value of the bytes in the cache block
              that are not transferred on the STORE bus or are
              masked off will be written to zero. All data cache
              copies of the block will be invalidated, except
              for the data cache of an initiating core. The
              cache block will not be put into the L2 cache.
              These transactions are only issued by the IOB.
    iobld8  - Load Reflection 8bit: An ADD cycle will be
              reflected onto the FILL bus. This is used for
              communication from the cores to the IOB. A load
              reflection transaction is generated by the cores
              to transfer a load to IOB.
    iobld16 - Load Reflection 16bit.
    iobld32 - Load Reflection 32bit.
    iobld64 - Load Reflection 64bit.
    iobst   - Store Reflection: Reflect an ADD cycle and
              corresponding STORE cycle(s) onto the FILL bus.
              This is used for core IOB communication. A store
              reflection transaction is generated by the cores
              to transfer a store/IOBDMA to IOB. An IOBDMA must
              have exactly 64 bits of (aligned) STORE data. A
              store may have 64, 32, 16, or 8 bits of aligned
              STORE data. These transactions are destined to
              IOB.
    iobdma  - A store reflection transaction is generated
              by the IOB to respond to a prior load/IOBDMA
              request from a core. A load response always
              contains exactly 64 bits of (aligned) STORE
              data. An individual IOBDMA response contains
              between one and sixteen 64 bit (aligned) words
              of data. These transactions are destined to a core.
    all     - All of the above commands added together.
Brief description of the &lt;sources&gt;:
    dwb     - Indicates a DWB from the DWB engine in IOB.
    iobreq  - Indicates a FPA, TIM, DFA, PCI, ZIP, or POW
              read/write, or a PKO write.
    pko     - Indicates a PKO read.
    pki     - Indicates a PIP/IPD write.
    pp0-pp15- Indicates a particular core.
    all     - All of the sources added together.
Brief description of the &lt;destinations&gt;:
    pow     - Indicates a destination of POW (get work, add
              work, status/memory/index loads, NULLRd loads,
              CSRs).
    rng     - Indicates a destination of RNG (loads/IOBDMAs).
    zip     - Indicates a destination of ZIP (doorbells).
    dfa     - Indicates a destination of DFA (CSR's, doorbells,
              and other operations).
    fpa     - Indicates a destination of FPA (free pool
              allocates / frees).
    key     - Indicates a destination of KEY (reads/writes).
    pci     - Indicates a destination of PCI (access to RSL-type
              CSRs from many CN38XX blocks, PCI bus operations,
              and PCI CSRs).
    mio     - Indicates a destination of CIU or GPIO (for CSRs).
    all     - Matches all destinations.
Examples:
    ./oct-remote-tra -f "ldi,all"
        Trace all Icache loads.
    ./oct-remote-tra -f "stc+stf+stp+stt,pp5+pp4,all"
        Trace all stores from Core 4 and 5.
    ./oct-remote-tra -f "stc+stf+stp+stt,all,all,0,0xffffffffffff0000"
        Trace all stores to the first 64KB of memory (exception vectors).
    ./oct-remote-tra -t 1,3 -f "ldi,all"
    Trace all Icache loads from cores traced by TRA units 1 and 3
</pre></div><h2><a class="anchor" id="pci_target_gdb">
17. Debugging using GDB</a></h2>
<p>For debugging an application over PCI, use the Simple Executive Debugger. This uses the oct-debug-agent to connect to the OCTEON board over PCI. This program is located in the host/debug-agent directory and depends on the host/remote-lib library like all other remote-utils applications. Once the application is built invoke the Simple Executive debugger as mentioned below:</p>
<div class="fragment"><pre class="fragment">
    $ mipsisa64-octeon-elf-gdb -q passthrough
    (Core#0-gdb) target octeonpci bootoct $(fileaddr) coremask=ffff
    Sending bootloader command:  bootoct $(fileaddr) coremask=ffff debug

    Listening on port: 44625
    Connected to peer: 127.0.0.1
    Remote target octeon connected to tcp::44625
    (Core#0-gdb)
</pre></div><p>The boot command should be passed as an argument to the target octeonpci command. Note that <b>debug</b> option is automatically added to the boot command by GDB. This will make the program enter into the debug exception handler.</p>
<p>After the target command you can insert breakpoints and continue debugging.</p>
<div class="fragment"><pre class="fragment">
    (Core#0-gdb) b main
    Breakpoint 1 at 0x10000290: file passthrough.c, line 379.
    (Core#0-gdb) set step-all on
    (Core#0-gdb) set active-cores
    (Core#0-gdb) c
    Continuing.

    Breakpoint 1, main () at passthrough.c:379
    379         cvmx_user_app_init();
    (Core#0-gdb)
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>Please refer to Simple Executive Debugger for the meaning of "set step-all on" and "set active-cores" commands.</dd></dl>
<p>These are the additional Cavium specific GDB commands that are supported only while debugging over PCI.</p>
<ul>
<li>show core-state: Displays the state of the core by dumping all the general purpose registers, COP0 registers and 32 TLB entries.</li>
</ul>
<ul>
<li>set/show pci-bootcmd: A shell command for booting over PCI. The default value is set is "oct-remote-reset". The "target octeonpci" command basically resets the board before loading the program. For the boards that don't have boot flash, one needs to load the bootloader after reset. Pass the bootloader needed for PCI boot through "pci-bootcmd" before invoking "target octeonpci" command.</li>
</ul>
<p>Here is an example on how to set pci-bootcmd.</p>
<div class="fragment"><pre class="fragment">
    $ mipsisa64-octeon-elf-gdb -q passthrough
    (Core#0-gdb) set pci-bootcmd oct-remote-boot
    (Core#0-gdb) target octeonpci bootoct $(fileaddr) coremask=ffff
    Found Octeon on bus 3 in slot 2. BAR0=0xe7fff000, BAR1=0xd8000000
    Using bootloader image: /home/creese/work/octsw/sdk/target/bin/u-boot-pciboot-ebt3000.bin
    Found Octeon on bus 3 in slot 2. BAR0=0xe7fff000, BAR1=0xd8000000

    Sending bootloader command: bootoct $(fileaddr) coremask=ffff debug

    0x10000018 in _init ()
    (Core#0-gdb)
</pre></div><p>You can also attach to a program that is already running on the board by invoking the target octeonpci command with no arguments. After the target command the cores are stopped.</p>
<div class="fragment"><pre class="fragment">
    $ mipsisa64-octeon-elf-gdb -q passthrough
    (Core#0-gdb) target octeonpci
    Found Octeon on bus 3 in slot 2. BAR0=0xe7fff000, BAR1=0xd8000000
    (Core#0-gdb) bt
    #0  main () at /home/anemet/octsw/sdk/target/include/cvmx-pow.h:360
</pre></div><p>The detach command or exiting GDB resumes execution of the program.</p>
<p>You can use a different remote protocol by changing how the target command is used. Example: </p>
<div class="fragment"><pre class="fragment">
    $ mipsisa64-octeon-elf-gdb -q passthrough
    (Core#0-gdb) target octeon LINUX
</pre></div><p>You can invoke oct-debug-agent manually to be able to debug oct-debug-agent or be able to run the debugger on another computer. Example: </p>
<div class="fragment"><pre class="fragment">
    $ oct-debug-agent ./passthrough -q --target PCI --listen 38026 --pci-bootcmd oct-pci-boot -- bootoct 0 coremask=ffff
</pre></div><div class="fragment"><pre class="fragment">
Usage: oct-debug-agent &lt;exec_file&gt; &lt;option(s)&gt; [&lt;boot commands&gt;]

 Listen on &lt;port&gt; for incoming connection fro GDB and perform the
 corresponding operation over the &lt;comm&gt; debug interface.

 Possible values for &lt;option(s)&gt; are:
  -l, --listen &lt;num&gt;  Port number to listen for GDB connection
  -t, --target &lt; targetstr &gt; (Required)
  -d, --debug         Print debug messages during execution
  -b, --pci-bootcmd &lt;exec&gt;  Set boot command needed for PCI booting
  -q, --quiet         Quiet during execution
  -h, --help          Display help message
</pre></div><h2><a class="anchor" id="oct-remote-app-ctl">
18. Remote controlling hotplugable SE applications.</a></h2>
<div class="fragment"><pre class="fragment">
    This utility is used for start/add_cores/delete_cores/shutdown hotplugable
    SE applications running on Octeon PCIe connected (LiquidIO) card(s) from x86
    HOST computer. Its CLI is same as the 'oct-app-ctl' utility CLI present in
    Linux rpm, which can run in Octeon Linux user space on one of the Octeon CPU
    cores on LiquidIO card. However this utility was specially designed per
    customer request in order to free all available Octeon CPU cores for runiing
    data-plane applications. The following lines come from oct-app-ctl README.txt
    file and are valid for both oct-app-ctl and oct-remote-app-ctl utilities.

    The utility supports 5 basic operations which are described below.
    The specific operation may be either specified in the first argument.

STARTING APPS
    - # oct-app-ctl boot &lt;options&gt; &lt;app_file_name&gt; [&lt;app_arguments&gt;]

    &lt;options&gt; are optional, and include these options:

    -verbose=&lt;num&gt;	Increase verbosity level of the program up to the value of 3
			Default is 0.(LiquidIO)
    -numcores=&lt;N&gt;	The number of CPU cores to start the application on.
			Default is 1.
    -mask=&lt;hex-number&gt;	The coremask of CPUs that the application should be started on.
    -heapsize=&lt;bytes&gt;	Set the size of the heap memory allocated per CPU core.
			Default is 3 Megabytes.
    -stacksize=&lt;bytes&gt;	Set the size of the stack memory allocated per CPU cure.
			Default is 1 Megabytes.

NOTES:
    Any SE application can be started this way, whether it supports
    hot-plugging or not, but the remaining operations require the support of
    hot-plugging in the application.  The core-mask argument only supports up
    to 64 cores, and should be abandoned in favour of the -numcores argument.
    If the core-mask argument is specified is contains cores that are not
    presently available, the unavailable cores will be replaced with the
    same number of available cores to at least satisfy the core count in
    the requested mask, if possible.

DISPLAYING STATUS

    -# oct-app-ctl info

    The information displayed indicates which SE applications are currently
    running on which cores. It does not specify which cores are being
    currently used by Linux itself. In order to control and display the
    CPU cores running Linux please refer to the Linux CPU hot-plugging
    documentation.

    The "Active" core mask indicates which applications are capable of
    supporting hot-plugging, which is required for the following operations.

    The first column displays an index for every instance of an application,
    which is useful for performing any of the remaining operations on
    a specific instance of an applications, should there be multiple
    applications started from the same executable file and thus having the
    same name.

    The last item displayed by this operation is the coremask of the CPU
    coremask that are presently not utilized, and are thus available for
    starting new applications, or adding into existing ones.

SHUTTING DOWN APPLICATIONS

    -# oct-app-ctl shutdown &lt;options&gt; {-index=&lt;app-index&gt; | &lt;app-name&gt;}

    &lt;options&gt; are optional, and include these options:

    -verbose=&lt;num&gt;	Increase verbosity level of the program up to
			the value of 3. Default is 0.

    This operation will shut down a running application on all the CPU cores
    it runs.

    The above operation as well as all the subsequently described operations
    only work if the application supports hot-plugging, and has installed
    call-back routines to be notified of the request of relinquishing or add
    resources. Please see the example program in "sdk/examples/hotplug_app"
    for additional information.

    The application effected must be identified either by its name, which is
    identical to the name of the executable object file that was used to start
    the application, or by means of the application instance index number.

    Note that the executable file needs not be present in the current
    (or any other) directory for this operation to succeed, as it is not
    accessed for any operation other than the "boot" operation.

ADDING CORES TO AN APPLICATIONS

    - # oct-app-ctl add &lt;options&gt; {-index= &lt;app-index&gt; | &lt;app-name&gt;}

    &lt;options&gt; are optional, and include these options:

    -verbose=&lt;num&gt;	Increase verbosity level of the program up to
			the value of 3. Default is 0.
    -numcores=&lt;N&gt;	The number of CPU cores to start the application on.
			Default is 1.
    -mask=&lt;hex-number&gt;	The coremask of CPUs that the application should be
			started on.

NOTES:
    The core-mask argument only supports up to 64 cores, and should be abandoned
    in favour of the -numcores argument.

    If the core-mask argument is specified is contains cores that are not
    presently available, the unavailable cores will be replaced with the
    same number of available cores to at least satisfy the core count in
    the requested mask, if possible.

DELETING CORES FROM AN APPLICATIONS

    -# oct-app-ctl del &lt;options&gt; {-index= &lt;app-index&gt; | &lt;app-name&gt;}

    &lt;options&gt; are optional, and include these options:

    -verbose=&lt;num&gt;	Increase verbosity level of the program up to
			the value of 3. Default is 0.
    -numcores=&lt;N&gt;	The number of CPU cores to relinquish. Default is 1.
    -mask=&lt;hex-number&gt;	The coremask of CPUs that should be stopped.

NOTES:
    This operation will refuse to delete the initial core running
    the application, which is the lowest-numbered core that the application
    was initially started on. All other cores, which could be numerically
    lower than the initial core of these where added subsequently to starting
    the application with the aforementioned "add" operation, can be deleted.

    If a core-mask is specified in the command line, but it includes some
    cores that are not running said application instance, or if the mask
    specifies the initial core, the actual mask will be modified to stop
    the same number of cores as requested in the mask, if possible.

LIMITATIONS:

    The utility has only been tested with big-endian executables host,
    and does not presently support little-endian variants of either.

USE CASES

    There are many use cases for controlling stand-alone SE applications
    from x86 HOST. One such case is LiquidIO customer request for 'live update',
    where currently running data-plane SE application could be replaced
    dynamically (delete_cores/shutdown the current SE app and boot/add_cores to
    another SE app on the same core(s)) with its next improved version.
    There is a shell script (burn_hp.sh) demonstarting this feature, which also
    is used for testing.
    In the most simple case, it allows packaging the entire
    application, including control and data plane in a single embedded
    root file system, or enabling a "live" upgrade of the data-plane
    portion wuthout rebooting the control plane.

    Other use cases include the dynamic load balancing where the number
    of CPU cores can be shiften between data-plane SE application to match
    changing load patterns dynamically.
</pre></div> </div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Oct 2017 for Octeon Software Development Kit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
