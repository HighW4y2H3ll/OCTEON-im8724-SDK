<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Octeon Software Development Kit: OCTEON as a PCI host</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="pci_host">OCTEON as a PCI host </a></h1><h2><a class="anchor" id="pci_host_intro">
1. Introduction</a></h2>
<p>PCI host mode refers to when OCTEON is configured as the PCI bus arbiter controlling access to other devices. In this mode, OCTEON most closely resembles a desktop PC or a rack mount server. This document provides detailed information on the following aspects of OCTEON as a PCI host:</p>
<ul>
<li><a class="el" href="pci_host.html#pci_host_intro">1. Introduction</a></li>
<li><a class="el" href="pci_host.html#pci_host_hw_coverage">2. Hardware Coverage of this Document</a></li>
<li><a class="el" href="pci_host.html#pci_host_32bit">3. 32bit PCI Device Limitations</a></li>
<li><a class="el" href="pci_host.html#pci_host_reset">4. PCI Host Bus Reset and Initialization</a></li>
<li><a class="el" href="pci_host.html#pci_host_config_space">5. PCI config space addressing</a></li>
<li><a class="el" href="pci_host.html#pci_host_io_space">6. PCI port IO addressing</a></li>
<li><a class="el" href="pci_host.html#pci_host_memory_space">7. PCI memory IO addressing</a></li>
<li><a class="el" href="pci_host.html#pci_host_dma">8. DMA Memory Coherency</a></li>
<li><a class="el" href="pci_host.html#pci_host_interrupts">9. PCI Interrupts</a></li>
<li><a class="el" href="pci_host.html#pci_host_linux_config">10. Configuring Linux for PCI Host</a></li>
<li><a class="el" href="pci_host.html#pci_host_tested_drivers">11. Tested Linux Device Drivers</a></li>
</ul>
<h2><a class="anchor" id="pci_host_hw_coverage">
2. Hardware Coverage of this Document</a></h2>
<p>This document does not cover all of the modes and registers available for the OCTEON PCI block. Only the most common setup used for host mode is described. For a complete PCI block reference, refer to the <b>OCTEON Hardware Manual</b>.</p>
<h2><a class="anchor" id="pci_host_32bit">
3. 32bit PCI Device Limitations</a></h2>
<p>Most PCI devices implement 32bit memory addressing and don't support full 64bit accesses. This greatly constrains the address space available to OCTEON. Normally OCTEON can map devices to any 64bit address, but 32bit addresses must be mapped below 4GB. Adding this limitation to the fact that all BAR registers must not overlap (including OCTEON's), limits memory accesses to OCTEON through BAR1 only. BAR1 covers a 128MB range, divided into 32 4MB entries. Each entry may be mapped to an arbitrary OCTEON memory address. By convention, memory mapped through BAR1 is visible to PCI devices as the lower 128MB address region.</p>
<ol type="1">
<li>OCTEON's BAR2 can't be used by 32bit devices. Since BAR2 is 39bits wide, it overlaps with all possible 32bit addresses when mapped at 0. The next possible mapping (1&lt;&lt;39) is outside of the 32bit address region.</li>
<li>BAR1 entries are dynamically allocated as needed by calls to dma_map_single(). Overlapping regions are merged. If more than 32 regions are needed, the kernel will panic.</li>
<li>64bit devices can use OCTEON's BAR2 to access all of memory. BAR2 must be mapped outside of the 32bit region.</li>
</ol>
<h2><a class="anchor" id="pci_host_reset">
4. PCI Host Bus Reset and Initialization</a></h2>
<p>The recommended host mode PCI reset and initialization sequence requires quite a few register setups and strict timing constraints. Refer to <b>linux/kernel/linux/arch/mips/cavium-octeon/pci.c</b> for the exact code for PCI initialization. Below are the general steps for reference, but please use <b>pci.c</b> as the definitive reference.</p>
<ol type="1">
<li>Reset the bus using CIU_SOFT_PRST</li>
<li>Delay for 2ms</li>
<li>Set the max write combining to 1 using NPI_CTL_STATUS</li>
<li>Deassert PCI reset and advertize PCX Host Mode Device Capability</li>
<li>Wait 2 ms after deasserting PCI reset</li>
<li>Setup NPI_PCI_CTL_STATUS_2</li>
<li>Wait 2 ms before doing PCI reads</li>
<li>Read NPI_PCI_CTL_STATUS_2 to determine the PCI mode (64/32, PCI-X/PCI)</li>
<li>Setup NPI_PCI_CFG01<ol type="a">
<li>Memory Space Access Enable</li>
<li>Master Enable</li>
<li>PERR# Enable</li>
<li>System Error Enable</li>
<li>Fast Back to Back Transaction Enable</li>
</ol>
</li>
<li>Enable the internal arbiter using NPI_PCI_INT_ARB_CFG</li>
<li>Disable the Master Latency Timer using NPI_PCI_CFG16</li>
<li>Setup NPI_PCI_CFG22<ol type="a">
<li>Master Retry Value [1..255] and 0=infinite</li>
<li>AM_DO_FLUSH_I control</li>
</ol>
</li>
<li>Setup NPI_PCI_CFG56<ol type="a">
<li>Data Parity Error Recovery Enable</li>
<li>Relaxed Ordering Enable</li>
<li>Maximum Memory Byte Count 1024B</li>
<li>Maximum outstanding Split transactions to 3</li>
</ol>
</li>
<li>Setup OCTEON BARs for best performance<ol type="a">
<li>NPI_PCI_READ_CMD_6 = 0x22</li>
<li>NPI_PCI_READ_CMD_C = 0x33</li>
<li>NPI_PCI_READ_CMD_E = 0x33</li>
</ol>
</li>
<li>Setup PCI memory accesses from OCTEON using NPI_MEM_ACCESS_SUBID3<ol type="a">
<li>Endian-Swap on read.</li>
<li>Endian-Swap on write.</li>
<li>No-Snoop on read.</li>
<li>No-Snoop on write.</li>
<li>Relax Read on read.</li>
<li>Relax Order on write.</li>
</ol>
</li>
<li>Remap the OCTEON BAR 0 to disable it.</li>
<li>Remap the OCTEON BAR 1 to map 0-128MB<ol type="a">
<li>Put in L2 cache.</li>
<li>Byte swapping</li>
</ol>
</li>
<li>Remap the OCTEON BAR 2 to disable it.</li>
</ol>
<h2><a class="anchor" id="pci_host_config_space">
5. PCI config space addressing</a></h2>
<p>PCI configuration space is accessed through OCTEON DID 3, SUBDID 1. The recommended method of referencing PCI configuration space is by constructing an OCTEON IO space address from the needed bus, device, function, and register. The following structure defines the format for the IO address.</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">typedef</span> <span class="keyword">union</span>
    {
        uint64_t    u64;
        uint64_t *  u64_ptr;
        uint32_t *  u32_ptr;
        uint16_t *  u16_ptr;
        uint8_t *   u8_ptr;
        <span class="keyword">struct</span>
        {
            uint64_t    upper       : 2;
            uint64_t    reserved    : 13;
            uint64_t    io          : 1;
            uint64_t    did         : 5;
            uint64_t    subdid      : 3;
            uint64_t    reserved2   : 4;
            uint64_t    endian_swap : 2;
            uint64_t    reserved3   : 10;
            uint64_t    bus         : 8;
            uint64_t    dev         : 5;
            uint64_t    func        : 3;
            uint64_t    reg         : 8;
        } <a class="code" href="cvmx-coremask_8c.html#a7cc33a7fd56e1ab82f778fe3f0e88c25">s</a>;
    } octeon_pci_address_t;
</pre></div><p>To access a PCI device, set the fields of the address: </p>
<div class="fragment"><pre class="fragment">    octeon_pci_address_t pci_addr;
    pci_addr.u64 = 0;
    pci_addr.s.upper = 2;
    pci_addr.s.io = 1;
    pci_addr.s.did = 3;
    pci_addr.s.subdid = 1;
    pci_addr.s.endian_swap = 1;
    pci_addr.s.bus = bus_number;
    pci_addr.s.dev = device;
    pci_addr.s.func = function;
    pci_addr.s.reg = <span class="keyword">register</span>;
</pre></div><p>A read or write can then be performed using the *_ptr union members.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>PCI configuration space is in little endian format. All accesses need to be byte swapped before a store and after a load.</dd></dl>
<h2><a class="anchor" id="pci_host_io_space">
6. PCI port IO addressing</a></h2>
<p>All PCI IO port addressing is based at 0x00011a0400000000. To reference a PCI IO at 0x1234, you must read and write to 0x00011a0400001234.</p>
<h3><a class="anchor" id="pci_host_io_space_1">
Endian swapping</a></h3>
<p>OCTEON supports multiple swapping modes across the PCI bus. For host mode development, only mode 1 is useful.</p>
<h3><a class="anchor" id="pci_host_io_space_2">
Legacy ISA Devices</a></h3>
<p>Legacy PC devices, such as floppy controllers and CMOS RTCs, use IO ports below 0x1000. These ports are treated special by PCI bridges. In PCI bridge poweron defaults, these ports are normally blocked completely. If your board has a legacy PC device, such as a south bridge or video card behind a PCI bridge, the bridge must be specially configured. The bridge must be configured to pass all IO addresses 0x0 to 0x1000 without any alias filtering. This is done in the Linux kernel for Intel and PLX bridge chips. This must be changed if your board uses multiple bridge chips or a different brand. The code for this can be found in <b>pci_chips.c</b>.</p>
<p>Here is configuration changes made by Linux:</p>
<ol type="1">
<li>2 bytes at PCI config space 0x3e<ol type="a">
<li>Disable bit 2, ISA port filtering</li>
<li>Enable bit 3, VGA</li>
<li>Enable bit 4, VGA Alias Filter</li>
</ol>
</li>
<li>1 byte at PCI config space 0x1c and 0x30 to set the IO base to 0</li>
</ol>
<h4><a class="anchor" id="pci_host_io_space_3">
VIA South Bridge</a></h4>
<p>The Via 686 series of south bridges, common on OCTEON motherboards, have an IO address limitation. These devices require that the IO ports be below 0x10000 for the PCI devices embedded in the chip. The recommended way of doing this is to start allocation IO ports at 0x4000. Keep in mind there are ISA emulated devices using the port number below 0x1000 inside these chips.</p>
<h2><a class="anchor" id="pci_host_memory_space">
7. PCI memory IO addressing</a></h2>
<p>OCTEON's PCI controller uses did=3, subdid=3,4,5 for PCI memory. In normal usage a single subdid is enough for all devices (0x00011b0000000000). It is important the PCI devices don't overlap with the OCTEON BAR registers. It is recommended that PCI devices start at 0x8000000, right after the 0-128MB BAR1 mapping.</p>
<h3><a class="anchor" id="pci_host_memory_space_1">
Endian swapping</a></h3>
<p>OCTEON supports multiple swapping modes across the PCI bus. For host mode development, only mode 1 is useful.</p>
<h3><a class="anchor" id="pci_host_memory_space_2">
OCTEON BAR setup</a></h3>
<p>The following code sets the OCTEON BAR registers in the recommended setup for PCI host mode.</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">typedef</span> <span class="keyword">union</span>
    {
        uint32_t u32;
        <span class="keyword">struct</span>
        {
            uint64_t reserved                : 14;      <span class="comment">// Reserved</span>
            uint64_t addr_idx                : 14;      <span class="comment">// Address bits [35:22] sent to L2C</span>
            uint64_t ca                      : 1;       <span class="comment">// Set &apos;1&apos; when access is to be cached in L2.</span>
            uint64_t end_swp                 : 2;       <span class="comment">// Endian Swap Mode</span>
            uint64_t addr_v                  : 1;       <span class="comment">// Set &apos;1&apos; when the selected address range is valid.</span>
        } <a class="code" href="cvmx-coremask_8c.html#a7cc33a7fd56e1ab82f778fe3f0e88c25">s</a>;
    } octeon_pci_bar1_indexx_t;

    <span class="comment">// Write a 32bit value to the OCTEON NPI register space</span>
    <span class="keyword">static</span> <span class="keywordtype">void</span> npi_write32(uint64_t address, uint32_t val)
    {
        <span class="keyword">volatile</span> uint32_t *ptr = (<span class="keyword">volatile</span> uint32_t *)(address ^ 4);
        *ptr = val;
    }


    <span class="comment">// Read a 32bit value from the OCTEON NPI register space</span>
    <span class="keyword">static</span> uint32_t npi_read32(uint64_t address)
    {
        <span class="keyword">volatile</span> uint32_t *ptr = (<span class="keyword">volatile</span> uint32_t *)(address ^ 4);
        <span class="keywordflow">return</span> *ptr;
    }

    <span class="comment">// Remap the OCTEON BAR 0 to disable it. We&apos;ll map to to the highest possible address</span>
    npi_write32(OCTEON_NPI_PCI_CFG04, 0xffffffff);
    npi_write32(OCTEON_NPI_PCI_CFG05, 0xffffffff);

    <span class="comment">// Remap the OCTEON BAR 1 to map 0-128MB</span>
    octeon_pci_bar1_indexx_t bar1_index;
    <span class="keywordtype">int</span> index;
    bar1_index.u32 = 0;
    bar1_index.s.ca = 1;            <span class="comment">// 1 = Put in L2 cache</span>
    bar1_index.s.end_swp = 1;       <span class="comment">// 1 = Byte swapping</span>
    bar1_index.s.addr_v = 1;        <span class="comment">// This entry is valid</span>
    <span class="keywordflow">for</span> (index=0; index&lt;32; index++)
    {
        bar1_index.s.addr_idx = index;
        npi_write32(OCTEON_NPI_PCI_BAR1_INDEXX(index), bar1_index.u32);
    }
    npi_write32(OCTEON_NPI_PCI_CFG06, 0);
    npi_write32(OCTEON_NPI_PCI_CFG07, 0);

    <span class="comment">// Remap the OCTEON BAR 2 to disable it. We&apos;ll map to to the highest possible address</span>
    npi_write32(OCTEON_NPI_PCI_CFG08, 0xffffffff);
    npi_write32(OCTEON_NPI_PCI_CFG09, 0xffffffff);
</pre></div><h2><a class="anchor" id="pci_host_dma">
8. DMA Memory Coherency</a></h2>
<p>PCI DMA accesses go through the OCTEON's L2 cache just like any other memory access. The L2 performs all core invalidates necessary to make sure memory is always coherent. This means that drivers don't need to worry about cache coherency.</p>
<h2><a class="anchor" id="pci_host_interrupts">
9. PCI Interrupts</a></h2>
<p>The PCI INT-A,B,C,D interrupt lines route to CIU_INTX_EN0 bits 36-39. The status of these lines can be monitored using CIU_INTX_SUM0. Depending on the setup of CIU_INTX_EN0, these will be routed to Mips interrupt 2 or 3. Under Linux, these are always mapped to Mips interrupt 2, which is then decoded into Linux IRQ 44-47 based on the status of CIU_INTX_SUM0.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>PCI interrupts are <b>level triggered active low</b>. Don't connect active high or edge triggered devices to the PCI interrupts. Use GPIO pins for these devices.</dd></dl>
<h3><a class="anchor" id="pci_host_interrupts_1">
Interrupt routing</a></h3>
<p>To determine the interrupt line used for each device, you must consult with the board schematic. Unfortunately most designers do not follow the PCI spec guidelines for choosing interrupt lines. This means the only way to determine where each interrupt line goes is through the board schematic. This board specific setup is performed for Linux in <b>pcibios_map_irq</b> and <b>octeon_get_pci_interrupts</b> (linux/kernel/linux/arch/mips/cavium-octeon/{pci.c, hal.c}).</p>
<h3><a class="anchor" id="pci_host_interrupts_2">
GPIO Interrupts</a></h3>
<p>The GPIO pins should be used for interrupts from any devices that do not follow the PCI specification for interrupt generation. Each GPIO pin can be independently configured for edge / level triggered as well as active high/low. In addition, these pins have configurable debouce logic per pin. It is recommended that devices be hooked to GPIO 15, then 14, and so on. This allows boards to work properly with OCTEON Pass 1 as well as newer chips.</p>
<h3><a class="anchor" id="pci_host_interrupts_3">
VIA South Bridge Interrupts</a></h3>
<p>The Via 686 series of south bridges are designed to be directly connected to x86 processors. These devices do not create standard PCI interrupts. <b>The 686 interrupts are active high</b>. This interrupt line must be connected to an OCTEON GPIO register, preferably GPIO15. Inside the 686 chip, the original PC 8259 dual interrupt controllers is emulated. In order for interrupts from the 686 chip to work, both the master and slave 8259s must be programmed. Refer to <b>linux/arch/mips/cavium-octeon/i8259.c</b> for details.</p>
<h3><a class="anchor" id="pci_host_interrupts_4">
Interrupt Affinity</a></h3>
<p>Interrupts are normally handled by the cpu that loads the driver. This is normally cpu 0. This can be changed through the <b>/proc/irq</b> interface. Writing a cpumask to <b>/proc/irq/#/smp_affinity</b> will route an interrupt to the cores in the mask.</p>
<p>For example, lets say this is what "cat /proc/interrupts" shows: </p>
<div class="fragment"><pre class="fragment">
                  CPU00      CPU01
          3:        215        277          Octeon  IPC
          7:     404782     404029          Octeon  timer, Perfcounter
         23:      15242      15203          Octeon  Ethernet
         42:          0        143          Octeon  serial
         45:     987869          0          Octeon  eth0
         54:          0          0          Octeon  ECC
         64:          0          0          Octeon  dwc_otg, dwc_otg_pcd, dwc_otg_hcd:usb1
</pre></div><p>To switch the interrupts for eth0 to the second core: </p>
<div class="fragment"><pre class="fragment">
        echo 2 &gt; /proc/irq/45/smp_affinity
</pre></div><p>To have both cores process the interrupt: </p>
<div class="fragment"><pre class="fragment">
        echo 3 &gt; /proc/irq/45/smp_affinity
</pre></div><h2><a class="anchor" id="pci_host_linux_config">
10. Configuring Linux for PCI Host</a></h2>
<p>Linux uses the bootloader flag CVMX_BOOTINFO_CFG_FLAG_PCI_HOST to determine if the board supports PCI in host mode. If this bit is set in the config_flags field, PCI is setup and enumerated. If it isn't set, Linux doesn't configure PCI.</p>
<h2><a class="anchor" id="pci_host_tested_drivers">
11. Tested Linux Device Drivers</a></h2>
<p>The following Linux device drivers are known to work with OCTEON in host mode. Many other drivers should work without modification, but only these have been tested so far.</p>
<ul>
<li>Via Rhine II 100Mbps Ethernet</li>
<li>Realtech 8139D 100Mbps Ethernet</li>
<li>NEC D720100 USB 2.0</li>
<li>Intel E1000 1Gbps Ethernet (Wired and Fiber)</li>
<li>CMD640 Parallel IDE Controller</li>
<li>Silicon Motion SATA controller</li>
<li>AirLink AWILL3026/NA USB 802.11b/g</li>
<li>USB Mass storage devices </li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Oct 2017 for Octeon Software Development Kit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
