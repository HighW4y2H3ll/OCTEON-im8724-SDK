<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Octeon Software Development Kit: 1588 Precision Time Protocol</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="ptp">1588 Precision Time Protocol </a></h1><h2><a class="anchor" id="ptp_intro">
1. Introduction</a></h2>
<p>The Cavium Inc. implementation of the IEEE1588 specification for Precision Time Protocol (PTP) supports all OCTEON models. The implementation uses hardware timestamps available in OCTEON II for better accuracy, or reverts to software timestamps on OCTEON and OCTEON Plus chips. Throughout this document and the source code, the IEEE1588 specifications are called out to help reference where concepts and data are directly dictated by the specification. These generally refer to a specific section number in the IEEE specification.</p>
<ul>
<li><a class="el" href="ptp.html#ptp_intro">1. Introduction</a></li>
<li><a class="el" href="ptp.html#ptp_version">2. Protocol Versions</a></li>
<li><a class="el" href="ptp.html#ptp_version2">3. PTPv2 - IEEE 1588-2008</a><ul>
<li><a class="el" href="ptp.html#ptp_sync">3.1. Synchronization Model</a></li>
<li><a class="el" href="ptp.html#ptp_unicast">3.2. Unicast versus Multicast Messages</a></li>
<li><a class="el" href="ptp.html#ptp_management">3.3. Supported 1588v2 Signalling and Management Messages</a></li>
<li><a class="el" href="ptp.html#ptp_accuracy">3.4. Accuracy</a></li>
<li><a class="el" href="ptp.html#ptp_usage">3.5. System Integration and Usage</a></li>
<li><a class="el" href="ptp.html#ptp_daemon">3.6. ptp-1588v2, the Linux userspace Daemon</a></li>
</ul>
</li>
<li><a class="el" href="ptp.html#ptp_version1">4. PTPv1 - IEEE 1588-2004</a></li>
</ul>
<h2><a class="anchor" id="ptp_version">
2. Protocol Versions</a></h2>
<p>The IEEE 1588 specification has two major versions, 2004 and 2008. The version from 2004 is commonly referred to as PTPv1, while 2008 is referred to as PTPv2. Unfortunately the two standards do not interoperate directly, so most systems choose only one for use in a complete synchronization system. PTPv2 defines an optional translation compatibility for allowing PTPv1 clocks to synchronize with PTPv2 clocks in IEEE1588-2008 section 18. Cavium Inc. implementation of the two standards can be found in <a class="el" href="ptp.html#ptp_version2">3. PTPv2 - IEEE 1588-2008</a> and <a class="el" href="ptp.html#ptp_version1">4. PTPv1 - IEEE 1588-2004</a>.</p>
<h2><a class="anchor" id="ptp_version2">
3. PTPv2 - IEEE 1588-2008</a></h2>
<p>Sections from the specification that are implemented:</p>
<ul>
<li>Sections 1-4 - Informative only</li>
<li>Section 5 - Data types and on-the-wire formats in a PTP system.</li>
<li>Section 6 - Clock synchronization model<ul>
<li>Sections 6.1 through 6.4</li>
<li>Section 6.5.1 - General</li>
<li>Section 6.5.2 - Ordinary clocks</li>
<li>Section 6.5.3 - Boundary clocks</li>
<li>Section 6.5.6 - Management nodes</li>
<li>Sections 6.6 and 6.7</li>
</ul>
</li>
<li>Section 7 - Characterization of PTP entities</li>
<li>Section 8 - PTP data sets<ul>
<li>Section 8.1 - General specifications for data set members</li>
<li>Section 8.2 - Data sets for ordinary and boundary clocks</li>
</ul>
</li>
<li>Section 9 - PTP for ordinary and boundary clocks.</li>
<li>Section 11 - Clock offset, path delay, residence time, and asymmetry corrections.</li>
<li>Section 12 - Synchronization and syntonization of clocks.</li>
<li>Section 13 - PTP message formats.</li>
<li>Section 14 - TLV entity specifications</li>
<li>Section 15 - Management</li>
<li>Section 16 - General optional features<ul>
<li>Section 16.1 - Unicast message negotiation.</li>
<li>Section 16.2 - Path trace.</li>
</ul>
</li>
<li>Section 17 - State configuration options.</li>
<li>Annex D - Transport of PTP over User Datagram Protocol over Internet Protocol Version 4</li>
<li>Annex E - Transport of PTP over User Datagram Protocol over Internet Protocol Version 6</li>
<li>Annex F - Transport of PTP over IEEE 802.3 / Ethernet.</li>
</ul>
<p>Optional Features from IEEE1588-2008 that are not supported:</p>
<ul>
<li>Section 6 - Clock synchronization model<ul>
<li>Section 6.5.4 - End-to-end transparent clocks</li>
<li>Section 6.5.5 - Peer-to-peer transparent clocks</li>
</ul>
</li>
<li>Section 8 - PTP data sets<ul>
<li>Section 8.3 - Data sets for transparent clocks</li>
</ul>
</li>
<li>Section 10 - PTP for transparent clocks</li>
<li>Section 16 - General optional features<ul>
<li>Section 16.3 - Alternate timescales.</li>
</ul>
</li>
<li>Section 18 - Compatibility requirements.</li>
<li>Section 19 - Conformance</li>
<li>Annex A-C - Informative only</li>
<li>Annex G-J</li>
<li>Annex K-M - Informative only</li>
</ul>
<h3><a class="anchor" id="ptp_sync">
3.1. Synchronization Model</a></h3>
<p>In order to synchronize a slave clock with a master, three calculations must be performed to characterize the differences between the two clocks. First the network delay between the clocks must be measured. Second the slave must calculate its clock tick rate in comparison to the master. Finally the slave must measure its clock's time with respect to the absolute value of the master clock. Each of these calculations is covered in the following sections.</p>
<h4><a class="anchor" id="ptp_sync_delay">
3.1.1 Delay Calculation</a></h4>
<p>PTPv2 defines two possible methods of measuring the delay between the slave and master clocks.</p>
<ul>
<li>IEEE1588-2008 section 11.3 defines the delay request-response mechanism.</li>
<li>IEEE1588-2008 section 11.4 defines the peer delay request-response mechanism.</li>
</ul>
<table align="center" cellspacing="0" cellpadding="1" border="1">
<tr>
<th><p>Delay Mechanism</p>
</th><th><p>Peer Delay Mechanism </p>
</th></tr>
<tr>
<td><div align="center">
<img src="inline_dotgraph_22.dot.png" alt="inline_dotgraph_22.dot" border="0" usemap="#inline_dotgraph_22.dot.map">
<map name="inline_dotgraph_22.dot.map" id="inline_dotgraph_22.dot.map"></map>
</div>
 </td><td><div align="center">
<img src="inline_dotgraph_23.dot.png" alt="inline_dotgraph_23.dot" border="0" usemap="#inline_dotgraph_23.dot.map">
<map name="inline_dotgraph_23.dot.map" id="inline_dotgraph_23.dot.map"></map>
</div>
  </td></tr>
</table>
<p>When using the delay mechanism:</p>
<ul>
<li>t1 = Time the master sent a sync message (Master clock)</li>
<li>t2 = Time the slave received the sync message (Slave clock)</li>
<li>t3 = Time the slave sent a delay request (Slave clock)</li>
<li>t4 = Time the master received the delay request (Master clock)</li>
<li>Slave learns t1 from the follow up message</li>
<li>Slave learns t4 from the delay response</li>
<li>meanPathDelay = ((t4 - t1) - (t3 - t2)) / 2</li>
</ul>
<p>When using the peer delay mechanism:</p>
<ul>
<li>t1 = Time the slave sent a peer delay request (Slave clock)</li>
<li>t2 = Time the master received the peer delay request (Master clock)</li>
<li>t3 = Time the master sent the peer delay response (Master clock)</li>
<li>t4 = Time the slave received the peer delay response (Slave clock)</li>
<li>Slave learns t2 from the peer delay response</li>
<li>Slave learns t3 from the peer delay follow up</li>
<li>meanPathDelay = ((t4-t1) - (t3-t2)) / 2</li>
</ul>
<h4><a class="anchor" id="ptp_sync_delay_which">
When to use Peer Delay versus Delay</a></h4>
<p>The Peer delay machanism provides better path delay calculation than the older delay mechanism, but it can only be used when both peers support the protocol. As an example of how peer delay and normally delay messages can be used, refer to the figure below.</p>
<div align="center">
<img src="inline_dotgraph_24.dot.png" alt="inline_dotgraph_24.dot" border="0" usemap="#inline_dotgraph_24.dot.map">
<map name="inline_dotgraph_24.dot.map" id="inline_dotgraph_24.dot.map"></map>
</div>
<p>In the above figure, peer delay calculations should be performed on these links:</p>
<ul>
<li>Switch 1 to Master</li>
<li>Slave A to Switch 1</li>
<li>Slave B to Switch 1</li>
<li>Slave C to Switch 1</li>
<li>Slave E to Slave C</li>
</ul>
<p>Less accurate delay calculations must be performed between these clocks:</p>
<ul>
<li>Slave D to Slave B through Switch 2</li>
</ul>
<p>As synchronization messages pass through switch 1 on their way toward slaves A-C the switch will update the packet timing data. Switch 1 will change the correctionField of each message to account for the measured delay of the Master to switch link. Switch 1 will also update Follow Up messages with the time the Sync messages took to traverse the intervals of the switch. This allows slaves A-C to calculate their offset from Master very accurately. Similarly Slave E will update message timing based on peer delay from slave C. Again this will be quite accurate.</p>
<p>When Slave D receives a message from Slave B through switch 2, it will not know how much time was spent inside of the switch. The best estimate slave D can perform is to measure the delay through the switch to slave B and hope it is consistent. Modern "store and forward" switches do not have constant forwarding times due to changing port load and internal processing. Latency through these switch varies randomly in the order of a few microseconds.</p>
<h4><a class="anchor" id="ptp_sync_rate">
3.1.2 Clock Rate Synchronization</a></h4>
<table align="center" cellspacing="0" cellpadding="1" border="1">
<tr>
<th><p>Synchronization Mechanism </p>
</th></tr>
<tr>
<td><div align="center">
<img src="inline_dotgraph_25.dot.png" alt="inline_dotgraph_25.dot" border="0" usemap="#inline_dotgraph_25.dot.map">
<map name="inline_dotgraph_25.dot.map" id="inline_dotgraph_25.dot.map"></map>
</div>
  </td></tr>
</table>
<p>The clock ticks for the master between the two syncs is t3-t1. The clock ticks for the slave between the two syncs is t4-t2. If the clocks are perfectly synchronized, these two values should be identical. If they are not identical, this represents clock drift between the master and slave. A scale factor of (t3-t1)/(t4-t2) for the slave's clock rate would make it match the master.</p>
<h3><a class="anchor" id="ptp_sync_time">
3.1.3 Clock Time Synchronization</a></h3>
<table align="center" cellspacing="0" cellpadding="1" border="1">
<tr>
<th><p>Synchronization Mechanism </p>
</th></tr>
<tr>
<td><div align="center">
<img src="inline_dotgraph_26.dot.png" alt="inline_dotgraph_26.dot" border="0" usemap="#inline_dotgraph_26.dot.map">
<map name="inline_dotgraph_26.dot.map" id="inline_dotgraph_26.dot.map"></map>
</div>
  </td></tr>
</table>
<p>Once the meanPathDelay has been calculated and the slave's clock rate has been synchronized with the master's clock, it is possible to figure out the slave's absolute offset from the master.</p>
<ul>
<li>Slave learns t1 from the follow up message</li>
<li>offsetFromMaster = t2 - t1 - meanPathDelay</li>
</ul>
<p>If offsetFromMaster is small, the clock rate of the slave can be skewed slightly to bring it into synchronization with the master. Larger values of offsetFromMaster cause the slave to set its internal clock causing a discontinuity.</p>
<h3><a class="anchor" id="ptp_unicast">
3.2. Unicast versus Multicast Messages</a></h3>
<p>IEEE1588-2008 defines unicast message support as an optional feature. The purpose of this option is to allow clock synchronization over a WAN network where not all switches/routers in the network support PTP. The diagram below demonstrates an example system where unicast messaging would be necessary.</p>
<div align="center">
<img src="inline_dotgraph_27.dot.png" alt="inline_dotgraph_27.dot" border="0" usemap="#inline_dotgraph_27.dot.map">
<map name="inline_dotgraph_27.dot.map" id="inline_dotgraph_27.dot.map"></map>
</div>
<p>Master and Slave A will be able to communicate on the local network using multicast messages as defined in IEEE1588-2008. Router 1 will block all messages from both Master 1 and Slave A from leaving the local network. This leaves Slave B unable to connect to the Master's clock domain. In order to get messages between Slave B and Master, unicast routable messages must be sent through router 1, the WAN, and router 2. It is quite rare for routers to support the PTP protocol, so messages are forward without any latency information. The accuracy of Slave B's clock is completely dependent on the routers and WAN have a constant delay time. Most WANs have latencies in the range of 10-100 milliseconds with random variations. These random latencies will limit the accuracy of Slave B's clock synchronization to 10's of milliseconds.</p>
<p>In sparse setups where network delay may change randomly, it is recommended the remote node only match clock frequency with the master. Per the Telecom 1588 profile, nodes may choose to not calculate network delay and only use synchronization messages for frequency matching. The OCTEON PTP 1588v2 implementation supports frequency only as well as full frequency and phase matching.</p>
<h3><a class="anchor" id="ptp_management">
3.3. Supported 1588v2 Signalling and Management Messages</a></h3>
<p>The table below summarizes the supported 1588v2 signalling messages.</p>
<table align="center" cellspacing="0" cellpadding="1" border="1">
<tr>
<th><p>TLV Type</p>
</th><th><p>Supported </p>
</th></tr>
<tr>
<td><p>Management TLVs</p>
</td><td><p>See table below </p>
</td></tr>
<tr>
<td><p>Organization Extension</p>
</td><td bgcolor="red"><p>No </p>
</td></tr>
<tr>
<th colspan="2"><p>Optional unicast message negotiation TLVs </p>
</th></tr>
<tr>
<td><p>REQUEST_UNICAST_TRANSMISSION</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>GRANT_UNICAST_TRANSMISSION</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>CANCEL_UNICAST_TRANSMISSION</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>ACKNOWLEDGE_CANCEL_UNICAST_TRANSMISSION</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<th colspan="2"><p>Optional path trace mechanism TLV </p>
</th></tr>
<tr>
<td><p>PATH_TRACE</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<th colspan="2"><p>Optional alternate timescale TLV </p>
</th></tr>
<tr>
<td><p>ALTERNATE_TIME_OFFSET_INDICATOR</p>
</td><td bgcolor="red"><p>No </p>
</td></tr>
<tr>
<th colspan="2"><p>Experimental TLVs </p>
</th></tr>
<tr>
<th colspan="2"><p>Security TLVs </p>
</th></tr>
<tr>
<td><p>AUTHENTICATION</p>
</td><td bgcolor="red"><p>No </p>
</td></tr>
<tr>
<td><p>AUTHENTICATION_CHALLENGE</p>
</td><td bgcolor="red"><p>No </p>
</td></tr>
<tr>
<td><p>SECURITY_ASSOCIATION_UPDATE</p>
</td><td bgcolor="red"><p>No </p>
</td></tr>
<tr>
<th colspan="2"><p>Cumulative frequency scale factor offset </p>
</th></tr>
<tr>
<td><p>CUM_FREQ_SCALE_FACTOR_OFFSET</p>
</td><td bgcolor="red"><p>No </p>
</td></tr>
</table>
<p>The table below summarized the supported 1588v2 management messages.</p>
<table align="center" cellspacing="0" cellpadding="1" border="1">
<tr>
<th><p>Management Id</p>
</th><th><p>Supported </p>
</th></tr>
<tr>
<th colspan="2"><p>Applicable to all node types </p>
</th></tr>
<tr>
<td><p>NULL_MANAGEMENT</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>CLOCK_DESCRIPTION</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>USER_DESCRIPTION</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>SAVE_IN_NON_VOLATILE_STORAGE</p>
</td><td bgcolor="red"><p>No </p>
</td></tr>
<tr>
<td><p>RESET_NON_VOLATILE_STORAGE</p>
</td><td bgcolor="red"><p>No </p>
</td></tr>
<tr>
<td><p>INITIALIZE</p>
</td><td bgcolor="red"><p>No </p>
</td></tr>
<tr>
<td><p>FAULT_LOG</p>
</td><td bgcolor="red"><p>No </p>
</td></tr>
<tr>
<td><p>FAULT_LOG_RESET</p>
</td><td bgcolor="red"><p>No </p>
</td></tr>
<tr>
<th colspan="2"><p>Applicable to ordinary and boundary clocks </p>
</th></tr>
<tr>
<td><p>DEFAULT_DATA_SET</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>CURRENT_DATA_SET</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>PARENT_DATA_SET</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>TIME_PROPERTIES_DATA_SET</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>PORT_DATA_SET</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>PRIORITY1</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>PRIORITY2</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>DOMAIN</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>SLAVE_ONLY</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>LOG_ANNOUNCE_INTERVAL</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>ANNOUNCE_RECEIPT_TIMEOUT</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>LOG_SYNC_INTERVAL</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>VERSION_NUMBER</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>ENABLE_PORT</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>DISABLE_PORT</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>TIME</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>CLOCK_ACCURACY</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>UTC_PROPERTIES</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>TRACEABILITY_PROPERTIES</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>TIMESCALE_PROPERTIES</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>UNICAST_NEGOTIATION_ENABLE</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>PATH_TRACE_LIST</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>PATH_TRACE_ENABLE</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>GRANDMASTER_CLUSTER_TABLE</p>
</td><td bgcolor="red"><p>No </p>
</td></tr>
<tr>
<td><p>UNICAST_MASTER_TABLE</p>
</td><td bgcolor="red"><p>No </p>
</td></tr>
<tr>
<td><p>UNICAST_MASTER_MAX_TABLE_SIZE</p>
</td><td bgcolor="red"><p>No </p>
</td></tr>
<tr>
<td><p>ACCEPTABLE_MASTER_TABLE</p>
</td><td bgcolor="red"><p>No </p>
</td></tr>
<tr>
<td><p>ACCEPTABLE_MASTER_TABLE_ENABLED</p>
</td><td bgcolor="red"><p>No </p>
</td></tr>
<tr>
<td><p>ACCEPTABLE_MASTER_MAX_TABLE_SIZE</p>
</td><td bgcolor="red"><p>No </p>
</td></tr>
<tr>
<td><p>ALTERNATE_MASTER</p>
</td><td bgcolor="red"><p>No </p>
</td></tr>
<tr>
<td><p>ALTERNATE_TIME_OFFSET_ENABLE</p>
</td><td bgcolor="red"><p>No </p>
</td></tr>
<tr>
<td><p>ALTERNATE_TIME_OFFSET_NAME</p>
</td><td bgcolor="red"><p>No </p>
</td></tr>
<tr>
<td><p>ALTERNATE_TIME_OFFSET_MAX_KEY</p>
</td><td bgcolor="red"><p>No </p>
</td></tr>
<tr>
<td><p>ALTERNATE_TIME_OFFSET_PROPERTIES</p>
</td><td bgcolor="red"><p>No </p>
</td></tr>
<tr>
<th colspan="2"><p>Applicable to transparent clocks </p>
</th></tr>
<tr>
<td><p>TRANSPARENT_CLOCK_DEFAULT_DATA_SET</p>
</td><td bgcolor="red"><p>No </p>
</td></tr>
<tr>
<td><p>TRANSPARENT_CLOCK_PORT_DATA_SET</p>
</td><td bgcolor="red"><p>No </p>
</td></tr>
<tr>
<td><p>PRIMARY_DOMAIN</p>
</td><td bgcolor="red"><p>No </p>
</td></tr>
<tr>
<th colspan="2"><p>Applicable to ordinary, boundary, and transparent clocks </p>
</th></tr>
<tr>
<td><p>DELAY_MECHANISM</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
<tr>
<td><p>LOG_MIN_PDELAY_REQ_INTERVAL</p>
</td><td bgcolor="green"><p>Yes </p>
</td></tr>
</table>
<h3><a class="anchor" id="ptp_accuracy">
3.4. Accuracy</a></h3>
<p>Using a properly configured PTP network with accurate timestamps on every hop, the OCTEON PTP 1588v2 implementation can achieve clock synchronization below 20ns, often below 10ns. The quality and frequency of the hardware PTP clock greatly affects this accuracy. As a general rule, clock synchronization is limited to three ticks of the PTP clock. For example, if your PTP reference clock runs at 100Mhz, your clock synchronization will be limited to around 30ns. Faster PTP clocks achieve better accuracy. Sub 10ns results have been achieved using the internal 800Mhz clock generated on CN63XX.</p>
<h3><a class="anchor" id="ptp_usage">
3.5. System Integration and Usage</a></h3>
<p>The ptp1588v2 example is organized into two parts, a PTP library and a simple daemon caller. In order to make it easy to integrate PTPv2 functionality into an existing Linux based application, all PTPv2 processing is done in a library that can easily be called from any application. The API for this library is documented in <b>ptplib.h</b>.</p>
<p>API Functions in ptplib:</p>
<ul>
<li>int ptplib_initialize(ptplib_state_t *ptp, ptplib_flags_t flags);</li>
<li>int ptplib_interface_add(ptplib_state_t *ptp, packetio_t *port);</li>
<li>int ptplib_process(ptplib_state_t *ptp, const packetio_packet_t *packet);</li>
<li>int ptplib_process_errorqueue(ptplib_state_t *ptp, const packetio_packet_t *packet);</li>
<li>int ptplib_periodic(ptplib_state_t *ptp);</li>
<li>int ptplib_display(ptplib_state_t *ptp, int clear_screen);</li>
<li>int ptplib_shutdown(ptplib_state_t *ptp);</li>
</ul>
<p>Configuration defines in ptplib:</p>
<ul>
<li>USE_PTP_CLOCK<ul>
<li>Adjust the hardware PTP counter directly instead of using the Linux system time. This greatly improves accuracy as the expense of violating the usual userspace protection mechanism. This define is set in the Makefile for ptp-1588v2 and is highly recommended.</li>
</ul>
</li>
<li>PTP_GPIO_PPS_OUT<ul>
<li>GPIO to use for output of a pulse signal. Default is GPIO 1. Set to -1 to disable the pulse output.</li>
</ul>
</li>
<li>PTP_GPIO_PPS_HZ<ul>
<li>Frequency for the PPS signal in Hertz. Default value is 1Hz, corresponding to the standard 1588 PPS signal.</li>
</ul>
</li>
<li>PTP_GPIO_CLOCK_OUT<ul>
<li>GPIO to use for output of a clock signal. Default is GPIO 2. Set to -1 to disable the clock output.</li>
</ul>
</li>
<li>PTP_GPIO_CLOCK_HZ<ul>
<li>Frequency for the clock signal in Hertz. Default value is 30.72Mhz. The phase alignment is such that the rising edge is aligned at second boundaries.</li>
</ul>
</li>
<li>Other defines in ptplib.c<ul>
<li>Many other parameters of the 1588v2 protocol can be adjusted through defines located in ptplib.c. Parameters that directly derive from the 1588v2 specification site the relevant section numbers.</li>
</ul>
</li>
</ul>
<p>Configuration flags for ptplib_initialize:</p>
<ul>
<li>PTPLIB_FLAGS_USE_PEER_DELAY<ul>
<li>Use peer to peer versus normal delay messages.</li>
</ul>
</li>
<li>PTPLIB_FLAGS_USE_MULTICAST<ul>
<li>Use multicast announce and sync. Otherwise messages are unicast to the respective clock.</li>
</ul>
</li>
<li>PTPLIB_FLAGS_USE_UNICAST<ul>
<li>Use unicast whenever possible. The 1588v2 protocol dictates that all messages use multicast addresses even when directed at a specific host. This flag changes this behavior to use unicast messages for all messages destine to a single host. Messages sent to multiple host still use multicast.</li>
</ul>
</li>
<li>PTPLIB_FLAGS_USE_FREQUENCY_ADJUST<ul>
<li>Adjust the frequency of the clock. Without this flag the local clock frequency will be monitored but not adjusted.</li>
</ul>
</li>
<li>PTPLIB_FLAGS_USE_PHASE_ADJUST<ul>
<li>Adjust the phase of the local clock. Without this flag the local will not be adjusted to match 1588v2 time. The only time you would not want this flag is when you are using the Telecom extension and only adjusting clock frequency. Delay messages will only be sent if PTPLIB_FLAGS_USE_PHASE_ADJUST is used.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="ptp_daemon">
3.6. ptp-1588v2, the Linux userspace Daemon</a></h3>
<p><b>TBD</b> </p>
<div class="fragment"><pre class="fragment">
Usage:
./ptp-1588v2 interface[:transport] [interface[:transport]]*

    interface = Linux network device name (eth0, eth1, etc).
    transport = Which transport to use (802.3, UDP). Defaults to 802.3.

</pre></div><h2><a class="anchor" id="ptp_version1">
4. PTPv1 - IEEE 1588-2004</a></h2>
<p>Cavium Network's implementation of IEEE1588-2004 is based on the opensource project PTPd. From the web page (<a href="http://ptpd.sourceforge.net/">http://ptpd.sourceforge.net/</a>), here is a description of PTPd:</p>
<div class="fragment"><pre class="fragment">
The PTP daemon (PTPd) implements the Precision Time protocol (PTP) as
defined by the IEEE 1588 standard.  PTP was developed to provide very
precise time coordination of LAN connected computers.

PTPd is a complete implementation of the IEEE 1588 specification for a
standard (non-boundary) clock.  PTPd has been tested with and is known
to work properly with other IEEE 1588 implementations.  The source
code for PTPd is freely available under a BSD-style license.  Thanks
to contributions from users, PTPd is becoming an increasingly
portable, interoperable, and stable IEEE 1588 implementation.

PTPd can run on most 32-bit little- or big-endian processors.  It does
not require an FPU, so it is great for embedded processors.  PTPd
currently runs on Linux, uClinux, FreeBSD, and NetBSD.  It should also
be easy to port to other platforms.

PTPd is free. Everyone is welcome to use and contribute to PTPd.
</pre></div><p>PTPd is part of the Linux filesystem supplied as part of the OCTEON SDK. The source code can be found under <b>linux/embedded_rootfs/storage/ptpd-1.0.0.tar.gz</b>. Cavium used the opensource PTPd version 1.0 with a single source patch. This patch allows PTPd to be compiled using the Cavium GCC compiler, which is much newer than the one used by the PTPd project. This patch can be found in the same directory with a filename of ptpd-fix-limits.patch. </p>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Oct 2017 for Octeon Software Development Kit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
