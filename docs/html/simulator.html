<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Octeon Software Development Kit: OCTEON Simulator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="simulator">OCTEON Simulator </a></h1><h2><a class="anchor" id="sim_contents">
Contents</a></h2>
<ul>
<li><a class="el" href="simulator.html#sim_overview">Overview</a></li>
<li><a class="el" href="simulator.html#sim_running">Running the OCTEON Simulator</a></li>
<li><a class="el" href="simulator.html#magic">Simulator "magic"</a></li>
<li><a class="el" href="simulator.html#oct-sim">oct-sim (simulator wrapper script)</a></li>
<li><a class="el" href="simulator.html#sim_args">Simulator Arguments</a></li>
<li><a class="el" href="simulator.html#packet_io">OCTEON Simulator Live Packet Input and Output</a></li>
<li><a class="el" href="simulator.html#core_statistics">Per core performance statistics from the simulator</a></li>
<li><a class="el" href="simulator.html#system_statistics">System performance statistics from the simulator</a></li>
</ul>
<h2><a class="anchor" id="sim_overview">
Overview</a></h2>
<p>The files "bin/pp" and "cn3*xx-simulator*" are the the OCTEON simulators and "bin/oct-sim" is the wrapper script that is typically used to invoke the simulator. The simulator provides a functional and performance simulator for Cavium Network's OCTEON processor. Detailed information on the simulator can be found in the "OCTEON Simulator" whitepaper. The oct-sim script uses the OCTEON_MODEL environment variable to select what member of the OCTEON family to simulate.</p>
<h2><a class="anchor" id="sim_running">
Running the OCTEON Simulator</a></h2>
<p>First, build the 'hello' example in 'examples/hello':</p>
<div class="fragment"><pre class="fragment">    make hello
</pre></div><p>To run this application on the simulator, use the following command:</p>
<div class="fragment"><pre class="fragment">    oct-sim hello -quiet
</pre></div><p>To run this on multiple cores, add the -numcores=NUM option to the command line. Each core will run in its own memory space, with private stack, heap, and local data. Read only code and data are mapped to a shared region for all cores.</p>
<p>Running hello produces a good deal of output, including the line: </p>
<div class="fragment"><pre class="fragment">    PP0:~CONSOLE-&gt; Hello world!
</pre></div><p>Statistics like these also come out: </p>
<div class="fragment"><pre class="fragment">
PP0 Model 1 Estimated performance.
Instructions Issued               -&gt;   1036  30.5%
Bubbles due to no pipe swapping   -&gt;    139   4.1%
Bubbles due to single issue LD/ST -&gt;    149   4.4%
Bubbles due to single issue Branch-&gt;     61   1.8%
Bubbles due to single issue other -&gt;      4   0.1%
Bubbles due to RAW                -&gt;    230   6.8%
Bubbles due to unaligned ld/st    -&gt;      0   0.0%
Bubbles due to mul/div busy       -&gt;     10   0.3%
Bubbles due to crypto  busy       -&gt;      0   0.0%
Bubbles due to llm busy           -&gt;      0   0.0%
Bubbles due to BR taken           -&gt;    152   4.5%
Bubbles due to JR taken           -&gt;     46   1.4%
Bubbles due to BR mispredict      -&gt;    148   4.4%
Bubbles due to MTCOP0 stall       -&gt;     35   1.0%
Bubbles due to Ifetch             -&gt;   2694  79.2%
Bubbles due to BRfetch            -&gt;    152   4.5%
Bubbles due to Dmiss              -&gt;    458  13.5%
Bubbles due to Dmiss with Wbuf hit-&gt;   1380  40.6%
Bubbles due to Write Buf Avail    -&gt;      0   0.0%
Bubbles due to sync               -&gt;     96   2.8%
Bubbles due to delay slot dual    -&gt;     11   0.3%
Bubbles due to io lds             -&gt;      0   0.0%
Total Cycles (no zombie)          -&gt;   3400 100.0% (   3400)
</pre></div><p>Showing that 1036 instructions issued in the 3400 cycles that the simulator executed for this Mips core. Note that the total of the first columns ("Instructions Issued" + "Bubbles *") approximately equals twice the number of cycles since OCTEON is dual-issue.</p>
<p>You also get stats like: </p>
<div class="fragment"><pre class="fragment">
Memory fills                            -&gt;     52 (utilization 12.232%)
Memory writebacks                       -&gt;      0 (utilization 0.000%)
L2 store bus cycles                     -&gt;     72 (utilization 2.117%)
L2 address bus cycles                   -&gt;     69 (utilization 2.029%, L2C ctl utilization 4.058%)
L2 fill bus cycles                      -&gt;    188 (utilization 5.528%)
</pre></div><p>Which display some interesting CB, L2C, and local DRAM bus utilizations. Please see the sections <a class="el" href="simulator.html#core_statistics">Per core performance statistics from the simulator</a> and <a class="el" href="simulator.html#system_statistics">System performance statistics from the simulator</a> below for a detailed description of simulator performance statistics.</p>
<p>You can get more detail in the text output with: </p>
<div class="fragment"><pre class="fragment">    oct-sim hello
</pre></div><p>which will give output like: </p>
<div class="fragment"><pre class="fragment">
 PP0:20009C40&lt;vfprintf+376&gt;:2091@1        : [7040102b] SNE     $v0, $v0, $zero [$v0=1]
 PP0:20009C44&lt;vfprintf+380&gt;:2092@0        : [  431024] AND     $v0, $v0, $v1 [$v0=1]
 PP0:20009C48&lt;vfprintf+384&gt;:2093@0~SL     : [1440fff5] BNE     $v0, $zero,  20009C20&lt;vfprintf+344&gt;
 PP0:20009C4C&lt;vfprintf+388&gt;:2093@1        : [       0] NOP
 PP0:20009C20&lt;vfprintf+344&gt;:2095@0~BR     : [afc003e8] SW      $zero, 1000($fp) [(7FFFEB88,7FFFEB88)=0]  MEM[0x7FFFEB88]&lt;- 0x0(mask=FFFFFFFF00000000)
 PP0:20009C24&lt;vfprintf+348&gt;:2096@0~SL     : [92620000] LBU     $v0, 0($s3) [$v0=A(2011CAFC&lt;_libc_intl_domainname+2572&gt;,2011CAFC)]
 PP0:20009C28&lt;vfprintf+352&gt;:2098@0~RAW    : [  501024] AND     $v0, $v0, $s0 [$v0=0]
 PP0:20009C2C&lt;vfprintf+356&gt;:2099@0~SL     : [14400ebe] BNE     $v0, $zero, 2000D728
 PP0:20009C30&lt;vfprintf+360&gt;:2099@1        : [67c603e8] DADDIU  $a2, $fp, 1000 [$a2=7FFFEB88]
 PP0:20009C34&lt;vfprintf+364&gt;:2100@0        : [66730001] DADDIU  $s3, $s3, 1 [$s3=2011CAFD]
 PP0:20009C38&lt;vfprintf+368&gt;:2101@0~SL     : [92620000] LBU     $v0, 0($s3) [$v0=0(2011CAFD&lt;_libc_intl_domainname+2573&gt;,2011CAFD)]
</pre></div><p>Showing the individual instructions that execute, the cycle #, the binary instruction, the mnemonic, and some additional description.</p>
<p>Or you can do: </p>
<div class="fragment"><pre class="fragment">    oct-sim hello -quiet -vz
</pre></div><p>To create an octeon.vz file for later visual examination with the viewzilla tool.</p>
<h2><a class="anchor" id="magic">
Simulator "magic"</a></h2>
<p>The simulator provides some 'magic' functions for performance and convenience that are unique to the simulator environment. These functions are called as normal C functions, but are handled specially by the simulator. When an instruction at a certain address (currently 0xfeffe000) is executed, the simulator traps this and executes code providing various services. Since these functions rely on simulator tricks and a Linux host, they cannot be provided when running on real hardware.</p>
<p>The current special functions are:</p>
<ul>
<li>simprintf(char *format,...)</li>
</ul>
<p>This function passes the format string and arguments to the native printf() in the simulator. No string processing or argument conversion is simulated, so it is much faster. The implementation is very simple, as a result there are significant limitations on the usage:</p>
<ol type="1">
<li>maximum of 7 arguments. (more than this requires pulling arguments off of the stack.)</li>
<li>all format specifiers must be of the form ll, or incorrect results will be printed. This is a result of the native printf being run on a 32-bit machine, and the register values being 64 bit. If the ll is not specified, the native printf pulls the arguments off the stack at 32-bit offsets, instead of 64-bit offsets, resulting in incorrect results. Warnings will be printed if any format specifiers are not ll.</li>
<li>The number of arguments is determined by counting '' characters, so you cannot print '' characters in your output.</li>
<li>No buffering is done - each simprintf call results in immediate output</li>
</ol>
<ul>
<li>int open(const char *pathname, int flags)</li>
<li>int close(int fd)</li>
<li>int read(int fd, void *buf, size_t count)</li>
<li>int write(int fd, const void *buf, size_t count)</li>
</ul>
<p>These four system calls are mapped to use the host systems file system. Normal files can be read and written through these system calls. Also, C library functions that use these functions can be used. Using these calls on stdout, stderr, or stdin is not supported.</p>
<h2><a class="anchor" id="oct-sim">
oct-sim (simulator wrapper script)</a></h2>
<div class="fragment"><pre class="fragment">
Usage: oct_sim octeon_executable [-memsize=size] [-envfile=filename] [-debug] \
                 [-stacksize=0xXXXX] [-heapsize=0xXXXX] [-appargs="args for application"] [simulator options]

oct-sim option descriptions:
         -memsize=size          size is in megabytes.  Defaults to 128 megabytes.
         -envfile=filename      u-boot will load environment from file 'filename'.
         -debug                 enables debugging of application.
         -stacksize=0xXXX       sets stack size in bytes for simple exec applications (1 MB default)
         -heapsize=0xXXX        sets heap size in bytes for simple exec applications (3 MB default)
         -appargs="arg string"  passes "arg string" to application as argc/argv

</pre></div><p>The OCTEON SDK provides the oct-sim wrapper script to simplify the usage of the simulator for running simple executive based applications. The oct-sim script is the preferred way to invoke the simulator. The script loads the u-boot bootloader at the correct address, and places the user program at the address that the bootloader expects it. The script also passes the memory size that is simulated to the bootloader. The oct-sim script passes all unrecognized options to the simulator.</p>
<p>The oct-sim script provides the follow additional arguments:</p>
<ul>
<li>-memsize=DRAM_size Specify DRAM size in megabytes. Default DRAM size is 128 Megabytes. DRAM is only simulated at the correct physical addresses based on the amount of DRAM simulated.</li>
</ul>
<ul>
<li>-envfile=filename specifies an alternate environment for the u-boot bootloader. This allows various bootloader parameters to be adjusted at runtime. Currently the only environment variable that is used is the 'bootcmd' variable, and this can be used to change the address from which the application is loaded, and the stack and heap size that the application is allocated. The format of the file is a string of the form "bootcmd=bootoct 0x10000000 stack=0x3000
heap=0x3000" (without the quotes). The hello example provides an example of using the environment file to specify stack and heap sizes.</li>
</ul>
<ul>
<li>-debug Enable debugging of the application with GDB.</li>
</ul>
<ul>
<li>-stacksize=0xXXXXX Sets the stack size in bytes for simple exec applications. This allows the stack size for the application to be configured at runtime.</li>
</ul>
<ul>
<li>-heapsize=0xXXXXX Sets the heap size in bytes for simple exec applications. This allows the heap size for the application to be configured at runtime.</li>
</ul>
<ul>
<li>-appargs="arg string" Specifes the command line arguments to be passed to the simple exec application. The string is added to the end of the bootloader command, parsed by the bootloader, and passed to the application <a class="el" href="cvmx-app-init-linux_8c.html#ac0f2228420376f4db7e1274f2b41667c" title="Main entrypoint of the application.">main()</a> routine as argc/argv.</li>
</ul>
<h2><a class="anchor" id="sim_args">
Simulator Arguments</a></h2>
<p>Below are the arguments supported by the OCTEON simulator and a brief description of each. Invoking oct-sim without any arguments will display the usage for the currently configured simulator. The simulators for each of the OCTEON models have slightly different options.</p>
<div class="fragment"><pre class="fragment">


        -quiet[=cycle]     Don't display instructions executed until the specified cycle. If cycle is ommitted instructions will not be displayed.
        -trace=[...]       Enable tracing for specific features/units.
        -modes=[...]       Enable particular hardware modes.
        -numcores=cpus     Control the number of processors simulated. Defaults to one.
        -maxcycles=cycles  Terminate simulation after a set number of cycles.
        -maxperfcycles=cyc Terminate simulation after the performance model has run a set number of cycles.
        -maxperfinsts=cnt  Terminate simulation after the performance model has run a set number of instructions.
        -maxtracecycles=cyc Terminate simulation a set number of cycles after -wait is true.
        -maxtraceinsts=cnt Terminate simulation a set number of instructions after -wait is true.
        -numbbs=cnt        Control the number of basic blocks the performance model prints. Defaults to 0.
        -uart0=port        Listen on the supplied TCP port for a connection for UART0
        -uart1=port        Listen on the supplied TCP port for a connection for UART1
        -serve=port        Listen on the supplied TCP port for connections for Packet I/O
        -freq=speed        Specify the core clock speed in MHz (default = 500)
        -memdatarate=speed Specify the main memory data rate in MHz (default = 533)
        -pci=port          Listen on the supplied TCP port for a connection for PCI bus emulation
        -ld=address:file   Setup main memory at the supplied address with the supplied file.
        -ld=address:bytes  Setup main memory at the supplied address with bytes zeroes.
        -llsize=words      Initialize low latency memory of the supplied size (in 36-bit words) with zeros.
        -ll=file           Initialize low latency memory with the contents of the supplied file.
        -vz[=file]         Enable viewzilla output
        -log               Enable additional logging
        -noperf[=symbol|cycle] Disable cycle performance characterization for improved speed. If symbol|cycle are present,
                           performance characterization is disabled only until execution passes the supplied symbol or cycle count.
        -wait=symbol|cycle Don't start instruction tracing or viewzilla until execution passes the supplied symbol or cycle count.
        -idle              Terminate the simulation if all processors are idle and no POW work is available.
        -l2inst            force all instruction references to appear to hit in L2 cache (and remove one of the 8 L2 ways)

        All number may either be specified as decimal "10", hexadecimal "0xA", or octal "012".

</pre></div><p>Additional arguments for the CN78XX simulator are:</p>
<div class="fragment"><pre class="fragment">
	-numnodes=node_count
	-memsize=node0mem,node1mem

	See -ldaddress:file for more information on multinode executive loading.
</pre></div><p><b>-quiet[=cycle]</b></p>
<p>Don't produce the more verbose textual output indicating each core instruction that is executed. If this argument does not exist, the verbose textual output will start after the wait period. Note that verbose output can be very large for long simulation runs. (Use -wait to reduce it.) If the cycle argument is supplied, the simulator does not print out instructions until the selected cycle. If "-trace" is not otherwise supplied, this command turns off all tracing.</p>
<p><b>file</b></p>
<p>"file" is an ELF file to be loaded into memory before running the simulator. The simulator allocates memory regions corresponding the sections in the ELF file and loads the appropriate data into the memory. The simulator assumes that the virtual addresses in the ELF file are the physical addresses that should be used. Physical memory locations not allocated by either an ELF section load or by "-ld" (see below) do not exist and cause errors when referenced.</p>
<p><b>-trace=[fau,fpa,packet,pow,tag,pip,pko,lreg,dfa,dfb,wb,tlb,iob,all]</b></p>
<p>Determines how much the simulator prints out about the operation of various hardware units:</p>
<ul>
<li>fau = print fetch and add updates</li>
<li>fpa = print free pool operations</li>
<li>packet = when "-serve" is not used, print out packet data</li>
<li>pow = print POW work movements</li>
<li>tag = print POW tag switch operations</li>
<li>pip = print work queue creation (via "-serve")</li>
<li>pko = print PKO packet output steps</li>
<li>lreg = print changes to CVMSEG LM</li>
<li>dfa = print coarse DFA engine behavior</li>
<li>dfb = print detailed (state-by-state) DFA engine behavior</li>
<li>wb = print when core memory stores become visible (i.e. exit the write buffer)</li>
<li>tlb = print out detailed core TLB information on each update</li>
<li>iob = print memory references that originate from the IO bus</li>
<li>all = print all of the above</li>
</ul>
<p><b>-noperf</b></p>
<p>Run simulator with functional modeling only, no performance modeling.</p>
<p><b>-wait=label|cycle</b></p>
<p>Do not gather statistics, print verbosely, nor generate viewzilla output until an instruction with a symbol of label or the selected cycle count is executed. For example, "-wait=cvm_process_packet" will cause the simulator to wait until the first instruction from the cvm_process_packet() routine is executed before printing out instruction or viewzilla traces.</p>
<p><b>-vz</b> <b>-vz=file</b></p>
<p>Generate output for viewzilla after the wait period. If file is not supplied, "octeon.vz" is used. E.g. "-vz" produces "octeon.vz", "-vz=myvzfile.vz" produces "myvzfile.vz". Note that viewzilla output can be very large for long simulation runs. (Use -wait to reduce it.)</p>
<p><b>-numcores=N</b></p>
<p>Simulate with N cores instead of 1. E.g. "-numcores=2".</p>
<p><b>-serve=port</b></p>
<p>Allows the simulator to emulate packet receipt and transmit (through the GMX/SPX packet interfaces) through information transferred over a TCP connection. When this option is used, the simulator acts as a server for the selected TCP port. More than one client can connect to the simulator via the port. Each client specifies the SPX/GMX ports it will receive packets for. (Exactly one client must receive output packets for a given SPX/GMX port.) The appendix describes the details of the information transferred over the TCP connection.</p>
<p><b>-uart0=port,-uart1=port</b></p>
<p>Allows the simulator to receive and send bytes via the simulated uarts. The ports specify the TCP ports that the simulator will wait for a connect on. Exactly one client must connect to the port.</p>
<p><b>-l2inst</b></p>
<p>Assume that all instruction references to the L2 cache hit in one of the 8 sets. The remaining 7 sets are used for data references.</p>
<p><b>-llsize=X</b></p>
<p>Create a low-latency DRAM area (starting at low-latency address 0) of size X words. E.g. "-llsize=4096" creates a 4096 x 36-bit low-latency memory, "-llsize=0x4000" creates a 0x4000 x 36-bit low-latency memory. By default, no low-latency memory exists, and an error will result on a reference to it. Only "-ll" commands allocate it.</p>
<p><b>-ldaddress:file</b></p>
<p>Allocate a memory region Load the binary contents of "file" into local memory (byte) address "address". E.g. "-ld0x200000:myfile" will load the binary contents of "myfile" at physical memory address 0x200000. The size of the allocated region is the size of the file. Memory addresses nominally do not exist, and will cause a simulation error when if accessed unless it was allocated by this command or an ELF file load.</p>
<p>Note: For</p>
<p><b>-ldaddress:size</b></p>
<p>ex: -ld0x200000000:0x10000 will cause 0x10000 bytes of memory at address 0x200000000 to be simulated and be filled with zeros.</p>
<p><b>-llfile</b></p>
<p>Create a low-latency DRAM area and preload it with the contents of "file". "file" must be a binary file - each 8 bytes in the file correspond to one 36-bit low-latency memory location.</p>
<p><b>-log=[std,cmb,sep]</b></p>
<p>This option controls how the simulator logs the standard output generated by the cores. By default, all output goes to stdout of the simulator, with text similar to 'PP5:~CONSOLE-&gt;' prepended to each line. The 'sep' option enables separate logging for each core, while the 'cmb' option enables logging of all the cores' output to a single file. If either separate or combined logging is selected, output from the cores is not copied to the simulator stdout unless the 'std' option is selected. (log=std is equivalent to the default behavior)</p>
<p><b>-maxcycles=[cycle count]</b></p>
<p>Specify the maximum number of cycles that will be simulated. The simulator will exit after the specified number of cycles, and will print a message indicating that it exited for this reason.</p>
<p><b>-idle</b></p>
<p>When this option is selected, simulation will stop soon after there is no available work.</p>
<p><b>-modes=[spi0,spi1,packetstd,fastboot,pass1,pass2,...]</b> This field allows control of various simulator options. Some common ones are set by default by the oct-sim script.</p>
<ul>
<li>spi0 = interface 0 is SPI4.2 rather than RGMII</li>
<li>spi1 = interface 1 is SPI4.2 rather than RGMII</li>
<li>packetstd = send output packets to stdout rather than -serve socket</li>
<li>fastboot = make boot bus references complete instantly. This is set by oct-sim by default to speed up booting.</li>
<li>pass1 = simulate pass 1 silicon</li>
<li>pass2 = simulate pass 2 silicon</li>
<li>fullperf: Prints out L2 per-set and DRAM per-bank statistics.</li>
<li>pktXX: This allows PCI packets to flow in/out via the usual -serve=port path that is used for non-PCI packets.</li>
<li>pktstd: When set and -serve=port is not used, the simulator will simply print out the packets that you send out.</li>
<li>spi0, spi1: Set specified interface to SPI mode instead of RGMII (only applies to models with SPI interfaces.)</li>
<li>XXXl2: Set L2 size to specified size. This is set by the oct-sim wrapper based on the OCTEON_MODEL environment variable.</li>
<li>cryptovz: Generate viewzilla output for crypto unit.</li>
<li>pass*: Selects with silicon revision to simulate. This is properly set by the oct-sim wrapper based on the setting of OCTEON_MODEL.</li>
<li>fastboot: Makes boot bus accesses instantaneous to increase simulation performance. This is set by default in the oct-sim wrapper to speed up booting.</li>
<li>no*: Simulate chips with specified block disabled. This allows simulation EXP/NSP/... Octeon models.</li>
<li>narrowpackage: Sets the DDR interface width to the narrow width supported by the smaller package. This is set by the oct-sim wrapper based on the OCTEON_MODEL environment variable.</li>
</ul>
<h2><a class="anchor" id="packet_io">
OCTEON Simulator Live Packet Input and Output</a></h2>
<p>The OCTEON simulator can accept TCP connections to a particular TCP port when the "-serve" option is used. The data travelling over these connections transfer packets into and out of OCTEON as if they arrived via the GMX/SPX interfaces. Applications can use as many client TCP connections as they like with "-serve". The OCTEON SDK utility "oct-packet-io" provides a simplified interface for simualtor packet IO supporting multiple packet sources. The rest of this section documents the use of the simulator packet IO directly, without oct-packet-io.</p>
<p>The simulator does not currently support unbuffered operation on the TCP channel. To prevent deadlock, clients may need to receive bytes from their inbound TCP connection before they can send bytes on their outbound TCP connection.</p>
<h3>Initialization Line</h3>
<p>Immediately after connecting, the client must send a mask that indicates the OCTEON internal output ports that the TCP connection wishes to receive packets for. For example, the input line: 0xf000f indicates that OCTEON will direct output packets destined for OCTEON internal ports 0,1,2,3,16,17,18,19 to this connection. (OCTEON internal ports 0,1,2,and 3 are ports 0-3 on GMX0/SPX0/XAUI0. OCTEON internal ports 16,17,18, and 19 are ports 0-3 on GMX1/SPX1/XAUI1.) The internal ports are different for ebb6800 processor, each ports are passed in a sequence separated by comma to simulator instead of input line. Based on the input packet, the simulator reads packets from that SGMII/XAUI interface and writes packets to that particular SGMII/XAUI interface. The following table describes the internal port used by simulator as well as the software:</p>
<p>INTERFACE QLM PORT NUMBER ------------------------------------------------------------------ SGMII 0 2048,2064,2080,2096 XAUI 0 2112 SGMII 2 2560,2576,2592,2608 XAUI 2 2624 SGMII 3 2816,2832,2848,2864 XAUI 3 2880 SGMII 4 3072,3088,3104,3120 XAUI 4 3136 ILK 1 1024,1025,1026,1027,1028,1029,1030,1031,1032 ILK 2 1028,1029,1030,1031,1032,1033,1034,1035,1036 ------------------------------------------------------------------</p>
<p>The masks for multiple TCP connections must not overlap. OCTEON will wait and eventually time out if no client connection receives the packets for a port that needs to send a packet.</p>
<h3>Normal Operation Lines</h3>
<p>There are four legal lines after initialization. The description below is for the OCTEON simulator receiving packets from an external client. All of it also applies in the opposite direction for the client receiving packets from the OCTEON simulator.</p>
<h3>Release Backpressure</h3>
<p>If any line that starts with an integer in the range 128 through 163, that line indicates that back-pressure is no longer applied to output ports 0 through 35, respectively. (sent_value = 128 + port) OCTEON is free to send out the selected output port after it receives a RELEASE BACKPRESSURE.</p>
<div class="fragment"><pre class="fragment">
Example lines:
    130              // RELEASE for port 2
    0x90             // RELEASE for port 16
</pre></div><p>RELEASE BACKPRESSURE can be sent at any time (and for any port). When the OCTEON simulator wants to release backpressure for an internal input port ID, it sends a RELEASE BACKPRESSURE to the client that is receiving packets for the output port with the same ID.</p>
<h3>Force Backpressure</h3>
<p>If any line that starts with an integer in the range 64 through 99, that line indicates that back-pressure should be applied to output ports 0 through 35, respectively. (sent_value = 64 + port) OCTEON will eventually stop sending out the selected output port after it receives a FORCE BACKPRESSURE.</p>
<div class="fragment"><pre class="fragment">
Example lines:
    67               // FORCE for port 3
    0x51             // FORCE for port 17
</pre></div><p>FORCE BACKPRESSURE can be sent at any time (and for any port). When the OCTEON simulator wants to assert backpressure for an internal input port ID, it sends a FORCE BACKPRESSURE to the client that is receiving packets for the output port with the same ID.</p>
<h3>Start Packet</h3>
<p>Packets are transferred with one START PACKET and a number of PACKET WORD transfers. Their lines look like this:</p>
<div class="fragment"><pre class="fragment">    &lt;port&gt;   &lt;bytes&gt;   &lt;cycles&gt;
</pre></div><ul>
<li>port = The input port that the simulator should receive the packet on.</li>
<li>bytes = The number of bytes in the packet.</li>
<li>cycles = The number of internal OCTEON cycles that will be consumed on the input port by the packet.</li>
</ul>
<div class="fragment"><pre class="fragment">
Example lines:
    3 111 500       // the packet arriving on port 3 is
                    // 111 bytes and will consume 500
                    // cycles on the input port
    31 567 780      // the packet arriving on port 31 is
                    // 567 bytes and will consume 780
                    // cycles on the input port
</pre></div><p>START PACKET can only be sent at the start of the packet. After a START PACKET, the client must eventually send exactly ((bytes+7)/8) PACKET WORD transfers on the selected port before it can send another START PACKET. Data from multiple packets cannot be interleaved in the TCP stream when the two packets are destined for the same port. (Note also that it is illegal for two different clients to send in interleaved packets destined for the same port.) START PACKET and PACKET WORD transfers for different ports can be freely interleaved, however.</p>
<h3>Packet Word</h3>
<p>PACKET WORD transfers are:</p>
<div class="fragment"><pre class="fragment">   &lt;port&gt;   &lt;64-bit word&gt;
</pre></div><p>The 64-bit word is big-endian format - the first byte is the most-significant one.</p>
<div class="fragment"><pre class="fragment">
Example lines:
   3  0xbaddeed00deeddab
   31 345698
</pre></div><p>Example Normal operation lines</p>
<p>A 40 (+14 for ether hdr) byte TCP (somewhat real) packet on port input 0:</p>
<div class="fragment"><pre class="fragment">
   0 54 2000
   0 0x5cff23c698694873
   0 0xdc51456708004508
   0 0x0028000040000806
   0 0x0000329fabcd3489
   0 0x6300000700030000
   0 0x0000000000005010
   0 0x0
</pre></div><p>Interleaving two bogus packets to input ports 7 and 18, with back-pressure twiddling (on and off) for output ports 7 and 8:</p>
<div class="fragment"><pre class="fragment">
   7 111 5600
   7 0x235762395
   7 3569375
   71
   7 4687046849
   7 8426784567
   18 67 3000
   7 0x243275693745
   7 0x32ab84367288426
   18 429375635
   0x12 2359376539745
   7 7325374965
   0x7 23536259347
   7 23457350734
   7 23452395767345
   18 0x35932573487
   72
   18 7432537465375
   18 73952736573
   18 0x3453475
   7 23569237569357
   135
   7 0x3756923745
   18 0x37456356
   18 7892735635
   136
   18 0x237569237563
   7 372965375
   7 0xbe3472955635748
</pre></div><h3>Notes on simulator packet IO</h3>
<p>The simulator models, roughly, gigabit ethernet output speeds on a single output port. The output packet rate is limited this way, and the cycles value indicates this also.</p>
<p>Packets from multiple ports may share the same TCP connection, but it may not be desirable. The simulator stops receiving bytes from the TCP input stream whenever a START PACKET stalls. (The usual START PACKET stall condition will be when the prior packet is still consuming the input port. This would happen if the cycles value for the prior packet is large.) Consequently, it may be appropriate to put packets from different ports on different TCP connections. The simulator continues to execute cycles even when a TCP connection is stalled by a START PACKET.</p>
<p>It may also be desirable for back-pressure indications to go on a separate TCP channel to avoid the same START PACKET stalls.</p>
<h2><a class="anchor" id="core_statistics">
Per core performance statistics from the simulator</a></h2>
<div class="fragment"><pre class="fragment">
PP0 Estimated performance.
</pre></div><p>The following stats are for core 0.</p>
<div class="fragment"><pre class="fragment">
 Instructions Issued               -&gt; 596173  51.7%
</pre></div><p>The above says that there were 596173 instruction issues in the selected area, and that this was 0.52 instruction issues every cycle. This is 25% of the maximum possible two instructions per cycle.</p>
<div class="fragment"><pre class="fragment">
 Bubbles due to no pipe swapping   -&gt;  89299   7.7%
</pre></div><p>CnMIPS assigns the oldest instruction to pipe 0. This says that 0.08 issues per cycle (3.8% of the max possible two issues per cycle) may have been lost because of this fixed placement. Some instructions, like loads/stores, branches, etc. can only issue on pipe 0.</p>
<div class="fragment"><pre class="fragment">
 Bubbles due to single issue LD/ST -&gt; 287846  25.0%
</pre></div><p>This says that 0.25 issues per cycle (12.5% of the max possible two issues per cycle) may have been lost because cnMIPS only supports one memory operation per cycle.</p>
<div class="fragment"><pre class="fragment">
 Bubbles due to single issue Branch-&gt;  16582   1.4%
</pre></div><p>This says that 0.01 issues per cycle (0.7% of the max possible two issues per cycle) may have been lost because cnMIPS only supports one memory operation per cycle.</p>
<div class="fragment"><pre class="fragment">
 Bubbles due to single issue other -&gt;    189   0.0%
</pre></div><p>This says that few issue slots were lost because cnMIPS cannot dual-issue trap, MT/MF, and SYNC instructions.</p>
<div class="fragment"><pre class="fragment">
 Bubbles due to RAW                -&gt;   6169   0.5%
</pre></div><p>This says that few issue slots were lost solely because the operands were not available in the input registers.</p>
<div class="fragment"><pre class="fragment">
 Bubbles due to unaligned ld/st    -&gt;     56   0.0%
</pre></div><p>OCTEON HW unaligned loads/stores take two issue slots. This says that there were few unaligned loads/stores.</p>
<div class="fragment"><pre class="fragment">
 Bubbles due to mul/div busy       -&gt;   1157   0.1%
</pre></div><p>This says that few issue issue slots may have been lost due to the multiplier or divide units being busy.</p>
<div class="fragment"><pre class="fragment">
 Bubbles due to crypto  busy       -&gt;    504   0.0%
</pre></div><p>This says that few issue issue slots may have been lost due to the COP2 units being busy, excluding LLM. This can be due to either reading the result from the unit before it has been calculated by the HW, or writing the unit before it has finished the previous operation.</p>
<div class="fragment"><pre class="fragment">
 Bubbles due to llm busy           -&gt;      0   0.0%
</pre></div><p>This says that no issue slots were lost due to accessing one of the two LLM units. This can be due to either reading the result from one of the units before it is available from the LLM, or writing the unit before it has finished the previous operation.</p>
<div class="fragment"><pre class="fragment">
 Bubbles due to BR taken           -&gt;   6691   0.6%
</pre></div><p>This says that few issue slots were lost solely due to taken branches that are correctly predicted.</p>
<div class="fragment"><pre class="fragment">
 Bubbles due to JR taken           -&gt;    206   0.0%
</pre></div><p>This says that few issue slots were lost solely due to taken jumps (either correctly or incorrectly predicted).</p>
<div class="fragment"><pre class="fragment">
 Bubbles due to BR mispredict      -&gt;    768   0.1%
</pre></div><p>This says that few issue slots were lost solely due to taken branches that are incorrectly predicted.</p>
<div class="fragment"><pre class="fragment">
 Bubbles due to MTCOP0 stall       -&gt;    893   0.1%
</pre></div><p>This says that few issue slots were lost solely due to move-to-COP0 (MTCOP0) instructions. MTCOP0 instructions take 3 cycles (6 issues slots).</p>
<div class="fragment"><pre class="fragment">
 Bubbles due to Ifetch             -&gt;  15679   1.4%
</pre></div><p>This says that 0.01 issues per cycle (0.7% of the max possible two issues per cycle) may have been lost due to instruction fetch issues, which normally accumulate due to icache misses.</p>
<div class="fragment"><pre class="fragment">
 Bubbles due to BRfetch            -&gt;    500   0.0%
</pre></div><p>Ignore this one. The simulator is outdated in this area.</p>
<div class="fragment"><pre class="fragment">
 Bubbles due to Dmiss              -&gt;1177208 102.2%
</pre></div><p>This says that 1.02 issues per cycle (51% of the max possible two issues per cycle) may have been lost because of dcache misses that did not need to force a write buffer entry to the L2 cache first.</p>
<div class="fragment"><pre class="fragment">
 Bubbles due to Dmiss with Wbuf hit-&gt;   2526   0.2%
</pre></div><p>This says that few issue slots were lost solely due to load misses that needed to force a write buffer entry to the L2 cache first.</p>
<div class="fragment"><pre class="fragment">
 Bubbles due to Dcache aliases     -&gt;      0   0.0%
</pre></div><p>This says that no issue slots were lost solely due to loads that trapped because they found an alias in the dcache. (An alias is a virtual address that maps to the same physical address.)</p>
<div class="fragment"><pre class="fragment">
 Bubbles due to Write Buf Avail    -&gt;  11392   1.0%
</pre></div><p>This says that 0.01 issues per cycle (0.5% of the max possible two issues per cycle) may have been lost due to a full write buffer.</p>
<div class="fragment"><pre class="fragment">
 Bubbles due to sync               -&gt;    398   0.0%
</pre></div><p>This says that no issue slots wer lost solely due to SYNC/SYNCS/SYNCIOBDMA instruction waits.</p>
<div class="fragment"><pre class="fragment">
 Bubbles due to delay slot dual    -&gt;  82581   7.2%
</pre></div><p>Ignore this, it is due to an out-of-date simulator.</p>
<div class="fragment"><pre class="fragment">
 Bubbles due to io lds             -&gt;   7714   0.7%
</pre></div><p>This says that very few issue slots were lost due to waiting IO space (i.e. uncached) loads to return.</p>
<div class="fragment"><pre class="fragment">
 Total Issues+Bubbles              -&gt;2304531 200.0%
</pre></div><p>This just emphasizes that the total % of the Bubbles should be 200%, corresponding to 2 issues per cycle.</p>
<div class="fragment"><pre class="fragment">
 Estimated fraction of time due to icache misses =   0.6%
</pre></div><p>This will typically not be too far from to "Bubbles due to Ifetch" above.</p>
<div class="fragment"><pre class="fragment">
 Total Cycles (no zombie,wait)     -&gt;1152265 100.0% (1152250)
</pre></div><p>A zombie is a core that is waiting for work (from POW) when work is not available. This is the non-zombie, non-wait cycle count.</p>
<div class="fragment"><pre class="fragment">
User Cycles (no zombie,wait)      -&gt;      0   0.0%
Kernel/Debug Cycles (no zom,wait) -&gt;3408688 100.0%
Supervisor Cycles (no zom,wait)   -&gt;      0   0.0%
</pre></div><p>Count of cycles spent in user, kernel/debug, and supervisor modes. These counts exlude zombie and wait cycles.</p>
<div class="fragment"><pre class="fragment">
 Total Waits                       -&gt;      0
</pre></div><p>The number of cycles subtracted due to the MIPS WAIT instruction.</p>
<div class="fragment"><pre class="fragment">
 Total Cycles (includ zombie,wait) -&gt;1153346
</pre></div><p> The true total cycle count.</p>
<div class="fragment"><pre class="fragment">
ITLB and address exceptions       -&gt;      0
DTLB and address exceptions       -&gt;      0
</pre></div><p>Count of instruction and data address exceptions (TLB misses.)</p>
<div class="fragment"><pre class="fragment">
 Loads                             -&gt; 131639 0.114/cycle
 Local Mem Loads                   -&gt;     72 0.000/cycle
 IO space Loads                    -&gt;     26 0.000/cycle
 Stores                            -&gt; 208072 0.181/cycle
 Local Mem Stores                  -&gt;     62 0.000/cycle
 IO space Stores                   -&gt;    938 0.001/cycle
 Istream IO fills                  -&gt;      2 0.000/cycle
 L2 fills to Dcache                -&gt;   8233 0.007/cycle
 L2 fills to Icache(all)           -&gt;    123 0.000/cycle
 L2 fills to Icache(prefetches)    -&gt;     68 0.000/cycle
</pre></div><p>Mostly self-explanatory. Some notes:</p>
<ul>
<li>"Loads" and "Stores" count the ones to L2/DRAM only</li>
<li>"Local Mem" is CVMSEG LM</li>
<li>"IO" is equivalent to non-cached</li>
<li>L2 fills to Icache(all) is the total number of icache fills. (prefetches) counts only the istream fills initiated by an istream prefetch</li>
</ul>
<div class="fragment"><pre class="fragment">
 Store WB entries to L2            -&gt;  13858 0.012/cycle
 Store WB entries to L2 timed out  -&gt;      0 0.000/cycle
 Store WB entries to L2 from loads -&gt;     14 0.000/cycle
</pre></div><p>The number of store write-buffer entries written by the core to the L2 cache. In this case, no write-buffer entries were evicted due to time outs, and only a small number were forced out by a load match.</p>
<div class="fragment"><pre class="fragment">
 Store dats to L2                  -&gt; 103853 0.090/cycle
</pre></div><p>The number of cycles used on the 128-bit store data bus by this core.</p>
<div class="fragment"><pre class="fragment">
 Store extra cycles                -&gt;      0 0.000/cycle
</pre></div><p>Ignore this. It is always zero.</p>
<div class="fragment"><pre class="fragment">
 Invalidates                       -&gt;      1 0.000/cycle
</pre></div><p>The number of invalidates recieved by the core.</p>
<div class="fragment"><pre class="fragment">
 2832 unique instructions issued.
</pre></div><p>Count of unique instructions.</p>
<div class="fragment"><pre class="fragment">
 Worst branch at pc=2000ca8c predicts=66073 mispredicts=7
 Worst jumpr  at pc=2000cc70 predicts=2 mispredicts=3
</pre></div><p>Indicates the branch and jump pc's that had the most mispredicts.</p>
<div class="fragment"><pre class="fragment">
 Icache had (28 33 32 30 ) 123 misses.
 Icache had (0 0 0 0 ) 0 replacements.
 Icache had (0 0 0 0 ) 0 fill invalidates.
 Icache had (0 0 0 0 ) 0 all invalidates.
</pre></div><p>The numbers in the () are for the sets inside the four different quadrants of the icache. The last number is total. misses = The number of misses replacement = The number of blocks that were valid when they were re-used fill invalidates = Ignore it. Should rarely happen. all invalidates = Counts the number of blocks whose valid bit was cleared due to an CACHE/SYNCI instruction invalidate or instruction address error.</p>
<div class="fragment"><pre class="fragment">
 Dcache had 8233 misses (repl=8172,hstall=0,lalias=0,salias=0,inv=1,fillinv=0,allinv=0,tlbinv=0,lmeminv=0).
</pre></div><p>repl = The number of blocks that were valid when they were re-used in the dcache. hstall = Ignore this. lalias = The number of loads that found an alias in the dcache. salias = The number of stores that found an alias in the dcache. inv+fillinv = The number of invalidates recieved. allinv = Counts the number of dcache blocks whose valid bit was cleared due to an CACHE instruction or Status[ERL] change. tlbinv = Counts the number of dcache blocks whose valid bit was cleared due to an eviction of a TLB entry. tlbinv = Counts the number of dcache blocks whose valid bit was cleared due to increasing the CVMSEG LM size.</p>
<div class="fragment"><pre class="fragment">
 -----------------------------------------------
 Total switch wait check issues = 8
 popular switch wait instructions
 -----------------------------------------------
    2 switch wait check issues at pc=0x2000139c
    2 switch wait check issues at pc=0x2000268c
    2 switch wait check issues at pc=0x200028f8
    2 switch wait check issues at pc=0x20001508
 -----------------------------------------------
</pre></div><p>Indicates the number of times that rdhwr $30 (i.e. ChOrd) instructions issued an where.</p>
<div class="fragment"><pre class="fragment">
 Total loads    issued -&gt;131738 Most frequent(16386) at pc=2000ced4
 Total stores   issued -&gt;208142 Most frequent(66080) at pc=2000ca90
 Total branches issued -&gt;102445 Most frequent(66080) at pc=2000ca8c
 Total jumps    issued -&gt;    67 Most frequent(10) at pc=20005618
 Total jumprs   issued -&gt;    69 Most frequent(10) at pc=2000db0c
 Total adds     issued -&gt;130398 Most frequent(66080) at pc=2000ca88
 Total logics   issued -&gt; 17470 Most frequent(16386) at pc=2000ceb8
 Total shifts   issued -&gt;  4354 Most frequent(2048) at pc=20005428
 Total cmovs    issued -&gt;    44 Most frequent(16) at pc=200053f0
 Total muldivs  issued -&gt;    28 Most frequent(2) at pc=20004d00
 Miscellaneous  issued -&gt;  1411 Most frequent(512) at pc=20003f0c
</pre></div><p>Totals of various instruction types, along with most frequent PC of each instruction type.</p>
<div class="fragment"><pre class="fragment">
 Cycle profiling by symbolic label.
 _wordcopy_fwd_aligned               890982 77.33%
 memset                              165470 14.36%
 setup_timer                          24580 2.13%
 setup_output_queue_tables             8273 0.72%
 ...
</pre></div><p>Tells you the routines that were running for the most time on the core.</p>
<h2><a class="anchor" id="system_statistics">
System performance statistics from the simulator</a></h2>
<div class="fragment"><pre class="fragment">
L2 cache results (3408689 core cycles, 500MHz core clock, 533MHz mem data rate, 128-bit interface, 0.006817 simulated seconds)
</pre></div><p>Tells the total number of core cycles in the simulation, and other information about the simulated configuration.</p>
<div class="fragment"><pre class="fragment">
 Istream L2 misses,missesnotl2,hits      -&gt;    123,0,0
</pre></div><p>123 istream misses on the CMB 0 istream misses that do not allocate into the L2 cache on the CMB 0 istream references that hit in the L2 cache</p>
<div class="fragment"><pre class="fragment">
 Dcache fill L2 misses,missesnotl2,hits  -&gt;   8216,0,31
</pre></div><p>Same as istream, but for dcache.</p>
<div class="fragment"><pre class="fragment">
 Memory fills                            -&gt;   8362 (utilization 5.800%)
 Memory writebacks + writethroughs       -&gt;   8337 (utilization 5.783%)
 Memory fill and write total             -&gt;  16699 (utilization 11.583%)
</pre></div><p>Raw counts of main memory reads and writes, plus main memory data bus utilization. The total utilization is unlikely to exceed 70%. (In this case, it is 11.6%.)</p>
<div class="fragment"><pre class="fragment">
 L2 store bus cycles                     -&gt; 103977 (utilization 9.015%)
</pre></div><p>The utilization of the 128-bit store data bus.</p>
<div class="fragment"><pre class="fragment">
 L2 address bus cycles                   -&gt;  25045 (utilization 2.172%, L2C ctl utilization 4.169%)
</pre></div><p>The utilization of the address bus, and the utilization of the L2 cache controller.</p>
<div class="fragment"><pre class="fragment">
 L2 fill bus cycles                      -&gt;  34483 (utilization 2.990%)
</pre></div><p>The utilization of the 256-bit fill bus.</p>
<div class="fragment"><pre class="fragment">
 IO stores,iobdmas,loads                 -&gt;    929,9,28
 DWB hits,misses                         -&gt;      6,2729
</pre></div><p>Counts of IO space operations, and of DWB (don't write back) operations.</p>
<div class="fragment"><pre class="fragment">
 L2 only hits,misses                     -&gt;      0,0
</pre></div><p>This refers to prefetches that put the block into the L2 only, without putting the block into the L1 cache.</p>
<div class="fragment"><pre class="fragment">
 LLM write insts                         -&gt;      0
 LLM reads interface 0                   -&gt;      0 (util 0.000%)
 LLM writes interface 0                  -&gt;      0 (util 0.000%)
 LLM reads interface 1                   -&gt;      0 (util 0.000%)
 LLM writes interface 1                  -&gt;      0 (util 0.000%)
</pre></div><p>Describes the accesses to the low-latency memory.</p>
<h3>Additional statistics available with "-modes=fullperf": </h3>
<div class="fragment"><pre class="fragment">
 L2 Per-Set Statistics
 ----------------------------------------
 0x000: memfills=          11 memfillsthru=           0 writebacks=          10 writethrus=           0
 0x001: memfills=          12 memfillsthru=           0 writebacks=          11 writethrus=           0
 0x002: memfills=          12 memfillsthru=           0 writebacks=          10 writethrus=           0
 0x003: memfills=           9 memfillsthru=           0 writebacks=           9 writethrus=           0
 0x004: memfills=           9 memfillsthru=           0 writebacks=           9 writethrus=           0
 ...
</pre></div><p>Indicates the individual statistics for each set in the L2 cache. memfills = reads of main memory into L2 memfillsthru = reads of main memory into L1 cache, but not L2 writebacks = the number of dirty blocks that were replaced writethrus = the number of full cache block writes that were not put into L2</p>
<div class="fragment"><pre class="fragment">
 DDR Per-Bank Statistics
 ----------------------------------------
 0: reads=        2091 writes=        2082
 1: reads=        2093 writes=        2082
 2: reads=        2092 writes=        2092
 3: reads=        2086 writes=        2081
</pre></div><p>Similar individual stats for each of the four main memory banks. </p>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Oct 2017 for Octeon Software Development Kit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
