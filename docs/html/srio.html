<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Octeon Software Development Kit: OCTEON II Serial RapidIO</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="srio">OCTEON II Serial RapidIO </a></h1><h2><a class="anchor" id="srio_intro">
1. Introduction</a></h2>
<p>The OCTEON II series of processors introduced support for Serial RapidIO (SRIO) to the OCTEON family. This document describes the Cavium Inc. API for programming SRIO under the simple executive environment, the Linux kernel, and Linux userspace. For the Linux APIs, Cavium built on top of the existing RapidIO subsystem, but was forced to modify the kernel's API to workaround limitations (kernel version 2.6.27.7). The Cavium specific changes are detailed under the sections describing the affected SRIO operations.</p>
<ul>
<li><a class="el" href="srio.html#srio_intro">1. Introduction</a></li>
<li><a class="el" href="srio.html#srio_maintenance">2. Maintenance Operations (RapidIO format type 8)</a></li>
<li><a class="el" href="srio.html#srio_memory">3. Memory Operations (RapidIO format type 2, 5, and 6)</a></li>
<li><a class="el" href="srio.html#srio_doorbell">4. Doorbells (RapidIO format type 10)</a></li>
<li><a class="el" href="srio.html#srio_port_writes">5. Port Writes (RapidIO format type 8)</a></li>
<li><a class="el" href="srio.html#srio_message">6. Packet Messages (RapidIO format type 11)</a></li>
<li><a class="el" href="srio.html#srio_enumeration">7. Discovery and Enumeration</a></li>
<li><a class="el" href="srio.html#srio_types">8. RapidIO Low Level Packet Types</a></li>
</ul>
<h2><a class="anchor" id="srio_maintenance">
2. Maintenance Operations (RapidIO format type 8)</a></h2>
<p>RapidIO uses "Maintenance" operations to configure the system. As defined the the RapidIO specification, these transactions must use multiples of 4 bytes and do not having guaranteed delivery.</p>
<h3><a class="anchor" id="srio_maintenance_kernel">
2.1. Linux kernel</a></h3>
<p>The Linux kernel exposes maintenance operations through the following functions:</p>
<ul>
<li>rio_mport_read_config_32()</li>
<li>rio_mport_write_config_32()</li>
<li>rio_local_read_config_32()</li>
<li>rio_local_write_config_32()</li>
<li>rio_read_config_32()</li>
<li>rio_write_config_32()</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>The kernel contains 8 and 16 bit access functions, but these violate the RapidIO specification. The 8 and 16 bit functions are not supported on OCTEON.</dd></dl>
<h4><a class="anchor" id="srio_maintenance_kernel_error">
2.1.1 Error recovery</a></h4>
<ul>
<li>Reads: Maintenance read operations that fails will return a non zero error code. Reads are synchronous such that the full operation has completed before the kernel's RapidIO function returns.</li>
</ul>
<ul>
<li>Writes: Maintenance write operations may fail either with a non zero error code, or log a kernel message. Write operations are asynchronous such that the full operation will not have completed before the kernel's RapidIO function returns. Errors that can be detected at submit will be returned as an error code. Errors that occur after the operation is submitted to the SRIO block will generate kernel log messages since these are after the calling function has already returned.</li>
</ul>
<h3><a class="anchor" id="srio_maintenance_userspace">
2.2. Linux userspace</a></h3>
<p>For applications running under userspace, the kernel exposes a 16MB window into the maintenance address space for every RapidIO device. Under "/sys/bus/rapidio/devices" the Linux kernel populates a directory tree representing the layout of the RapidIO system. Under the directory for each device is a file "config". Reads and writes to this file generate maintenance request to the device. Reads and writes must be 4 byte aligned and be in multiples of 4 bytes.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The current implementation of the RapidIO subsystem does not allow using the mmap() system call on this file.</dd></dl>
<h4><a class="anchor" id="srio_maintenance_userspace_error">
2.2.1 Error recovery</a></h4>
<ul>
<li>Reads: IO reads to the "config" file will return less bytes than requested when an error occurs. The return value from the "read" system call will be the number of bytes successfully read through the maintenance operation.</li>
</ul>
<ul>
<li>Writes: Where possible, writes to the "config" file will return the number of bytes successfully written. Errors that occur after the transaction is submitted to the SRIO block will generate kernel log messages since these are after the calling function has already returned.</li>
</ul>
<h3><a class="anchor" id="srio_maintenance_se">
2.3. Simple executive</a></h3>
<p>The simple executive supports two methods of generating maintenance request. These requests can be generated using either function calls or through physically mapped memory. The functions involved are:</p>
<ul>
<li><a class="el" href="cvmx-srio_8c.html#a4d424a4a18c0a5ec2066ffa5e1e20a36" title="Read 32bits from a Device&#39;s config space.">cvmx_srio_config_read32()</a></li>
<li><a class="el" href="cvmx-srio_8c.html#a9b617c1615a5c9e4689de5e0e200296b" title="Write 32bits to a Device&#39;s config space.">cvmx_srio_config_write32()</a></li>
<li><a class="el" href="cvmx-srio_8c.html#a5908f12c4365b3d395a2944afc62e7ae" title="Map a remote device&#39;s memory region into Octeon&#39;s physical address area.">cvmx_srio_physical_map()</a></li>
<li><a class="el" href="cvmx-srio_8c.html#afaf08026661bbf9ed5396f22e3af0d5a" title="Unmap a physical address window created by cvmx_srio_phys_map().">cvmx_srio_physical_unmap()</a></li>
</ul>
<p>The function <a class="el" href="cvmx-srio_8c.html#a5908f12c4365b3d395a2944afc62e7ae" title="Map a remote device&#39;s memory region into Octeon&#39;s physical address area.">cvmx_srio_physical_map()</a> can be used to gain a physical address to the remote RapidIO device. This physical address can then be passed to <a class="el" href="cvmx-access_8h.html#a9adf20d6b29145111460ecbc6fbca3dd" title="Convert a hardware physical address (uint64_t) into a memory pointer (void *).">cvmx_phys_to_ptr()</a> to generated a C pointer that directly generates maintenance requests. Memory mapped requests have the same limitations as functions calls, so they must be 4 byte aligned and in multiples of 4 byte widths.</p>
<h4><a class="anchor" id="srio_maintenance_se_error">
2.3.1 Error recovery</a></h4>
<ul>
<li>Reads through function: Maintenance read operations that fails will return a non zero error code. Reads are synchronous such that the full operation has completed before the function returns.</li>
</ul>
<ul>
<li>Reads through physical map: Reads using physically mapped memory will raise an asynchronous interrupt and return zero data. It is up the application to handle the interrupt properly. The default handler for the simple executive will print a message and continue.</li>
</ul>
<ul>
<li>Writes through function: Maintenance write operations may fail either with a non zero error code, or assert an error bit. Write operations are asynchronous such that the full operation will not have completed before the function returns. Errors that can be detected at submit will be returned as an error code. Errors that occur after the operation is submitted to the SRIO block will generate error bits since these are after the calling function has already returned.</li>
</ul>
<ul>
<li>Writes through physical map: Maintenance operation that fail while using physically mapped memory will not report errors.</li>
</ul>
<h2><a class="anchor" id="srio_memory">
3. Memory Operations (RapidIO format type 2, 5, and 6)</a></h2>
<p>RapidIO defines a rich set of memory based transactions supporting atomic access in addition to the more standard read/write model. Strict ordering of operations are not guaranteed unless proper synchronization barriers are implemented.</p>
<ul>
<li>Types of Reads<ul>
<li>NREAD - Normal reads</li>
<li>Atomic Test and swap</li>
<li>Atomic Swap</li>
<li>Atomic Compare and swap</li>
</ul>
</li>
<li>Types of Writes<ul>
<li>NWRITE - Normal writes</li>
<li>SWRITE - Streaming writes</li>
<li>NWRITE_R - Write with response</li>
<li>Atomic Set</li>
<li>Atomic Clear</li>
<li>Atomic Increment</li>
<li>Atomic Decrement</li>
</ul>
</li>
</ul>
<p>RapidIO memory transactions are guaranteed operations. Requests will be retried automatically by the hardware on failure. In the event the hardware is unable to issue the request, the failure mode varies based on if the operation is a read or write.</p>
<h3><a class="anchor" id="srio_memory_kernel">
3.1. Linux kernel</a></h3>
<p>The official Linux RapidIO subsystem does not support memory mapped transactions. Cavium Inc. has extended the kernel's RapidIO subsystem by adding the following functions for memory access:</p>
<ul>
<li>void *rio_map_memory(struct rio_dev *rdev, u64 offset, u64 length);</li>
<li>void rio_unmap_memory(struct rio_dev *rdev, u64 offset, u64 length, void *map);</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>The Linux kernel does not supply an interface to any of the atomic operations.</dd></dl>
<h4><a class="anchor" id="srio_memory_kernel_error">
3.1.1 Error recovery</a></h4>
<ul>
<li>Reads: The kernel pointer returned as part of mapping the resource will return zero data on failure conditions. An asynchronous error bit will assert and the kernel will display a message when an error occurs. Information about the first failed access will be logged.</li>
</ul>
<ul>
<li>Writes: On failure, writes are dropped by the SRIO subsystem. If the write fails in the link between OCTEON and the SRIO device connected directly to it, OCTEON will display a message on failure. This message will occur once all the retires for the write transaction fail. Information about the first failed access will be logged.</li>
</ul>
<h3><a class="anchor" id="srio_memory_userspace">
3.2. Linux userspace</a></h3>
<p>Cavium Inc. exposes the memory mapped functions available in the kernel through files under "/sys/bus/rapidio/devices". Similar to the "config" file, the kernel creates a file "memory" for each available RapidIO device. Each "memory" file represents the entire address space for a RapidIO device (2^34, 2^50, or 2^66 based on support addressing modes). These files support read and write and may support mmap() in the future.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Linux userspace does not supply an interface to any of the atomic operations.</dd></dl>
<h4><a class="anchor" id="srio_memory_userspace_error">
3.2.1 Error recovery</a></h4>
<ul>
<li>Reads: The read() system call will return the number of bytes successfully sent to the SRIO hardware. Reads that fail will return zero data and the kernel will log a message. No read status is returned to the userspace program.</li>
</ul>
<ul>
<li>Memory mapped reads: Reads that fail will return zero data and the kernel will log a message. No read status is returned to the userspace program.</li>
</ul>
<ul>
<li>Writes: Writes to the "memory" file will return the number of bytes successfully written to the SRIO hardware. Errors that occur after the transaction is submitted to the SRIO block will generate kernel log messages. No write status is returned to the userspace program.</li>
</ul>
<ul>
<li>Memory mapped writes: Memory mapped writes from userspace will not report failures. The kernel may log an error, but userspace will not receive any signals or other error notification. This is due to the asynchronous nature of writes.</li>
</ul>
<h3><a class="anchor" id="srio_memory_se">
3.3. Simple executive</a></h3>
<p>The simple executive supplies two functions for working with physical address addressing remote RapidIO devices. These functions are:</p>
<ul>
<li><a class="el" href="cvmx-srio_8c.html#a5908f12c4365b3d395a2944afc62e7ae" title="Map a remote device&#39;s memory region into Octeon&#39;s physical address area.">cvmx_srio_physical_map()</a></li>
<li><a class="el" href="cvmx-srio_8c.html#afaf08026661bbf9ed5396f22e3af0d5a" title="Unmap a physical address window created by cvmx_srio_phys_map().">cvmx_srio_physical_unmap()</a></li>
</ul>
<p>Unlike maintenance operations, memory mapped transactions do not have any alignment or size constraints.</p>
<h4><a class="anchor" id="srio_memory_se_error">
3.3.1 Error recovery</a></h4>
<ul>
<li>Reads: The pointer returned as part of mapping the resource will return zero data on failure conditions. An asynchronous error bit will assert and the executive will display a message when an error occurs. Information about the first failed access will be logged.</li>
</ul>
<ul>
<li>Writes: Maintenance operation that fail while using physically mapped memory will not report failures.</li>
</ul>
<h3><a class="anchor" id="srio_memory_dma">
3.4. DMA Operations</a></h3>
<p>In order for remote RapidIO devices to DMA in/out of OCTEON memory, the OCTEON BAR registers must be setup and the appropriate bus address must be given to the remote device.</p>
<p><b>TBD</b> </p>
<dl class="note"><dt><b>Note:</b></dt><dd>There is no guarantee that RapidIO bus address for DMAs correspond to internal OCTEON physical addresses. It is incorrect to pass an OCTEON physical address to a RapidIO device as a DMA source/destination.</dd></dl>
<h2><a class="anchor" id="srio_doorbell">
4. Doorbells (RapidIO format type 10)</a></h2>
<p>RapidIO allows devices to asynchronously send 16 bits of data to other devices using "doorbell" messages. These messages are similar to MSI interrupts over PCIe.</p>
<h3><a class="anchor" id="srio_doorbell_kernel">
4.1. Linux kernel</a></h3>
<p>The existing Linux RapidIO API for doorbells has been implemented. Below is a list of functions related to doorbells in the kernel.</p>
<ul>
<li>rio_send_doorbell()</li>
<li>rio_request_inb_dbell()</li>
<li>rio_release_inb_dbell()</li>
<li>rio_request_outb_dbell()</li>
<li>rio_release_outb_dbell()</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>The Linux kernel API does not have the ability to report doorbell failures back to the caller. The OCTEON SRIO implementation will log the failure, but the original requester will not know of a transmit doorbell failure.</dd></dl>
<h3><a class="anchor" id="srio_doorbell_userspace">
4.2. Linux userspace</a></h3>
<p>Doorbells are not exposed to userspace by the Linux RapidIO subsystem.</p>
<h3><a class="anchor" id="srio_doorbell_se">
4.3. Simple executive</a></h3>
<p>The following functions implement doorbells in the simple executive:</p>
<ul>
<li><a class="el" href="cvmx-srio_8c.html#a43fe5f9bae749dad4346676665ee019d" title="Send a RapidIO doorbell to a remote device.">cvmx_srio_send_doorbell()</a></li>
<li><a class="el" href="cvmx-srio_8c.html#a2642997f303900e85205f3debb856e44" title="Get the status of the last doorbell sent.">cvmx_srio_send_doorbell_status()</a></li>
<li><a class="el" href="cvmx-srio_8c.html#a925b6ca1880892dad43393f8a0b5c83c" title="Read a received doorbell and report data about it.">cvmx_srio_receive_doorbell()</a></li>
</ul>
<h2><a class="anchor" id="srio_port_writes">
5. Port Writes (RapidIO format type 8)</a></h2>
<p>Maintenance port write transactions are used by the SRIO system to communicate asynchronous error status. For example, switches are normally configured to issue port writes when a port link state changes. OCTEON supports sending and receiving these messages through the SRIO soft packet FIFO.</p>
<h3><a class="anchor" id="srio_port_writes_kernel">
5.1. Linux kernel</a></h3>
<p>Incomming port writes are forwarded to the RapidIO subsytem through the function rio_inb_pwrite_handler(). Cavium's support for port writes in the kernel was backported from pending RapidIO patches. The Linux kernel does not expose an interface for sending port writes.</p>
<h3><a class="anchor" id="srio_port_writes_userspace">
5.2. Linux userspace</a></h3>
<p>Port writes are not exposed to userspace by the Linux RapidIO subsystem.</p>
<h3><a class="anchor" id="srio_port_writes_se">
5.3. Simple executive</a></h3>
<p>Port writes can be sent from the simple executive using the same functions as used for memory access. Port writes are a special type of transaction, supported using the CVMX_SRIO_WRITE_MODE_PORT enumeration.</p>
<ul>
<li><a class="el" href="cvmx-srio_8c.html#a5908f12c4365b3d395a2944afc62e7ae" title="Map a remote device&#39;s memory region into Octeon&#39;s physical address area.">cvmx_srio_physical_map()</a></li>
<li><a class="el" href="cvmx-srio_8c.html#afaf08026661bbf9ed5396f22e3af0d5a" title="Unmap a physical address window created by cvmx_srio_phys_map().">cvmx_srio_physical_unmap()</a></li>
</ul>
<p>Ports writes are received from the SRIO soft FIFO. These messages can be read using the following function.</p>
<ul>
<li><a class="el" href="cvmx-srio_8c.html#ae993309ece65b5fa7eb8a8083fa5aee9" title="Receive a packet from the Soft Packet FIFO (SPF).">cvmx_srio_receive_spf()</a></li>
</ul>
<h2><a class="anchor" id="srio_message">
6. Packet Messages (RapidIO format type 11)</a></h2>
<p>A key benefit of RapidIO over PCIe is the ability to send arbitrary packetized data efficiently. RapidIO can send packets of up to 4096 bytes of data to another device with guaranteed delivery. Hardware automatically retries failures on messages similarly to TCP.</p>
<h3><a class="anchor" id="srio_message_kernel">
6.1. Linux kernel</a></h3>
<p>Cavium Inc. does not support the kernel's existing RapidIO messaging API. The API has a number of issues that cause performance problems as well as not exposing enough of RapidIO system features. For these reasons, Cavium Inc. supports RapidIO messaging through an ethernet device model. This is documented in the following section describing the userspace API.</p>
<h3><a class="anchor" id="srio_message_userspace">
6.2. Linux userspace</a></h3>
<p>Linux has an ethernet device for each of the four standard RapidIO mailboxes. With four mailboxes and two SRIO interfaces, the following ethernet interfaces are available through "ifconfig".</p>
<ul>
<li>rio0 = Interface 0, send/receive on mailbox 0</li>
<li>rio1 = Interface 0, send/receive on mailbox 1</li>
<li>rio2 = Interface 0, send/receive on mailbox 2</li>
<li>rio3 = Interface 0, send/receive on mailbox 3</li>
<li>rio4 = Interface 1, send/receive on mailbox 0</li>
<li>rio5 = Interface 1, send/receive on mailbox 1</li>
<li>rio6 = Interface 1, send/receive on mailbox 2</li>
<li>rio7 = Interface 1, send/receive on mailbox 3</li>
</ul>
<p>Since the RapidIO transport is different from the expected ethernet transport, these devices treat MAC addresses specially. Extra data describing the RapidIO message header fields is encoded into the destination MAC address. The format of the MAC address is:</p>
<table cellspacing="0" cellpadding="1" border="1">
<tr>
<th><p>Byte </p>
</th><th><p>Bits </p>
</th><th><p>Description  </p>
</th></tr>
<tr>
<td><p>0-3 </p>
</td><td><p>31:0 </p>
</td><td><p>Must be zero  </p>
</td></tr>
<tr>
<td><p>4-5 </p>
</td><td><p>15:0 </p>
</td><td><p>16bits for the SRIO destination ID.  </p>
</td></tr>
</table>
<p>RapidIO allows messages up to 4096 bytes, which is larger than what is allowed on the low level message transport. It is necessary for the underlying hardware to break these messages into individual segments. The size of each segment is controlled by a define in the Cavium Networks ethernet driver. Most systems will not need to adjust the default value, which is 256 bytes per segment (ssize=0xe). This allows the maximum messages size using 16 segments with 256 bytes each, totalling 4096 bytes.</p>
<h4><a class="anchor" id="srio_message_ioctl">
6.2.1. Network Device IOCTLs</a></h4>
<p>Additional control of SRIO messages are exposed through "netdev" IOCTLs. These IOCTLs are per network device and not application private. The supported IOCTLs are defined in <b>linux/include/asm/octeon/octeon-ethernet-user.h</b>. The list below is only for reference as "octeon-ethernet-user.h" is the official specification.</p>
<table cellspacing="0" cellpadding="1" border="1">
<tr>
<th><p>IOCTL Command </p>
</th><th><p>IOCTL Number </p>
</th><th><p>Description  </p>
</th></tr>
<tr>
<td><p>CAVIUM_NET_IOCTL_SETPRIO </p>
</td><td><p>0x89F0 </p>
</td><td><p>Sets the SRIO priority for all messages sent on this interface. Priority 0-3. Default is 0  </p>
</td></tr>
<tr>
<td><p>CAVIUM_NET_IOCTL_GETPRIO </p>
</td><td><p>0x89F1 </p>
</td><td><p>Gets the SRIO priority for all messages sent on this interface. Priority 0-3  </p>
</td></tr>
<tr>
<td><p>CAVIUM_NET_IOCTL_SETIDSIZE </p>
</td><td><p>0x89F2 </p>
</td><td><p>Sets the device ID size used for all packets on this interface. 0 = 8 bit, 1 = 16 bit IDs. Default is 1  </p>
</td></tr>
<tr>
<td><p>CAVIUM_NET_IOCTL_GETIDSIZE </p>
</td><td><p>0x89F3 </p>
</td><td><p>Gets the device ID size used for all packets on this interface. 0 = 8 bit, 1 = 16 bit IDs  </p>
</td></tr>
<tr>
<td><p>CAVIUM_NET_IOCTL_SETSRCID </p>
</td><td><p>0x89F4 </p>
</td><td><p>Sets which source ID is used for all packets on this interface. 0 = primary ID, 1 = secondary ID. Default is 0  </p>
</td></tr>
<tr>
<td><p>CAVIUM_NET_IOCTL_GETSRCID </p>
</td><td><p>0x89F5 </p>
</td><td><p>Gets which source ID is used for all packets on this interface. 0 = primary ID, 1 = secondary ID  </p>
</td></tr>
<tr>
<td><p>CAVIUM_NET_IOCTL_SETLETTER </p>
</td><td><p>0x89F6 </p>
</td><td><p>Sets the letter code used for all packets on this interface. Letter code 0-3, or -1 for auto. Default is -1  </p>
</td></tr>
<tr>
<td><p>CAVIUM_NET_IOCTL_GETLETTER </p>
</td><td><p>0x89F7 </p>
</td><td><p>Gets the letter code used for all packets on this interface. Letter code 0-3, or -1 for auto  </p>
</td></tr>
</table>
<dl class="note"><dt><b>Note:</b></dt><dd>The OCTEON Linux embedded root filesystem contains a command line utility for accessing these IOCTLs. The utility, <b>rio-control</b>, is found in /usr/sbin and its source is located in embedded_rootfs/source/rio-control.c.</dd></dl>
<h3><a class="anchor" id="srio_message_se">
6.3. Simple executive</a></h3>
<p>The simple executive doesn't expose an API specifically for generating RapidIO messages. Messages are handle by the normal OCTEON packet processing hardware, so they are treated similarly to ethernet packets. When generating packets for transmit using <a class="el" href="cvmx-pko_8h.html#a9417ad93d9e655b79e90456b2db5ab21" title="Complete packet output.">cvmx_pko_send_packet_finish()</a>, you must make sure the SRIO packet header is present at the beginning of the packet. On reception using <a class="el" href="cvmx-pow_8h.html#a663a32115088b6888949303edea06e5f" title="Synchronous work request.">cvmx_pow_work_request_sync()</a>, the SRIO receive packet header will always proceed the the packet data. Note the SRIO receive and transmit headers are different.</p>
<ul>
<li><a class="el" href="cvmx-pow_8h.html#a663a32115088b6888949303edea06e5f" title="Synchronous work request.">cvmx_pow_work_request_sync()</a></li>
<li><a class="el" href="cvmx-pow_8h.html#ab7f66e0dbe686746ec48dc25c7602645" title="Asynchronous work request.">cvmx_pow_work_request_async()</a></li>
<li><a class="el" href="cvmx-hwpko_8h.html#ac3816ce23cea85ff80bef465ad700bf8" title="Prepare to send a packet.">cvmx_pko_send_packet_prepare()</a></li>
<li><a class="el" href="cvmx-pko_8h.html#a9417ad93d9e655b79e90456b2db5ab21" title="Complete packet output.">cvmx_pko_send_packet_finish()</a></li>
<li><a class="el" href="cvmx-pko_8h.html#ad01aab1e0d6ab87ce4bbe64a371934ce" title="Complete packet output.">cvmx_pko_send_packet_finish3()</a></li>
<li>cvmx_srio_tx_message_header_t, the SRIO transmit header.</li>
<li>cvmx_srio_rx_message_header_t, the SRIO receive header.</li>
</ul>
<h2><a class="anchor" id="srio_enumeration">
7. Discovery and Enumeration</a></h2>
<p>The OCTEON SDK relies on the Linux kernel to perform RapidIO device discovery and enumeration. During initial boot the kernel's RapidIO subsystem will probe all OCTEON SRIO ports to discover what devices are available. Any RapidIO devices discovered will create device structures in the kernel and entries under "/sys/bus/rapidio/devices". Discovered devices that haven't had device IDs assigned will be enumerated into the system per part 7 of the RapidIO specification.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Devices with hard coded IDs, which violate the specification, will not be enumerated correctly. These devices will not be discovered nor enumerated.</dd></dl>
<h3><a class="anchor" id="srio_enumeration_switches">
7.1 SRIO switch driver</a></h3>
<p>Pending RapidIO patches from the Linux kernel for SRIO switches have been backported into Cavium's Linux kernel. These changes add support for a number of SRIO switch vendors. These drivers can be found in "drivers/rapidio/switches".</p>
<h3><a class="anchor" id="srio_enumeration_hotplug">
7.2 Adding and removing devices</a></h3>
<p><b>TBD</b> </p>
<h2><a class="anchor" id="srio_types">
8. RapidIO Low Level Packet Types</a></h2>
<p>The table below summarizes the APIs used to create the various RapidIO packet types.</p>
<table cellspacing="0" cellpadding="1" border="1">
<tr>
<th><p>Format Type </p>
</th><th><p>API Support  </p>
</th></tr>
<tr>
<td><p><a class="el" href="srio.html#srio_type_0">8.1 Type 0 Packet format (Implementation Defined)</a> </p>
</td><td><p>Not exposed by APIs  </p>
</td></tr>
<tr>
<td><p><a class="el" href="srio.html#srio_type_1">8.2 Type 1 Packet format (Reserved)</a> </p>
</td><td><p>-  </p>
</td></tr>
<tr>
<td><p><a class="el" href="srio.html#srio_type_2">8.3 Type 2 Packet format (Request Class)</a> </p>
</td><td><p><a class="el" href="srio.html#srio_memory">3. Memory Operations (RapidIO format type 2, 5, and 6)</a>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="srio.html#srio_type_3">8.4 Type 3 Packet format (Reserved)</a> </p>
</td><td><p>-  </p>
</td></tr>
<tr>
<td><p><a class="el" href="srio.html#srio_type_4">8.5 Type 4 Packet format (Reserved)</a> </p>
</td><td><p>-  </p>
</td></tr>
<tr>
<td><p><a class="el" href="srio.html#srio_type_5">8.6 Type 5 Packet format (Write class)</a> </p>
</td><td><p><a class="el" href="srio.html#srio_memory">3. Memory Operations (RapidIO format type 2, 5, and 6)</a>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="srio.html#srio_type_6">8.7 Type 6 Packet format (Streaming Write Class)</a> </p>
</td><td><p><a class="el" href="srio.html#srio_memory">3. Memory Operations (RapidIO format type 2, 5, and 6)</a>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="srio.html#srio_type_7">8.8 Type 7 Packet format (Reserved)</a> </p>
</td><td><p>-  </p>
</td></tr>
<tr>
<td><p><a class="el" href="srio.html#srio_type_8">8.9 Type 8 Packet format (Maintenance Class)</a> </p>
</td><td><p><a class="el" href="srio.html#srio_maintenance">2. Maintenance Operations (RapidIO format type 8)</a>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="srio.html#srio_type_9">8.10 Type 9 Packet format (Reserved)</a> </p>
</td><td><p>-  </p>
</td></tr>
<tr>
<td><p><a class="el" href="srio.html#srio_type_10">8.11 Type 10 Packet format (Doorbell Class)</a> </p>
</td><td><p><a class="el" href="srio.html#srio_doorbell">4. Doorbells (RapidIO format type 10)</a>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="srio.html#srio_type_11">8.12 Type 11 Packet format (Message Class)</a> </p>
</td><td><p><a class="el" href="srio.html#srio_message">6. Packet Messages (RapidIO format type 11)</a>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="srio.html#srio_type_12">8.13 Type 12 Packet format (Reserved)</a> </p>
</td><td><p>-  </p>
</td></tr>
<tr>
<td><p><a class="el" href="srio.html#srio_type_13">8.14 Type 13 Packet format (Response class)</a> </p>
</td><td><p>Implicit in support for the corresponding request  </p>
</td></tr>
<tr>
<td><p><a class="el" href="srio.html#srio_type_14">8.15 Type 14 Packet format (Reserved)</a> </p>
</td><td><p>-  </p>
</td></tr>
<tr>
<td><p><a class="el" href="srio.html#srio_type_15">8.16 Type 15 Packet format (Implementation Defined)</a> </p>
</td><td><p>Not exposed by APIs  </p>
</td></tr>
<tr>
<td><p>Multicast Event Control Symbol </p>
</td><td><p>Not exposed by APIs  </p>
</td></tr>
</table>
<h3><a class="anchor" id="srio_type_0">
8.1 Type 0 Packet format (Implementation Defined)</a></h3>
<p>This packet type is unused.</p>
<h3><a class="anchor" id="srio_type_1">
8.2 Type 1 Packet format (Reserved)</a></h3>
<p>This packet type is reserved.</p>
<h3><a class="anchor" id="srio_type_2">
8.3 Type 2 Packet format (Request Class)</a></h3>
<table cellspacing="0" cellpadding="1" border="1">
<tr>
<th><p>Layer </p>
</th><th><p>Bits </p>
</th><th><p>Name </p>
</th><th><p>Description  </p>
</th></tr>
<tr>
<td rowspan="4"><p>SRIO </p>
</td><td><p>5 </p>
</td><td><p>ackID </p>
</td><td><p>Acknowledge ID  </p>
</td></tr>
<tr>
<td><p>2 </p>
</td><td><p>reserved </p>
</td><td><p>Reserved  </p>
</td></tr>
<tr>
<td><p>1 </p>
</td><td><p>CRF </p>
</td><td><p>Critical Request Flow (Not supported)  </p>
</td></tr>
<tr>
<td><p>2 </p>
</td><td><p>prio </p>
</td><td><p>Packet priority. 0 = lowest, 3 = highest  </p>
</td></tr>
<tr>
<td><p>Transport </p>
</td><td><p>2 </p>
</td><td><p>tt </p>
</td><td><ul>
<li>0 8-bit deviceID fields</li>
<li>1 16-bit deviceID fields</li>
<li>2-3 Reserved  </li>
</ul>
</td></tr>
<tr>
<td><p>Logical </p>
</td><td><p>4 </p>
</td><td><p>ftype </p>
</td><td><p>Format type = 0x2  </p>
</td></tr>
<tr>
<td rowspan="2"><p>Transport </p>
</td><td><p>8/16 </p>
</td><td><p>destinationID </p>
</td><td><p>Destination ID  </p>
</td></tr>
<tr>
<td><p>8/16 </p>
</td><td><p>sourceID </p>
</td><td><p>Source ID  </p>
</td></tr>
<tr>
<td rowspan="7"><p>Logical </p>
</td><td><p>4 </p>
</td><td><p>transaction </p>
</td><td><ul>
<li>0b0000-0011 Reserved</li>
<li>0b0100 NREAD transaction</li>
<li>0b0101-1011 Reserved</li>
<li>0b1100 ATOMIC inc: post-increment the data</li>
<li>0b1101 ATOMIC dec: post-decrement the data</li>
<li>0b1110 ATOMIC set: set the data (write 0b11111...')</li>
<li>0b1111 ATOMIC clr: clear the data (write 0b00000...')  </li>
</ul>
</td></tr>
<tr>
<td><p>4 </p>
</td><td><p>rdsize </p>
</td><td><p>Read Size  </p>
</td></tr>
<tr>
<td><p>8 </p>
</td><td><p>srcTID </p>
</td><td><p>Source Tag ID to pair request and response  </p>
</td></tr>
<tr>
<td><p>0/16/32 </p>
</td><td><p>extended address </p>
</td><td><p>Bits[47:32]/Bits[63:32]  </p>
</td></tr>
<tr>
<td><p>29 </p>
</td><td><p>address </p>
</td><td><p>Bits[31:3], Address with last three bits missing  </p>
</td></tr>
<tr>
<td><p>1 </p>
</td><td><p>wdptr </p>
</td><td><p>Word pointer. Used with rdsize/wrsize  </p>
</td></tr>
<tr>
<td><p>2 </p>
</td><td><p>xamsbs </p>
</td><td><p>Bits[33:32]/Bits[49:48]/Bits[65:64]  </p>
</td></tr>
<tr>
<td><p>SRIO </p>
</td><td><p>16 </p>
</td><td><p>CRC </p>
</td><td><p>Cyclic Redundancy Code  </p>
</td></tr>
</table>
<h3><a class="anchor" id="srio_type_3">
8.4 Type 3 Packet format (Reserved)</a></h3>
<p>This packet type is reserved.</p>
<h3><a class="anchor" id="srio_type_4">
8.5 Type 4 Packet format (Reserved)</a></h3>
<p>This packet type is reserved.</p>
<h3><a class="anchor" id="srio_type_5">
8.6 Type 5 Packet format (Write class)</a></h3>
<table cellspacing="0" cellpadding="1" border="1">
<tr>
<th><p>Layer </p>
</th><th><p>Bits </p>
</th><th><p>Name </p>
</th><th><p>Description  </p>
</th></tr>
<tr>
<td rowspan="4"><p>SRIO </p>
</td><td><p>5 </p>
</td><td><p>ackID </p>
</td><td><p>Acknowledge ID  </p>
</td></tr>
<tr>
<td><p>2 </p>
</td><td><p>reserved </p>
</td><td><p>Reserved  </p>
</td></tr>
<tr>
<td><p>1 </p>
</td><td><p>CRF </p>
</td><td><p>Critical Request Flow (Not supported)  </p>
</td></tr>
<tr>
<td><p>2 </p>
</td><td><p>prio </p>
</td><td><p>Packet priority. 0 = lowest, 3 = highest  </p>
</td></tr>
<tr>
<td><p>Transport </p>
</td><td><p>2 </p>
</td><td><p>tt </p>
</td><td><ul>
<li>0 8-bit deviceID fields</li>
<li>1 16-bit deviceID fields</li>
<li>2-3 Reserved  </li>
</ul>
</td></tr>
<tr>
<td><p>Logical </p>
</td><td><p>4 </p>
</td><td><p>ftype </p>
</td><td><p>Format type = 0x5  </p>
</td></tr>
<tr>
<td rowspan="2"><p>Transport </p>
</td><td><p>8/16 </p>
</td><td><p>destinationID </p>
</td><td><p>Destination ID  </p>
</td></tr>
<tr>
<td><p>8/16 </p>
</td><td><p>sourceID </p>
</td><td><p>Source ID  </p>
</td></tr>
<tr>
<td rowspan="8"><p>Logical </p>
</td><td><p>4 </p>
</td><td><p>transaction </p>
</td><td><ul>
<li>0b0000-0011 Reserved</li>
<li>0b0100 NWRITE</li>
<li>0b0101 NWRITE_R</li>
<li>0b0110-1011 Reserved</li>
<li>0b1100 ATOMIC swap</li>
<li>0b1101 ATOMIC compare-and-swap</li>
<li>0b1110 ATOMIC test-and-swap</li>
<li>0b1111 Reserved  </li>
</ul>
</td></tr>
<tr>
<td><p>4 </p>
</td><td><p>wrsize </p>
</td><td><p>Write Size  </p>
</td></tr>
<tr>
<td><p>8 </p>
</td><td><p>srcTID </p>
</td><td><p>Source Tag ID to pair request and response  </p>
</td></tr>
<tr>
<td><p>0/16/32 </p>
</td><td><p>extended address </p>
</td><td><p>Bits[47:32]/Bits[63:32]  </p>
</td></tr>
<tr>
<td><p>29 </p>
</td><td><p>address </p>
</td><td><p>Bits[31:3], Address with last three bits missing  </p>
</td></tr>
<tr>
<td><p>1 </p>
</td><td><p>wdptr </p>
</td><td><p>Word pointer. Used with rdsize/wrsize  </p>
</td></tr>
<tr>
<td><p>2 </p>
</td><td><p>xamsbs </p>
</td><td><p>Bits[33:32]/Bits[49:48]/Bits[65:64]  </p>
</td></tr>
<tr>
<td><p>? </p>
</td><td><p>data </p>
</td><td><p>Write data  </p>
</td></tr>
<tr>
<td><p>SRIO </p>
</td><td><p>16 </p>
</td><td><p>CRC </p>
</td><td><p>Cyclic Redundancy Code  </p>
</td></tr>
</table>
<h3><a class="anchor" id="srio_type_6">
8.7 Type 6 Packet format (Streaming Write Class)</a></h3>
<table cellspacing="0" cellpadding="1" border="1">
<tr>
<th><p>Layer </p>
</th><th><p>Bits </p>
</th><th><p>Name </p>
</th><th><p>Description  </p>
</th></tr>
<tr>
<td rowspan="4"><p>SRIO </p>
</td><td><p>5 </p>
</td><td><p>ackID </p>
</td><td><p>Acknowledge ID  </p>
</td></tr>
<tr>
<td><p>2 </p>
</td><td><p>reserved </p>
</td><td><p>Reserved  </p>
</td></tr>
<tr>
<td><p>1 </p>
</td><td><p>CRF </p>
</td><td><p>Critical Request Flow (Not supported)  </p>
</td></tr>
<tr>
<td><p>2 </p>
</td><td><p>prio </p>
</td><td><p>Packet priority. 0 = lowest, 3 = highest  </p>
</td></tr>
<tr>
<td><p>Transport </p>
</td><td><p>2 </p>
</td><td><p>tt </p>
</td><td><ul>
<li>0 8-bit deviceID fields</li>
<li>1 16-bit deviceID fields</li>
<li>2-3 Reserved  </li>
</ul>
</td></tr>
<tr>
<td><p>Logical </p>
</td><td><p>4 </p>
</td><td><p>ftype </p>
</td><td><p>Format type = 0x6  </p>
</td></tr>
<tr>
<td rowspan="2"><p>Transport </p>
</td><td><p>8/16 </p>
</td><td><p>destinationID </p>
</td><td><p>Destination ID  </p>
</td></tr>
<tr>
<td><p>8/16 </p>
</td><td><p>sourceID </p>
</td><td><p>Source ID  </p>
</td></tr>
<tr>
<td rowspan="8"><p>Logical </p>
</td><td><p>4 </p>
</td><td><p>transaction </p>
</td><td><ul>
<li>0b0000-0011 Reserved</li>
<li>0b0100 NWRITE</li>
<li>0b0101 NWRITE_R</li>
<li>0b0110-1011 Reserved</li>
<li>0b1100 ATOMIC swap</li>
<li>0b1101 ATOMIC compare-and-swap</li>
<li>0b1110 ATOMIC test-and-swap</li>
<li>0b1111 Reserved  </li>
</ul>
</td></tr>
<tr>
<td><p>4 </p>
</td><td><p>wrsize </p>
</td><td><p>Write Size  </p>
</td></tr>
<tr>
<td><p>8 </p>
</td><td><p>srcTID </p>
</td><td><p>Source Tag ID to pair request and response  </p>
</td></tr>
<tr>
<td><p>0/16/32 </p>
</td><td><p>extended address </p>
</td><td><p>Bits[47:32]/Bits[63:32]  </p>
</td></tr>
<tr>
<td><p>29 </p>
</td><td><p>address </p>
</td><td><p>Bits[31:3], Address with last three bits missing  </p>
</td></tr>
<tr>
<td><p>1 </p>
</td><td><p>reserved </p>
</td><td><p>Reserved  </p>
</td></tr>
<tr>
<td><p>2 </p>
</td><td><p>xamsbs </p>
</td><td><p>Bits[33:32]/Bits[49:48]/Bits[65:64]  </p>
</td></tr>
<tr>
<td><p>64*n </p>
</td><td><p>data </p>
</td><td><p>Write data  </p>
</td></tr>
<tr>
<td><p>SRIO </p>
</td><td><p>16 </p>
</td><td><p>CRC </p>
</td><td><p>Cyclic Redundancy Code  </p>
</td></tr>
</table>
<h3><a class="anchor" id="srio_type_7">
8.8 Type 7 Packet format (Reserved)</a></h3>
<p>This packet type is reserved.</p>
<h3><a class="anchor" id="srio_type_8">
8.9 Type 8 Packet format (Maintenance Class)</a></h3>
<table cellspacing="0" cellpadding="1" border="1">
<tr>
<th><p>Layer </p>
</th><th><p>Bits </p>
</th><th><p>Name </p>
</th><th><p>Description  </p>
</th></tr>
<tr>
<td rowspan="4"><p>SRIO </p>
</td><td><p>5 </p>
</td><td><p>ackID </p>
</td><td><p>Acknowledge ID  </p>
</td></tr>
<tr>
<td><p>2 </p>
</td><td><p>reserved </p>
</td><td><p>Reserved  </p>
</td></tr>
<tr>
<td><p>1 </p>
</td><td><p>CRF </p>
</td><td><p>Critical Request Flow (Not supported)  </p>
</td></tr>
<tr>
<td><p>2 </p>
</td><td><p>prio </p>
</td><td><p>Packet priority. 0 = lowest, 3 = highest  </p>
</td></tr>
<tr>
<td><p>Transport </p>
</td><td><p>2 </p>
</td><td><p>tt </p>
</td><td><ul>
<li>0 8-bit deviceID fields</li>
<li>1 16-bit deviceID fields</li>
<li>2-3 Reserved  </li>
</ul>
</td></tr>
<tr>
<td><p>Logical </p>
</td><td><p>4 </p>
</td><td><p>ftype </p>
</td><td><p>Format type = 0x8  </p>
</td></tr>
<tr>
<td rowspan="2"><p>Transport </p>
</td><td><p>8/16 </p>
</td><td><p>destinationID </p>
</td><td><p>Destination ID  </p>
</td></tr>
<tr>
<td><p>8/16 </p>
</td><td><p>sourceID </p>
</td><td><p>Source ID  </p>
</td></tr>
<tr>
<td rowspan="7"><p>Logical </p>
</td><td><p>4 </p>
</td><td><p>transaction </p>
</td><td><ul>
<li>0b0000 Specifies a maintenance read request</li>
<li>0b0001 Specifies a maintenance write request</li>
<li>0b0010 Specifies a maintenance read response</li>
<li>0b0011 Specifies a maintenance write response</li>
<li>0b0100 Specifies a maintenance port-write request</li>
<li>0b0101-1111 Reserved  </li>
</ul>
</td></tr>
<tr>
<td><p>4 </p>
</td><td><p>rdsize/wrsize </p>
</td><td><p>Read/Write Size  </p>
</td></tr>
<tr>
<td><p>8 </p>
</td><td><p>srcTID </p>
</td><td><p>Source Tag ID to pair request and response  </p>
</td></tr>
<tr>
<td><p>8 </p>
</td><td><p>hopcount </p>
</td><td><p>Number of hops to the device  </p>
</td></tr>
<tr>
<td><p>21 </p>
</td><td><p>config offset </p>
</td><td><p>Double-word offset into the CAR/CSR register block for reads and writes  </p>
</td></tr>
<tr>
<td><p>1 </p>
</td><td><p>wdptr </p>
</td><td><p>Word pointer. Used with rdsize/wrsize  </p>
</td></tr>
<tr>
<td><p>2 </p>
</td><td><p>reserved </p>
</td><td><p>Reserved  </p>
</td></tr>
<tr>
<td><p>64*n </p>
</td><td><p>data </p>
</td><td><p>Read/Write data  </p>
</td></tr>
<tr>
<td><p>SRIO </p>
</td><td><p>16 </p>
</td><td><p>CRC </p>
</td><td><p>Cyclic Redundancy Code  </p>
</td></tr>
</table>
<h3><a class="anchor" id="srio_type_9">
8.10 Type 9 Packet format (Reserved)</a></h3>
<p>This packet type is reserved.</p>
<h3><a class="anchor" id="srio_type_10">
8.11 Type 10 Packet format (Doorbell Class)</a></h3>
<table cellspacing="0" cellpadding="1" border="1">
<tr>
<th><p>Layer </p>
</th><th><p>Bits </p>
</th><th><p>Name </p>
</th><th><p>Description  </p>
</th></tr>
<tr>
<td rowspan="4"><p>SRIO </p>
</td><td><p>5 </p>
</td><td><p>ackID </p>
</td><td><p>Acknowledge ID  </p>
</td></tr>
<tr>
<td><p>2 </p>
</td><td><p>reserved </p>
</td><td><p>Reserved  </p>
</td></tr>
<tr>
<td><p>1 </p>
</td><td><p>CRF </p>
</td><td><p>Critical Request Flow (Not supported)  </p>
</td></tr>
<tr>
<td><p>2 </p>
</td><td><p>prio </p>
</td><td><p>Packet priority. 0 = lowest, 3 = highest  </p>
</td></tr>
<tr>
<td><p>Transport </p>
</td><td><p>2 </p>
</td><td><p>tt </p>
</td><td><ul>
<li>0 8-bit deviceID fields</li>
<li>1 16-bit deviceID fields</li>
<li>2-3 Reserved  </li>
</ul>
</td></tr>
<tr>
<td><p>Logical </p>
</td><td><p>4 </p>
</td><td><p>ftype </p>
</td><td><p>Format type = 0xa  </p>
</td></tr>
<tr>
<td rowspan="2"><p>Transport </p>
</td><td><p>8/16 </p>
</td><td><p>destinationID </p>
</td><td><p>Destination ID  </p>
</td></tr>
<tr>
<td><p>8/16 </p>
</td><td><p>sourceID </p>
</td><td><p>Source ID  </p>
</td></tr>
<tr>
<td rowspan="3"><p>Message </p>
</td><td><p>8 </p>
</td><td><p>reserved </p>
</td><td><p>Reserved  </p>
</td></tr>
<tr>
<td><p>8 </p>
</td><td><p>srcTID </p>
</td><td><p>Source Tag ID to pair request and response  </p>
</td></tr>
<tr>
<td><p>16 </p>
</td><td><p>info </p>
</td><td><p>Info data payload for doorbell  </p>
</td></tr>
<tr>
<td><p>SRIO </p>
</td><td><p>16 </p>
</td><td><p>CRC </p>
</td><td><p>Cyclic Redundancy Code  </p>
</td></tr>
</table>
<h3><a class="anchor" id="srio_type_11">
8.12 Type 11 Packet format (Message Class)</a></h3>
<table cellspacing="0" cellpadding="1" border="1">
<tr>
<th><p>Layer </p>
</th><th><p>Bits </p>
</th><th><p>Name </p>
</th><th><p>Description  </p>
</th></tr>
<tr>
<td rowspan="4"><p>SRIO </p>
</td><td><p>5 </p>
</td><td><p>ackID </p>
</td><td><p>Acknowledge ID  </p>
</td></tr>
<tr>
<td><p>2 </p>
</td><td><p>reserved </p>
</td><td><p>Reserved  </p>
</td></tr>
<tr>
<td><p>1 </p>
</td><td><p>CRF </p>
</td><td><p>Critical Request Flow (Not supported)  </p>
</td></tr>
<tr>
<td><p>2 </p>
</td><td><p>prio </p>
</td><td><p>Packet priority. 0 = lowest, 3 = highest  </p>
</td></tr>
<tr>
<td><p>Transport </p>
</td><td><p>2 </p>
</td><td><p>tt </p>
</td><td><ul>
<li>0 8-bit deviceID fields</li>
<li>1 16-bit deviceID fields</li>
<li>2-3 Reserved  </li>
</ul>
</td></tr>
<tr>
<td><p>Logical </p>
</td><td><p>4 </p>
</td><td><p>ftype </p>
</td><td><p>Format type = 0xb  </p>
</td></tr>
<tr>
<td rowspan="2"><p>Transport </p>
</td><td><p>8/16 </p>
</td><td><p>destinationID </p>
</td><td><p>Destination ID  </p>
</td></tr>
<tr>
<td><p>8/16 </p>
</td><td><p>sourceID </p>
</td><td><p>Source ID  </p>
</td></tr>
<tr>
<td rowspan="6"><p>Message </p>
</td><td><p>4 </p>
</td><td><p>msglen </p>
</td><td><p>Message length in segments. 0=1 segment  </p>
</td></tr>
<tr>
<td><p>4 </p>
</td><td><p>ssize </p>
</td><td><p>Segment size  </p>
</td></tr>
<tr>
<td><p>2 </p>
</td><td><p>letter </p>
</td><td><p>Mailbox letter code  </p>
</td></tr>
<tr>
<td><p>2 </p>
</td><td><p>mbox </p>
</td><td><p>Mailbox number  </p>
</td></tr>
<tr>
<td><p>4 </p>
</td><td><p>msgseg/xmbox </p>
</td><td><p>Message segment number or extended mailbox number  </p>
</td></tr>
<tr>
<td><p>64*n </p>
</td><td><p>data </p>
</td><td><p>Message payload  </p>
</td></tr>
<tr>
<td><p>SRIO </p>
</td><td><p>16 </p>
</td><td><p>CRC </p>
</td><td><p>Cyclic Redundancy Code  </p>
</td></tr>
</table>
<h3><a class="anchor" id="srio_type_12">
8.13 Type 12 Packet format (Reserved)</a></h3>
<p>This packet type is reserved.</p>
<h3><a class="anchor" id="srio_type_13">
8.14 Type 13 Packet format (Response class)</a></h3>
<table cellspacing="0" cellpadding="1" border="1">
<tr>
<th><p>Layer </p>
</th><th><p>Bits </p>
</th><th><p>Name </p>
</th><th><p>Description  </p>
</th></tr>
<tr>
<td rowspan="4"><p>SRIO </p>
</td><td><p>5 </p>
</td><td><p>ackID </p>
</td><td><p>Acknowledge ID  </p>
</td></tr>
<tr>
<td><p>2 </p>
</td><td><p>reserved </p>
</td><td><p>Reserved  </p>
</td></tr>
<tr>
<td><p>1 </p>
</td><td><p>CRF </p>
</td><td><p>Critical Request Flow (Not supported)  </p>
</td></tr>
<tr>
<td><p>2 </p>
</td><td><p>prio </p>
</td><td><p>Packet priority. 0 = lowest, 3 = highest  </p>
</td></tr>
<tr>
<td><p>Transport </p>
</td><td><p>2 </p>
</td><td><p>tt </p>
</td><td><ul>
<li>0 8-bit deviceID fields</li>
<li>1 16-bit deviceID fields</li>
<li>2-3 Reserved  </li>
</ul>
</td></tr>
<tr>
<td><p>Logical </p>
</td><td><p>4 </p>
</td><td><p>ftype </p>
</td><td><p>Format type = 0xd  </p>
</td></tr>
<tr>
<td rowspan="2"><p>Transport </p>
</td><td><p>8/16 </p>
</td><td><p>destinationID </p>
</td><td><p>Destination ID  </p>
</td></tr>
<tr>
<td><p>8/16 </p>
</td><td><p>sourceID </p>
</td><td><p>Source ID  </p>
</td></tr>
<tr>
<td rowspan="4"><p>Logical </p>
</td><td><p>4 </p>
</td><td><p>transaction </p>
</td><td><ul>
<li>0b0000 RESPONSE transaction with no data payload</li>
<li>0b0001 MESSAGE RESPONSE</li>
<li>0b0002-0111 Reserved</li>
<li>0b1000 RESPONSE transaction with data payload</li>
<li>0b1001-1111 Reserved  </li>
</ul>
</td></tr>
<tr>
<td><p>4 </p>
</td><td><p>status </p>
</td><td><ul>
<li>0b0000 DONE</li>
<li>0b0001-0010 Reserved</li>
<li>0b0011 RETRY</li>
<li>0b0100-0110 Reserved</li>
<li>0b0111 ERROR</li>
<li>0b1000-1011 Reserved</li>
<li>0b1100-1111 Implementation defined  </li>
</ul>
</td></tr>
<tr>
<td><p>8 </p>
</td><td><p>targetTID/targetInfo </p>
</td><td><p>Target Tag ID to pair request and response.<br/>
 Messages use letter|mbox|msgseg.  </p>
</td></tr>
<tr>
<td><p>64*n </p>
</td><td><p>data </p>
</td><td><p>Response data  </p>
</td></tr>
<tr>
<td><p>SRIO </p>
</td><td><p>16 </p>
</td><td><p>CRC </p>
</td><td><p>Cyclic Redundancy Code  </p>
</td></tr>
</table>
<h3><a class="anchor" id="srio_type_14">
8.15 Type 14 Packet format (Reserved)</a></h3>
<p>This packet type is reserved.</p>
<h3><a class="anchor" id="srio_type_15">
8.16 Type 15 Packet format (Implementation Defined)</a></h3>
<p>This packet type is unused. </p>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Oct 2017 for Octeon Software Development Kit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
