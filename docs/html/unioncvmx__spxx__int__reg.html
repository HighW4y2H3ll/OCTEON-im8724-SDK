<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Octeon Software Development Kit: cvmx_spxx_int_reg Union Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cvmx_spxx_int_reg Union Reference</h1><!-- doxytag: class="cvmx_spxx_int_reg" -->
<p>cvmx_spx::_int_reg  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cvmx-spxx-defs_8h_source.html">cvmx-spxx-defs.h</a>&gt;</code></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcvmx__spxx__int__reg_1_1cvmx__spxx__int__reg__s.html">cvmx_spxx_int_reg_s</a></td></tr>
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unioncvmx__spxx__int__reg.html#ac20a599535fd775ca54a397215b6d903">u64</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <br class="typebreak"/>
<a class="el" href="structcvmx__spxx__int__reg_1_1cvmx__spxx__int__reg__s.html">cvmx_spxx_int_reg::cvmx_spxx_int_reg_s</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unioncvmx__spxx__int__reg.html#a0ca8e2e45b4492c55f5644b9981bc9ef">s</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcvmx__spxx__int__reg_1_1cvmx__spxx__int__reg__s.html">cvmx_spxx_int_reg_s</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unioncvmx__spxx__int__reg.html#ae7a5c8a10af0759fda2ed161d739a34e">cn38xx</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcvmx__spxx__int__reg_1_1cvmx__spxx__int__reg__s.html">cvmx_spxx_int_reg_s</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unioncvmx__spxx__int__reg.html#a22c4a897d5c138e7ad32e5b0af1a8b42">cn38xxp2</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcvmx__spxx__int__reg_1_1cvmx__spxx__int__reg__s.html">cvmx_spxx_int_reg_s</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unioncvmx__spxx__int__reg.html#ac8eab6e4c61ae7d7baa3ab5ac494853b">cn58xx</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcvmx__spxx__int__reg_1_1cvmx__spxx__int__reg__s.html">cvmx_spxx_int_reg_s</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unioncvmx__spxx__int__reg.html#a66fab3c2bcfae28b8b9ba6365a34487d">cn58xxp1</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>cvmx_spx::_int_reg </p>
<p>SPX_INT_REG - Interrupt Register</p>
<p>Notes: * PRTNXA This error indicates that the port on the Spi bus was not a valid port for the system. Spi4 accesses occur on payload control bit-times. The SRX can be configured with the exact number of ports available (by SRX_COM_CTL[PRTS] register). Any Spi access to anthing outside the range of 0 .. (SRX_COM_CTL[PRTS] - 1) is considered an error. The offending port is logged in SPX_INT_DAT[PRT] if there are no pending interrupts in SPX_INT_REG that require SPX_INT_DAT[PRT].</p>
<p>SRX will not drop the packet with the bogus port address. Instead, the port will be mapped into the supported port range. The remapped address in simply...</p>
<p>Address = [ interfaceId, ADR[3:0] ]</p>
<p>If the SPX detects that a PRTNXA error has occured, the packet will have its ERR bit set (or'ed in with the ERR bit from the transmitter) if the SPX_ERR_CTL[PRTNXA] bit is clear.</p>
<p>In Spi4 mode, SPX will generate an interrupt for every 8B data burst associated with the invalid address. The SPX_INT_DAT[MUL] bit will never be set.</p>
<p>* ABNORM This bit simply indicates that a given packet had abnormal terminiation. In Spi4 mode, this means that packet completed with an EOPS[1:0] code of 2'b01. This error can also be thought of as the application specific error (as mentioned in the Spi4 spec). The offending port is logged in SPX_INT_DAT[PRT] if there are no pending interrupts in SPX_INT_REG that require SPX_INT_DAT[PRT].</p>
<p>The ABNORM error is only raised when the ERR bit that comes from the Spi interface is set. It will never assert if any internal condition causes the ERR bit to assert (e.g. PRTNXA or DPERR).</p>
<p>* SPIOVR This error indicates that the FIFOs that manage the async crossing from the Spi clocks to the core clock domains have overflowed. This is a fatal error and can cause much data/control corruption since ticks will be dropped and reordered. This is purely a function of clock ratios and correct system ratios should make this an impossible condition.</p>
<p>* CLSERR This is a Spi4 error that indicates that a given data transfer burst that did not terminate with an EOP, did not end with the 16B alignment as per the Spi4 spec. The offending port cannot be logged since the block does not know the streamm terminated until the port switches. At that time, that packet has already been pushed down the pipe.</p>
<p>The CLSERR bit does not actually check the Spi4 burst - just how data is accumulated for the downstream logic. Bursts that are separted by idles or training will still be merged into accumulated transfers and will not fire the CLSERR condition. The checker is really checking non-8B aligned, non-EOP data ticks that are sent downstream. These ticks are what will really mess up the core.</p>
<p>This is an expensive fix, so we'll probably let it ride. We never claim to check Spi4 protocol anyway.</p>
<p>* DRWNNG This error indicates that the Spi4 FIFO that services the GMX has overflowed. Like the SPIOVR error condition, correct system ratios should make this an impossible condition.</p>
<p>* RSVERR This Spi4 error indicates that the Spi4 receiver has seen a reserve control packet. A reserve control packet is an invalid combiniation of bits on DAT[15:12]. Basically this is DAT[15] == 1'b0 and DAT[12] == 1'b1 (an SOP without a payload command). The RSVERR indicates an error has occured and SPX_INT_DAT[RSVOP] holds the first reserved opcode and will be set if there are no pending interrupts in SPX_INT_REG that require SPX_INT_DAT[RSVOP].</p>
<p>* TPAOVR This bit indicates that the TPA Watcher has flagged an event. See the TPA Watcher for a more detailed discussion.</p>
<p>* DIPERR This bit indicates that the Spi4 receiver has encountered a DIP4 miscompare on the datapath. A DIPERR can occur in an IDLE or a control word that frames a data burst. If the DIPERR occurs on a framing word there are three cases.</p>
<p>1) DIPERR occurs at the end of a data burst. The previous packet is marked with the ERR bit to be processed later if SPX_ERR_CTL[DIPCLS] is clear. 2) DIPERR occurs on a payload word. The subsequent packet is marked with the ERR bit to be processed later if SPX_ERR_CTL[DIPPAY] is clear. 3) DIPERR occurs on a control word that closes on packet and is a payload for another packet. In this case, both packets will have their ERR bit marked depending on the respective values of SPX_ERR_CTL[DIPCLS] and SPX_ERR_CTL[DIPPAY] as discussed above.</p>
<p>* SYNCERR This bit indicates that the Spi4 receiver has encountered SPX_ERR_CTL[ERRCNT] consecutive Spi4 DIP4 errors and the interface should be synched.</p>
<p>* CALERR This bit indicates that the Spi4 calendar table encountered a parity error. This error bit is associated with the calendar table on the RX interface - the interface that receives the Spi databus. Parity errors can occur during normal operation when the calendar table is constantly being read for the port information, or during initialization time, when the user has access. Since the calendar table is split into two banks, SPX_INT_DAT[CALBNK] indicates which banks have taken a parity error. CALBNK[1] indicates the error occured in the upper bank, while CALBNK[0] indicates that the error occured in the lower bank. SPX_INT_DAT[CALBNK] will be set if there are no pending interrupts in SPX_INT_REG that require SPX_INT_DAT[CALBNK].</p>
<p>* SPF This bit indicates that a Spi fatal error has occurred. A fatal error is defined as any error condition for which the corresponding SPX_INT_SYNC bit is set. Therefore, conservative systems can halt the interface on any error condition although this is not strictly necessary. Some error are much more fatal in nature than others.</p>
<p>PRTNXA, SPIOVR, CLSERR, DRWNNG, DIPERR, CALERR, and SYNCERR are examples of fatal error for different reasons - usually because multiple port streams could be effected. ABNORM, RSVERR, and TPAOVR are conditions that are contained to a single packet which allows the interface to drop a single packet and remain up and stable. </p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="ae7a5c8a10af0759fda2ed161d739a34e"></a><!-- doxytag: member="cvmx_spxx_int_reg::cn38xx" ref="ae7a5c8a10af0759fda2ed161d739a34e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcvmx__spxx__int__reg_1_1cvmx__spxx__int__reg__s.html">cvmx_spxx_int_reg_s</a> <a class="el" href="unioncvmx__spxx__int__reg.html#ae7a5c8a10af0759fda2ed161d739a34e">cvmx_spxx_int_reg::cn38xx</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a22c4a897d5c138e7ad32e5b0af1a8b42"></a><!-- doxytag: member="cvmx_spxx_int_reg::cn38xxp2" ref="a22c4a897d5c138e7ad32e5b0af1a8b42" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcvmx__spxx__int__reg_1_1cvmx__spxx__int__reg__s.html">cvmx_spxx_int_reg_s</a> <a class="el" href="unioncvmx__spxx__int__reg.html#a22c4a897d5c138e7ad32e5b0af1a8b42">cvmx_spxx_int_reg::cn38xxp2</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac8eab6e4c61ae7d7baa3ab5ac494853b"></a><!-- doxytag: member="cvmx_spxx_int_reg::cn58xx" ref="ac8eab6e4c61ae7d7baa3ab5ac494853b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcvmx__spxx__int__reg_1_1cvmx__spxx__int__reg__s.html">cvmx_spxx_int_reg_s</a> <a class="el" href="unioncvmx__spxx__int__reg.html#ac8eab6e4c61ae7d7baa3ab5ac494853b">cvmx_spxx_int_reg::cn58xx</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a66fab3c2bcfae28b8b9ba6365a34487d"></a><!-- doxytag: member="cvmx_spxx_int_reg::cn58xxp1" ref="a66fab3c2bcfae28b8b9ba6365a34487d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcvmx__spxx__int__reg_1_1cvmx__spxx__int__reg__s.html">cvmx_spxx_int_reg_s</a> <a class="el" href="unioncvmx__spxx__int__reg.html#a66fab3c2bcfae28b8b9ba6365a34487d">cvmx_spxx_int_reg::cn58xxp1</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0ca8e2e45b4492c55f5644b9981bc9ef"></a><!-- doxytag: member="cvmx_spxx_int_reg::s" ref="a0ca8e2e45b4492c55f5644b9981bc9ef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcvmx__spxx__int__reg_1_1cvmx__spxx__int__reg__s.html">cvmx_spxx_int_reg::cvmx_spxx_int_reg_s</a>  <a class="el" href="unioncvmx__spxx__int__reg.html#a0ca8e2e45b4492c55f5644b9981bc9ef">cvmx_spxx_int_reg::s</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac20a599535fd775ca54a397215b6d903"></a><!-- doxytag: member="cvmx_spxx_int_reg::u64" ref="ac20a599535fd775ca54a397215b6d903" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="unioncvmx__spxx__int__reg.html#ac20a599535fd775ca54a397215b6d903">cvmx_spxx_int_reg::u64</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this union was generated from the following file:<ul>
<li><a class="el" href="cvmx-spxx-defs_8h_source.html">cvmx-spxx-defs.h</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Oct 2017 for Octeon Software Development Kit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
