<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Octeon Software Development Kit: cvmx_spxx_trn4_ctl Union Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cvmx_spxx_trn4_ctl Union Reference</h1><!-- doxytag: class="cvmx_spxx_trn4_ctl" -->
<p>cvmx_spx::_trn4_ctl  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cvmx-spxx-defs_8h_source.html">cvmx-spxx-defs.h</a>&gt;</code></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcvmx__spxx__trn4__ctl_1_1cvmx__spxx__trn4__ctl__s.html">cvmx_spxx_trn4_ctl_s</a></td></tr>
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unioncvmx__spxx__trn4__ctl.html#ac16e37a2d7006d2bfc8397a30c444fb6">u64</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <br class="typebreak"/>
<a class="el" href="structcvmx__spxx__trn4__ctl_1_1cvmx__spxx__trn4__ctl__s.html">cvmx_spxx_trn4_ctl::cvmx_spxx_trn4_ctl_s</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unioncvmx__spxx__trn4__ctl.html#ab1e013b8c8750635116b11f2fb063783">s</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcvmx__spxx__trn4__ctl_1_1cvmx__spxx__trn4__ctl__s.html">cvmx_spxx_trn4_ctl_s</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unioncvmx__spxx__trn4__ctl.html#aa128a6b4521df5960b79479dd3c1b013">cn38xx</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcvmx__spxx__trn4__ctl_1_1cvmx__spxx__trn4__ctl__s.html">cvmx_spxx_trn4_ctl_s</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unioncvmx__spxx__trn4__ctl.html#a85df06e8f947f75c8f0180da429c9135">cn38xxp2</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcvmx__spxx__trn4__ctl_1_1cvmx__spxx__trn4__ctl__s.html">cvmx_spxx_trn4_ctl_s</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unioncvmx__spxx__trn4__ctl.html#a5967d4b1c4ebbf538069464c7046b917">cn58xx</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcvmx__spxx__trn4__ctl_1_1cvmx__spxx__trn4__ctl__s.html">cvmx_spxx_trn4_ctl_s</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unioncvmx__spxx__trn4__ctl.html#a2f3d1ddded1776e9dea4158ff77b2770">cn58xxp1</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>cvmx_spx::_trn4_ctl </p>
<p>Notes: These bits are controls for the Spi4 RX bit deskew logic. See that Spec for further details.</p>
<p>* BOOT_BIT On the initial training synchronization sequence, the hardware has the BOOT_BIT set which means that it will continueously perform macro operations. Once the BOOT_BIT is cleared, the macro machine will finish the macro operation is working on and then return to the idle state. Subsequent training sequences will only go through a single macro operation in order to do slight deskews.</p>
<p>* JITTER Minimum value is 1. This parameter must be set for Spi4 mode using auto-bit deskew. Regardless of the original intent, this field must be set non-zero for deskew to function correctly.</p>
<p>The thought is the JITTER range is no longer required since the macro machine was enhanced to understand about edge direction. Originally these bits were intended to compensate for clock jitter.</p>
<p>dly: this is the intrinsic delay of each delay element tap currently, it is 70ps-110ps. jitter: amount of jitter we expect in the system (~200ps) j: number of taps to account for jitter</p>
<p>j = ((jitter / dly) + 1)</p>
<p>* TRNTEST This mode is used to test systems to make sure that the bit deskew parameters have been correctly setup. After configuration, software can set the TRNTEST mode bit. This should be done before SRX_COM_CTL[ST_EN] is set such that we can be sure that the TX device is simply sending continuous training patterns.</p>
<p>The test mode samples every incoming bit-time and makes sure that it is either a training control or a training data packet. If any other data is observed, then SPX_DBG_DESKEW_STATE[TESTRES] will assert signaling a test failure.</p>
<p>Software must clear TRNTEST before training is terminated.</p>
<p>* Example Spi4 RX init flow...</p>
<p>1) set the CLKDLY lines (SPXX_CLK_CTL[CLKDLY])</p>
<ul>
<li>these bits must be set before the DLL can successfully lock</li>
</ul>
<p>2) set the SRXDLCK (SPXX_CLK_CTL[SRXDLCK])</p>
<ul>
<li>this is the DLL lock bit which also acts as a block reset</li>
</ul>
<p>3) wait for the DLLs lock</p>
<p>4) set any desired fields in SPXX_DBG_DESKEW_CTL</p>
<ul>
<li>This register has only one field that most users will care about. When set, DLLDIS will disable sending update pulses to the Spi4 RX DLLs. This pulse allows the DLL to adjust to clock variations over time. In general, it is desired behavior.</li>
</ul>
<p>5) set fields in SPXX_TRN4_CTL</p>
<ul>
<li>These fields deal with the MUX training sequence * MUX_EN This is the enable bit for the mux select. The MUX select will run in the training sequence between the DLL and the Macro sequence when enabled. Once the MUX selects are selected, the entire macro sequence must be rerun. The expectation is that this is only run at boot time and this is bit cleared at/around step #8.</li>
<li>These fields deal with the Macro training sequence * MACRO_EN This is the enable bit for the macro sequence. Macro sequences will run after the DLL and MUX training sequences. Each macro sequence can move the offset by one value. * MAXDIST This is how far we will search for an edge. Example...</li>
</ul>
<p>dly: this is the intrinsic delay of each delay element tap currently, it is 70ps-110ps. U: bit time period in time units.</p>
<p>MAXDIST = MIN(16, ((bit_time / 2) / dly)</p>
<p>Each MAXDIST iteration consists of an edge detect in the early and late (+/-) directions in an attempt to center the data. This requires two training transistions, the control/data and data/control transistions which comprise a training sequence. Therefore, the number of training sequences required for a single macro operation is simply MAXDIST.</p>
<p>6) set the RCVTRN go bit (SPXX_CLK_CTL[RCVTRN])</p>
<ul>
<li>this bit synchs on the first valid complete training cycle and starts to process the training packets</li>
</ul>
<p>6b) This is where software could manually set the controls as opposed to letting the hardware do it. See the SPXX_DBG_DESKEW_CTL register description for more detail.</p>
<p>7) the TX device must continue to send training packets for the initial time period.</p>
<ul>
<li>this can be determined by...</li>
</ul>
<p>DLL: one training sequence for the DLL adjustment (regardless of enable/disable) MUX: one training sequence for the Flop MUX taps (regardless of enable/disable) INIT_SEQUENCES: max number of taps that we must move</p>
<p>INIT_SEQUENCES = MIN(16, ((bit_time / 2) / dly))</p>
<p>INIT_TRN = DLL + MUX + ROUNDUP((INIT_SEQUENCES * (MAXDIST + 2)))</p>
<ul>
<li>software can either wait a fixed amount of time based on the clock frequencies or poll the SPXX_CLK_STAT[SRXTRN] register. Each assertion of SRXTRN means that at least one training sequence has been received. Software can poll, clear, and repeat on this bit to eventually count all required transistions.</li>
</ul>
<p>int cnt = 0; while (cnt &lt; INIT_TRN) [ if (SPXX_CLK_STAT[SRXTRN]) [ cnt++; SPXX_CLK_STAT[SRXTRN] = 0; ] ]</p>
<ul>
<li>subsequent training sequences will normally move the taps only one position, so the ALPHA equation becomes...</li>
</ul>
<p>MAC = (MAXDIST == 0) ? 1 : ROUNDUP((1 * (MAXDIST + 2))) + 1</p>
<p>ALPHA = DLL + MUX + MAC</p>
<p>ergo, MAXDIST simplifies to...</p>
<p>ALPHA = (MAXDIST == 0) ? 3 : MAXDIST + 5</p>
<p>DLL and MUX and MAC will always require at least a training sequence each - even if disabled. If the macro sequence is enabled, an additional training sequenece at the end is necessary. The extra sequence allows for all training state to be cleared before resuming normal operation.</p>
<p>8) after the recevier gets enough training sequences in order to achieve deskew lock, set SPXX_TRN4_CTL[CLR_BOOT]</p>
<ul>
<li>this disables the continuous macro sequences and puts into into one macro sequnence per training operation</li>
<li>optionally, the machine can choose to fall out of training if enough NOPs follow the training operation (require at least 32 NOPs to follow the training sequence).</li>
</ul>
<p>There must be at least MAXDIST + 3 training sequences after the SPXX_TRN4_CTL[CLR_BOOT] is set or sufficient NOPs from the TX device.</p>
<p>9) the TX device continues to send training sequences until the RX device sends a calendar transistion. This is controlled by SRXX_COM_CTL[ST_EN]. Other restrictions require other Spi parameters (e.g. the calendar table) to be setup before this bit can be enabled. Once the entire interface is properly programmed, software writes SRXX_COM_CTL[INF_EN]. At this point, the Spi4 packets will begin to be sent into the N2K core and processed by the chip. </p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="aa128a6b4521df5960b79479dd3c1b013"></a><!-- doxytag: member="cvmx_spxx_trn4_ctl::cn38xx" ref="aa128a6b4521df5960b79479dd3c1b013" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcvmx__spxx__trn4__ctl_1_1cvmx__spxx__trn4__ctl__s.html">cvmx_spxx_trn4_ctl_s</a> <a class="el" href="unioncvmx__spxx__trn4__ctl.html#aa128a6b4521df5960b79479dd3c1b013">cvmx_spxx_trn4_ctl::cn38xx</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a85df06e8f947f75c8f0180da429c9135"></a><!-- doxytag: member="cvmx_spxx_trn4_ctl::cn38xxp2" ref="a85df06e8f947f75c8f0180da429c9135" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcvmx__spxx__trn4__ctl_1_1cvmx__spxx__trn4__ctl__s.html">cvmx_spxx_trn4_ctl_s</a> <a class="el" href="unioncvmx__spxx__trn4__ctl.html#a85df06e8f947f75c8f0180da429c9135">cvmx_spxx_trn4_ctl::cn38xxp2</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5967d4b1c4ebbf538069464c7046b917"></a><!-- doxytag: member="cvmx_spxx_trn4_ctl::cn58xx" ref="a5967d4b1c4ebbf538069464c7046b917" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcvmx__spxx__trn4__ctl_1_1cvmx__spxx__trn4__ctl__s.html">cvmx_spxx_trn4_ctl_s</a> <a class="el" href="unioncvmx__spxx__trn4__ctl.html#a5967d4b1c4ebbf538069464c7046b917">cvmx_spxx_trn4_ctl::cn58xx</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2f3d1ddded1776e9dea4158ff77b2770"></a><!-- doxytag: member="cvmx_spxx_trn4_ctl::cn58xxp1" ref="a2f3d1ddded1776e9dea4158ff77b2770" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcvmx__spxx__trn4__ctl_1_1cvmx__spxx__trn4__ctl__s.html">cvmx_spxx_trn4_ctl_s</a> <a class="el" href="unioncvmx__spxx__trn4__ctl.html#a2f3d1ddded1776e9dea4158ff77b2770">cvmx_spxx_trn4_ctl::cn58xxp1</a><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab1e013b8c8750635116b11f2fb063783"></a><!-- doxytag: member="cvmx_spxx_trn4_ctl::s" ref="ab1e013b8c8750635116b11f2fb063783" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcvmx__spxx__trn4__ctl_1_1cvmx__spxx__trn4__ctl__s.html">cvmx_spxx_trn4_ctl::cvmx_spxx_trn4_ctl_s</a>  <a class="el" href="unioncvmx__spxx__trn4__ctl.html#ab1e013b8c8750635116b11f2fb063783">cvmx_spxx_trn4_ctl::s</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac16e37a2d7006d2bfc8397a30c444fb6"></a><!-- doxytag: member="cvmx_spxx_trn4_ctl::u64" ref="ac16e37a2d7006d2bfc8397a30c444fb6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="unioncvmx__spxx__trn4__ctl.html#ac16e37a2d7006d2bfc8397a30c444fb6">cvmx_spxx_trn4_ctl::u64</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this union was generated from the following file:<ul>
<li><a class="el" href="cvmx-spxx-defs_8h_source.html">cvmx-spxx-defs.h</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 27 Oct 2017 for Octeon Software Development Kit by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
