#!/usr/bin/python
# Copyright (c) 2003-2005, Cavium Inc. All rights reserved.
#
# This Software is the property of Cavium Inc.  The Software and all
# accompanying documentation are copyrighted.  The Software made available
# here constitutes the proprietary information of Cavium Inc.  You
# agree to take reasonable steps to prevent the disclosure, unauthorized use
# or unauthorized distribution of the Software.  You shall use this Software
# solely with Cavium hardware.
#
# Except as expressly permitted in a separate Software License Agreement
# between You and Cavium Inc.  you shall not modify, decompile,
# disassemble, extract, or otherwise reverse engineer this Software.  You
# shall not make any copy of the Software or its accompanying documentation,
# except for copying incident to the ordinary and intended use of the
# Software and the Underlying Program and except for the making of a single
# archival copy.
#
# This Software, including technical data, may be subject to U.S.  export
# control laws, including the U.S.  Export Administration Act and its
# associated regulations, and may be subject to export or import regulations
# in other countries.  You warrant that You will comply strictly in all
# respects with all such regulations and acknowledge that you have the
# responsibility to obtain licenses to export, re-export or import the
# Software.
#
# TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
# AND WITH ALL FAULTS AND CAVIUM MAKES NO PROMISES, REPRESENTATIONS OR
# WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT
# TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY
# REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT
# DEFECTS, AND CAVIUM SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES
# OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR
# PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET
# POSSESSION OR CORRESPONDENCE TO DESCRIPTION.  THE ENTIRE RISK ARISING OUT
# OF USE OR PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
#

import sys
import os
import gc
import re
import bisect
import array
import stat

REGISTER_REF = ["DW_OP_reg%d" % r for r in xrange(32)]
KEEP_TYPES = ["DW_TAG_inlined_subroutine", "DW_TAG_subprogram", "DW_TAG_lexical_block", "DW_TAG_compile_unit"]
REGISTER_NAMES = [
    "zero",
    "at",
    "v0","v1",
    "a0","a1","a2","a3",
    "t0","t1","t2","t3","t4","t5","t6","t7",
    "s0","s1","s2","s3","s4","s5","s6","s7",
    "t8","t9",
    "k0","k1",
    "gp",
    "sp",
    "s8",
    "ra",
    "COP0_STATUS_REG",
    "mflo",
    "mfhi",
    "COP0_BADVADDR_REG",
    "COP0_CAUSE_REG",
    "pc",
    "COP0_DEBUG_REG",
    "COP0_MDEBUG_REG"]

HEXDIGITS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9','a', 'b', 'c', 'd', 'e', 'f',
                     'A', 'B', 'C', 'D', 'E', 'F']

REGION_UNKNOWN = "Unknown"
REGION_XKPHYS = "xkphys - 64bit Physical Memory"
REGION_CACHED = "Cached Physical Memory"
REGION_UNCAHCED = "Uncached Physical Memory"
REGION_KERNEL64 = "64bit Kernel"
REGION_KSEG0 = "kseg0 - 32bit Cached Kernel"
REGION_KSEG1 = "kseg1 - 32bit Uncached Kernel"
REGION_KSEG2 = "kseg2 - 32bit Mapped Kernel"
REGION_KUSEG = "kuseg - 32bit User space"
REGION_USER64 = "64bit User space"
REGION_SUPER =  "Supervisor space"
REGION_VECTOR = "Exception Vector Region"

elfPassed = 0		# Set this to 1 when elf file is passed	
coreSel = 0		# Set this to 1 when per-cpu option --cpu is passed
inverse = 0		# Set this to 1 for hit count in descending order with oct-top
stats = 0             # Set this to 1 when statistics has to be displayed(-s option)
kallsyms = 0
elfFilename = ""        # Elffile name passed to oct-top
arguments = ""		# Arguments with which oct-remote-profile is invoked

#
# Convert a hex string into a number. The builtin long(x,16) in python does
# weird things
#
def fromHex(hex_str):
    if hex_str.startswith("0x"):
        hex_str = hex_str[2:]
    result = long(hex_str, 16)
    l = len(hex_str)
    if l == 16:
        if result >= 0x8000000000000000L:
            result -= 0x10000000000000000L
    elif l == 8:
        if result >= 0x80000000L:
            result -= 0x100000000L
    return result

#
# Convert a number to a hex string with at least "digits" in length. The
# builtin hex() in python does weird things
#
def toHex(v, digits):
    hex_digit = "0123456789abcdef"
    result = ""
    for digit in xrange(digits):
        bit_shift = (digits - digit - 1) * 4
        result += hex_digit[(v>>bit_shift) & 0xf]
    return result

def banner():
    if coreSel:
        print '\033[31m' + "\t \t \t \t \t Function Name:      core#:%d (Total hits)" '\033[0m' % (core)
    else:
        print '\033[31m' + "\t \t \t \t \t Function Name:        Total hits" '\033[0m'
    print "\t \t \t \t     --------------------------------------"

class DebugLineContainer:
    def __init__(self):
        self.list = []
        self.need_sort = 0

    def add(self, entry):
        self.list.append(entry)
        self.need_sort = 1;

    def getCount(self):
        return len(self.list)

    def lookup(self, find_address):
        length = len(self.list)
        if not length:
            return None
        if self.need_sort:
            self.need_sort = 0;
            self.list.sort()
        loc = bisect.bisect_left(self.list, (find_address, None))
        if loc == length:
            loc -= 1
        (address, source, row) = self.list[loc]
        if (address <= find_address) and (address > find_address - 256):
            return DebugLineInfo(address, source, row)
        elif loc > 0:
            (address, source, row) = self.list[loc-1]
            if (address <= find_address) and (address > find_address - 256):
                return DebugLineInfo(address, source, row)
            else:
                return None
        else:
            return None

    def print_info(self):
        length = len(self.list)
        for i in xrange(length):
            (address, source, row) = self.list[i]
            print "%x %s %d " % (address, source, row)

class PrivateDwarfTree:
    def __init__(self):
        self.num_string_mapping = 0
        self.string_mapping = {}
        self.reverse_string_mapping = {}
        self.attributes = array.array('i')
        self.node_type = array.array('i')
        self.node_attribute_first = array.array('i')
        self.node_attribute_num = array.array('i')
        self.node_child_first = array.array('i')
        self.node_next_sibling = array.array('i')
        self.progress= ""
    def string_to_index(self, str):
        str = str.strip()
        try:
            return self.string_mapping[str]
        except:
            self.string_mapping[str] = self.num_string_mapping
            self.num_string_mapping += 1
            return self.num_string_mapping-1
    def index_to_string(self, index):
        try:
            return self.reverse_string_mapping[index]
        except:
            for k,i in self.string_mapping.iteritems():
                self.reverse_string_mapping[i] = k
            return self.reverse_string_mapping[index]

    def fix_node_numbers(self, node_id_mapping):
        for node_id,node_num in node_id_mapping.iteritems():
            old_key = "<%d>" % node_id
            if old_key in self.string_mapping:
                new_key = "<<%d>>" % node_num
                id = self.string_mapping[old_key]
                del self.string_mapping[old_key]
                self.string_mapping[new_key] = id

    def showProgress(self, file_handle, message):
        loc = file_handle.tell()
        total_filesize = os.fstat(file_handle.fileno())[stat.ST_SIZE]
        self.progress += message
        sys.stdout.write("\r\x1b[K"+self.progress.__str__() + '\t\t%d%% Complete' % (100*loc/total_filesize))
        sys.stdout.flush()

    #
    # Read the object (types, variables, etc...) from an ELF file
    # This can take a while...
    #
    def readDwarfTree(self, filename):
        TMP_FILE = "top_debuginfo_%s.tmp" % (filename.split('/')[-1])
        self.attributes = array.array('i')
        self.node_type = array.array('i')
        self.node_attribute_first = array.array('i')
        self.node_attribute_num = array.array('i')
        self.node_child_first = array.array('i')
        self.node_next_sibling = array.array('i')

        node_id_mapping = {}
        # This is the root node of the tree
        self.node_type.append(self.string_to_index("root"))
        self.node_attribute_first.append(0)
        self.node_attribute_num.append(0)
        self.node_child_first.append(-1)
        self.node_next_sibling.append(-1)
        node_id_mapping[0] = 0
        last_children = [-1]
        parent = [0]
        scope = 1
        # Regular expression used to extract object node information
        object_re = re.compile("^< *([0-9]+)><0x([0-9a-f]*)>  ([a-zA-Z0-9_\- ]+)$")
        object_const = re.compile("([a-zA-Z0-9_:%,\- ]+)")

        print "Creating dwarfdump for %s" % filename
        if not os.path.isfile(TMP_FILE):
            os.system("dwarfdump -i \"" + filename + "\" > " + TMP_FILE)
        print "Reading Dwarftree"
        lineno = 0
        infile = open(TMP_FILE, "r") 
        for line in infile:
            lineno += 1
            if (lineno & 0xfffff) == 0:
                self.showProgress(infile, ".")
            # Strip the newline
            line = line[0:-1]
            constMatch = object_const.match(line)
            if line.strip() == "":
                continue
            # Found an attribute for an object
            elif line[0:20] == "                    ":
                (attrib, value) = line.strip().split(" ", 1) 
                if "DW_OP_reg" in value:
                    for i in xrange(31, -1, -1):
                        value = value.replace(REGISTER_REF[i], REGISTER_NAMES[i])
                self.attributes.append(self.string_to_index(attrib))
                self.attributes.append(self.string_to_index(value))
                self.node_attribute_num[-1] += 1
	    elif line[0:2] == "\t\t":
                continue
            # Begin a new object
            elif line[0] == '<':
                assert(len(parent) == scope)
                assert(len(last_children) == scope)
                match = object_re.match(line)
                obj_scope = int(match.group(1))+1
                self.node_type.append(self.string_to_index(match.group(3)))
                self.node_attribute_first.append(len(self.attributes))
                self.node_attribute_num.append(0)
                self.node_child_first.append(-1)
                self.node_next_sibling.append(-1)
                current_object = len(self.node_type)-1
                node_id_mapping[int(fromHex(match.group(2)))] = current_object
                # Figure out what level of the tree we need to be in
                if obj_scope == scope:
                    assert(scope > 0)
                    p = parent[scope-1]
                    # This object is a sibling to the current object
                    if last_children[scope-1] == -1:
                        assert(self.node_next_sibling[p] == -1)
                        assert(self.node_child_first[p] == -1)
                        self.node_child_first[p] = current_object
                    else:
                        assert(self.node_child_first[p] != -1)
                        assert(self.node_next_sibling[last_children[scope-1]] == -1)
                        self.node_next_sibling[last_children[scope-1]] = current_object
                    last_children[scope-1] = current_object
                elif obj_scope == scope + 1:
                    # This object is a child of the current object
                    parent.append(current_object-1)
                    assert(self.node_child_first[parent[scope]] == -1)
                    assert(self.node_next_sibling[parent[scope]] == -1)
                    self.node_child_first[parent[scope]] = current_object
                    last_children.append(current_object)
                    scope = obj_scope
                elif obj_scope < scope:
                    # This child is from a different root
                    scope = obj_scope
                    parent = parent[0:scope]
                    last_children = last_children[0:scope]
                    p = parent[scope-1]
                    if last_children[scope-1] == -1:
                        assert(self.node_next_sibling[p] == -1)
                        assert(self.node_child_first[p] == -1)
                        self.node_child_first[p] = current_object
                    else:
                        assert(self.node_child_first[p] != -1)
                        assert(self.node_next_sibling[last_children[scope-1]] == -1)
                        self.node_next_sibling[last_children[scope-1]] = current_object
                    last_children[scope-1] = current_object
                else:
                    # This should be impossible
                    raise Exception("Scoping error")
            # Begin a new compile unit. All tables reset
            elif line[0:12] == "COMPILE_UNIT":
                self.fix_node_numbers(node_id_mapping)
                node_id_mapping = {}
                scope = 1
                parent = parent[0:scope]
                last_children = last_children[0:scope]
            # Skip some useless lines
            elif line in [".debug_info", "LOCAL_SYMBOLS:"]:
                pass
            elif constMatch:
                parts = constMatch.groups()
                #print parts[0]
                continue
            else:
                raise Exception("Unexpected input: " + line)
        infile.close()
        self.fix_node_numbers(node_id_mapping)

#
# Represents the debugging information for an address
#
class DebugLineInfo:
    def __init__(self, address, sourcefile, row):
        self.address = address
        self.sourcefile = sourcefile
        self.row = row
    def __str__(self):
        return "%s => %s:%d" % (toHex(self.address, 16), self.sourcefile, self.row)

#
# Container for all debugging information
#
class DebugInfo:
    def __init__(self):
        self.addressInfo = DebugLineContainer()
        self.objectInfo = None
        self.privateDwarfTree = PrivateDwarfTree()

    #
    # Read debug line information from an ELF file
    #
    def readLineInfo(self, filename):
        TMP_FILE = "top_debuglineinfo_%s.tmp" % (filename.split('/')[-1])

        if os.path.isfile(TMP_FILE):
            fd = open(TMP_FILE,"r")
            content = fd.readlines()
            for i in content:
                 entry = i[1:-2]
                 tuple = entry.split(',')[0], entry.split(',')[1], int(entry.split(',')[2]) 
                 self.addressInfo.add(tuple)
        else:
            fd = open(TMP_FILE,"w")

            infile = os.popen("dwarfdump -l \"" + filename + "\"", "r")
            for line in infile:
            	if line == "\n" or line.startswith(".debug_line: line number info") or line.startswith("Source lines") or line.startswith(" Line table is") or line.strip().startswith("IS=val") or line.startswith("<pc>") or line.strip().startswith("NS") or line.strip().startswith("PE") :
                    continue
                elif line.startswith("No DWARF information"):
                    print line.replace("\n", "")
                    infile.close()
                    sys.exit(-1)
 
                line = line[0:-1]
                parts = line.split()
                try:
                    parts.remove('[')
                except:
                    pass

                if parts[0].startswith("0x"):
                    address = fromHex(parts[0][2:])
                else:
                    address = int(parts[0])
                if address == 0:
                    break

                if parts[1][0:].startswith("["):
                    location = parts[1][1:].split(",")
                else:
                    location = parts[1][0:].split(",")

                try:
                    absFilepath = parts[5]
                    if absFilepath == "":
                        absFilepath = source
                    else:
                        if absFilepath == "uri:":
                            absFilepath = parts[6]
                            source = absFilepath
                        else:
                            source = absFilepath
                except:
                    source = absFilepath
             
                #print "%s %s %s %d" % (parts[0][0:], address, source, int(location[0]))

                entry = address, source.replace('\"',''), int(location[0])
                # Stop loading line info if we get a zero address. The ELF hasn't been linked
                if address == 0:
                    break
                self.addressInfo.add(entry)
                fd.write(str(entry))
                fd.write("\n")
            infile.close()
            #self.addressInfo.print_info()

    #
    # Read the object (types, variables, etc...) from an ELF file
    # This can take a while...
    #
    def readObjectInfo(self, filename):
        self.privateDwarfTree.readDwarfTree(filename)
        self.objectInfo = DebugObjectInfo(0, self.privateDwarfTree)
        #self.objectInfo.display()
        print

    #
    # Read debug information from an ELF file
    #
    def read(self, filename):
        self.readLineInfo(filename)
        #self.readObjectInfo(filename)

    #
    # Get debug info for a specified address
    #
    def getDebugLineInfo(self, find_address):
        return self.addressInfo.lookup(find_address)

    #
    # Find the address of a variable given its name
    #
    def getVariableAddress(self, name):
        if self.objectInfo:
            node = self.objectInfo.findNode(name)
            if node:
                if node.get("DW_AT_location", "").startswith("addr"):
                    return fromHex(node.get("DW_AT_location", "").split()[1][2:])
        return 0

    #
    # Display the data using the supplied typedef
    #
    def formatType(self, typename, hex_data):
        if self.objectInfo:
            node = self.objectInfo.findNode(typename)
            if node:
                data = []
                while hex_data:
                    data.append(int(hex_data[0:2], 16))
                    hex_data = hex_data[2:]
                return node.formatType(data, 0, typename)
        return None

#
# Represents the Object tree. Objects in the tree represent types, variables,
# functions, etc ...
#
class DebugObjectInfo:
    def __init__(self, object_id, privateDwarfTree):
        self.object_id = object_id
        self.pt = privateDwarfTree
        self.object_type = self.pt.index_to_string(self.pt.node_type[object_id])

    def children(self):
        child = self.pt.node_child_first[self.object_id]
        while child != -1:
            yield DebugObjectInfo(child, self.pt)
            child = self.pt.node_next_sibling[child]

    def attributes(self):
        base = self.pt.node_attribute_first[self.object_id]
        num = self.pt.node_attribute_num[self.object_id]
        for i in xrange(num):
            a = base + i*2
            name = self.pt.index_to_string(self.pt.attributes[a])
            value = self.pt.index_to_string(self.pt.attributes[a+1])
            yield name, value

    def get(self, name, default=None, depth=0):
        base = self.pt.node_attribute_first[self.object_id]
        num = self.pt.node_attribute_num[self.object_id]
        match = self.pt.string_to_index(name)
        for i in xrange(num):
            a = base + i*2
            if match == self.pt.attributes[a]:
                return self.pt.index_to_string(self.pt.attributes[a+1])
        if (name != "DW_AT_abstract_origin") and (depth < 10):
            origin = self.get("DW_AT_abstract_origin", "", depth+1)
            if origin:
                return DebugObjectInfo(int(fromHex(origin[1:-1])), self.pt).get(name, default, depth+1)
        if default == None:
            raise AttributeError()
        else:
            return default

    # Find the node with the associated name
    def findNode(self, search_name):
        if name == self.get("DW_AT_name", ""):
            return self
        else:
            for c in self.children():
                result = c.findNode(search_name)
                if result:
                    return result
        return None

    def containsPC(self, address):
        low = self.get("DW_AT_low_pc", "")
        if low:
            high = self.get("DW_AT_high_pc", low)
            low = fromHex(low)
            high = fromHex(high)
            return (address >= low) and (address < high)
        else:
            return 0

    # Format a block of binary data for display using the current type node
    def formatType(self, binary_data, offset, prefix):
        if self.object_type == "DW_TAG_typedef":
            # Ignore typedefs and traverse to their actual type
            return self.get("DW_AT_type","").formatType(binary_data, offset, prefix)

        elif self.object_type == "DW_TAG_union_type":
            # A union type is unique in that each of its members gets the
            # same data. Data isn't consumed until the entire union is parsed
            size = int(self.get("DW_AT_byte_size", ""))
            prefix += ".union"
            result = []
            for c in self.children():
                result.extend(c.formatType(binary_data, offset, prefix))
            return result

        elif self.object_type == "DW_TAG_structure_type":
            # Structures are just the addition of all members. We
            # copy the data since I don't trust the members to consume
            # the proper amount of data
            size = int(self.get("DW_AT_byte_size", ""))
            result = []
            for c in self.children():
                loc = int(c.get("DW_AT_data_member_location", "").split()[1])
                result.extend(c.formatType(binary_data, offset + loc, prefix))
            return result

        elif self.object_type == "DW_TAG_member":
            # Member of a structure or union
            name = self.get("DW_AT_name", "")
            if self.get("DW_AT_bit_size", ""):
                bits = int(self.get("DW_AT_bit_size", ""))
                size = int(self.get("DW_AT_byte_size", ""))
                shift = size*8 - bits - int(self.get("DW_AT_bit_offset", "0"))
                child_data = 0
                for i in xrange(size):
                    child_data = child_data * 256 + binary_data[i + offset]
                child_data = (child_data >> shift) & ((1<<bits) - 1)
                child_list = range(size)
                for i in xrange(size):
                    child_list[i] = (child_data >> 8*(size-i-1)) & 0xff
                return self.get("DW_AT_type", "").formatType(child_list, 0, prefix + "." + name)
            else:
                return self.get("DW_AT_type", "").formatType(binary_data, offset, prefix + "." + name)

        elif self.object_type == "DW_TAG_base_type":
            # Finally we've gotten down to the base types
            typename = self.get("DW_AT_name", "")
            size = int(self.get("DW_AT_byte_size", ""))
            encoding = self.get("DW_AT_encoding", "")
            if encoding == "DW_ATE_unsigned" or encoding == "DW_ATE_unsigned_char":
                value = 0
                for i in xrange(size):
                    value = value * 256 + binary_data[i + offset]
                value = str(value) + "(" + hex(value) + ")"
            else:
                raise Exception("Illegal encoding: " + encoding)
            return [(prefix, value)]

        elif self.object_type == "DW_TAG_enumeration_type":
            # Display the value as well as the name for enumerations
            value = 0
            size = int(self.get("DW_AT_byte_size", ""))
            for i in xrange(size):
                value = value * 256 + binary_data[i + offset]
            text_value = ""
            for c in self.children():
                if value == int(c.get("DW_AT_const_value", "")):
                    text_value = c.get("DW_AT_name", "")
                    break
            return [(prefix, str(value) + "(" + text_value + ")")]

        elif self.object_type == "DW_TAG_pointer_type":
            # Simple pointer somewhere. We don't follow it
            value = 0
            size = int(self.get("DW_AT_byte_size", ""))
            for i in xrange(size):
                value = value * 256 + binary_data[i + offset]
            return [(prefix, hex(value) + "(pointer)")]

        elif self.object_type == "DW_TAG_array_type":
            # Fixed size Array of objects
            upper = int(self.children().get("DW_AT_upper_bound", ""))
            typenode = self.get("DW_AT_type", "")
            while not typenode.get("DW_AT_byte_size", ""):
                typenode = typenode.get("DW_AT_type", "")
            size = int(typenode.get("DW_AT_byte_size", ""))
            result = []
            for i in xrange(upper+1):
                result.extend(typenode.formatType(binary_data, offset + i * size, prefix + "[" + str(i) + "]"))
            return result

        else:
            # Something not supported yet
            raise Exception("Unsupported object type: " + self.object_type)

    # Display myself and my children.
    def display(self, indent=""):
        print indent, self.object_id, self.object_type
        for a,v in self.attributes():
            print indent, a, v
        for c in self.children():
            c.display(indent + "    ")

class ProfileEntry:
    def __init__(self, name):
        self.name = name
        self.count = [0 for core in xrange(64)]
        self.children = {}

class Profiler:
    #
    # Initialize global data structures
    #
    def __init__(self, show_line=0, show_address=0, arguments=""):
        self.show_line=show_line
        self.show_address=show_address
        self.arguments = arguments
        self.dbg = DebugInfo()
        self.symbols = []
        self.desc = []
        self.linuxElf = 0
        SYMFILE = kallsyms
        if elfPassed:
            print "Reading line number information"
            self.dbg.read(elfFilename)
            
            self.validateElffile(elfFilename)
            if self.linuxElf:
                print "Reading symbol information"
                self.loadElfSymbols(elfFilename)
            else:
                self.dbg.readObjectInfo(elfFilename)
        elif kallsyms:
            self.loadKallsyms("/proc/kallsyms") 
        elif not elfPassed and not stats:
            print
            print "Warning: Elf file not passed, printing PC values"
        gc.collect()
	self.profile_data = ProfileEntry(elfFilename)

    # Verify if the ELffile is vmlinux 
    def validateElffile(self, filename):
        exitStatus = os.system("objdump -tf '%s' | grep kernel_entry &>/dev/null" %filename)
        if not exitStatus:
            self.linuxElf = "1"

    # Load symbols from an ELF file
    def loadElfSymbols(self, filename):
        infile = os.popen("objdump -t \"" + filename + "\"", "r", 0)
        for line in infile:
            if not line[0] in HEXDIGITS:
                continue
            parts = line.split()
            if len(parts) != 6:
                continue
            try:
                address = fromHex(parts[0])
                if address == 0:
                    continue
                name = parts[5]
                self.symbols.append((address, name))
            except:
                pass
        infile.close()
        self.symbols.sort()
        #print self.symbols

    def loadKallsyms(self, filename):
        infile = open(filename, "r")
        for entry in infile:
            line = entry[0:-1]
            if not line[0] in HEXDIGITS:
                continue
            parts = line.strip().split()
            if len(parts) < 3:
                continue
            try:
                address = fromHex(parts[0])
                if address == 0:
                    continue
                if len(parts) == 4:
                    name = parts[3] + " " + parts[2]
                else:
                    name = parts[2]
                self.symbols.append((address, name))
            except:
                pass
        infile.close()
        self.symbols.sort()

    # Lookup a symbol for an address
    def getSymbol(self, find_address):
        if len(self.symbols) == 0:
            return None
        loc = bisect.bisect_left(self.symbols, (find_address, None))
        if loc == len(self.symbols):
            loc -= 1
        (address, name) = self.symbols[loc]
        if address <= find_address and address > find_address - 65536:
            return (address, name)
        elif loc > 0:
            (address, name) = self.symbols[loc-1]
            if address <= find_address and address > find_address - 65536:
                return (address, name)
            else:
                return None
        else:
            return None

    def handleUnknownAddress(self, address):
        # All the numbers below should be hex. Damn python and its broken
        # hex conversion. It doesn't work for numbers that have the top bit
        # set.
        if address < -8070450532247928832: # 0x9000000000000000
            return REGION_XKPHYS
        elif address < -7493989779944505344: # 0x9800000000000000
            return REGION_CACHED
        elif address < -4611686018427387904: # 0xC000000000000000
            return REGION_UNCAHCED
        elif address < -4611684918915760129: # 0xC00000ffffffffff
            return REGION_KERNEL64
        elif address < -2147483648: # 0xffffffff80000000
            return REGION_UNKNOWN
        elif address < -2147414016: # 0xffffffff80011000
            ebase = (address>>12) & 0x1f
            offset = address & 0xfff
            if offset < 0x100:
                return "TLB Handler"
            elif offset < 0x180:
                return "Cache Error Handler"
            elif offset < 0x200:
                return "Exception Handler"
            elif offset < 0x280:
                return "Interrupt Handler"
            else:
                return REGION_VECTOR
        elif address < -1610612736: # 0xffffffffa0000000
            return REGION_KSEG0
        elif address < -1073741824: # 0xffffffffc0000000
            return REGION_KSEG1
        elif address < 0x0000000000000000:
            return REGION_KSEG2
        elif address < 0x0000000080000000:
            return REGION_KUSEG
        elif address < 0x000000ffffffffff:
            return REGION_USER64
        elif address < 0x4000000000000000:
            return REGION_UNKNOWN
        elif address < 0x400000ffffffffff:
            return REGION_SUPER
        else:
            return REGION_UNKNOWN

    #
    # Recursively format the debugging information for display
    #
    def get_scope_info(self, address, node):
        result = []
        if node.object_type in ["DW_TAG_inlined_subroutine", "DW_TAG_subprogram"]:
            result.append(node.get("DW_AT_name"))
        for c in node.children():
            if c.containsPC(address):
                result.extend(self.get_scope_info(address, c))
                break
            elif c.object_type in ["DW_TAG_lexical_block", "DW_TAG_compile_unit"]:
                r = self.get_scope_info(address, c)
                if r:
                    result.extend(r)
                    break
        return result

    #
    # Add a profile entry
    #
    def addProfileEntry(self, address, counts):
        scope_info = []
        if address:
            if self.linuxElf or kallsyms:
                symbol = self.getSymbol(address)
                if symbol != None:
                    scope_info.append(symbol[1])
                else:
                    scope_info.append(self.handleUnknownAddress(address))
            else:
                scope_info = self.get_scope_info(address, self.dbg.objectInfo)
                if not scope_info:
                    scope_info.append(self.handleUnknownAddress(address))
        if self.show_line:
            line_info = self.dbg.getDebugLineInfo(address)
            if line_info:
                scope_info.append(line_info.sourcefile + ":" + str(line_info.row))
        if self.show_address:
            scope_info.append("0x" + toHex(address, 16))
        entry = self.profile_data
        for s in scope_info:
            if not s in entry.children:
                entry.children[s] = ProfileEntry(s)
            entry = entry.children[s]
            for c in xrange(len(counts)):
                entry.count[c] += counts[c]
    #
    # Add a profile entry, adds only Hexadecimal values and is invoked 
    # if no elf file is passed. 
    #
    def addProfileEntryHex(self, address, counts):
        scope_info = []
        if address:
            scope_info.append("0x" + toHex(address, 16))
        entry = self.profile_data
        for s in scope_info:
            if not s in entry.children:
                entry.children[s] = ProfileEntry(s)
            entry = entry.children[s]
            for c in xrange(len(counts)):
                entry.count[c] += counts[c]

    def display(self, entry, indent=""):
	# If 'per-cpu' top info selected, hitcount would be set to particular core
        if coreSel:
            if core in profiledCores:
                hitcount = entry.count[profiledCores.index(core)]
            else:
                print 'Error: Invalid cpu number passed, valid cpus %s' % (profiledCores)
                sys.exit(-1)
        else: 
                hitcount = sum(entry.count)
        if indent:
            self.desc.append((entry.name,hitcount))
        keys = entry.children.keys()
        keys.sort()
        for c in keys:
            self.display(entry.children[c], indent + "  ")

    #
    # Sort the list based on second tuple element i.e count in this case
    # 
    def sortSymbols(self, desc):
        func_list = sorted(desc, key=lambda func: func[1], reverse=inverse)
        return func_list

    #	
    # FIXME, Needs improvement with show_address, show_line conditions.
    #
    # Create multiple lists from desc list, with each list having function name, hexadecimal values sorted;
    # then compare first tuple of individual list with another list(containing function names alone)
    # and print them in sorted order
    #
    def sortList(self, desc):
        finalList = []
        funcList = []
        if self.show_address:
            list = self.desc
            for sym in list:
                if not sym[0].startswith("0x"):
                    funcname = sym[0]
                    funcList.append(sym)
                    funcname = []
                    funcname.append(sym)
                    finalList.append(funcname)
                elif sym[0].startswith("0x"):
                    funcname.append(sym)

            funcList = self.sortSymbols(funcList) 
            for i in funcList: 
                for j in finalList:
                    sortTempList = sorted(j, key=lambda func: func[1], reverse=True)
                    if i == sortTempList[0]:
                        for k,v in sortTempList:
                            if k.startswith("0x"):
                                print "%55s:\t %d " % (k, v)
                            else: 
                                print '\033[94m' "%55s:\t %d " '\033[0m' % (k, v) 
            self.desc = []
        elif self.show_line:
            list = self.desc
            for sym in list:
                if not sym[0].startswith("/"):
                    funcname = sym[0]
                    funcList.append(sym)
                    funcname = []
                    funcname.append(sym)
                    finalList.append(funcname)
                else:
                    funcname.append(sym)

            funcList = self.sortSymbols(funcList) 
            for i in funcList: 
                for j in finalList:
                    sortTempList = sorted(j, key=lambda func: func[1], reverse=True)
                    if i == sortTempList[0]:
                        for k,v in sortTempList:
                            if k.startswith("/"):
                                print "%55s:\t %d " % (k, v)
                            else: 
                                print '\033[94m' "%55s:\t %d " '\033[0m' % (k, v) 
            self.desc = []
        else:
            list = self.sortSymbols(desc)
            for k,v in list:
                if v:
                    print "%55s:\t %d " % (k, v)
                #else:
                #    print "%55s:\t %d  [0 Hits on core#:%d]" % (k, v, core)
            self.desc = []

    #
    # Parse output of oct-linux-profile
    #
    def parseSummary(self, line):
        if line.startswith("L2"):
            print ""
            print '\033[94m' "%s" '\033[0m' % (line)
        elif line.startswith("DRAM"):
            print ""
            print '\033[94m' "DRAM Statistics:" '\033[0m'
            print line.split(',')[0]
            print (line.split(',')[1]).strip()
            print (line.split(',')[2]).strip()
        elif line.startswith("Packet"):
            print ""
            print '\033[94m' "FPA Pool statistics:" '\033[0m'
            print line
        elif line.startswith("SSO Qos"):
            print ""
            print '\033[94m' "POW/SSO Qos Input queue Statistics:" '\033[0m'
        else:
            print line

    #
    # Begin profiling
    #
    def profile(self):
        global counts
        global profiledCores
        infile = os.popen("oct-linux-profile" + self.arguments, "r", 0)
        while infile:
            line = infile.readline()
            if not line:
                break
            line = line.strip()
            if line == "":
                if stats:
                    continue
                else:
                    self.display(self.profile_data)
                    self.profile_data.children = {}
                    if self.desc:
                        os.system('clear')
                        banner()
                        self.sortList(self.desc)
            elif line.startswith("0x"):
                address = fromHex(line[2:18])
                parts = line.split()
                counts = [int(x) for x in parts[1:]]
                if elfPassed:
                    self.addProfileEntry(address, counts)
                elif kallsyms:
                    self.addProfileEntry(address, counts) 
                else:    
                    self.addProfileEntryHex(address, counts)
                    self.show_address = 0 # Should be disabled as elf file isn't passed
                    self.show_line = 0
            elif line.startswith("core#"):
                cores = line.split()
                profiledCores = [int(x) for x in cores[1:]]
                if stats:
                    os.system('clear')
                    print '\033[94m' "Core Counters:" '\033[0m'
                else:
                    continue
            elif stats:
                self.parseSummary(line)
        retStatus = infile.close()
        if retStatus is not None:
            print; print "Invalid arguments with oct-pci-profile encountered"
            usage()
#
# Main entry point
def usage():
    print
    print "Usage: oct-top [--line] [--address] <elf>"
    print "    <elf file>               Mips ELF files to load debugging information from."
    print "    [--line]                 Show line number information."
    print "    [--address]              Show exact PC addresses."
    print "    [--perf1=<Core counter>] Setup Core performance counter 1"
    print "    [--perf2=<Core counter>] Setup Core performance counter 2"
    print "    [--perf3=<Core counter>] Setup Core performance counter 3 (Available from CN7XXX onwards)"
    print "    [--perf4=<Core counter>] Setup Core performance counter 4 (Available from CN7XXX onwards)"
    print "    [--l2perf1=<L2 counter>] Setup L2 performance counter 1"
    print "    [--l2perf2=<L2 counter>] Setup L2 performance counter 2"
    print "    [--l2perf3=<L2 counter>] Setup L2 performance counter 3"
    print "    [--l2perf4=<L2 counter>] Setup L2 performance counter 4"
    print "    [--dwell=<seconds>]      Number of seconds between printing"
    print "    [--core_mask=<mask>]     Mask which specifies the cores to sample"
    print "    [--cpu=<core no>]        Per cpu 'top' information, [0-n cores]"
    print "    [-s]                     Octeon Memory, Perf Counter Statistics"
    print "    [-r]                     reverse the results of the output"
    print "    [-k]                     use kernel sysmbols from /proc/kallsyms"
    print
    print
    sys.exit(2)

validArgs = [ "--line", "--address", "--perf1", "--perf2", "--perf3", "--perf4", "--l2perf1" , "--l2perf2", "--l2perf3", "--l2perf4", "--dwell", "--core_mask", "--cpu", "-s", "-r" ]

options = sys.argv[1:]
for arg in options:
    if os.path.exists(arg):
        elfPassed = 1
        elfFilename = arg
    elif arg.startswith("--perf") or arg.startswith("--l2perf") or arg.startswith("--dwell") or arg.startswith("--core_mask"):
        arguments += " " + arg
    elif arg.startswith("--cpu"):
        coreSel = 1
        try:
            core = int(re.split('=', arg)[1])
        except:
            print "Invalid --cpu option"
            usage()
    elif arg in ("-h", "--help"):
        usage()
    elif arg in ("-r"):
        inverse = 1
    elif arg in ("-s"):
        stats = 1
	arguments += " " + "--perfonly"
    elif arg in ("-k"):
        kallsyms = 1
    elif not arg in validArgs:
        print "Invalid option %s entered" % (arg)
        usage()

p = Profiler(("--line" in sys.argv), ("--address" in sys.argv), arguments)
p.profile()
