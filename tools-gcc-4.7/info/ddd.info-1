This is ../../../src/ddd/ddd/ddd.info, produced by makeinfo version
4.13 from ../../../src/ddd/ddd/ddd.texi.

INFO-DIR-SECTION Programming & development tools.
START-INFO-DIR-ENTRY
* DDD: (ddd).                     The Data Display Debugger.
END-INFO-DIR-ENTRY

DDD is a graphical front-end for GDB and other command-line debuggers.

This is the First Edition, 15 January, 2004, of `Debugging with DDD'
for DDD Version 3.3.11.


   Copyright (C) 2004 Universität des Saarlandes
Lehrstuhl Softwaretechnik
Postfach 15 11 50
66041 Saarbrücken
GERMANY

Distributed by
Free Software Foundation, Inc.
59 Temple Place - Suite 330
Boston, MA 02111-1307
USA

DDD and this manual are available via the DDD WWW page
(http://www.gnu.org/software/ddd/).

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts and no Back-Cover Texts.  A
copy of the license is included in the section entitled "GNU Free
Documentation License".

   Send questions, comments, suggestions, etc. to <ddd@gnu.org>.
Send bug reports to <bug-ddd@gnu.org>.

File: ddd.info,  Node: Top,  Next: Summary,  Up: (dir)

Debugging with DDD
******************

DDD is a graphical front-end for GDB and other command-line debuggers.

   This is the First Edition of `Debugging with DDD', 15 January, 2004,
for DDD Version 3.3.11.

   The first part of this master menu lists the major nodes in this Info
document, including the label and command indices.  The rest of the menu
lists all the lower level nodes in the document.

* Menu:

* Summary::                     Summary of DDD.

* Sample Session::              A sample DDD session.
* Invocation::                  Getting in and out of DDD.
* Windows::                     The DDD windows, menus, and buttons.
* Navigating::                  Moving through the source code.
* Stopping::                    Making your program stop at specific locations.
* Running::                     Running programs under DDD.
* Examining Data::              Examining variable values and data structures.
* Machine-Level Debugging::     Examining machine code and registers.
* Changing the Program::        Changing source and object code.
* Commands::                    Entering and editing DDD commands.

* Application Defaults::        Resources used in DDD.
* Bugs::                        How, when, and why to report DDD bugs.
* Configuration Notes::         Configuration-specific notes.
* Dirty Tricks::                Room for your contributions.
* Extending::                   Extending DDD.
* FAQ::                         Frequently Answered Questions.
* License::                     The DDD license.
* Help and Assistance::         Mailing Lists and other resources.
* Documentation License::       The license of this document.

* Label Index::                 All labels shown on the DDD GUI.
* Key Index::                   Keys used to control DDD.
* Command Index::               Commands that can be typed within DDD.
* Resource Index::              All resources and environment variables.
* File Index::                  All programs and files referenced by DDD.
* Concept Index::               All concepts as mentioned in this manual.



 --- The Detailed Node Listing ---

Summary of DDD

* About this Manual::           Getting copies in various formats.
* Free Software::               How to copy and redistribute DDD.
* Getting DDD::              How to obtain copies of DDD.
* Contributors::                Who has done all this?
* History::                     Old DDD versions.

A Sample DDD Session

* Sample Program::              Source `sample.c'

Getting In and Out of DDD

* Invoking::                    How to invoke DDD.
* Quitting::                    How to quit DDD.
* Sessions::                    Saving work across invocations.
* Remote Debugging::            Running DDD on a different host.
* Customizing Debugger Interaction::  How DDD and GDB communicate.

Invoking DDD

* Choosing an Inferior Debugger::  Which debugger to use?
* Options::                     How to invoke DDD
* X Options::                   Setting X properties
* Inferior Debugger Options::   Customizing GDB, DBX, and so on
* Multiple Instances::          Running multiple DDD instances
* X Warnings::                  Turning off obnoxious warnings

Inferior Debugger Options

* GDB Options::
* DBX and Ladebug Options::
* XDB Options::
* JDB Options::
* PYDB Options::
* Perl Options::
* Bash Options::

Persistent Sessions

* Saving Sessions::
* Resuming Sessions::
* Deleting Sessions::
* Customizing Sessions::

Remote Debugging

* Remote Host::                 Running DDD on a Remote Host
* Remote Debugger::             Using a Remote Inferior Debugger
* Remote Program::              Debugging a Remote Program

Using DDD with a Remote Inferior Debugger

* Customizing Remote Debugging::

Customizing Interaction with the Inferior Debugger

* Debugger Invocation::
* Debugger Initialization::
* Debugger Communication::

Initializing the Inferior Debugger

* GDB Initialization::
* DBX Initialization::
* XDB Initialization::
* JDB Initialization::
* PYDB Initialization::
* Perl Initialization::
* Bash Initialization::
* Finding a Place to Start::
* Opening the Selection::

The DDD Windows

* Menu Bar::                    All DDD pull-down menus.
* Tool Bar::                    The DDD icon buttons.
* Command Tool::                The floating command tool.
* Getting Help::                What does this thing mean?
* Undo and Redo::               Oops!
* Customizing::                 You can customize DDD

The Menu Bar

* File Menu::                   Selecting programs and processes.
* Edit Menu::                   Cut, copy, paste, and preferences.
* View Menu::                   All DDD windows.
* Program Menu::                Starting and stopping.
* Commands Menu::               All DDD commands.
* Status Menu::                 Examining the program status.
* Source Menu::                 Navigating around.
* Data Menu::                   Examining data.
* Maintenance Menu::            Maintaining DDD.
* Help Menu::                   Getting help.
* Customizing the Menu Bar::    Alternate key bindings, etc.

Customizing the Menu Bar

* Auto-Raise Menus::
* Customizing the Edit Menu::

The Tool Bar

* Customizing the Tool Bar::

The Command Tool

* Customizing the Command Tool::
* Customizing Tool Position::

Customizing the Command Tool

* Disabling the Command Tool::

Command Tool Position

* Customizing Tool Decoration::

Customizing DDD

* How Customizing Works::
* Customizing Help::
* Customizing Undo::
* Customizing Windows::
* Debugger Settings::

How Customizing DDD Works

* Resources::
* Changing Resources::
* Saving Options::

Customizing DDD Help

* Button tips::                 Turning off tips.
* Tip of the day::              Turning off the tip of the day.
* Help Helpers::                Helper programs invoked by Help.

Customizing the DDD Windows

* Splash Screen::               Turning off the splash screen.
* Window Layout::               Re-arranging windows.
* Customizing Fonts::           Using alternate fonts.
* Toggling Windows::            Turning off windows.
* Text Fields::                 Popdown histories.
* Icons::                       Iconifying DDD windows.
* Adding Buttons::              Create your own button set.
* More Customizations::

Navigating through the Code

* Compiling for Debugging::     Always use `-g' to compile.
* Opening Files::               How to open a program for debugging.
* Looking up Items::            Searching files and functions.
* Customizing Source::          Arranging the source window.

Opening Files

* Opening Programs::            How to open a program for debugging.
* Opening Core Dumps::          Analyze a previous crash.
* Opening Source Files::        Open a source file of the program.
* Filtering Files::             DDD only lists matching files.

Looking up Items

* Looking up Definitions::      Jump towards a specific item.
* Textual Search::              Search within the current source.
* Looking up Previous Locations::  Navigate back and forth.
* Source Path::                 Make DDD know where to search.

Customizing the Source Window

* Customizing Glyphs::
* Customizing Searching::
* Customizing Source Appearance::
* Customizing Source Scrolling::
* Customizing Source Lookup::
* Customizing File Filtering::

Stopping the Program

* Breakpoints::                 Stop at a certain point.
* Watchpoints::                 Stop at a certain condition.
* Interrupting::                Stop manually.
* Stopping X Programs::         Take care of grabbed pointers!

Breakpoints

* Setting Breakpoints::
* Deleting Breakpoints::
* Disabling Breakpoints::
* Temporary Breakpoints::
* Editing Breakpoint Properties::
* Breakpoint Conditions::
* Breakpoint Ignore Counts::
* Breakpoint Commands::
* Moving and Copying Breakpoints::
* Looking up Breakpoints::
* Editing all Breakpoints::
* Hardware-Assisted Breakpoints::

Watchpoints

* Setting Watchpoints::
* Editing Watchpoint Properties::
* Editing all Watchpoints::
* Deleting Watchpoints::

Stopping X Programs

* Customizing Grab Checking::

Running the Program

* Starting Program Execution::
* Using the Execution Window::
* Attaching to a Process::
* Program Stop::
* Resuming Execution::
* Continuing Somewhere Else::
* Stack::
* Undoing Program Execution::
* Threads::
* Signals::
* Killing the Program::

Starting Program Execution

* Arguments::                   Your program's arguments.
* Environment::                 Your program's environment.
* Working Directory::           Your program's directory.
* Input/Output::                Your program's I/O.

Using the Execution Window

* Customizing the Execution Window::

Attaching to a Running Process

* Customizing Attaching to Processes::

Examining the Stack

* Frames::                      Callers and callees.
* Backtraces::                  And you may ask yourself, `how did I get here?'
* Selecting a frame::           Moving up and down.

Examining Data

* Value Tips::                  Just move the pointer on a variable.
* Printing Values::             Printing a value in the debugger console.
* Displaying Values::           Displaying structures as graphs.
* Plotting Values::             Displaying values as plots.
* Examining Memory::            Low-level memory examination.

Displaying Complex Values in the Data Window

* Display Basics::              How to create, manipulate, and delete displays.
* Arrays::                      Special functions for arrays.
* Assignment::                  Setting variable values.
* Examining Structures::        Dereferencing pointers and other references.
* Customizing Displays::        Data Themes.
* Layouting the Graph::         Automatic layout.
* Printing the Graph::          Printing on paper.

Display Basics

* Creating Single Displays::
* Selecting Displays::
* Showing and Hiding Details::
* Rotating Displays::
* Displaying Local Variables::
* Displaying Program Status::
* Refreshing the Data Window::
* Placement::
* Clustering::
* Creating Multiple Displays::
* Editing all Displays::
* Deleting Displays::

Arrays

* Array Slices::                Displaying FROM..TO parts of an array
* Repeated Values::             How repeated values are handled.
* Arrays as Tables::            Displaying two-dimensional arrays.

Examining Structures

* Dependent Values::            Edges from values to values.
* Dereferencing Pointers::      Examining pointer-based data structures.
* Shared Structures::           Multiple pointers to one display.
* Display Shortcuts::           Customize your own menus.

Customizing Displays

* Using Data Themes::
* Applying Data Themes to Several Values::
* Editing Themes::
* Writing Data Themes::
* Display Resources::
* VSL Resources::

Layouting the Graph

* Moving Displays::
* Scrolling Data::
* Aligning Displays::
* Automatic Layout::
* Rotating the Graph::

Plotting Values

* Plotting Arrays::             Plotting 1-D and 2-D arrays.
* Plot Appearance::             Controlling the appearance.
* Scalars and Composites::      Plotting simple values.
* Plotting Histories::          Plotting the history of a variable.
* Printing Plots::              Printing on paper.
* Entering Plotting Commands::  Raw Gnuplot commands.
* Exporting Plot Data::         Processing data outside of DDD
* Animating Plots::             Visualizing dynamic behaviour.
* Customizing Plots::           All at your leisure.

Customizing Plots

* Gnuplot Invocation::
* Gnuplot Settings::

Machine-Level Debugging

* Machine Code::                Examining machine code.
* Machine Code Execution::      Stepping across instructions.
* Registers::                   Examining registers.
* Customizing Machine Code::    Settings.

Changing the Program

* Editing Source Code::         You can invoke a source editor from DDD.
* Recompiling::                 Invoking `make' from within DDD.
* Patching::                    Changing source and object code.

Editing Source Code

* Customizing Editing::
* In-Place Editing::

The Command-Line Interface

* Entering Commands::           Direct interaction with the inferior debugger.
* TTY mode::                    Controlling DDD from a terminal.
* Integrating DDD::          DDD and your programming environment.
* Defining Buttons::            Add your own DDD buttons.
* Defining Commands::           Add your own DDD commands.

Entering Commands

* Command Completion::          Using the <TAB> key.
* Command History::             Repeating previous commands.
* Typing in the Source Window::

Defining Buttons

* Customizing Buttons::         Adding your own command buttons.

Defining Commands

* GDB Simple Commands::
* GDB Argument Commands::
* Commands with Other Debuggers::

Application Defaults

* Actions::                     All actions used in translation tables.
* Images::                      All images used in resources,

Actions

* General Actions::
* Data Display Actions::
* Debugger Console Actions::
* Source Window Actions::

Bugs and How To Report Them

* Where to Send Bug Reports::   Our e-mail address.
* Is it a DDD Bug?::         DDD may not be at fault.
* How to Report Bugs::          Report all the facts.
* Bug Reports::                 Include all configuration information.
* Diagnostics::                 Maintaining DDD

Getting Diagnostics

* Logging::                     DDD logs all interactions.
* Debugging DDD::            Facilities to debug DDD.
* Customizing Diagnostics::     All diagnostics resources.

Logging

* Disabling Logging::

Configuration Notes

* GDB::                         Using DDD with GDB
* DBX::                         Using DDD with DBX
* Ladebug::                     Using DDD with Ladebug
* XDB::                         Using DDD with XDB
* JDB::                         Using DDD with JDB
* Perl::                        Using DDD with Perl
* Bash::                        Using DDD with Bash
* LessTif::                     Using DDD with LessTif

Using DDD with GDB

* WDB::                         Using DDD with WDB
* WindRiver GDB::               Using DDD with WindRiver GDB (Tornado)


File: ddd.info,  Node: Summary,  Next: Sample Session,  Prev: Top,  Up: Top

Summary of DDD
**************

The purpose of a debugger such as DDD is to allow you to see what is
going on "inside" another program while it executes--or what another
program was doing at the moment it crashed.

   DDD can do four main kinds of things (plus other things in support
of these) to help you catch bugs in the act:

   * Start your program, specifying anything that might affect its
     behavior.

   * Make your program stop on specified conditions.

   * Examine what has happened, when your program has stopped.

   * Change things in your program, so you can experiment with
     correcting the effects of one bug and go on to learn about another.

   Technically speaking, DDD is a front-end to a command-line debugger
(called "inferior debugger", because it lies at the layer beneath DDD).
DDD supports the following inferior debuggers:

   * To debug _executable binaries_, you can use DDD with "GDB", "DBX",
     "Ladebug", or "XDB".

        - "GDB", the GNU debugger, is the recommended inferior debugger
          for DDD.  GDB supports native executables binaries originally
          written in C, C++, Java, Modula-2, Modula-3, Pascal, Chill,
          Ada, and FORTRAN.  (*note Using GDB with Different Languages:
          (gdb)Languages, for information on language support in GDB.)

        - As an alternative to GDB, you can use DDD with the "DBX"
          debugger, as found on several UNIX systems.  Most DBX
          incarnations offer fewer features than GDB, and some of the
          more advanced DBX features may not be supported by DDD.
          However, using DBX may be useful if GDB does not understand
          or fully support the debugging information as generated by
          your compiler.

        - As an alternative to GDB and DBX, you can use DDD with
          "Ladebug", as found on Compaq and DEC systems.  Ladebug
          offers fewer features than GDB, and some of the more advanced
          Ladebug features may not be supported by DDD.  However, using
          Ladebug may be useful if GDB or DBX do not understand or
          fully support the debugging information as generated by your
          compiler.(1)

        - As another alternative to GDB, you can use DDD with the "XDB"
          debugger, as found on HP-UX systems.(2).

   * To debug _Java byte code programs_, you can use DDD with "JDB",
     the Java debugger, as of JDK 1.1 and later.  (DDD has been tested
     with JDK 1.1 and JDK 1.2.)

   * To debug _Python programs_, you can use DDD with "PYDB", a Python
     debugger.

   * To debug _Perl programs_, you can use DDD with the "Perl
     debugger," as of Perl 5.003 and later.

   * To debug _Bash programs_, you need a version Bash that supports
     extended debugging support. To get this enhanced version see
     `http://bashdb.sourceforge.net'. You will need version
     2.05b-debugger-0.32 or later to work with DDD.

   *Note Choosing an Inferior Debugger::, for choosing the appropriate
inferior debugger.  *Note Sample Session::, for getting a first
impression of DDD.

* Menu:

* About this Manual::           Getting copies in various formats.
* Typographic Conventions::     Typographic conventions.
* Free Software::               How to copy and redistribute DDD.
* Getting DDD::              How to obtain copies of DDD.
* Contributors::                Who has done all this?
* History::                     Old DDD versions.

   ---------- Footnotes ----------

   (1) Within DDD (and this manual), Ladebug is considered a DBX
variant.  Hence, everything said for DBX also applies to Ladebug,
unless stated otherwise.

   (2) XDB will no longer be maintained in future DDD releases.  Use a
recent GDB version instead.


File: ddd.info,  Node: About this Manual,  Next: Typographic Conventions,  Up: Summary

About this Manual
=================

This manual comes in several formats:

   * The _Info_ format is used for browsing on character devices; it
     comes without pictures.  You should have a local copy installed,
     which you can browse via Emacs, the stand-alone `info' program, or
     from DDD via `Help => DDD Reference'.

     The DDD source distribution `ddd-3.3.11.tar.gz' contains this
     manual as pre-formatted info files; you can also download them
     from
     the DDD WWW page (http://www.gnu.org/software/ddd/).

   * The _PostScript_ format is used for printing on paper; it comes
     with pictures as well.

     The DDD source distribution `ddd-3.3.11.tar.gz' contains this
     manual as pre-formatted PostScript file; you can also download it
     from
     the DDD WWW page (http://www.gnu.org/software/ddd/).

   * The _PDF_ format is used for printing on paper as well as for
     online browsing; it comes with pictures as well.

     The DDD source distribution `ddd-3.3.11.tar.gz' contains this
     manual as pre-formatted PDF file; you can also download it from
     the DDD WWW page (http://www.gnu.org/software/ddd/).

   * The _HTML_ format is used for browsing on bitmap devices; it
     includes several pictures.  You can view it using a HTML browser,
     typically from a local copy.

     A pre-formatted HTML version of this manual comes in a separate
     DDD package
     `ddd-3.3.11-html-manual.tar.gz'; you can browse and download it
     via
     the DDD WWW page (http://www.gnu.org/software/ddd/).

   The manual itself is written in TeXinfo format; its source code
`ddd.texi' is contained in the DDD source distribution
`ddd-3.3.11.tar.gz'.

   The picture sources come in a separate package
`ddd-3.3.11-pics.tar.gz'; you need this package only if you want to
re-create the PostScript, HTML, or PDF versions.


File: ddd.info,  Node: Typographic Conventions,  Next: Free Software,  Prev: About this Manual,  Up: Summary

Typographic conventions
=======================

<Ctrl+A>
     The name for a key on the keyboard (or multiple keys pressed
     simultaneously)

`run'
     A sequence of characters to be typed on the keyboard.

`~/.ddd/init'
     A file.

`Help'
     A graphical control element, such as a button or menu item.

`File => Open Program'
     A sequence of menu items, starting at the top-level menu bar.

`argc - 1'
     Program code or debugger command.

`-g'
     A command-line option.

`$'
     System prompt.

`(gdb) '
     Debugger prompt.

`_'
     Cursor position.

VERSION
     A metasyntactic variable; something that stands for another piece
     of text.

"definition"
     A definition.

_caution_
     Emphasis.

*A warning*
     Strong emphasis.

DDD
     An acronym.

   Here's an example.  `break LOCATION' is a typed command at the
``(gdb) '' prompt; the metasyntactic variable `LOCATION' would be
replaced by the actual location.  ``_'' is the cursor position after
entering the command.

     (gdb) break LOCATION
     Breakpoint NUMBER at LOCATION
     (gdb) _


File: ddd.info,  Node: Free Software,  Next: Getting DDD,  Prev: Typographic Conventions,  Up: Summary

Free software
=============

DDD is "free"; this means that everyone is free to use it and free to
redistribute it on a free basis.  DDD is not in the public domain; it
is copyrighted and there are restrictions on its distribution, but
these restrictions are designed to permit everything that a good
cooperating citizen would want to do.  What is not allowed is to try to
prevent others from further sharing any version of DDD that they might
get from you.  The precise conditions are found in the GNU General
Public License that comes with DDD; *Note License::, for details.

   The easiest way to get a copy of DDD is from someone else who has
it.  You need not ask for permission to do so, or tell any one else;
just copy it.


File: ddd.info,  Node: Getting DDD,  Next: Contributors,  Prev: Free Software,  Up: Summary

Getting DDD
===========

If you have access to the Internet, you can get the latest version of
DDD from the anonymous FTP server `ftp.gnu.org' in the directory
`/gnu/ddd'.  This should contain the following files:

``ddd-VERSION.tar.gz''
     The DDD source distribution.  This should be all you need.

``ddd-VERSION-html-manual.tar.gz''
     The DDD manual in HTML format.  You need this only if you want to
     install a local copy of the DDD manual in HTML format.

``ddd-VERSION-pics.tar.gz''
     Sources of images included in the DDD manual.  You need this only
     if you want to recreate the DDD manual.

   DDD can also be found at numerous other archive sites around the
world; check the file `ANNOUNCE' in a DDD distribution for the latest
known list.


File: ddd.info,  Node: Contributors,  Next: History,  Prev: Getting DDD,  Up: Summary

Contributors to DDD
===================

Dorothea Lütkehaus and Andreas Zeller were the original authors of DDD.
Many others have contributed to its development.  The files `ChangeLog'
and `THANKS' in the DDD distribution approximates a blow-by-blow
account.


File: ddd.info,  Node: History,  Prev: Contributors,  Up: Summary

History of DDD
==============

The history of DDD is a story of code recycling.  The oldest parts of
DDD were written in 1990, when _Andreas Zeller_ designed VSL, a
box-based visual structure language for visualizing data and program
structures.  The VSL interpreter and the Box library became part of
Andreas' Diploma Thesis, a graphical syntax editor based on the
Programming System Generator PSG.

   In 1992, the VSL and Box libraries were recycled for the NORA
project.  For NORA, an experimental inference-based software
development tool set, Andreas wrote a graph editor (based on VSL and
the Box libraries) and facilities for inter-process knowledge exchange.
Based on these tools, _Dorothea Lütkehaus_ (now _Dorothea Krabiell_)
realized DDD as her Diploma Thesis, 1994.

   The original DDD had no source window; this was added by Dorothea
during the winter of 1994-1995.  In the first quarter of 1995, finally,
Andreas completed DDD by adding command and execution windows,
extensions for DBX and remote debugging as well as configuration
support for several architectures.  Since then, Andreas has further
maintained and extended DDD, based on the comments and suggestions of
several DDD users around the world.  See the comments in the DDD source
for details.

   Major DDD events:

April, 1995
     DDD 0.9: First DDD beta release.

May, 1995
     DDD 1.0: First public DDD release.

December, 1995
     DDD 1.4: Machine-level debugging, glyphs, Emacs integration.

October, 1996
     DDD 2.0: Color displays, XDB support, generic DBX support, command
     tool.

May, 1997
     DDD 2.1: Alias detection, button tips, status displays.

November, 1997
     DDD 2.2: Sessions, display shortcuts.

June, 1998
     DDD 3.0: Icon tool bar, Java support, JDB support.

December, 1998
     DDD 3.1: Data plotting, Perl support, Python support, Undo/Redo.

January, 2000
     DDD 3.2: New manual, Readline support, Ladebug support.

January, 2001
     DDD 3.3: Data themes, JDB 1.2 support, VxWorks support.

November, 2002
     DDD 3.3.2: Bash support.

March, 2003
     DDD 3.3.3: Better Bash support. Compiles using modern tools thanks
     to Daniel Schepler.


File: ddd.info,  Node: Sample Session,  Next: Invocation,  Prev: Summary,  Up: Top

1 A Sample DDD Session
**********************

You can use this manual at your leisure to read all about DDD.
However, a handful of features are enough to get started using the
debugger.  This chapter illustrates those features.

   The sample program `sample.c' (*note Sample Program::) exhibits the
following bug.  Normally, `sample' should sort and print its arguments
numerically, as in the following example:

     $ ./sample 8 7 5 4 1 3
     1 3 4 5 7 8
     $ _

   However, with certain arguments, this goes wrong:

     $ ./sample 8000 7000 5000 1000 4000
     1000 1913 4000 5000 7000
     $ _

   Although the output is sorted and contains the right number of
arguments, some arguments are missing and replaced by bogus numbers;
here, `8000' is missing and replaced by `1913'.(1)

   Let us use DDD to see what is going on.  First, you must compile
`sample.c' for debugging (*note Compiling for Debugging::), giving the
`-g' flag while compiling:

     $ gcc -g -o sample sample.c
     $ _

* Menu:

* Sample Program::              Source `sample.c'

   Now, you can invoke DDD (*note Invocation::) on the `sample'
executable:

     $ ddd sample

   After a few seconds, DDD comes up.  The "Source Window" contains the
source of your debugged program; use the "Scroll Bar" to scroll through
the file.

   The "Debugger Console" (at the bottom) contains DDD version
information as well as a GDB prompt.(2)

     GNU DDD Version 3.3.11, by Dorothea Lütkehaus and Andreas Zeller.
     Copyright (C) 1995-1999 Technische Universität Braunschweig, Germany.
     Copyright (C) 1999-2001 Universität Passau, Germany.
     Copyright (C) 2001-2004 Universität des Saarlandes, Germany.
     Reading symbols from sample...done.
     (gdb) _

   The first thing to do now is to place a "Breakpoint" (*note
Breakpoints::), making `sample' stop at a location you are interested
in.  Click on the blank space left to the initialization of `a'.  The
"Argument field" `():' now contains the location (`sample.c:31').  Now,
click on `Break' to create a breakpoint at the location in `()'.  You
see a little red stop sign appear in line 31.

   The next thing to do is to actually "execute" the program, such that
you can examine its behavior (*note Running::).  Select `Program =>
Run' to execute the program; the `Run Program' dialog appears.

   In `Run with Arguments', you can now enter arguments for the
`sample' program.  Enter the arguments resulting in erroneous behavior
here--that is, `8000 7000 5000 1000 4000'.  Click on `Run' to start
execution with the arguments you just entered.

   GDB now starts `sample'.  Execution stops after a few moments as the
breakpoint is reached.  This is reported in the debugger console.

     (gdb) break sample.c:31
     Breakpoint 1 at 0x8048666: file sample.c, line 31.
     (gdb) run 8000 7000 5000 1000 4000
     Starting program: sample 8000 7000 5000 1000 4000

     Breakpoint 1, main (argc=6, argv=0xbffff918) at sample.c:31
     (gdb) _

   The current execution line is indicated by a green arrow.

     => a = (int *)malloc((argc - 1) * sizeof(int));

   You can now examine the variable values.  To examine a simple
variable, you can simply move the mouse pointer on its name and leave
it there.  After a second, a small window with the variable value pops
up (*note Value Tips::).  Try this with `argc' to see its value (`6').
The local variable `a' is not yet initialized; you'll probably see
`0x0' or some other invalid pointer value.

   To execute the current line, click on the `Next' button on the
command tool.  The arrow advances to the following line.  Now, point
again on `a' to see that the value has changed and that `a' has
actually been initialized.

   To examine the individual values of the `a' array, enter `a[0]' in
the argument field (you can clear it beforehand by clicking on `():')
and then click on the `Print' button.  This prints the current value of
`()' in the debugger console (*note Printing Values::).  In our case,
you'll get

     (gdb) print a[0]
     $1 = 0
     (gdb) _

or some other value (note that `a' has only been allocated, but the
contents have not yet been initialized).

   To see all members of `a' at once, you must use a special GDB
operator.  Since `a' has been allocated dynamically, GDB does not know
its size; you must specify it explicitly using the `@' operator (*note
Array Slices::).  Enter `a[0]@(argc - 1)' in the argument field and
click on the `Print' button.  You get the first `argc - 1' elements of
`a', or

     (gdb) print a[0]@(argc - 1)
     $2 = {0, 0, 0, 0, 0}
     (gdb) _

   Rather than using `Print' at each stop to see the current value of
`a', you can also "display" `a', such that its is automatically
displayed.  With `a[0]@(argc - 1)' still being shown in the argument
field, click on `Display'.  The contents of `a' are now shown in a new
window, the "Data Window".  Click on `Rotate' to rotate the array
horizontally.

   Now comes the assignment of `a''s members:

     =>  for (i = 0; i < argc - 1; i++)
             a[i] = atoi(argv[i + 1]);

   You can now click on `Next' and `Next' again to see how the
individual members of `a' are being assigned.  Changed members are
highlighted.

   To resume execution of the loop, use the `Until' button.  This makes
GDB execute the program until a line greater than the current is
reached.  Click on `Until' until you end at the call of `shell_sort' in

     =>  shell_sort(a, argc);

   At this point, `a''s contents should be `8000 7000 5000 1000 4000'.
Click again on `Next' to step over the call to `shell_sort'.  DDD ends
in

     =>  for (i = 0; i < argc - 1; i++)
             printf("%d ", a[i]);

and you see that after `shell_sort' has finished, the contents of `a'
are `1000, 1913, 4000, 5000, 7000'--that is, `shell_sort' has somehow
garbled the contents of `a'.

   To find out what has happened, execute the program once again.  This
time, you do not skip through the initialization, but jump directly into
the `shell_sort' call.  Delete the old breakpoint by selecting it and
clicking on `Clear'.  Then, create a new breakpoint in line 35 before
the call to `shell_sort'.  To execute the program once again, select
`Program => Run Again'.

   Once more, DDD ends up before the call to `shell_sort':
     =>  shell_sort(a, argc);

   This time, you want to examine closer what `shell_sort' is doing.
Click on `Step' to step into the call to `shell_sort'.  This leaves
your program in the first executable line, or

     => int h = 1;

   while the debugger console tells us the function just entered:

     (gdb) step
     shell_sort (a=0x8049878, size=6) at sample.c:9
     (gdb) _

   This output that shows the function where `sample' is now suspended
(and its arguments) is called a "stack frame display".  It shows a
summary of the stack.  You can use `Status => Backtrace' to see where
you are in the stack as a whole; selecting a line (or clicking on `Up'
and `Down') will let you move through the stack.  Note how the `a'
display disappears when its frame is left.

   Let us now check whether `shell_sort''s arguments are correct.
After returning to the lowest frame, enter `a[0]@size' in the argument
field and click on `Print':

     (gdb) print a[0] @ size
     $4 = {8000, 7000, 5000, 1000, 4000, 1913}
     (gdb) _

   Surprise!  Where does this additional value `1913' come from?  The
answer is simple: The array size as passed in `size' to `shell_sort' is
_too large by one_--`1913' is a bogus value which happens to reside in
memory after `a'.  And this last value is being sorted in as well.

   To see whether this is actually the problem cause, you can now assign
the correct value to `size' (*note Assignment::).  Select `size' in the
source code and click on `Set'.  A dialog pops up where you can edit
the variable value.

   Change the value of `size' to `5' and click on `OK'.  Then, click on
`Finish' to resume execution of the `shell_sort' function:

     (gdb) set variable size = 5
     (gdb) finish
     Run till exit from #0  shell_sort (a=0x8049878, size=5) at sample.c:9
     0x80486ed in main (argc=6, argv=0xbffff918) at sample.c:35
     (gdb) _

   Success!  The `a' display now contains the correct values `1000,
4000, 5000, 7000, 8000'.

   You can verify that these values are actually printed to standard
output by further executing the program.  Click on `Cont' to continue
execution.

     (gdb) cont
     1000 4000 5000 7000 8000

     Program exited normally.
     (gdb) _

   The message `Program exited normally.' is from GDB; it indicates
that the `sample' program has finished executing.

   Having found the problem cause, you can now fix the source code.
Click on `Edit' to edit `sample.c', and change the line

     shell_sort(a, argc);

to the correct invocation

     shell_sort(a, argc - 1);

   You can now recompile `sample'

     $ gcc -g -o sample sample.c
     $ _

and verify (via `Program => Run Again') that `sample' works fine now.

     (gdb) run
     `sample' has changed; re-reading symbols.
     Reading in symbols...done.
     Starting program: sample 8000 7000 5000 1000 4000
     1000 4000 5000 7000 8000

     Program exited normally.
     (gdb) _

   All is done; the program works fine now.  You can end this DDD
session with `Program => Exit' or `Ctrl+Q'.

   ---------- Footnotes ----------

   (1) Actual numbers and behavior on your system may vary.

   (2) Re-invoke DDD with `--gdb', if you do not see a `(gdb)' prompt
here (*note Choosing an Inferior Debugger::)


File: ddd.info,  Node: Sample Program,  Up: Sample Session

1.1 Sample Program
==================

Here's the source `sample.c' of the sample program.


     /* sample.c -- Sample C program to be debugged with DDD */

     #include <stdio.h>
     #include <stdlib.h>

     static void shell_sort(int a[], int size)
     {
         int i, j;
         int h = 1;
         do {
             h = h * 3 + 1;
         } while (h <= size);
         do {
             h /= 3;
             for (i = h; i < size; i++)
             {
                 int v = a[i];
                 for (j = i; j >= h && a[j - h] > v; j -= h)
                     a[j] = a[j - h];
                 if (i != j)
                     a[j] = v;
             }
         } while (h != 1);
     }

     int main(int argc, char *argv[])
     {
         int *a;
         int i;

         a = (int *)malloc((argc - 1) * sizeof(int));
         for (i = 0; i < argc - 1; i++)
             a[i] = atoi(argv[i + 1]);

         shell_sort(a, argc);

         for (i = 0; i < argc - 1; i++)
             printf("%d ", a[i]);
         printf("\n");

         free(a);
         return 0;
     }


File: ddd.info,  Node: Invocation,  Next: Windows,  Prev: Sample Session,  Up: Top

2 Getting In and Out of DDD
***************************

This chapter discusses how to start DDD, and how to get out of it.  The
essentials are:

   * Type `ddd' to start DDD (*note Invoking::).

   * Use `File => Exit' or `Ctrl+Q' to exit (*note Quitting::).

* Menu:

* Invoking::                    How to invoke DDD.
* Quitting::                    How to quit DDD.
* Sessions::                    Saving work across invocations.
* Remote Debugging::            Running DDD on a different host.
* Customizing Debugger Interaction::  How DDD and GDB communicate.


File: ddd.info,  Node: Invoking,  Next: Quitting,  Up: Invocation

2.1 Invoking DDD
================

Normally, you can run DDD by invoking the program `ddd'.

   You can also run DDD with a variety of arguments and options, to
specify more of your debugging environment at the outset.

   The most usual way to start DDD is with one argument, specifying an
executable program:

     ddd PROGRAM

If you use GDB, DBX, Ladebug, or XDB as inferior debuggers, you can also
start with both an executable program and a core file specified:

     ddd PROGRAM CORE

   You can, instead, specify a process ID as a second argument, if you
want to debug a running process:

     ddd PROGRAM 1234

would attach DDD to process `1234' (unless you also have a file named
`1234'; DDD does check for a core file first).

   You can further control DDD by invoking it with specific "options".
To get a list of DDD options, invoke DDD as

     ddd --help

   Most important are the options to specify the inferior debugger
(*note Choosing an Inferior Debugger::), but you can also customize
several aspects of DDD upon invocation (*note Options::).

   DDD also understands the usual X options such as `-display' or
`-geometry'.  *Note X Options::, for details.

   All arguments and options that are not understood by DDD are passed
to the inferior debugger; *Note Inferior Debugger Options::, for a
survey.  To pass an option to the inferior debugger that conflicts with
an X option, or with a DDD option listed here, use the `--debugger'
option (*note Options::).

* Menu:

* Choosing an Inferior Debugger::  Which debugger to use?
* Options::                     How to invoke DDD
* X Options::                   Setting X properties
* Inferior Debugger Options::   Customizing GDB, DBX, and so on
* Multiple Instances::          Running multiple DDD instances
* X Warnings::                  Turning off obnoxious warnings


File: ddd.info,  Node: Choosing an Inferior Debugger,  Next: Options,  Up: Invoking

2.1.1 Choosing an Inferior Debugger
-----------------------------------

The most frequently required options are those to choose a specific
inferior debugger.

   Normally, the inferior debugger is determined by the program to
analyze:

   * If the program requires a specific interpreter, such as Java,
     Python, Perl or Bash, then you should use a JDB, PYDB, Perl, or
     Bash inferior debugger.

     Use

          ddd --jdb PROGRAM

          ddd --pydb PROGRAM

          ddd --perl PROGRAM

          ddd --bash PROGRAM
          ddd --interpreter='_path-to-debugger-bash_ --debugger' PROGRAM

     to run DDD with JDB, PYDB, Perl, or Bash as an inferior debugger.

   * If the program is an executable binary, you should use GDB, DBX,
     Ladebug, or XDB.  In general, GDB (or its HP variant, WDB)
     provides the most functionality of these debuggers.

     Use

          ddd --gdb PROGRAM

          ddd --wdb PROGRAM

          ddd --dbx PROGRAM

          ddd --ladebug PROGRAM

          ddd --xdb PROGRAM

     to run DDD with GDB, WDB, DBX, Ladebug, or XDB as inferior
     debugger.

   If you invoke DDD without any of these options, but give a PROGRAM
to analyze, then DDD will automatically determine the inferior debugger:

   * If PROGRAM is a Python program, a Perl script, or a Java class,
     DDD will invoke the appropriate debugger.

   * If PROGRAM is an executable binary, DDD will invoke its default
     debugger for executables (usually GDB).

   *Note Customizing Debugger Interaction::, for more details on
determining the inferior debugger.


File: ddd.info,  Node: Options,  Next: X Options,  Prev: Choosing an Inferior Debugger,  Up: Invoking

2.1.2 DDD Options
-----------------

You can further control how DDD starts up using the following options.
All options may be abbreviated, as long as they are unambiguous; single
dashes `-' instead of double dashes `--' may also be used.  Almost all
options control a specific DDD resource or resource class (*note
Customizing::).

`--attach-windows'
     Attach the source and data windows to the debugger console,
     creating one single big DDD window.  This is the default setting.

     Giving this option is equivalent to setting the DDD `Separate'
     resource class to `off'.  *Note Window Layout::, for details.

`--attach-source-window'
     Attach only the source window to the debugger console.

     Giving this option is equivalent to setting the DDD
     `separateSourceWindow' resource to `off'.  *Note Window Layout::,
     for details.

`--attach-data-window'
     Attach only the source window to the debugger console.

     Giving this option is equivalent to setting the DDD
     `separateDataWindow' resource to `off'.  *Note Window Layout::,
     for details.

`--automatic-debugger'
     Determine the inferior debugger automatically from the given
     arguments.

     Giving this option is equivalent to setting the DDD `autoDebugger'
     resource to `on'.  *Note Customizing Debugger Interaction::, for
     details.

`--button-tips'
     Enable button tips.

     Giving this option is equivalent to setting the DDD `buttonTips'
     resource to `on'.  *Note Customizing Help::, for details.

`--configuration'
     Print the DDD configuration settings on standard output and exit.

     Giving this option is equivalent to setting the DDD
     `showConfiguration' resource to `on'.  *Note Diagnostics::, for
     details.

`--check-configuration'
     Check the DDD environment (in particular, the X configuration),
     report any possible problem causes and exit.

     Giving this option is equivalent to setting the DDD
     `checkConfiguration' resource to `on'.  *Note Diagnostics::, for
     details.

`--data-window'
     Open the data window upon start-up.

     Giving this option is equivalent to setting the DDD
     `openDataWindow' resource to `on'.  *Note Toggling Windows::, for
     details.

`--dbx'
     Run DBX as inferior debugger.

     Giving this option is equivalent to setting the DDD `debugger'
     resource to `dbx'.  *Note Customizing Debugger Interaction::, for
     details.

`--debugger NAME'
     Invoke the inferior debugger NAME.  This is useful if you have
     several debugger versions around, or if the inferior debugger
     cannot be invoked under its usual name (i.e. `gdb', `wdb', `dbx',
     `xdb', `jdb', `pydb', or `perl').

     This option can also be used to pass options to the inferior
     debugger that would otherwise conflict with DDD options.  For
     instance, to pass the option `-d DIRECTORY' to XDB, use:

          ddd --debugger "xdb -d DIRECTORY"

     If you use the `--debugger' option, be sure that the type of
     inferior debugger is specified as well.  That is, use one of the
     options `--gdb', `--dbx', `--xdb', `--jdb', `--pydb', or `--perl'
     (unless the default setting works fine).

     Giving this option is equivalent to setting the DDD
     `debuggerCommand' resource to NAME.  *Note Customizing Debugger
     Interaction::, for details.

`--debugger-console'
     Open the debugger console upon start-up.

     Giving this option is equivalent to setting the DDD
     `openDebuggerConsole' resource to `on'.  *Note Toggling Windows::,
     for details.

`--disassemble'
     Disassemble the source code.  See also the `--no-disassemble'
     option, below.

     Giving this option is equivalent to setting the DDD `disassemble'
     resource to `on'.  *Note Customizing Source::, for details.

`--exec-window'
     Run the debugged program in a specially created execution window.
     This is useful for programs that have special terminal
     requirements not provided by the debugger window, as raw keyboard
     processing or terminal control sequences.  *Note Using the
     Execution Window::, for details.

     Giving this option is equivalent to setting the DDD
     `separateExecWindow' resource to `on'.  *Note Customizing the
     Execution Window::, for details.

`--font FONTNAME'
`-fn FONTNAME'
     Use FONTNAME as default font.

     Giving this option is equivalent to setting the DDD `defaultFont'
     resource to `fontname'.  *Note Customizing Fonts::, for details.

`--fonts'
     Show the font definitions used by DDD on standard output.

     Giving this option is equivalent to setting the DDD `showFonts'
     resource to `on'.  *Note Diagnostics::, for details.

`--fontsize SIZE'
     Set the default font size to SIZE (in 1/10 points).  To make DDD
     use 12-point fonts, say `--fontsize 120'.

     Giving this option is equivalent to setting the DDD `FontSize'
     resource class to `size'.  *Note Customizing Fonts::, for details.

`--fullname'
`-f'
     Enable the TTY interface, taking additional debugger commands from
     standard input and forwarding debugger output on standard output.
     Current positions are issued in GDB `-fullname' format suitable
     for debugger front-ends.  By default, both the debugger console
     and source window are disabled.  *Note TTY mode::, for a
     discussion.

     Giving this option is equivalent to setting the DDD `TTYMode'
     resource class to `on'.  *Note TTY mode::, for details.

`--gdb'
     Run GDB as inferior debugger.

     Giving this option is equivalent to setting the DDD `debugger'
     resource to `gdb'.  *Note Customizing Debugger Interaction::, for
     details.

`--glyphs'
     Display the current execution position and breakpoints as glyphs.
     See also the `--no-glyphs' option, below.

     Giving this option is equivalent to setting the DDD
     `displayGlyphs' resource to `on'.  *Note Customizing Source::, for
     details.

`--help'
`-h'
`-?'
     Give a list of frequently used options.  Show options of the
     inferior debugger as well.

     Giving this option is equivalent to setting the DDD
     `showInvocation' resource to `on'.  *Note Diagnostics::, for
     details.

`--host HOSTNAME'
`--host USERNAME@HOSTNAME'
     Invoke the inferior debugger directly on the remote host HOSTNAME.
     If USERNAME is given and the `--login' option is not used, use
     USERNAME as remote user name.  *Note Remote Debugger::, for
     details.

     Giving this option is equivalent to setting the DDD `debuggerHost'
     resource to HOSTNAME.  *Note Remote Debugger::, for details.

`--jdb'
     Run JDB as inferior debugger.

     Giving this option is equivalent to setting the DDD `debugger'
     resource to `gdb'.  *Note Customizing Debugger Interaction::, for
     details.

`--ladebug'
     Run Ladebug as inferior debugger.

     Giving this option is equivalent to setting the DDD `debugger'
     resource to `ladebug'.  *Note Customizing Debugger Interaction::,
     for details.

`--lesstif-hacks'
     Equivalent to `--lesstif-version 999'.  Deprecated.

     Giving this option is equivalent to setting the DDD
     `lessTifVersion' resource to `999'.  *Note LessTif::, for details.

`--lesstif-version VERSION'
     Enable some hacks to make DDD run properly with LessTif.  *Note
     LessTif::, for a discussion.

     Giving this option is equivalent to setting the DDD
     `lessTifVersion' resource to VERSION.  *Note LessTif::, for
     details.

`--license'
     Print the DDD license on standard output and exit.

     Giving this option is equivalent to setting the DDD `showLicense'
     resource to ON.  *Note Diagnostics::, for details.

`--login USERNAME'
`-l USERNAME'
     Use USERNAME as remote user name.  *Note Remote Debugger::, for
     details.

     Giving this option is equivalent to setting the DDD
     `debuggerHostLogin' resource to USERNAME.  *Note Remote
     Debugger::, for details.

`--maintenance'
     Enable the top-level `Maintenance' menu with options for debugging
     DDD.  *Note Maintenance Menu::, for details.

     Giving this option is equivalent to setting the DDD `maintenance'
     resource to ON.  *Note Maintenance Menu::, for details.

`--manual'
     Print the DDD manual on standard output and exit.

     Giving this option is equivalent to setting the DDD `showManual'
     resource to ON.  *Note Diagnostics::, for details.

`--news'
     Print the DDD news on standard output and exit.

     Giving this option is equivalent to setting the DDD `showNews'
     resource to ON.  *Note Diagnostics::, for details.

`--no-button-tips'
     Disable button tips.

     Giving this option is equivalent to setting the DDD `buttonTips'
     resource to `off'.  *Note Customizing Help::, for details.

`--no-data-window'
     Do not open the data window upon start-up.

     Giving this option is equivalent to setting the DDD
     `openDataWindow' resource to `off'.  *Note Toggling Windows::, for
     details.

`--no-debugger-console'
     Do not open the debugger console upon start-up.

     Giving this option is equivalent to setting the DDD
     `openDebuggerConsole' resource to `off'.  *Note Toggling
     Windows::, for details.

`--no-disassemble'
     Do not disassemble the source code.

     Giving this option is equivalent to setting the DDD `disassemble'
     resource to `off'.  *Note Customizing Source::, for details.

`--no-exec-window'
     Do not run the debugged program in a specially created execution
     window; use the debugger console instead.  Useful for programs
     that have little terminal input/output, or for remote debugging.
     *Note Using the Execution Window::, for details.

     Giving this option is equivalent to setting the DDD
     `separateExecWindow' resource to `off'.  *Note Customizing the
     Execution Window::, for details.

`--no-glyphs'
     Do not use glyphs; display the current execution position and
     breakpoints as text characters.

     Giving this option is equivalent to setting the DDD
     `displayGlyphs' resource to `off'.  *Note Customizing Source::,
     for details.

`--no-lesstif-hacks'
     Equivalent to `--lesstif-version 1000'.  Deprecated.

     Giving this option is equivalent to setting the DDD
     `lessTifVersion' resource to `1000'.  *Note LessTif::, for details.

`--no-maintenance'
     Do not enable the top-level `Maintenance' menu with options for
     debugging DDD.  This is the default.  *Note Maintenance Menu::,
     for details.

     Giving this option is equivalent to setting the DDD `maintenance'
     resource to OFF.  *Note Maintenance Menu::, for details.

`--no-source-window'
     Do not open the source window upon start-up.

     Giving this option is equivalent to setting the DDD
     `openSourceWindow' resource to `off'.  *Note Toggling Windows::,
     for details.

`--no-value-tips'
     Disable value tips.

     Giving this option is equivalent to setting the DDD `valueTips'
     resource to `off'.  *Note Value Tips::, for details.

`--nw'
     Do not use the X window interface.  Start the inferior debugger on
     the local host.

`--perl'
     Run Perl as inferior debugger.

     Giving this option is equivalent to setting the DDD `debugger'
     resource to `perl'.  *Note Customizing Debugger Interaction::, for
     details.

`--pydb'
     Run PYDB as inferior debugger.

     Giving this option is equivalent to setting the DDD `debugger'
     resource to `pydb'.  *Note Customizing Debugger Interaction::, for
     details.

`--panned-graph-editor'
     Use an Athena panner to scroll the data window.  Most people prefer
     panners on scroll bars, since panners allow two-dimensional
     scrolling.  However, the panner is off by default, since some
     M*tif implementations do not work well with Athena widgets.  *Note
     Display Resources::, for details; see also
     `--scrolled-graph-editor', below.

     Giving this option is equivalent to setting the DDD
     `pannedGraphEditor' resource to `on'.  *Note Display Resources::,
     for details.

`--play-log LOG-FILE'
     Recapitulate a previous DDD session.

          ddd --play-log LOG-FILE

     invokes DDD as inferior debugger, simulating the inferior debugger
     given in LOG-FILE (see below).  This is useful for debugging DDD.

     Giving this option is equivalent to setting the DDD `playLog'
     resource to `on'.  *Note Customizing Debugger Interaction::, for
     details.

`--PLAY LOG-FILE'
     Simulate an inferior debugger.  LOG-FILE is a `~/.ddd/log' file as
     generated by some previous DDD session (*note Logging::).  When a
     command is entered, scan LOG-FILE for this command and re-issue
     the logged reply; if the command is not found, do nothing.  This
     is used by the `--play' option.

`--rhost HOSTNAME'
`--rhost USERNAME@HOSTNAME'
     Run the inferior debugger interactively on the remote host
     HOSTNAME.  If USERNAME is given and the `--login' option is not
     used, use USERNAME as remote user name.  *Note Remote Debugger::,
     for details.

     Giving this option is equivalent to setting the DDD
     `debuggerRHost' resource to HOSTNAME.  *Note Remote Debugger::,
     for details.

`--scrolled-graph-editor'
     Use M*tif scroll bars to scroll the data window.  This is the
     default in most DDD configurations.  *Note Display Resources::,
     for details; see also `--panned-graph-editor', above.

     Giving this option is equivalent to setting the DDD
     `pannedGraphEditor' resource to `off'.  *Note Display Resources::,
     for details.

`--separate-windows'
`--separate'
     Separate the console, source and data windows.  See also the
     `--attach' options, above.

     Giving this option is equivalent to setting the DDD `Separate'
     resource class to `off'.  *Note Window Layout::, for details.

`--session SESSION'
     Load SESSION upon start-up.  *Note Resuming Sessions::, for
     details.

     Giving this option is equivalent to setting the DDD `session'
     resource to SESSION.  *Note Resuming Sessions::, for details.

`--source-window'
     Open the source window upon start-up.

     Giving this option is equivalent to setting the DDD
     `openSourceWindow' resource to `on'.  *Note Toggling Windows::,
     for details.

`--status-at-bottom'
     Place the status line at the bottom of the source window.

     Giving this option is equivalent to setting the DDD
     `statusAtBottom' resource to `on'.  *Note Window Layout::, for
     details.

`--status-at-top'
     Place the status line at the top of the source window.

     Giving this option is equivalent to setting the DDD
     `statusAtBottom' resource to `off'.  *Note Window Layout::, for
     details.

`--sync-debugger'
     Do not process X events while the debugger is busy.  This may
     result in slightly better performance on single-processor systems.

     Giving this option is equivalent to setting the DDD
     `synchronousDebugger' resource to `on'.  *Note Customizing
     Debugger Interaction::, for details.

`--toolbars-at-bottom'
     Place the toolbars at the bottom of the respective window.

     Giving this option is equivalent to setting the DDD
     `toolbarsAtBottom' resource to `on'.  *Note Window Layout::, for
     details.

`--toolbars-at-top'
     Place the toolbars at the top of the respective window.

     Giving this option is equivalent to setting the DDD
     `toolbarsAtBottom' resource to `off'.  *Note Window Layout::, for
     details.

`--trace'
     Show the interaction between DDD and the inferior debugger on
     standard error.  This is useful for debugging DDD.  If `--trace'
     is not specified, this information is written into `~/.ddd/log'
     (`~' stands for your home directory), such that you can also do a
     post-mortem debugging.  *Note Logging::, for details about logging.

     Giving this option is equivalent to setting the DDD `trace'
     resource to ON.  *Note Diagnostics::, for details.

`--tty'
`-t'
     Enable TTY interface, taking additional debugger commands from
     standard input and forwarding debugger output on standard output.
     Current positions are issued in a format readable for humans.  By
     default, the debugger console is disabled.

     Giving this option is equivalent to setting the DDD `ttyMode'
     resource to `on'.  *Note TTY mode::, for details.

`--value-tips'
     Enable value tips.

     Giving this option is equivalent to setting the DDD `valueTips'
     resource to `on'.  *Note Value Tips::, for details.

`--version'
`-v'
     Print the DDD version on standard output and exit.

     Giving this option is equivalent to setting the DDD `showVersion'
     resource to `on'.  *Note Diagnostics::, for details.

`--vsl-library LIBRARY'
     Load the VSL library LIBRARY instead of using the DDD built-in
     library.  This is useful for customizing display shapes and fonts.

     Giving this option is equivalent to setting the DDD `vslLibrary'
     resource to LIBRARY.  *Note VSL Resources::, for details.

`--vsl-path PATH'
     Search VSL libraries in PATH (a colon-separated directory list).

     Giving this option is equivalent to setting the DDD `vslPath'
     resource to PATH.  *Note VSL Resources::, for details.

`--vsl-help'
     Show a list of further options controlling the VSL interpreter.
     These options are intended for debugging purposes and are subject
     to change without further notice.

`--wdb'
     Run WDB as inferior debugger.

     Giving this option is equivalent to setting the DDD `debugger'
     resource to `wdb'.  *Note Customizing Debugger Interaction::, for
     details.

`--xdb'
     Run XDB as inferior debugger.

     Giving this option is equivalent to setting the DDD `debugger'
     resource to `xdb'.  *Note Customizing Debugger Interaction::, for
     details.


File: ddd.info,  Node: X Options,  Next: Inferior Debugger Options,  Prev: Options,  Up: Invoking

2.1.3 X Options
---------------

DDD also understands the following X options.  Note that these options
only take a single dash `-'.

`-display DISPLAY'
     Use the X server DISPLAY.  By default, DISPLAY is taken from the
     `DISPLAY' environment variable.

`-geometry GEOMETRY'
     Specify the initial size and location of the debugger console.

`-iconic'
     Start DDD iconified.

`-name NAME'
     Give DDD the name NAME.

`-selectionTimeout TIMEOUT'
     Specify the timeout in milliseconds within which two communicating
     applications must respond to one another for a selection request.

`-title NAME'
     Give the DDD window the title NAME.

`-xrm RESOURCESTRING'
     Specify a resource name and value to override any defaults.  


File: ddd.info,  Node: Inferior Debugger Options,  Next: Multiple Instances,  Prev: X Options,  Up: Invoking

2.1.4 Inferior Debugger Options
-------------------------------

All options that DDD does not recognize are passed to the inferior
debugger.  This section lists the most useful options of the different
inferior debuggers supported by DDD.  In case these options do not work
as expected, please lookup the appropriate reference.

* Menu:

* GDB Options::
* DBX and Ladebug Options::
* XDB Options::
* JDB Options::
* PYDB Options::
* Perl Options::
* Bash Options::


File: ddd.info,  Node: GDB Options,  Next: DBX and Ladebug Options,  Up: Inferior Debugger Options

2.1.4.1 GDB Options
...................

These GDB options are useful when using DDD with GDB as inferior
debugger.  Single dashes `-' instead of double dashes `--' may also be
used.

`-b BAUDRATE'
     Set serial port baud rate used for remote debugging.

`--cd DIR'
     Change current directory to DIR.

`--command FILE'
     Execute GDB commands from FILE.

`--core COREFILE'
     Analyze the core dump COREFILE.

`--directory DIR'
`-d DIR'
     Add DIRECTORY to the path to search for source files.

`--exec EXECFILE'
     Use EXECFILE as the executable.

`--mapped'
     Use mapped symbol files if supported on this system.

`--nx'

`-n'
     Do not read `.gdbinit' file.

`--readnow'
     Fully read symbol files on first access.

`--se FILE'
     Use FILE as symbol file and executable file.

`--symbols SYMFILE'
     Read symbols from SYMFILE.

   *Note Invoking GDB: (gdb)Invoking GDB, for further options that can
be used with GDB.


File: ddd.info,  Node: DBX and Ladebug Options,  Next: XDB Options,  Prev: GDB Options,  Up: Inferior Debugger Options

2.1.4.2 DBX and Ladebug Options
...............................

DBX variants differ widely in their options, so we cannot give a list
here.  Check out the `dbx(1)' and `ladebug(1)' manual pages.


File: ddd.info,  Node: XDB Options,  Next: JDB Options,  Prev: DBX and Ladebug Options,  Up: Inferior Debugger Options

2.1.4.3 XDB Options
...................

These XDB options are useful when using DDD with XDB as inferior
debugger.

`-d DIR'
     Specify DIR as an alternate directory where source files are
     located.

`-P PROCESS-ID'
     Specify the process ID of an existing process the user wants to
     debug.

`-l LIBRARY'
     Pre-load information about the shared library LIBRARY.  `-l ALL'
     means always pre-load shared library information.

`-S NUM'
     Set the size of the string cache to NUM bytes (default is 1024,
     which is also the minimum).

`-s'
     Enable debugging of shared libraries.

   Further options can be found in the `xdb(1)' manual page.


File: ddd.info,  Node: JDB Options,  Next: PYDB Options,  Prev: XDB Options,  Up: Inferior Debugger Options

2.1.4.4 JDB Options
...................

JDB as of JDK 1.2
.................

The following JDB options are useful when using DDD with JDB (from JDK
1.2) as inferior debugger.

`-attach ADDRESS'
     attach to a running virtual machine (VM) at ADDRESS using standard
     connector

`-listen ADDRESS'
     wait for a running VM to connect at ADDRESS using standard
     connector

`-listenany'
     wait for a running VM to connect at any available address using
     standard connector

`-launch'
     launch VM immediately instead of waiting for `run' command

   These JDB options are forwarded to the debuggee:

`-verbose[:class|gc|jni]'
`-v'
     Turn on verbose mode.

`-DNAME=VALUE'
     Set the system property NAME to VALUE.

`-classpath PATH'
     List directories in which to look for classes.  PATH is a list of
     directories separated by colons.

`-X OPTION'
     Non-standard target VM option

JDB as of JDK 1.1
.................

The following JDB options are useful when using DDD with JDB (from JDK
1.1) as inferior debugger.

`-host HOSTNAME'
     host machine of interpreter to attach to

`-password PSSWD'
     password of interpreter to attach to (from `-debug')

   These JDB options are forwarded to the debuggee:

`-verbose'
`-v'
     Turn on verbose mode.

`-debug'
     Enable remote Java debugging,

`-noasyncgc'
     Don't allow asynchronous garbage collection.

`-verbosegc'
     Print a message when garbage collection occurs.

`-noclassgc'
     Disable class garbage collection.

`-checksource'
`-cs'
     Check if source is newer when loading classes.

`-ss NUMBER'
     Set the maximum native stack size for any thread.

`-oss NUMBER'
     Set the maximum Java stack size for any thread.

`-ms NUMBER'
     Set the initial Java heap size.

`-mx NUMBER'
     Set the maximum Java heap size.

`-DNAME=VALUE'
     Set the system property NAME to VALUE.

`-classpath PATH'
     List directories in which to look for classes.  PATH is a list of
     directories separated by colons.

`-prof'
`-prof:FILE'
     Output profiling data to `./java.prof'.  If FILE is given, write
     the data to `./FILE'.

`-verify'
     Verify all classes when read in.

`-verifyremote'
     Verify classes read in over the network (default).

`-noverify'
     Do not verify any class.

`-dbgtrace'
     Print info for debugging JDB.

   Further options can be found in the JDB documentation.


File: ddd.info,  Node: PYDB Options,  Next: Perl Options,  Prev: JDB Options,  Up: Inferior Debugger Options

2.1.4.5 PYDB Options
....................

For a list of useful PYDB options, check out the PYDB documentation.


File: ddd.info,  Node: Perl Options,  Next: Bash Options,  Prev: PYDB Options,  Up: Inferior Debugger Options

2.1.4.6 Perl Options
....................

The most important Perl option to use with DDD is `-w'; it enables
several important warnings.  For further options, see the `perlrun(1)'
manual page.


File: ddd.info,  Node: Bash Options,  Prev: Perl Options,  Up: Inferior Debugger Options

2.1.4.7 Bash Options
....................

If you have the proper bash installed, the option needed to specify
debugging support is `--debugger'. (If your bash doesn't understand
this option you need to pick up a version of bash that does from
`http://bashdb.sourceforge.net'.)


File: ddd.info,  Node: Multiple Instances,  Next: X Warnings,  Prev: Inferior Debugger Options,  Up: Invoking

2.1.5 Multiple DDD Instances
----------------------------

If you have multiple DDD instances running, they share common
preferences and history files.  This means that changes applied to one
instance may get lost when being overwritten by the other instance.
DDD has two means to protect you against unwanted losses.  The first
means is an automatic reloading of changed options, controlled by the
following resource (*note Customizing::):

 -- Resource: checkOptions (class CheckOptions)
     Every N seconds, where N is the value of this resource, DDD checks
     whether the options file has changed.  Default is `30', which
     means that every 30 seconds, DDD checks for the options file.
     Setting this resource to `0' disables checking for changed option
     files.

   Normally, automatic reloading of options should already suffice.  If
you need stronger protection, DDD also provides a warning against
multiple instances.  This warning is disabled by default, If you want to
be warned about multiple DDD invocations sharing the same preferences
and history files, enable `Edit => Preferences => Warn if Multiple DDD
Instances are Running'.

   This setting is tied to the following resource (*note Customizing::):

 -- Resource: warnIfLocked (class WarnIfLocked)
     Whether to warn if multiple DDD instances are running (`on') or
     not (`off', default).


File: ddd.info,  Node: X Warnings,  Prev: Multiple Instances,  Up: Invoking

2.1.6 X warnings
----------------

If you are bothered by X warnings, you can suppress them by setting
`Edit => Preferences => General => Suppress X warnings'.

   This setting is tied to the following resource (*note Customizing::):

 -- Resource: suppressWarnings (class SuppressWarnings)
     If `on', X warnings are suppressed.  This is sometimes useful for
     executables that were built on a machine with a different X or
     M*tif configuration.  By default, this is `off'.


File: ddd.info,  Node: Quitting,  Next: Sessions,  Prev: Invoking,  Up: Invocation

2.2 Quitting DDD
================

To exit DDD, select `File => Exit'.  You may also type the `quit'
command at the debugger prompt or press <Ctrl+Q>.  GDB and XDB also
accept the `q' command or an end-of-file character (usually <Ctrl+D>).
Closing the last DDD window will also exit DDD.

   An interrupt (<ESC> or `Interrupt') does not exit from DDD, but
rather terminates the action of any debugger command that is in
progress and returns to the debugger command level.  It is safe to type
the interrupt character at any time because the debugger does not allow
it to take effect until a time when it is safe.

   In case an ordinary interrupt does not succeed, you can also use an
abort (<Ctrl+\> or `Abort'), which sends a `SIGABRT' signal to the
inferior debugger.  Use this in emergencies only; the inferior debugger
may be left inconsistent or even exit after a `SIGABRT' signal.

   As a last resort (if DDD hangs, for example), you may also interrupt
DDD itself using an interrupt signal (`SIGINT').  This can be done by
typing the interrupt character (usually <Ctrl+C>) in the shell DDD was
started from, or by using the UNIX `kill' command.  An interrupt signal
interrupts any DDD action; the inferior debugger is interrupted as
well.  Since this interrupt signal can result in internal
inconsistencies, use this as a last resort in emergencies only; save
your work as soon as possible and restart DDD.


File: ddd.info,  Node: Sessions,  Next: Remote Debugging,  Prev: Quitting,  Up: Invocation

2.3 Persistent Sessions
=======================

If you want to interrupt your current DDD session, you can save the
entire the entire DDD state as "session" on disk and resume later.

* Menu:

* Saving Sessions::
* Resuming Sessions::
* Deleting Sessions::
* Customizing Sessions::


File: ddd.info,  Node: Saving Sessions,  Next: Resuming Sessions,  Up: Sessions

2.3.1 Saving Sessions
---------------------

To save a session, select `File => Save Session As'.  You will be asked
for a symbolic session name SESSION.

   If your program is running (*note Running::), or if you have opened a
core file (*note Opening Core Dumps::), DDD can also include a core
file in the session such that the debuggee data will be restored when
re-opening it.  To get a core file, DDD typically must "kill" the
debuggee.  This means that you cannot resume program execution after
saving a session.  Depending on your architecture, other options for
getting a core file may also be available.

   Including a core dump is necessary for restoring memory contents and
the current execution position.  To include a core dump, enable
`Include Core Dump'.

   After clicking on `Save', the session is saved in
`~/.ddd/sessions/SESSION'.

   Here's a list of the items whose state is saved in a session:
   * The state of the debugged program, as a core file.(1)

   * All breakpoints and watchpoints (*note Stopping::).

   * All signal settings (*note Signals::).

   * All displays (*note Displaying Values::).(2)

   * All DDD options (*note Saving Options::).

   * All debugger settings (*note Debugger Settings::).

   * All user-defined buttons (*note Defining Buttons::).

   * All user-defined commands (*note Defining Commands::).

   * The positions and sizes of DDD windows.

   * The command history (*note Command History::).

   After saving the current state as a session, the session becomes
"active".  This means that DDD state will be saved as session defaults:

   * User options will be saved in `~/.ddd/sessions/SESSION/init'
     instead of `~/.ddd/init'.  *Note Saving Options::, for details.

   * The DDD command history will be saved in
     `~/.ddd/sessions/SESSION/history' instead of `~/.ddd/history'.
     *Note Command History::, for details.

   To make the current session inactive, open the _default session_
named `[None]'.  *Note Resuming Sessions::, for details on opening
sessions.

   ---------- Footnotes ----------

   (1) Only if a core file is included.

   (2) If a core file is _not_ to be included in the session, DDD data
displays are saved as _deferred_; that is, they will be restored as
soon as program execution reaches the scope in which they were created.
*Note Creating Single Displays::, for details.


File: ddd.info,  Node: Resuming Sessions,  Next: Deleting Sessions,  Prev: Saving Sessions,  Up: Sessions

2.3.2 Resuming Sessions
-----------------------

To resume a previously saved session, select `File => Open Session' and
choose a session name from the list.  After clicking on `Open', the
entire DDD state will be restored from the given session.

   The session named `[None]' is the "default session" which is active
when starting DDD.  To save options for default sessions, choose the
default session before exiting DDD.  *Note Saving Options::, for
details.

   If a the restored session includes a core dump, the program being
debugged will be in the same state at the time the session was saved; in
particular, you can examine the program data.  However, you will not be
able to resume program execution since the process and its environment
(open files, resources, etc.) no longer exist.  However, you can restart
the program, re-using the restored breakpoints and data displays.

   Opening sessions also restores command definitions, buttons, display
shortcuts and the source tab width.  This way, you can maintain a
different set of definitions for each session.

   You can also specify a session to open when starting DDD.  To invoke
DDD with a session SESSION, use

     ddd --session SESSION

   There is also a shortcut that opens the session SESSION and invokes
the inferior debugger on an executable named SESSION (in case SESSION
cannot be opened):

     ddd =SESSION

   There is no need to give further command-line options when
restarting a session, as they will be overridden by the options saved
in the session.

   You can also use an X session manager such as `xsm' to save and
restore DDD sessions.(1) When being shut down by a session manager, DDD
saves its state under the name specified by the session manager;
resuming the X session makes DDD reload its saved state.

   ---------- Footnotes ----------

   (1) Requires X11R6 or later.


File: ddd.info,  Node: Deleting Sessions,  Next: Customizing Sessions,  Prev: Resuming Sessions,  Up: Sessions

2.3.3 Deleting Sessions
-----------------------

To delete sessions that are no longer needed, select `File => Open
Session' or `File => Save Session'.  Select the sessions you want to
delete and click on `Delete'.

   The default session `[None]' cannot be deleted.


File: ddd.info,  Node: Customizing Sessions,  Prev: Deleting Sessions,  Up: Sessions

2.3.4 Customizing Sessions
--------------------------

You can change the place where DDD saves its sessions by setting the
environment variable `DDD_SESSIONS' to the name of a directory.
Default is `~/.ddd/sessions/'.

   Where applicable, DDD supports a `gcore' command to obtain core
files of the running program.  You can enter its path via `Edit =>
Preferences => Helpers => Get Core File'.  Leave the value empty if you
have no `gcore' or similar command.

   This setting is tied to the following resource (*note Customizing::):

 -- Resource: getCoreCommand (class GetCoreCommand)
     A command to get a core dump of a running process (typically,
     `gcore') `@FILE@' is replaced by the base name of the file to
     create; `@PID@' is replaced by the process id.  The output must be
     written to `@FILE@.@PID@'.

     Leave the value empty if you have no `gcore' or similar command.


File: ddd.info,  Node: Remote Debugging,  Next: Customizing Debugger Interaction,  Prev: Sessions,  Up: Invocation

2.4 Remote Debugging
====================

You can have each of DDD, the inferior debugger, and the debugged
program run on different machines.

* Menu:

* Remote Host::                 Running DDD on a Remote Host
* Remote Debugger::             Using a Remote Inferior Debugger
* Remote Program::              Debugging a Remote Program


File: ddd.info,  Node: Remote Host,  Next: Remote Debugger,  Up: Remote Debugging

2.4.1 Running DDD on a Remote Host
----------------------------------

You can run DDD on a remote host, using your current host as X display.
On the remote host, invoke DDD as

     ddd -display DISPLAY

where DISPLAY is the name of the X server to connect to (for instance,
`HOSTNAME:0.0', where HOSTNAME is your host).

   Instead of specifying `-display DISPLAY', you can also set the
`DISPLAY' environment variable to DISPLAY.


File: ddd.info,  Node: Remote Debugger,  Next: Remote Program,  Prev: Remote Host,  Up: Remote Debugging

2.4.2 Using DDD with a Remote Inferior Debugger
-----------------------------------------------

In order to run the inferior debugger on a remote host, you need
`remsh' (called `rsh' on BSD systems) access on the remote host.

   To run the debugger on a remote host HOSTNAME, invoke DDD as
     ddd --host HOSTNAME REMOTE-PROGRAM

   If your remote USERNAME differs from the local username, use

     ddd --host HOSTNAME --login USERNAME REMOTE-PROGRAM

or

     ddd --host USERNAME@HOSTNAME REMOTE-PROGRAM

instead.

   There are a few _caveats_ in remote mode:

   * The remote debugger is started in your remote home directory.
     Hence, you must specify an absolute path name for REMOTE-PROGRAM
     (or a path name relative to your remote home directory).  Same
     applies to remote core files.  Also, be sure to specify a remote
     process id when debugging a running program.

   * The remote debugger is started non-interactively.  Some DBX
     versions have trouble with this.  If you do not get a prompt from
     the remote debugger, use the `--rhost' option instead of `--host'.
     This will invoke the remote debugger via an interactive shell on
     the remote host, which may lead to better results.

     Note: using `--rhost', DDD invokes the inferior debugger as soon
     as a shell prompt appears.  The first output on the remote host
     ending in a space character or `>' and not followed by a newline is
     assumed to be a shell prompt.  If necessary, adjust your shell
     prompt on the remote host.

   * To run the remote program, DDD invokes an `xterm' terminal
     emulator on the remote host, giving your current `DISPLAY'
     environment variable as address.  If the remote host cannot invoke
     `xterm', or does not have access to your X display, start DDD with
     the `--no-exec-window' option.  The program input/output will then
     go through the DDD debugger console.

   * In remote mode, all sources are loaded from the remote host; file
     dialogs scan remote directories.  This may result in somewhat
     slower operation than normal.

   * To help you find problems due to remote execution, run DDD with
     the `--trace' option.  This prints the shell commands issued by
     DDD on standard error.

   *Note Customizing Remote Debugging::, for customizing remote mode.

* Menu:

* Customizing Remote Debugging::


File: ddd.info,  Node: Customizing Remote Debugging,  Up: Remote Debugger

2.4.2.1 Customizing Remote Debugging
....................................

When having the inferior debugger run on a remote host (*note Remote
Debugging::), all commands to access the inferior debugger as well as
its files must be run remotely.  This is controlled by the following
resources (*note Customizing::):

 -- Resource: rshCommand (class RshCommand)
     The remote shell command to invoke TTY-based commands on remote
     hosts.  Usually, `remsh', `rsh', `ssh', or `on'.  

 -- Resource: listCoreCommand (class listCoreCommand)
     The command to list all core files on the remote host.  The string
     `@MASK@' is replaced by a file filter.  The default setting is:

          Ddd*listCoreCommand: \
          file @MASK@ | grep '.*:.*core.*' | cut -d: -f1

 -- Resource: listDirCommand (class listDirCommand)
     The command to list all directories on the remote host.  The string
     `@MASK@' is replaced by a file filter.  The default setting is:

          Ddd*listDirCommand: \
          file @MASK@ | grep '.*:.*directory.*' | cut -d: -f1

 -- Resource: listExecCommand (class listExecCommand)
     The command to list all executable files on the remote host.  The
     string `@MASK@' is replaced by a file filter.  The default setting
     is:

          Ddd*listExecCommand: \
          file @MASK@ | grep '.*:.*exec.*' \
            | grep -v  '.*:.*script.*' \
            | cut -d: -f1 | grep -v '.*\.o$'

 -- Resource: listSourceCommand (class listSourceCommand)
     The command to list all source files on the remote host.  The
     string `@MASK@' is replaced by a file filter.  The default setting
     is:

          Ddd*listSourceCommand: \
          file @MASK@ | grep '.*:.*text.*' | cut -d: -f1


File: ddd.info,  Node: Remote Program,  Prev: Remote Debugger,  Up: Remote Debugging

2.4.3 Debugging a Remote Program
--------------------------------

The GDB debugger allows you to run the _debugged program_ on a remote
machine (called _remote target_), while GDB runs on the local machine.

   *Note Remote Debugging: (gdb)Remote, for details.  Basically, the
following steps are required:

   * Transfer the executable to the remote target.

   * Start `gdbserver' on the remote target.

   * Start DDD using GDB on the local machine, and load the same
     executable using the GDB `file' command.

   * Attach to the remote `gdbserver' using the GDB `target remote'
     command.  

   The local `.gdbinit' file is useful for setting up directory search
paths, etc.

   Of course, you can also combine DDD remote mode and GDB remote mode,
running DDD, GDB, and the debugged program each on a different machine.


File: ddd.info,  Node: Customizing Debugger Interaction,  Prev: Remote Debugging,  Up: Invocation

2.5 Customizing Interaction with the Inferior Debugger
======================================================

These settings control the interaction of DDD with its inferior
debugger.

* Menu:

* Debugger Invocation::
* Debugger Initialization::
* Debugger Communication::


File: ddd.info,  Node: Debugger Invocation,  Next: Debugger Initialization,  Up: Customizing Debugger Interaction

2.5.1 Invoking an Inferior Debugger
-----------------------------------

To choose the default inferior debugger, select `Edit => Preferences =>
Startup => Debugger Type'.  You can

   * have DDD determine the appropriate inferior debugger automatically
     from its command-line arguments.  Set `Determine Automatically
     from Arguments' to enable.

   * have DDD start the debugger of your choice, as specified in
     `Debugger Type'.

   The following DDD resources control the invocation of the inferior
debugger (*note Customizing::).

 -- Resource: autoDebugger (class AutoDebugger)
     If this is `on' (default), DDD will attempt to determine the
     debugger type from its arguments, possibly overriding the
     `debugger' resource (see below).  If this is `off', DDD will
     invoke the debugger specified by the `debugger' resource
     regardless of DDD arguments.

 -- Resource: debugger (class Debugger)
     The type of the inferior debugger to invoke (`gdb', `dbx',
     `ladebug', `xdb', `jdb', `pydb', `perl', or `bash').

     This resource is usually set through the `--gdb', `--dbx',
     `--ladebug', `--xdb', `--jdb', `--pydb', `--perl', and `--bash'
     options; *Note Options::, for details.

 -- Resource: debuggerCommand (class DebuggerCommand)
     The name under which the inferior debugger is to be invoked.  If
     this string is empty (default), the debugger type (`debugger'
     resource) is used.

     This resource is usually set through the `--debugger' option;
     *Note Options::, for details.


File: ddd.info,  Node: Debugger Initialization,  Next: Debugger Communication,  Prev: Debugger Invocation,  Up: Customizing Debugger Interaction

2.5.2 Initializing the Inferior Debugger
----------------------------------------

DDD uses a number of resources to initialize the inferior debugger
(*note Customizing::).

* Menu:

* GDB Initialization::
* DBX Initialization::
* XDB Initialization::
* JDB Initialization::
* PYDB Initialization::
* Perl Initialization::
* Bash Initialization::
* Finding a Place to Start::
* Opening the Selection::


File: ddd.info,  Node: GDB Initialization,  Next: DBX Initialization,  Up: Debugger Initialization

2.5.2.1 GDB Initialization
..........................

 -- Resource: gdbInitCommands (class InitCommands)
     This string contains a list of newline-separated commands that are
     initially sent to GDB.  As a side-effect, all settings specified
     in this resource are considered fixed and cannot be changed
     through the GDB settings panel, unless preceded by white space.
     By default, the `gdbInitCommands' resource contains some settings
     vital to DDD:

            Ddd*gdbInitCommands: \
            set height 0\n\
            set width 0\n\
             set verbose off\n\
            set prompt (gdb) \n

     While the `set height', `set width', and `set prompt' settings are
     fixed, the `set verbose' settings can be changed through the GDB
     settings panel (although being reset upon each new DDD invocation).

     Do not use this resource to customize GDB; instead, use a personal
     `~/.gdbinit' file.  See your GDB documentation for details.

 -- Resource: gdbSettings (class Settings)
     This string contains a list of newline-separated commands that are
     also initially sent to GDB.  Its default value is

            Ddd*gdbSettings: \
            set print asm-demangle on\n

     This resource is used to save and restore the debugger settings.

 -- Resource: sourceInitCommands (class SourceInitCommands)
     If `on' (default), DDD writes all GDB initialization commands into
     a temporary file and makes GDB read this file, rather than sending
     each initialization command separately.  This results in faster
     startup (especially if you have several user-defined commands).  If
     `off', DDD makes GDB process each command separately.


File: ddd.info,  Node: DBX Initialization,  Next: XDB Initialization,  Prev: GDB Initialization,  Up: Debugger Initialization

2.5.2.2 DBX Initialization
..........................

 -- Resource: dbxInitCommands (class InitCommands)
     This string contains a list of newline-separated commands that are
     initially sent to DBX.  By default, it is empty.

     Do not use this resource to customize DBX; instead, use a personal
     `~/.dbxinit' or `~/.dbxrc' file.  See your DBX documentation for
     details.

 -- Resource: dbxSettings (class Settings)
     This string contains a list of newline-separated commands that are
     also initially sent to DBX.  By default, it is empty.


File: ddd.info,  Node: XDB Initialization,  Next: JDB Initialization,  Prev: DBX Initialization,  Up: Debugger Initialization

2.5.2.3 XDB Initialization
..........................

 -- Resource: xdbInitCommands (class InitCommands)
     This string contains a list of newline-separated commands that are
     initially sent to XDB.  By default, it is empty.

     Do not use this resource to customize DBX; instead, use a personal
     `~/.xdbrc' file.  See your XDB documentation for details.

 -- Resource: xdbSettings (class Settings)
     This string contains a list of newline-separated commands that are
     also initially sent to XDB.  By default, it is empty.


File: ddd.info,  Node: JDB Initialization,  Next: PYDB Initialization,  Prev: XDB Initialization,  Up: Debugger Initialization

2.5.2.4 JDB Initialization
..........................

 -- Resource: jdbInitCommands (class InitCommands)
     This string contains a list of newline-separated commands that are
     initially sent to JDB.  This resource may be used to customize
     JDB.  By default, it is empty.

 -- Resource: jdbSettings (class Settings)
     This string contains a list of newline-separated commands that are
     also initially sent to JDB.  By default, it is empty.

     This resource is used by DDD to save and restore JDB settings.


File: ddd.info,  Node: PYDB Initialization,  Next: Perl Initialization,  Prev: JDB Initialization,  Up: Debugger Initialization

2.5.2.5 PYDB Initialization
...........................

 -- Resource: pydbInitCommands (class InitCommands)
     This string contains a list of newline-separated commands that are
     initially sent to PYDB.  By default, it is empty.

     This resource may be used to customize PYDB.

 -- Resource: pydbSettings (class Settings)
     This string contains a list of newline-separated commands that are
     also initially sent to PYDB.  By default, it is empty.

     This resource is used by DDD to save and restore PYDB settings.


File: ddd.info,  Node: Perl Initialization,  Next: Bash Initialization,  Prev: PYDB Initialization,  Up: Debugger Initialization

2.5.2.6 Perl Initialization
...........................

 -- Resource: perlInitCommands (class InitCommands)
     This string contains a list of newline-separated commands that are
     initially sent to the Perl debugger.  By default, it is empty.

     This resource may be used to customize the Perl debugger.

 -- Resource: perlSettings (class Settings)
     This string contains a list of newline-separated commands that are
     also initially sent to the Perl debugger.  By default, it is empty.

     This resource is used by DDD to save and restore Perl debugger
     settings.


File: ddd.info,  Node: Bash Initialization,  Next: Finding a Place to Start,  Prev: Perl Initialization,  Up: Debugger Initialization

2.5.2.7 Bash Initialization
...........................

 -- Resource: bashInitCommands (class InitCommands)
     This string contains a list of newline-separated commands that are
     initially sent to the Bash debugger.  By default, it is empty.

     This resource may be used to customize the Bash debugger.

 -- Resource: bash (class Settings)
     This string contains a list of newline-separated commands that are
     also initially sent to the Perl debugger.  By default, it is empty.

     This resource is used by DDD to save and restore Bash debugger
     settings.


File: ddd.info,  Node: Finding a Place to Start,  Next: Opening the Selection,  Prev: Bash Initialization,  Up: Debugger Initialization

2.5.2.8 Finding a Place to Start
................................

 -- Resource: initSymbols (class InitSymbols)
     When loading an executable, DDD queries the inferior debugger for
     the initial source location--typically the `main' function.  If
     this location is not found, DDD tries other symbols from this
     newline-separated list.  The default value makes DDD look for a
     variety of main functions (especially FORTRAN main functions):
          main\n\
          MAIN\n\
          main_\n\
          MAIN_\n\
          main__\n\
          MAIN__\n\
          _main\n\
          _MAIN\n\
          __main\n\
          __MAIN


File: ddd.info,  Node: Opening the Selection,  Prev: Finding a Place to Start,  Up: Debugger Initialization

2.5.2.9 Opening the Selection
.............................

 -- Resource: openSelection (class OpenSelection)
     If this is `on', DDD invoked without argument checks whether the
     current selection or clipboard contains the file name or URL of an
     executable program.  If this is so, DDD will automatically open
     this program for debugging.  If this resource is `off' (default),
     DDD invoked without arguments will always start without a debugged
     program.


File: ddd.info,  Node: Debugger Communication,  Prev: Debugger Initialization,  Up: Customizing Debugger Interaction

2.5.3 Communication with the Inferior Debugger
----------------------------------------------

The following resources control the communication with the inferior
debugger.

 -- Resource: blockTTYInput (class BlockTTYInput)
     Whether DDD should block when reading data from the inferior
     debugger via the pseudo-tty interface.  Most UNIX systems except
     GNU/Linux _require_ this; set it to `on'.  On GNU/Linux, set it to
     `off'.  The value `auto' (default) will always select the "best"
     choice (that is, the best choice known to the DDD developers).

 -- Resource: bufferGDBOutput (class BufferGDBOutput)
     If this is `on', all output from the inferior debugger is buffered
     until a debugger prompt appears.  This makes it easier for DDD to
     parse the output, but has the drawback that interaction with a
     running debuggee in the debugger console is not possible.  If
     `off', output is shown as soon as it arrives, enabling
     interaction, but making it harder for DDD to parse the output.  If
     `auto' (default), output is buffered if and only if the execution
     window is open, which redirects debuggee output and thus enables
     interaction.  *Note Using the Execution Window::, for details.

 -- Resource: contInterruptDelay (class InterruptDelay)
     The time (in ms) to wait before automatically interrupting a `cont'
     command.  DDD cannot interrupt a `cont' command immediately,
     because this may disturb the status change of the process.
     Default is `200'.

 -- Resource: displayTimeout (class DisplayTimeout)
     The time (in ms) to wait for the inferior debugger to finish a
     partial display information.  Default is `2000'.

 -- Resource: positionTimeout (class PositionTimeout)
     The time (in ms) to wait for the inferior debugger to finish a
     partial position information.  Default is `500'.

 -- Resource: questionTimeout (class QuestionTimeout)
     The time (in seconds) to wait for the inferior debugger to reply.
     Default is `10'.

 -- Resource: runInterruptDelay (class InterruptDelay)
     The time (in ms) to wait before automatically interrupting a `run'
     command.  DDD cannot interrupt a `cont' command immediately,
     because this may disturb process creation.  Default is `2000'.

 -- Resource: stopAndContinue (class StopAndContinue)
     If `on' (default), debugger commands interrupt program execution,
     resuming execution after the command has completed.  This only
     happens if the last debugger command was either a `run' or a
     `continue' command.  If `off', debugger commands do not interrupt
     program execution.

 -- Resource: synchronousDebugger (class SynchronousDebugger)
     If `on', X events are not processed while the debugger is busy.
     This may result in slightly better performance on single-processor
     systems.  *Note Options::, for the `--sync-debugger' option.

 -- Resource: terminateOnEOF (class TerminateOnEOF)
     If `on', DDD terminates the inferior debugger when DDD detects an
     EOF condition (that is, as soon as the inferior debugger closes
     its output channel).  This was the default behavior in DDD 2.x and
     earlier.  If `off' (default), DDD takes no special action.

 -- Resource: useTTYCommand (class UseTTYCommand)
     If `on', use the GDB `tty' command for redirecting input/output to
     the separate execution window.  If `off', use explicit redirection
     through shell redirection operators `<' and `>'.  The default is
     `off' (explicit redirection), since on some systems, the `tty'
     command does not work properly on some GDB versions.


File: ddd.info,  Node: Windows,  Next: Navigating,  Prev: Invocation,  Up: Top

3 The DDD Windows
*****************

DDD is composed of three main windows.  From top to bottom, we have:

   * The "Data Window" shows the current data of the debugged program.
     *Note Displaying Values::, for details.  

   * The "Source Window" shows the current source code of the debugged
     program.  *Note Navigating::, for details.  

   * The "Debugger Console" accepts debugger commands and shows debugger
     messages.  *Note Commands::, for details.  

   Besides these three main windows, there are some other optional
windows:

   * The "Command Tool" offers buttons for frequently used commands.
     It is usually placed on the source window.  *Note Command Tool::,
     for details.  

   * The "Machine Code Window" shows the current machine code.  It is
     usually placed beneath the current source.  *Note Machine Code::,
     for details.  

   * The "Execution Window" shows the input and output of the debugged
     program.  *Note Using the Execution Window::, for details.  

* Menu:

* Menu Bar::                    All DDD pull-down menus.
* Tool Bar::                    The DDD icon buttons.
* Command Tool::                The floating command tool.
* Getting Help::                What does this thing mean?
* Undo and Redo::               Oops!
* Customizing::                 You can customize DDD


File: ddd.info,  Node: Menu Bar,  Next: Tool Bar,  Up: Windows

3.1 The Menu Bar
================

The DDD Menu Bar gives you access to all DDD functions.

`File'
     Perform file-related operations such as selecting programs,
     processes, and sessions, printing graphs, recompiling, as well as
     exiting DDD.

`Edit'
     Perform standard editing operations, such as cutting, copying,
     pasting, and killing selected text.  Also allows editing DDD
     options and preferences.

`View'
     Allows accessing the individual DDD windows.

`Program'
     Perform operations related to the program being debugged, such as
     starting and stopping the program.

`Commands'
     Perform operations related to DDD commands, such as accessing the
     command history or defining new commands.

`Status'
     Examine the program status, such as the stack traces, registers, or
     threads.

`Source'
     Perform source-related operations such as looking up items or
     editing breakpoints.

`Data'
     Perform data-related operations such as editing displays or
     layouting the display graph.

`Maintenance'
     Perform operations that are useful for debugging DDD.  By default,
     this menu is disabled.

`Help'
     Give help on DDD usage.

   There are two ways of selecting an item from a pull-down menu:

   * Select an item in the menu bar by moving the cursor over it and
     click _mouse button 1_.  Then move the cursor over the menu item
     you want to choose and click left again.

   * Select an item in the menu bar by moving the cursor over it and
     click and hold _mouse button 1_.  With the mouse button depressed,
     move the cursor over the menu item you want, then release it to
     make your selection.

   The menus can also be "torn off" (i.e. turned into a persistent
window) by selecting the dashed line at the top.

   If a command in the pull-down menu is not applicable in a given
situation, the command is "disabled" and its name appears faded.  You
cannot invoke items that are faded.  For example, many commands on the
`Edit' menu appear faded until you select text on which they are to
operate; after you select a block of text, edit commands are enabled.

* Menu:

* File Menu::                   Selecting programs and processes.
* Edit Menu::                   Cut, copy, paste, and preferences.
* View Menu::                   All DDD windows.
* Program Menu::                Starting and stopping.
* Commands Menu::               All DDD commands.
* Status Menu::                 Examining the program status.
* Source Menu::                 Navigating around.
* Data Menu::                   Examining data.
* Maintenance Menu::            Maintaining DDD.
* Help Menu::                   Getting help.
* Customizing the Menu Bar::    Alternate key bindings, etc.


File: ddd.info,  Node: File Menu,  Next: Edit Menu,  Up: Menu Bar

3.1.1 The File Menu
-------------------

The `File' menu contains file-related operations such as selecting
programs, processes, and sessions, printing graphs, recompiling, as well
as exiting DDD.

`Open Program'
`Open Class'
     Open a program or class to be debugged (<Ctrl+O>).  *Note Opening
     Programs::, for details.

`Open Recent'
     Re-open a recently opened program to be debugged.  *Note Opening
     Programs::, for details.

`Open Core Dump'
     Open a core dump for the currently debugged program.  *Note
     Opening Core Dumps::, for details.

`Open Source'
     Open a source file of the currently debugged program.  *Note
     Opening Source Files::, for details.

`Open Session'
     Resume a previously saved DDD session (<Ctrl+N>).  *Note Resuming
     Sessions::, for details.

`Save Session As'
     Save the current DDD session such that you can resume it later
     (<Ctrl+S>).  *Note Saving Sessions::, for details.

`Attach to Process'
     Attach to a running process of the debugged program.  *Note
     Attaching to a Process::, for details.

`Detach Process'
     Detach from the running process.  *Note Attaching to a Process::,
     for details.

`Print Graph'
     Print the current graph on a printer.  *Note Printing the Graph::,
     for details.

`Change Directory'
     Change the working directory of your program.  *Note Working
     Directory::, for details.

`Make'
     Run the `make' program (<Ctrl+M>).  *Note Recompiling::, for
     details.

`Close'
     Close this DDD window (<Ctrl+W>).  *Note Quitting::, for details.

`Restart'
     Restart DDD.

`Exit'
     Exit DDD (<Ctrl+Q>).  *Note Quitting::, for details.


File: ddd.info,  Node: Edit Menu,  Next: View Menu,  Prev: File Menu,  Up: Menu Bar

3.1.2 The Edit Menu
-------------------

The `Edit' menu contains standard editing operations, such as cutting,
copying, pasting, and killing selected text.  Also allows editing DDD
options and preferences.

`Undo'
     Undo the most recent action (<Ctrl+Z>).  Almost all commands can be
     undone this way.  *Note Undo and Redo::, for details.

`Redo'
     Redo the action most recently undone (<Ctrl+Y>).  Every command
     undone can be redone this way.  *Note Undo and Redo::, for details.

`Cut'
     Removes the selected text block from the current text area and
     makes it the X clipboard selection (<Ctrl+X> or <Shift+Del>; *Note
     Customizing the Edit Menu::, for details).  Before executing this
     command, you have to select a region in a text area--either with
     the mouse or with the usual text selection keys.

     This item can also be applied to displays (*note Deleting
     Displays::).

`Copy'
     Makes a selected text block the X clipboard selection (<Ctrl+C> or
     <Ctrl+Ins>; *Note Customizing the Edit Menu::, for details).  You
     can select text by selecting a text region with the usual text
     selection keys or with the mouse.  *Note Customizing the Edit
     Menu::, for changing the default accelerator.

     This item can also be applied to displays (*note Deleting
     Displays::).

`Paste'
     Inserts the current value of the X clipboard selection in the most
     recently selected text area (<Ctrl+V> or <Shift+Ins>; *Note
     Customizing the Edit Menu::, for details).  You can paste in text
     you have placed in the clipboard using `Copy' or `Cut'.  You can
     also use `Paste' to insert text that was pasted into the clipboard
     from other applications.

`Clear'
     Clears the most recently selected text area (<Ctrl+U>).

`Delete'
     Removes the selected text block from the most recently selected
     text area, but does not make it the X clipboard selection.

     This item can also be applied to displays (*note Deleting
     Displays::).

`Select All'
     Selects all characters from the most recently selected text area
     (<Ctrl+A> or or <Ctrl+Shift+A>; *note Customizing the Edit Menu::,
     for details).

`Preferences'
     Allows you to customize DDD interactively.  *Note Customizing::,
     for details.

`Debugger Settings'
     Allows you to customize the inferior debugger.  *Note Debugger
     Settings::, for details.

`Save Options'
     If set, all preferences and settings will be saved for the next DDD
     invocation.  *Note Saving Options::, for details.


File: ddd.info,  Node: View Menu,  Next: Program Menu,  Prev: Edit Menu,  Up: Menu Bar

3.1.3 The View Menu
-------------------

The `View' menu allows accessing the individual DDD windows.

`Command Tool'
     Open and recenter the command tool (<Alt+8>).  *Note Command
     Tool::, for details.

`Execution Window'
     Open the separate execution window (<Alt+9>).  *Note Using the
     Execution Window::, for details.

`Debugger Console'
     Open the debugger console (<Alt+1>).  *Note Commands::, for
     details.

`Source Window'
     Open the source window (<Alt+2>).  *Note Navigating::, for details.

`Data Window'
     Open the data window (<Alt+3>).  *Note Displaying Values::, for
     details.

`Machine Code Window'
     Show machine code (<Alt+4>).  *Note Machine Code::, for details.


File: ddd.info,  Node: Program Menu,  Next: Commands Menu,  Prev: View Menu,  Up: Menu Bar

3.1.4 The Program Menu
----------------------

The `Program' menu performs operations related to the program being
debugged, such as starting and stopping the program.

   Most of these operations are also found on the command tool (*note
Command Tool::).

`Run'
     Start program execution, prompting for program arguments (<F2>).
     *Note Starting Program Execution::, for details.

`Run Again'
     Start program execution with the most recently used arguments
     (<F3>).  *Note Starting Program Execution::, for details.

`Run in Execution Window'
     If enabled, start next program execution in separate execution
     window.  *Note Using the Execution Window::, for details.

`Step'
     Continue running your program until control reaches a different
     source line, then stop it and return control to DDD (<F5>).  *Note
     Resuming Execution::, for details.

`Step Instruction'
     Execute one machine instruction, then stop and return to DDD
     (<Shift+F5>).  *Note Machine Code Execution::, for details.

`Next'
     Continue to the next source line in the current (innermost) stack
     frame (<F6>).  This is similar to `Step', but function calls that
     appear within the line of code are executed without stopping.
     *Note Resuming Execution::, for details.

`Next Instruction'
     Execute one machine instruction, but if it is a function call,
     proceed until the function returns (<Shift+F6>).  *Note Machine
     Code Execution::, for details.

`Until'
     Continue running until a source line past the current line, in the
     current stack frame, is reached (<F7>).  *Note Resuming
     Execution::, for details.

`Finish'
     Continue running until just after function in the selected stack
     frame returns (<F8>).  Print the returned value (if any).  *Note
     Resuming Execution::, for details.

`Continue'
     Resume program execution, at the address where your program last
     stopped (<F9>); any breakpoints set at that address are bypassed.
     *Note Resuming Execution::, for details.

`Continue Without Signal'
     Continue execution without giving a signal (<Shift+F9>).  This is
     useful when your program stopped on account of a signal and would
     ordinary see the signal when resumed with `Continue'.  *Note
     Signals::, for details.

`Kill'
     Kill the process of the debugged program (<F4>).  *Note Killing
     the Program::, for details.

`Interrupt'
     Interrupt program execution (<Esc> or <Ctrl+C>; *note Customizing
     the Edit Menu::, for details).  This is equivalent to sending an
     interrupt signal to the process.  *Note Interrupting::, for
     details.

`Abort'
     Abort program execution (and maybe debugger execution, too;
     <Ctrl+\>).  This is equivalent to sending a `SIGABRT' signal to
     the process.  *Note Quitting::, for details.


File: ddd.info,  Node: Commands Menu,  Next: Status Menu,  Prev: Program Menu,  Up: Menu Bar

3.1.5 The Commands Menu
-----------------------

The `Commands' menu performs operations related to DDD commands, such
as accessing the command history or defining new commands.

   Most of these items are not meant to be actually executed via the
menu; instead, they serve as _reminder_ for the equivalent keyboard
commands.

`Command History'
     View the command history.  *Note Command History::, for details.

`Previous'
     Show the previous command from the command history (<Up>).  *Note
     Command History::, for details.

`Next'
     Show the next command from the command history (<Down>).  *Note
     Command History::, for details.

`Find Backward'
     Do an incremental search backward through the command history
     (<Ctrl+B>).  *Note Command History::, for details.

`Find Forward'
     Do an incremental search forward through the command history
     (<Ctrl+F>).  *Note Command History::, for details.

`Quit Search'
     Quit incremental search through the command history (<Esc>).
     *Note Command History::, for details.

`Complete'
     Complete the current command in the debugger console (<Tab>).
     *Note Entering Commands::, for details.

`Apply'
     Apply the current command in the debugger console (<Apply>).
     *Note Entering Commands::, for details.

`Clear Line'
     Clear the current command line in the debugger console (<Ctrl+U>).
     *Note Entering Commands::, for details.

`Clear Window'
     Clear the debugger console (<Shift+Ctrl+U>).  *Note Entering
     Commands::, for details.

`Define Command'
     Define a new debugger command.  *Note Defining Commands::, for
     details.

`Edit Buttons'
     Customize DDD buttons.  *Note Defining Buttons::, for details.


File: ddd.info,  Node: Status Menu,  Next: Source Menu,  Prev: Commands Menu,  Up: Menu Bar

3.1.6 The Status Menu
---------------------

The `Status' menu lets you examine the program status, such as the
stack traces, registers, or threads.

`Backtrace'
     View the current backtrace.  *Note Backtraces::, for a discussion.

`Registers'
     View the current register contents.  *Note Registers::, for
     details.

`Threads'
     View the current threads.  *Note Threads::, for details.

`Signals'
     View and edit the current signal handling.  *Note Signals::, for
     details.

`Up'
     Select the stack frame (i.e. the function) that called this one
     (<Ctrl+Up>).  This advances toward the outermost frame, to higher
     frame numbers, to frames that have existed longer.  *Note Stack::,
     for details.

`Down'
     Select the stack frame (i.e. the function) that was called by this
     one (<Ctrl+Down>).  This advances toward the innermost frame, to
     lower frame numbers, to frames that were created more recently.
     *Note Stack::, for details.


File: ddd.info,  Node: Source Menu,  Next: Data Menu,  Prev: Status Menu,  Up: Menu Bar

3.1.7 The Source Menu
---------------------

The `Source' menu performs source-related operations such as looking up
items or editing breakpoints.

`Breakpoints'
     Edit all Breakpoints.  *Note Editing all Breakpoints::, for
     details.

`Lookup ()'
     Look up the argument `()' in the source code (<Ctrl+/>).  *Note
     Looking up Definitions::, for details.

`Find >> ()'
     Look up the next occurrence of the argument `()' in the current
     source code (<Ctrl+.>).  *Note Textual Search::, for details.

`Find << ()'
     Look up the previous occurrence of the argument `()' in the current
     source code (<Ctrl+,>).  *Note Textual Search::, for details.

`Find Words Only'
     If enabled, find only complete words (<Alt+W>).  *Note Textual
     Search::, for details.

`Find Case Sensitive'
     If enabled, find is case-sensitive (<Alt+I>).  *Note Textual
     Search::, for details.

`Display Line Numbers'
     If enabled, prefix source lines with their line number (<Alt+N>).
     *Note Customizing Source::, for details.

`Display Machine Code'
     If enabled, show machine code (<Alt+4>).  *Note Machine Code::,
     for details.

`Edit Source'
     Invoke an editor for the current source file (<Shift+Ctrl+V>).
     *Note Editing Source Code::, for details.

`Reload Source'
     Reload the current source file (<Shift+Ctrl+L>).  *Note Editing
     Source Code::, for details.


File: ddd.info,  Node: Data Menu,  Next: Maintenance Menu,  Prev: Source Menu,  Up: Menu Bar

3.1.8 The Data Menu
-------------------

The `Data' menu performs data-related operations such as editing
displays or layouting the display graph.

`Displays'
     Invoke the Display Editor.  *Note Editing all Displays::, for
     details.

`Watchpoints'
     Edit all Watchpoints.  *Note Editing all Watchpoints::, for
     details.

`Memory'
     View a memory dump.  *Note Examining Memory::, for details.

`Print ()'
     Print the value of `()' in the debugger console (<Ctrl+=>).  *Note
     Printing Values::, for details.

`Display ()'
     Display the value of `()' in the data window (<Ctrl+->).  *Note
     Displaying Values::, for details.

`Detect Aliases'
     If enabled, detect shared data structures (<Alt+A>).  *Note Shared
     Structures::, for a discussion.

`Display Local Variables'
     Show all local variables in a display (<Alt+L>).  *Note Displaying
     Local Variables::, for details.

`Display Arguments'
     Show all arguments of the current function in a display (<Alt+U>).
     *Note Displaying Local Variables::, for details.

`Status Displays'
     Show current debugging information in a display.  *Note Displaying
     Program Status::, for details.

`Align on Grid'
     Align all displays on the grid (<Alt+G>).  *Note Aligning
     Displays::, for a discussion.

`Rotate Graph'
     Rotate the graph by 90 degrees (<Alt+R>).  *Note Rotating the
     Graph::, for details.

`Layout Graph'
     Layout the graph (<Alt+Y>).  *Note Layouting the Graph::, for
     details.

`Refresh'
     Update all values in the data window (<Ctrl+L>).  *Note Refreshing
     the Data Window::, for details.


File: ddd.info,  Node: Maintenance Menu,  Next: Help Menu,  Prev: Data Menu,  Up: Menu Bar

3.1.9 The Maintenance Menu
--------------------------

The `Maintenance' menu performs operations that are useful for
debugging DDD.

   By default, this menu is disabled; it is enabled by specifically
requesting it at DDD invocation (via the `--maintenance' option; *note
Options::).  It is also enabled when DDD gets a fatal signal.

`Debug DDD'
     Invoke a debugger (typically, GDB) and attach it to this DDD
     process (<F12>).  This is useful only if you are a DDD maintainer.

`Dump Core Now'
     Make this DDD process dump core.  This can also be achieved by
     sending DDD a `SIGUSR1' signal.

`Tic Tac Toe'
     Invoke a Tic Tac Toe game.  You must try to get three stop signs
     in a row, while preventing DDD from doing so with its skulls.
     Click on `New Game' to restart.

`When DDD Crashes'
     Select what to do when DDD gets a fatal signal.

    `Debug DDD'
          Invoke a debugger on the DDD core dump when DDD crashes.
          This is useful only if you are a DDD maintainer.

    `Dump Core'
          Just dump core when DDD crashes; don't invoke a debugger.
          This is the default setting, as the core dump may contain
          important information required for debugging DDD.

    `Do Nothing'
          Do not dump core or invoke a debugger when DDD crashes.

`Remove Menu'
     Make this menu inaccessible again.


File: ddd.info,  Node: Help Menu,  Next: Customizing the Menu Bar,  Prev: Maintenance Menu,  Up: Menu Bar

3.1.10 The Help Menu
--------------------

The `Help' menu gives help on DDD usage.  *Note Getting Help::, for a
discussion on how to get help within DDD.

`Overview'
     Explains the most important concepts of DDD help.

`On Item'
     Lets you click on an item to get help on it.

`On Window'
     Gives you help on this DDD window.

`What Now?'
     Gives a hint on what to do next.

`Tip of the Day'
     Shows the current tip of the day.

`DDD Reference'
     Shows the DDD Manual.

`DDD News'
     Shows what's new in this DDD release.

`Debugger Reference'
     Shows the on-line documentation for the inferior debugger.

`DDD License'
     Shows the DDD License (*note License::).

`DDD WWW Page'
     Invokes a WWW browser for the DDD WWW page.

`About DDD'
     Shows version and copyright information.


File: ddd.info,  Node: Customizing the Menu Bar,  Prev: Help Menu,  Up: Menu Bar

3.1.11 Customizing the Menu Bar
-------------------------------

The Menu Bar can be customized in various ways (*note Customizing::).

* Menu:

* Auto-Raise Menus::
* Customizing the Edit Menu::


File: ddd.info,  Node: Auto-Raise Menus,  Next: Customizing the Edit Menu,  Up: Customizing the Menu Bar

3.1.11.1 Auto-Raise Menus
.........................

You can cause pull-down menus to be raised automatically.

 -- Resource: autoRaiseMenu (class AutoRaiseMenu)
     If `on' (default), DDD will always keep the pull down menu on top
     of the DDD main window.  If this setting interferes with your
     window manager, or if your window manager does not auto-raise
     windows, set this resource to `off'.

 -- Resource: autoRaiseMenuDelay (class AutoRaiseMenuDelay)
     The time (in ms) during which an initial auto-raised window blocks
     further auto-raises.  This is done to prevent two overlapping
     auto-raised windows from entering an _auto-raise loop_.  Default is
     `100'.


File: ddd.info,  Node: Customizing the Edit Menu,  Prev: Auto-Raise Menus,  Up: Customizing the Menu Bar

3.1.11.2 Customizing the Edit Menu
..................................

In the Menu Bar, the `Edit' Menu can be customized in various ways.
Use `Edit => Preferences => Startup' to customize these keys.

   The <Ctrl+C> key can be bound to different actions, each in
accordance with a specific style guide.

`Copy'
     This setting binds <Ctrl+C> to the Copy operation, as specified by
     the KDE style guide.  In this setting, use <ESC> to interrupt the
     debuggee.

`Interrupt'
   This (default) setting binds <Ctrl+C> to the Interrupt operation, as
used in several UNIX command-line programs.  In this setting, use
<Ctrl+Ins> to copy text to the clipboard.

   The <Ctrl+A> key can be bound to different actions, too.

`Select All'
     This (default) setting binds <Ctrl+A> to the `Select All'
     operation, as specified by the KDE style guide.  In this setting,
     use <Home> to move the cursor to the beginning of a line.

`Beginning of Line'
     This setting binds <Ctrl+A> to the `Beginning of Line' operation,
     as used in several UNIX text-editing programs.  In this setting,
     use <Ctrl+Shift+A> to select all text.

   Here are the related DDD resources:

 -- Resource: cutCopyPasteBindings (class BindingStyle)
     Controls the key bindings for clipboard operations.

        * If this is `Motif' (default), Cut/Copy/Paste is on
          <Shift+Del>/<Ctrl+Ins>/<Shift+Ins>.  This is conformant to
          the M*tif style guide.

        * If this is `KDE', Cut/Copy/Paste is on
          <Ctrl+X>/<Ctrl+C>/<Ctrl+V>.  This is conformant to the KDE
          style guide.  Note that this means that <Ctrl+C> no longer
          interrupts the debuggee; use <ESC> instead.

 -- Resource: selectAllBindings (class BindingStyle)
     Controls the key bindings for the `Select All' operation.

        * If this is `Motif', Select All is on <Shift+Ctrl+A>.

        * If this is `KDE' (default), Select All is on <Ctrl+A>.  This
          is conformant to the KDE style guide.  Note that this means
          that <Ctrl+A> no longer moves the cursor to the beginning of
          a line; use <Home> instead.


File: ddd.info,  Node: Tool Bar,  Next: Command Tool,  Prev: Menu Bar,  Up: Windows

3.2 The Tool Bar
================

Some DDD commands require an _argument_.  This argument is specified in
the _argument field_, labeled `():'.  Basically, there are four ways to
set arguments:

   * You can _key in_ the argument manually.

   * You can _paste_ the current selection into the argument field
     (typically using `mouse button 2').  To clear old contents
     beforehand, click on the `():' label.

   * You can _select an item_ from the source and data windows.  This
     will automatically copy the item to the argument field.

   * You can select a _previously used argument_ from the drop-down
     menu at the right of the argument field.

   Using GDB and Perl, the argument field provides a completion
mechanism.  You can enter the first few characters of an item an press
the <TAB> key to complete it.  Pressing <TAB> again shows alternative
completions.

   After having entered an argument, you can select one of the buttons
on the right.  Most of these buttons also have menus associated with
them; this is indicated by a small arrow in the upper right corner.
Pressing and holding _mouse button 1_ on such a button will pop up a
menu with further operations.

   These are the buttons of the tool bar.  Note that not all buttons
may be inactive, depending on the current state and the capabilities of
the inferior debugger.

`Lookup'
     Look up the argument `()' in the source code.  *Note Looking up
     Definitions::, for details.

`Find >>'
     Look up the next occurrence of the argument `()' in the current
     source code.  *Note Textual Search::, for details.

`Break/Clear'
     Toggle a breakpoint (*note Breakpoints::) at the location `()'.

    `Break'
          If there is no breakpoint at `()', then this button is labeled
          `Break'.  Clicking on `Break' sets a breakpoint at the
          location `()'.  *Note Setting Breakpoints::, for details.

    `Clear'
          If there already is a breakpoint at `()', then this button is
          labeled `Clear'.  Clicking on `Clear' clears (deletes) the
          breakpoint at the location `()'.  *Note Deleting
          Breakpoints::, for details.

`Watch/Unwatch'
     Toggle a watchpoint (*note Watchpoints::) on the expression `()'.

    `Watch'
          If `()' is not being watched, then this button is labeled
          `Watch'.  Clicking on `Watch' creates a watchpoint on the
          expression `()'.  *Note Setting Watchpoints::, for details.

    `Unwatch'
          If `()' is being watched, then this button is labeled
          `Unwatch'.  Clicking on `Unwatch' clears (deletes) the
          watchpoint on `()'.  *Note Deleting Watchpoints::, for
          details.

`Print'
     Print the value of `()' in the debugger console.  *Note Printing
     Values::, for details.

`Display'
     Display the value of `()' in the data window.  *Note Displaying
     Values::, for details.

`Plot'
     Plot `()' in a plot window.  *Note Plotting Values::, for details.

`Show/Hide'
     Toggle details of the selected display(s).  *Note Showing and
     Hiding Details::, for a discussion.

`Rotate'
     Rotate the selected display(s).  *Note Rotating Displays::, for
     details.

`Set'
     Set (change) the value of `()'.  *Note Assignment::, for details.

`Undisp'
     Undisplay (delete) the selected display(s).  *Note Deleting
     Displays::, for details.

* Menu:

* Customizing the Tool Bar::


File: ddd.info,  Node: Customizing the Tool Bar,  Up: Tool Bar

3.2.1 Customizing the Tool Bar
------------------------------

The DDD tool bar buttons can appear in a variety of styles, customized
via `Edit => Preferences => Startup'.

`Images'
     This lets each tool bar button show an image illustrating the
     action.

`Captions'
     This shows the action name below the image.

   The default is to have images as well as captions, but you can
choose to have only images (saving space) or only captions.

   If you choose to have neither images nor captions, tool bar buttons
are labeled like other buttons, as in DDD 2.x.  Note that this implies
that in the stacked window configuration, the common tool bar cannot be
displayed; it is replaced by two separate tool bars, as in DDD 2.x.

   If you enable `Flat' buttons (default), the border of tool bar
buttons will appear only if the mouse pointer is over them.  This
latest-and-greatest GUI invention can be disabled, such that the button
border is always shown.

   If you enable `Color' buttons, tool bar images will be colored when
entered.  If DDD was built using M*tif 2.0 and later, you can also
choose a third setting, where buttons appear in color all the time.

   Here are the related resources (*note Customizing::):

 -- Resource: activeButtonColorKey (class ColorKey)
     The XPM color key to use for the images of active buttons (entered
     or armed).  `c' means color, `g' (default) means grey, and `m'
     means monochrome.

 -- Resource: buttonCaptions (class ButtonCaptions)
     Whether the tool bar buttons should be shown using captions (`on',
     default) or not (`off').  If neither captions nor images are
     enabled, tool bar buttons are shown using ordinary labels.  See
     also `buttonImages', below.

 -- Resource: buttonCaptionGeometry (class ButtonCaptionGeometry)
     The geometry of the caption subimage within the button icons.
     Default is `29x7+0-0'.

 -- Resource: buttonImages (class ButtonImages)
     Whether the tool bar buttons should be shown using images (`on',
     default) or not (`off').  If neither captions nor images are
     enabled, tool bar buttons are shown using ordinary labels.  See
     also `buttonCaptions', above.

 -- Resource: buttonImageGeometry (class ButtonImageGeometry)
     The geometry of the image within the button icon.  Default is
     `25x21+2+0'.

 -- Resource: buttonColorKey (class ColorKey)
     The XPM color key to use for the images of inactive buttons
     (non-entered or insensitive).  `c' means color, `g' (default)
     means grey, and `m' means monochrome.

 -- Resource: flatToolbarButtons (class FlatButtons)
     If `on' (default), all tool bar buttons with images or captions
     are given a `flat' appearance--the 3-D border only shows up when
     the pointer is over the icon.  If `off', the 3-D border is shown
     all the time.

 -- Resource: flatDialogButtons (class FlatButtons)
     If `on' (default), all dialog buttons with images or captions are
     given a `flat' appearance--the 3-D border only shows up when the
     pointer is over the icon.  If `off', the 3-D border is shown all
     the time.


File: ddd.info,  Node: Command Tool,  Next: Getting Help,  Prev: Tool Bar,  Up: Windows

3.3 The Command Tool
====================

The command tool is a small window that gives you access to the most
frequently used DDD commands.  It can be moved around on top of the DDD
windows, but it can also be placed besides them.

   By default, the command tool _sticks_ to the DDD source window:
Whenever you move the DDD source window, the command tool follows such
that the distance between source window and command tool remains the
same.  By default, the command tool is also _auto-raised_, such that it
stays on top of other DDD windows.

   The command tool can be configured to appear as a command tool bar
above the source window; see `Edit => Preferences => Source => Tool
Buttons Location' for details.

   Whenever you save DDD state, DDD also saves the distance between
command tool and source window, such that you can select your own
individual command tool placement.  To move the command tool to its
saved position, use `View => Command Tool'.

   These are the buttons of the command tool.  Note that not all buttons
may be inactive, depending on the current state and the capabilities of
the inferior debugger.

`Run'
     Start program execution.  When you click this button, your program
     will begin to execute immediately.  *Note Starting Program
     Execution::, for details.

`Interrupt'
     Interrupt program execution.  This is equivalent to sending an
     interrupt signal to the process.  *Note Interrupting::, for
     details.

`Step'
     Continue running your program until control reaches a different
     source line, then stop it and return control to DDD.  *Note
     Resuming Execution::, for details.

`Stepi'
     Execute one machine instruction, then stop and return to DDD.
     *Note Machine Code Execution::, for details.

`Next'
     Continue to the next source line in the current (innermost) stack
     frame.  This is similar to `Step', but function calls that appear
     within the line of code are executed without stopping.  *Note
     Resuming Execution::, for details.

`Nexti'
     Execute one machine instruction, but if it is a function call,
     proceed until the function returns.  *Note Machine Code
     Execution::, for details.

`Until'
     Continue running until a source line past the current line, in the
     current stack frame, is reached.  *Note Resuming Execution::, for
     details.

`Finish'
     Continue running until just after function in the selected stack
     frame returns.  Print the returned value (if any).  *Note Resuming
     Execution::, for details.

`Cont'
     Resume program execution, at the address where your program last
     stopped; any breakpoints set at that address are bypassed.  *Note
     Resuming Execution::, for details.

`Kill'
     Kill the process of the debugged program.  *Note Killing the
     Program::, for details.

`Up'
     Select the stack frame (i.e. the function) that called this one.
     This advances toward the outermost frame, to higher frame numbers,
     to frames that have existed longer.  *Note Stack::, for details.

`Down'
     Select the stack frame (i.e. the function) that was called by this
     one.  This advances toward the innermost frame, to lower frame
     numbers, to frames that were created more recently.  *Note
     Stack::, for details.

`Undo'
     Undo the most recent action.  Almost all commands can be undone
     this way.  *Note Undo and Redo::, for details.

`Redo'
     Redo the action most recently undone.  Every command undone can be
     redone this way.  *Note Undo and Redo::, for details.

`Edit'
     Invoke an editor for the current source file.  *Note Editing
     Source Code::, for details.

`Make'
     Run the `make' program with the most recently given arguments.
     *Note Recompiling::, for details.

* Menu:

* Customizing the Command Tool::
* Customizing Tool Position::


File: ddd.info,  Node: Customizing the Command Tool,  Next: Customizing Tool Position,  Up: Command Tool

3.3.1 Customizing the Command Tool
----------------------------------

The Command Tool can be customized in various ways.

* Menu:

* Disabling the Command Tool::

   *Note Customizing Buttons::, for details on customizing the tool
buttons.


File: ddd.info,  Node: Disabling the Command Tool,  Up: Customizing the Command Tool

3.3.1.1 Disabling the Command Tool
..................................

You can disable the command tool and show its buttons in a separate row
beneath the tool bar.  To disable the command tool, set `Edit =>
Preferences => Source => Tool Buttons Location => Source Window'.

   Here's the related resource:

 -- Resource: commandToolBar (class ToolBar)
     Whether the tool buttons should be shown in a tool bar above the
     source window (`on') or within the command tool (`off', default).
     Enabling the command tool bar disables the command tool and vice
     versa.


File: ddd.info,  Node: Customizing Tool Position,  Prev: Customizing the Command Tool,  Up: Command Tool

3.3.2 Command Tool Position
---------------------------

The following resources control the position of the command tool (*note
Customizing::):

 -- Resource: autoRaiseTool (class AutoRaiseTool)
     If `on' (default), DDD will always keep the command tool on top of
     other DDD windows.  If this setting interferes with your window
     manager, or if your window manager keeps the command tool on top
     anyway, set this resource to `off'.

 -- Resource: stickyTool (class StickyTool)
     If `on' (default), the command tool automatically follows every
     movement of the source window.  Whenever the source window is
     moved, the command tool is moved by the same offset such that its
     position relative to the source window remains unchanged.  If
     `off', the command tool does not follow source window movements.

 -- Resource: toolRightOffset (class Offset)
     The distance between the right border of the command tool and the
     right border of the source text (in pixels).  Default is 8.

 -- Resource: toolTopOffset (class Offset)
     The distance between the upper border of the command tool and the
     upper border of the source text (in pixels).  Default is 8.

* Menu:

* Customizing Tool Decoration::


File: ddd.info,  Node: Customizing Tool Decoration,  Up: Customizing Tool Position

3.3.2.1 Customizing Tool Decoration
...................................

The following resources control the decoration of the command tool
(*note Customizing::):

 -- Resource: decorateTool (class Decorate)
     This resource controls the decoration of the command tool.

        * If this is `off', the command tool is created as a _transient
          window_.  Several window managers keep transient windows
          automatically on top of their parents, which is appropriate
          for the command tool.  However, your window manager may be
          configured not to decorate transient windows, which means
          that you cannot easily move the command tool around.

        * If this is `on', DDD realizes the command tool as a
          _top-level window_.  Such windows are always decorated by the
          window manager.  However, top-level windows are not
          automatically kept on top of other windows, such that you may
          wish to set the `autoRaiseTool' resource, too.

        * If this is `auto' (default), DDD checks whether the window
          manager decorates transients.  If yes, the command tool is
          realized as a transient window (as in the `off' setting); if
          no, the command tool is realized as a top-level window (as in
          the `on' setting).  Hence, the command tool is always
          decorated using the "best" method, but the extra check takes
          some time.


File: ddd.info,  Node: Getting Help,  Next: Undo and Redo,  Prev: Command Tool,  Up: Windows

3.4 Getting Help
================

DDD has an extensive on-line help system.  Here's how to get help while
working with DDD.

   * You can get a short help text on most DDD buttons by simply moving
     the mouse pointer on it and leave it there.  After a second, a
     small window (called "button tip"; also known as "tool tip" or
     "balloon help") pops up, giving a hint on the button's meaning.
     The button tip disappears as soon as you move the mouse pointer to
     another item.

   * The "status line" also displays information about the currently
     selected item.  By clicking on the status line, you can redisplay
     the most recent messages.

   * You can get detailed help on any visible DDD item.  Just point on
     the item you want help and press the `F1' key.  This pops up a
     detailed help text.

   * The DDD dialogs all contain `Help' buttons that give detailed
     information about the dialog.

   * You can get help on debugger commands by entering `help' at the
     debugger prompt.  *Note Entering Commands::, for details on
     entering commands.

   * If you are totally stuck, try `Help => What Now?' (the `What Now?'
     item in the `Help' menu) or press <Ctrl+F1>.  Depending on the
     current state, DDD will give you some hints on what you can do
     next.

   * Of course, you can always refer to the _on-line documentation_:

        - `Help => DDD Reference' gives you access to the DDD manual,
          the ultimate DDD reference.

        - `Help => Debugger Reference' shows you the on-line
          documentation of the inferior debugger.

        - `Help => DDD WWW Page' gives you access to the latest and
          greatest information on DDD.  

   * Finally, the DDD "Tip Of The Day" gives you important hints with
     each new DDD invocation.  

   All these functions can be customized in various ways (*note
Customizing Help::).

   If, after all, you made a mistake, don't worry: almost every DDD
command can be undone.  *Note Undo and Redo::, for details.


File: ddd.info,  Node: Undo and Redo,  Next: Customizing,  Prev: Getting Help,  Up: Windows

3.5 Undoing and Redoing Commands
================================

Almost every DDD command can be undone, using `Edit => Undo' or the
`Undo' button on the command tool.

   Likewise, `Edit => Redo' repeats the command most recently undone.

   The `Edit' menu shows which commands are to be undone and redone
next; this is also indicated by the popup help on the `Undo' and `Redo'
buttons.


File: ddd.info,  Node: Customizing,  Prev: Undo and Redo,  Up: Windows

3.6 Customizing DDD
===================

DDD is controlled by several _resources_--user-defined variables that
take specific values in order to control and customize DDD behavior.

   Most DDD resources can be set interactively while DDD is running or
when invoking DDD.  *Note Resource Index::, for the full list of DDD
resources.

   We first discuss how customizing works in general; then we turn to
customizing parts of DDD introduced so far.

* Menu:

* How Customizing Works::
* Customizing Help::
* Customizing Undo::
* Customizing Windows::
* Debugger Settings::


File: ddd.info,  Node: How Customizing Works,  Next: Customizing Help,  Up: Customizing

3.6.1 How Customizing DDD Works
-------------------------------

* Menu:

* Resources::
* Changing Resources::
* Saving Options::


File: ddd.info,  Node: Resources,  Next: Changing Resources,  Up: How Customizing Works

3.6.1.1 Resources
.................

Just like any X program, DDD has a number of places to get resource
values from.  For DDD, the most important places to specify resources
are:

   * The `~/.ddd/init' file (`~' stands for your home directory).  This
     file is read in by DDD upon start-up; the resources specified
     herein override all other sources (except for resources given
     implicitly by command-line options).

     If the environment variable `DDD_STATE' is set, its value is used
     instead of `~/.ddd/'.

   * The `Ddd' application-defaults file.  This file is typically
     compiled into the DDD executable.  If it exists, its resource
     values override the values compiled into DDD.  If the versions of
     the `Ddd' application-defaults file and the DDD executable do not
     match, DDD may not function properly; DDD will give you a warning
     in this case.(1)

   * The command-line options.  These options override all other
     resource settings.

   * If the environment variable `DDD_SESSION' is set, it indicates the
     name of a session to start, overriding all options and resources.
     This is used by DDD when restarting itself.

   Not every resource has a matching command-line option.  Each resource
(whether in `~/.ddd/init' or `Ddd') is specified using a line

     Ddd*RESOURCE: VALUE

   For instance, to set the `pollChildStatus' resource to `off', you
would specify in `~/.ddd/init':

     Ddd*pollChildStatus: off

   For more details on the syntax of resource specifications, see the
section `RESOURCES' in the `X(1)' manual page.

   ---------- Footnotes ----------

   (1) If you use a `Ddd' application-defaults file, you will not be
able to maintain multiple DDD versions at the same time.  This is why
the suiting `Ddd' is normally compiled into the DDD executable.


File: ddd.info,  Node: Changing Resources,  Next: Saving Options,  Prev: Resources,  Up: How Customizing Works

3.6.1.2 Changing Resources
..........................

You can change DDD resources by three methods:

   * Use DDD to change the options, notably `Edit => Preferences'.
     This works for the most important DDD resources.  Be sure to save
     the options (*note Saving Options::) such that they apply to
     future DDD sessions, too.

   * You can also invoke DDD with an appropriate command-line option.
     This changes the related DDD resource for this particular DDD
     invocation.  However, if you save the options (*note Saving
     Options::), the changed resource will also apply to future
     invocations.

   * Finally, you can set the appropriate resource in a file named
     `.ddd/init' in your home directory.  *Note Resource Index::, for a
     list of DDD resources to be set.


File: ddd.info,  Node: Saving Options,  Prev: Changing Resources,  Up: How Customizing Works

3.6.1.3 Saving Options
......................

You can save the current option settings by setting `Edit => Save
Options'.  Options are saved in a file named `.ddd/init' in your home
directory when DDD exits.  If a session SESSION is active, options will
be saved in `~/.ddd/sessions/SESSION/init' instead.

   The options are automatically saved when exiting DDD.  You can turn
off this feature by unsetting `Edit => Save Options'.  This is tied to
the following resource:

 -- Resource: saveOptionsOnExit (class SaveOnExit)
     If `on' (default), the current option settings are automatically
     saved when DDD exits.


File: ddd.info,  Node: Customizing Help,  Next: Customizing Undo,  Prev: How Customizing Works,  Up: Customizing

3.6.2 Customizing DDD Help
--------------------------

DDD Help can be customized in various ways.

* Menu:

* Button tips::                 Turning off tips.
* Tip of the day::              Turning off the tip of the day.
* Help Helpers::                Helper programs invoked by Help.


File: ddd.info,  Node: Button tips,  Next: Tip of the day,  Up: Customizing Help

3.6.2.1 Button Tips
...................

Button tips are helpful for novices, but may be distracting for
experienced users.  You can turn off button tips via `Edit =>
Preferences => General => Automatic display of Button Hints => as Popup
Tips'.

   You can also turn off the hint that is displayed in the status line.
Just toggle `Edit => Preferences => General => Automatic Display of
Button Hints => in the Status Line'.

   These are the related DDD resources (*note Customizing::):

 -- Resource: buttonTips (class Tips)
     If `on' (default), enable button tips.

 -- Resource: buttonDocs (class Docs)
     If `on' (default), show button hints in the status line.


File: ddd.info,  Node: Tip of the day,  Next: Help Helpers,  Prev: Button tips,  Up: Customizing Help

3.6.2.2 Tip of the day
......................

You can turn off the tip of the day by toggling `Edit => Preferences =>
Startup => Startup Windows => Tip of the Day'.

   Here is the related DDD resource (*note Customizing::):

 -- Resource: startupTips (class StartupTips)
     If `on' (default), show a tip of the day upon DDD startup.

   *Note Options::, for options to set this resource upon DDD
invocation.

   The actual tips are controlled by these resources (*note
Customizing::):

 -- Resource: startupTipCount (class StartupTipCount)
     The number N of the tip of the day to be shown at startup.  See
     also the `tipN' resources.

 -- Resource: tipN (class Tip)
     The tip of the day numbered N (a string).


File: ddd.info,  Node: Help Helpers,  Prev: Tip of the day,  Up: Customizing Help

3.6.2.3 Help Helpers
....................

DDD relies on a number of external commands, specified via `Edit =>
Preferences => Helpers'.

   To uncompress help texts, you can define a `Uncompress' command:

 -- Resource: uncompressCommand (class UncompressCommand)
     The command to uncompress the built-in DDD manual, the DDD
     license, and the DDD news.  Takes a compressed text from standard
     input and writes the uncompressed text to standard output.  The
     default value is `gzip -d -c'; typical values include `zcat' and
     `gunzip -c'.

   To view WWW pages, you can define a `Web Browser' command:

 -- Resource: wwwCommand (class WWWCommand)
     The command to invoke a WWW browser.  The string `@URL@' is
     replaced by the URL to open.  Default is to try a running Netscape
     first (trying `mozilla', then `netscape'), then `$WWWBROWSER',
     then to invoke a new Netscape process, then to let a running Emacs
     or XEmacs do the job (via `gnudoit'), then to invoke Mosaic, then
     to invoke Lynx in an xterm.

     To specify `netscape-6.0' as browser, use the setting:

          Ddd*wwwCommand: \
               netscape-6.0 -remote 'openURL(@URL@)' \
            || netscape-6.0 '@URL@'

     This command first tries to connect to a running `netscape-6.0'
     browser; if this fails, it starts a new `netscape-6.0' process.

   This is the default WWW Page shown by `Help => DDD WWW Page':

 -- Resource: wwwPage (class WWWPage)
     The DDD WWW page.  Value: `http://www.gnu.org/software/ddd/'


File: ddd.info,  Node: Customizing Undo,  Next: Customizing Windows,  Prev: Customizing Help,  Up: Customizing

3.6.3 Customizing Undo
----------------------

DDD Undo can be customized in various ways.

   To set a maximum size for the undo buffer, set `Edit => Preferences
=> General => Undo Buffer Size'.

   This is related to the `maxUndoSize' resource:

 -- Resource: maxUndoSize (class MaxUndoSize)
     The maximum memory usage (in bytes) of the undo buffer.  Useful for
     limiting DDD memory usage.  A negative value means to place no
     limit.  Default is `2000000', or 2000 kBytes.

   You can also limit the number of entries in the undo buffer,
regardless of size (*note Customizing::):

 -- Resource: maxUndoDepth (class MaxUndoDepth)
     The maximum number of entries in the undo buffer.  This limits the
     number of actions that can be undone, and the number of states that
     can be shown in historic mode.  Useful for limiting DDD memory
     usage.  A negative value (default) means to place no limit.

   To clear the undo buffer at any time, thus reducing memory usage, use
`Edit => Preferences => General => Clear Undo Buffer'


File: ddd.info,  Node: Customizing Windows,  Next: Debugger Settings,  Prev: Customizing Undo,  Up: Customizing

3.6.4 Customizing the DDD Windows
---------------------------------

You can customize the DDD Windows in various ways.

* Menu:

* Splash Screen::               Turning off the splash screen.
* Window Layout::               Re-arranging windows.
* Customizing Fonts::           Using alternate fonts.
* Toggling Windows::            Turning off windows.
* Text Fields::                 Popdown histories.
* Icons::                       Iconifying DDD windows.
* Adding Buttons::              Create your own button set.
* More Customizations::


File: ddd.info,  Node: Splash Screen,  Next: Window Layout,  Up: Customizing Windows

3.6.4.1 Splash Screen
.....................

You can turn off the DDD splash screen shown upon startup.  Just select
`Edit => Preferences => Startup DDD Splash Screen'.

   The value applies only to the next DDD invocation.

   This setting is related to the following resource:

 -- Resource: splashScreen (class SplashScreen)
     If `on' (default), show a DDD splash screen upon start-up.

   You can also customize the appearance of the splash screen (*note
Customizing::):

 -- Resource: splashScreenColorKey (class ColorKey)
     The color key to use for the DDD splash screen.  Possible values
     include:

        * `c' (default) for a color visual,

        * `g' for a multi-level greyscale visual,

        * `g4' for a 4-level greyscale visual, and

        * `m' for a dithered monochrome visual.

        * `best' chooses the best visual available for your display.

     Please note: if DDD runs on a monochrome display, or if DDD was
     compiled without the XPM library, only the monochrome version
     (`m') can be shown.


File: ddd.info,  Node: Window Layout,  Next: Customizing Fonts,  Prev: Splash Screen,  Up: Customizing Windows

3.6.4.2 Window Layout
.....................

By default, DDD stacks commands, source, and data in one single
top-level window.  To have separate top-level windows for source, data,
and debugger console, set `Edit => Preferences => Startup => Window
Layout => Separate Windows'.

   Here are the related DDD resources:

 -- Resource: separateDataWindow (class Separate)
     If `on', the data window and the debugger console are realized in
     different top-level windows.  If `off' (default), the data window
     is attached to the debugger console.

 -- Resource: separateSourceWindow (class Separate)
     If `on', the source window and the debugger console are realized in
     different top-level windows.  If `off' (default), the source window
     is attached to the debugger console.

   By default, the DDD tool bars are located on top of the window.  If
you prefer the tool bar being located at the bottom, as in DDD 2.x and
earlier, set `Edit => Preferences => Startup => Tool Bar Appearance =>
Bottom'.

   This is related to the `toolbarsAtBottom' resource:

 -- Resource: toolbarsAtBottom (class ToolbarsAtBottom)
     Whether source and data tool bars should be placed above source and
     data, respectively (`off', default), or below, as in DDD 2.x
     (`on').

   The bottom setting is only supported for separate tool bars--that is,
you must either choose separate windows or configure the tool bar to
have neither images nor captions (*note Customizing the Tool Bar::).

   If you use stacked windows, you can choose whether there should be
one tool bar or two tool bars.  By default, DDD uses two tool bars if
you use separate windows and disable captions and images, but you can
also explicitly change the setting via this resource:

 -- Resource: commonToolBar (class ToolBar)
     Whether the tool bar buttons should be shown in one common tool
     bar at the top of the common DDD window (`on', default), or
     whether they should be placed in two separate tool bars, one for
     data, and one for source operations, as in DDD 2.x (`off').

   You can also change the location of the _status line_ (*note
Customizing::):

 -- Resource: statusAtBottom (class StatusAtBottom)
     If `on' (default), the status line is placed at the bottom of the
     DDD source window.  If `off', the status line is placed at the top
     of the DDD source window (as in DDD 1.x).

   *Note Options::, for options to set these resources upon DDD
invocation.


File: ddd.info,  Node: Customizing Fonts,  Next: Toggling Windows,  Prev: Window Layout,  Up: Customizing Windows

3.6.4.3 Customizing Fonts
.........................

You can configure the basic DDD fonts at run-time.  Each font is
specified using two members:

   * The "font family" is an X font specifications, where the initial
     `FOUNDRY-' specification may be omitted, as well as any
     specification after FAMILY.  Thus, a pair `FAMILY-WEIGHT' usually
     suffices.

   * The "font size" is given as (resolution-independent) 1/10 points.

   To specify fonts, select `Edit => Preferences => Fonts'.

   The `Browse' button opens a font selection program, where you can
select fonts and attributes interactively.  Clicking `quit' or `select'
in the font selector causes all non-default values to be transferred to
the DDD font preferences panel.

   The following fonts can be set using the preferences panel:

`Default Font'
     The default DDD font to use for labels, menus, and buttons.
     Default is `helvetica-bold'.

`Variable Width'
     The variable width DDD font to use for help texts and messages.
     Default is `helvetica-medium'.

`Fixed Width'
     The fixed width DDD font to use for source code, the debugger
     console, text fields, and the execution window.  Default is
     `lucidatypewriter-medium'.

`Data'
     The DDD font to use for data displays.  Default is
     `lucidatypewriter-medium'.

   Changes in this panel will take effect only in the next DDD session.
To make it effective right now, restart DDD (using `File => Restart
DDD').

   After having made changes in the panel, DDD will automatically offer
you to restart itself, such that you can see the changes taking effect.

   The `Reset' button restores the most recently saved preferences.

   Here are the resources related to font specifications:

 -- Resource: defaultFont (class Font)
     The default DDD font to use for labels, menus, buttons, etc.  The
     font is specified as an X font spec, where the initial FOUNDRY
     specification may be omitted, as well as any specification after
     FAMILY.

     Default value is `helvetica-bold'.

     To set the default DDD font to, say, `helvetica medium', insert a
     line

          Ddd*defaultFont: helvetica-medium

     in your `~/.ddd/init' file.

 -- Resource: defaultFontSize (class FontSize)
     The size of the default DDD font, in 1/10 points.  This resource
     overrides any font size specification in the `defaultFont' resource
     (see above).  The default value is `120' for a 12.0 point font.

 -- Resource: variableWidthFont (class Font)
     The variable width DDD font to use for help texts and messages.
     The font is specified as an X font spec, where the initial FOUNDRY
     specification may be omitted, as well as any specification after
     FAMILY.

     Default value is `helvetica-medium-r'.

     To set the variable width DDD font family to, say, `times', insert
     a line

          Ddd*fixedWidthFont: times-medium

     in your `~/.ddd/init' file.

 -- Resource: variableWidthFontSize (class FontSize)
     The size of the variable width DDD font, in 1/10 points.  This
     resource overrides any font size specification in the
     `variableWidthFont' resource (see above).  The default value is
     `120' for a 12.0 point font.

 -- Resource: fixedWidthFont (class Font)
     The fixed width DDD font to use for source code, the debugger
     console, text fields, and the execution window.  The font is
     specified as an X font spec, where the initial FOUNDRY
     specification may be omitted, as well as any specification after
     FAMILY.

     Default value is `lucidatypewriter-medium'.

     To set the fixed width DDD font family to, say, `courier', insert
     a line

          Ddd*fixedWidthFont: courier-medium

     in your `~/.ddd/init' file.

 -- Resource: fixedWidthFontSize (class FontSize)
     The size of the fixed width DDD font, in 1/10 points.  This
     resource overrides any font size specification in the
     `fixedWidthFont' resource (see above).  The default value is `120'
     for a 12.0 point font.

 -- Resource: dataFont (class Font)
     The fixed width DDD font to use data displays.  The font is
     specified as an X font spec, where the initial FOUNDRY
     specification may be omitted, as well as any specification after
     FAMILY.

     Default value is `lucidatypewriter-medium'.

     To set the DDD data font family to, say, `courier', insert a line

          Ddd*dataFont: courier-medium

     in your `~/.ddd/init' file.

 -- Resource: dataFontSize (class FontSize)
     The size of the DDD data font, in 1/10 points.  This resource
     overrides any font size specification in the `dataFont' resource
     (see above).  The default value is `120' for a 12.0 point font.

   As all font size resources have the same class (and by default the
same value), you can easily change the default DDD font size to, say,
9.0 points by inserting a line

     Ddd*FontSize: 90

in your `~/.ddd/init' file.

   Here's how to specify the command to select fonts:

 -- Resource: fontSelectCommand (class FontSelectCommand)
     A command to select from a list of fonts.  The string `@FONT@' is
     replaced by the current DDD default font; the string `@TYPE@' is
     replaced by a symbolic name of the DDD font to edit.  The program
     must either place the name of the selected font in the `PRIMARY'
     selection or print the selected font on standard output.  A
     typical value is:
          Ddd*fontSelectCommand: xfontsel -print
     
   *Note Options::, for options to set these resources upon DDD
invocation.


File: ddd.info,  Node: Toggling Windows,  Next: Text Fields,  Prev: Customizing Fonts,  Up: Customizing Windows

3.6.4.4 Toggling Windows
........................

In the default stacked window setting, you can turn the individual DDD
windows on and off by toggling the respective items in the `View' menu
(*note View Menu::).  When using separate windows (*note Window
Layout::), you can close the individual windows via `File => Close' or
by closing them via your window manager.

   Whether windows are opened or closed when starting DDD is controlled
by the following resources, immediately tied to the `View' menu items:

 -- Resource: openDataWindow (class Window)
     If `off' (default), the data window is closed upon start-up.

 -- Resource: openDebuggerConsole (class Window)
     If `off', the debugger console is closed upon start-up.

 -- Resource: openSourceWindow (class Window)
     If `off', the source window is closed upon start-up.

   *Note Options::, for options to set these resources upon DDD
invocation.


File: ddd.info,  Node: Text Fields,  Next: Icons,  Prev: Toggling Windows,  Up: Customizing Windows

3.6.4.5 Text Fields
...................

The DDD text fields can be customized using the following resources:

 -- Resource: popdownHistorySize (class HistorySize)
     The maximum number of items to display in pop-down value
     histories.  A value of `0' (default) means an unlimited number of
     values.

 -- Resource: sortPopdownHistory (class SortPopdownHistory)
     If `on' (default), items in the pop-down value histories are sorted
     alphabetically.  If `off', most recently used values will appear at
     the top.


File: ddd.info,  Node: Icons,  Next: Adding Buttons,  Prev: Text Fields,  Up: Customizing Windows

3.6.4.6 Icons
.............

If you frequently switch between DDD and other multi-window
applications, you may like to set `Edit => Preferences => General =>
Iconify all windows at once'.  This way, all DDD windows are iconified
and deiconified as a group.

   This is tied to the following resource:

 -- Resource: groupIconify (class GroupIconify)
     If this is `on', (un)iconifying any DDD window causes all other
     DDD windows to (un)iconify as well.  Default is `off', meaning
     that each DDD window can be iconified on its own.

   If you want to keep DDD off your desktop during a longer
computation, you may like to set `Edit => Preferences => General =>
Uniconify when ready'.  This way, you can iconify DDD while it is busy
on a command (e.g. running a program); DDD will automatically pop up
again after becoming ready (e.g. after the debugged program has stopped
at a breakpoint).  *Note Program Stop::, for a discussion.

   Here is the related resource:

 -- Resource: uniconifyWhenReady (class UniconifyWhenReady)
     If this is `on' (default), the DDD windows are uniconified
     automatically whenever GDB becomes ready.  This way, you can
     iconify DDD during some longer operation and have it uniconify
     itself as soon as the program stops.  Setting this to `off' leaves
     the DDD windows iconified.


File: ddd.info,  Node: Adding Buttons,  Next: More Customizations,  Prev: Icons,  Up: Customizing Windows

3.6.4.7 Adding Buttons
......................

You can extend DDD with new buttons.  *Note Defining Buttons::, for
details.


File: ddd.info,  Node: More Customizations,  Prev: Adding Buttons,  Up: Customizing Windows

3.6.4.8 More Customizations
...........................

You can change just about any label, color, keyboard mapping, etc.  by
changing resources from the `Ddd' application defaults file which comes
with the DDD source distribution.  Here's how it works:

   * Identify the appropriate resource in the `Ddd' file.

   * Copy the resource line to your `~/.ddd/init' file and change it at
     will.

   *Note Application Defaults::, for details on the application-defaults
file.


File: ddd.info,  Node: Debugger Settings,  Prev: Customizing Windows,  Up: Customizing

3.6.5 Debugger Settings
-----------------------

For most inferior debuggers, you can change their internal settings
using `Edit => Settings'.  Using the settings editor, you can determine
whether C++ names are to be demangled, how many array elements are to
print, and so on.

   The capabilities of the settings editor depend on the capabilities of
your inferior debugger.  Clicking on `?' gives an an explanation on the
specific item; the GDB documentation gives more details.

   Use `Edit => Undo' to undo changes.  Clicking on `Reset' restores
the most recently saved settings.

   Some debugger settings are insensitive and cannot be changed, because
doing so would endanger DDD operation.  See the `gdbInitCommands' and
`dbxInitCommands' resources for details.

   All debugger settings (except source and object paths) are saved with
DDD options.


File: ddd.info,  Node: Navigating,  Next: Stopping,  Prev: Windows,  Up: Top

4 Navigating through the Code
*****************************

This chapter discusses how to access code from within DDD.

* Menu:

* Compiling for Debugging::     Always use `-g' to compile.
* Opening Files::               How to open a program for debugging.
* Looking up Items::            Searching files and functions.
* Customizing Source::          Arranging the source window.


File: ddd.info,  Node: Compiling for Debugging,  Next: Opening Files,  Up: Navigating

4.1 Compiling for Debugging
===========================

In order to debug a program effectively, you need to generate debugging
information when you compile it.  This debugging information is stored
in the object file; it describes the data type of each variable or
function and the correspondence between source line numbers and
addresses in the executable code.(1)

   To request debugging information, specify the `-g' option when you
run the compiler.

   Many C compilers are unable to handle the `-g' and `-O' options
together.  Using those compilers, you cannot generate optimized
executables containing debugging information.

   GCC, the GNU C compiler, supports `-g' with or without `-O', making
it possible to debug optimized code.  We recommend that you _always_
use `-g' whenever you compile a program.  You may think your program is
correct, but there is no sense in pushing your luck.

   When you debug a program compiled with `-g -O', remember that the
optimizer is rearranging your code; the debugger shows you what is
really there.  Do not be too surprised when the execution path does not
exactly match your source file!  An extreme example: if you define a
variable, but never use it, DDD never sees that variable--because the
compiler optimizes it out of existence.

   ---------- Footnotes ----------

   (1) If you use DDD to debug Perl, Python or Bash scripts, then this
section does not apply.


File: ddd.info,  Node: Opening Files,  Next: Looking up Items,  Prev: Compiling for Debugging,  Up: Navigating

4.2 Opening Files
=================

If you did not invoke DDD specifying a program to be debugged, you can
use the `File' menu to open programs, core dumps and sources.

* Menu:

* Opening Programs::            How to open a program for debugging.
* Opening Core Dumps::          Analyze a previous crash.
* Opening Source Files::        Open a source file of the program.
* Filtering Files::             DDD only lists matching files.


File: ddd.info,  Node: Opening Programs,  Next: Opening Core Dumps,  Up: Opening Files

4.2.1 Opening Programs
----------------------

To open a program to be debugged, select `File => Open Program'.(1)
Click on `Open' to open the program

   In JDB, select `File => Open Class' instead.  This gives you a list
of available classes to choose from.

   To re-open a recently debugged program or class, select `File =>
Open Recent' and choose a program or class from the list.

   If no sources are found, *Note Source Path::, for specifying source
directories.

   ---------- Footnotes ----------

   (1) With XDB and some DBX variants, the debugged program must be
specified upon invocation and cannot be changed at run time.


File: ddd.info,  Node: Opening Core Dumps,  Next: Opening Source Files,  Prev: Opening Programs,  Up: Opening Files

4.2.2 Opening Core Dumps
------------------------

If a previous run of the program has crashed and you want to find out
why, you can have DDD examine its "core dump".(1)

   To open a core dump for the program, select `File => Open Core
Dump'.  Click on `Open' to open the core dump.

   Before `Open Core Dump', you should first use `File => Open Program'
to specify the program that generated the core dump and to load its
symbol table.

   ---------- Footnotes ----------

   (1) JDB, PYDB, Perl, and Bash do not support core dumps.


File: ddd.info,  Node: Opening Source Files,  Next: Filtering Files,  Prev: Opening Core Dumps,  Up: Opening Files

4.2.3 Opening Source Files
--------------------------

To open a source file of the debugged program, select `File => Open
Source'.

   * Using GDB, this gives you a list of the sources used for compiling
     your program.

   * Using other inferior debuggers, this gives you a list of accessible
     source files, which may or may not be related to your program.

   Click on `Open' to open the source file.  *Note Source Path::, if no
sources are found.


File: ddd.info,  Node: Filtering Files,  Prev: Opening Source Files,  Up: Opening Files

4.2.4 Filtering Files
---------------------

When presenting files to be opened, DDD by default filters files when
opening execution files, core dumps, or source files, such that the
selection shows only suitable files.  This requires that DDD opens each
file, which may take time.  *Note Customizing File Filtering::, if you
want to turn off this feature.


File: ddd.info,  Node: Looking up Items,  Next: Customizing Source,  Prev: Opening Files,  Up: Navigating

4.3 Looking up Items
====================

As soon as the source of the debugged program is available, the _source
window_ displays its current source text.  (*note Source Path::, if a
source text cannot be found.)

   In the source window, you can lookup and examine function and
variable definitions as well as search for arbitrary occurrences in the
source text.

* Menu:

* Looking up Definitions::      Jump towards a specific item.
* Textual Search::              Search within the current source.
* Looking up Previous Locations::  Navigate back and forth.
* Source Path::                 Make DDD know where to search.


File: ddd.info,  Node: Looking up Definitions,  Next: Textual Search,  Up: Looking up Items

4.3.1 Looking up Definitions
----------------------------

If you wish to lookup a specific function or variable definition whose
name is visible in the source text, click with _mouse button 1_ on the
function or variable name.  The name is copied to the argument field.
Change the name if desired and click on the `Lookup' button to find its
definition.

   As a faster alternative, you can simply press _mouse button 3_ on the
function name and select the `Lookup' item from the source popup menu.

   As an even faster alternative, you can also double-click on a
function call (an identifier followed by a `(' character) to lookup the
function definition.

   If a source file is not found, *Note Source Path::, for specifying
source directories.


File: ddd.info,  Node: Textual Search,  Next: Looking up Previous Locations,  Prev: Looking up Definitions,  Up: Looking up Items

4.3.2 Textual Search
--------------------

If the item you wish to search is visible in the source text, click with
_mouse button 1_ on it.  The identifier is copied to the argument
field.  Click on the `Find >>' button to find following occurrences and
on `Find >> => Find << ()' to find previous occurrences.

   By default, DDD finds only complete words.  To search for arbitrary
substrings, change the value of the `Source => Find Words Only' option.


File: ddd.info,  Node: Looking up Previous Locations,  Next: Source Path,  Prev: Textual Search,  Up: Looking up Items

4.3.3 Looking up Previous Locations
-----------------------------------

After looking up a location, use `Edit => Undo' (or the `Undo' button
on the command tool) to go back to the original locations.  `Edit =>
Redo' brings you back again to the location you looked for.


File: ddd.info,  Node: Source Path,  Prev: Looking up Previous Locations,  Up: Looking up Items

4.3.4 Specifying Source Directories
-----------------------------------

Executable programs sometimes do not record the directories of the
source files from which they were compiled, just the names.  Even when
they do, the directories could be moved between the compilation and your
debugging session.

   Here's how GDB accesses source files; other inferior debuggers have
similar methods.

   GDB has a list of directories to search for source files; this is
called the "source path".  Each time GDB wants a source file, it tries
all the directories in the list, in the order they are present in the
list, until it finds a file with the desired name.  Note that the
executable search path is _not_ used for this purpose.  Neither is the
current working directory, unless it happens to be in the source path.

   If GDB cannot find a source file in the source path, and the object
program records a directory, GDB tries that directory too.  If the
source path is empty, and there is no record of the compilation
directory, GDB looks in the current directory as a last resort.

   To specify a source path for your inferior debugger, use `Edit =>
Debugger Settings' (*note Debugger Settings:: and search for
appropriate entries (in GDB, this is `Search path for source files').

   If `Debugger Settings' has no suitable entry, you can also specify a
source path for the inferior debugger when invoking DDD.  *Note
Inferior Debugger Options::, for details.

   When using JDB, you can set the `CLASSPATH' environment variable to
specify directories where JDB (and DDD) should search for classes.

   If DDD does not find a source file for any reason, check the
following issues:

   * In order to debug a program effectively, you need to generate
     debugging information when you compile it.  Without debugging
     information, the inferior debugger will be unable to locate the
     source code. To request debugging information, specify the `-g'
     option when you run the compiler.  *Note Compiling for
     Debugging::, for details.

   * You may need to tell your inferior debugger where the source code
     files are.  *Note Source Path::, for details.

     Using GDB, you can also create a local `.gdbinit' file that
     contains a line `directory PATH'.  Here, PATH is a colon-separated
     list of source paths.


File: ddd.info,  Node: Customizing Source,  Prev: Looking up Items,  Up: Navigating

4.4 Customizing the Source Window
=================================

The source window can be customized in a number of ways, most of them
accessed via `Edit => Preferences => Source'.

* Menu:

* Customizing Glyphs::
* Customizing Searching::
* Customizing Source Appearance::
* Customizing Source Scrolling::
* Customizing Source Lookup::
* Customizing File Filtering::


File: ddd.info,  Node: Customizing Glyphs,  Next: Customizing Searching,  Up: Customizing Source

4.4.1 Customizing Glyphs
------------------------

In the source text, the current execution position and breakpoints are
indicated by symbols ("glyphs").  As an alternative, DDD can also
indicate these positions using text characters.  If you wish to disable
glyphs, set `Edit => Preferences => Source => Show Position and
Breakpoints => as Text Characters' option.  This also makes DDD run
slightly faster, especially when scrolling.

   This setting is tied to this resource:

 -- Resource: displayGlyphs (class DisplayGlyphs)
     If this is `on', the current execution position and breakpoints are
     displayed as glyphs; otherwise, they are shown through characters
     in the text.  The default is `on'.  *Note Options::, for the
     `--glyphs' and `--no-glyphs' options.

   You can further control glyphs using the following resources:

 -- Resource: cacheGlyphImages (class CacheMachineCode)
     Whether to cache (share) glyph images (`on') or not (`off').
     Caching glyph images requires less X resources, but has been
     reported to fail with OSF/Motif 2.1 on XFree86 servers.  Default
     is `off' for OSF/Motif 2.1 or later on GNU/Linux machines, and `on'
     otherwise.

 -- Resource: glyphUpdateDelay (class GlyphUpdateDelay)
     A delay (in ms) that says how much time to wait before updating
     glyphs while scrolling the source text.  A small value results in
     glyphs being scrolled with the text, a large value disables glyphs
     while scrolling and makes scrolling faster.  Default: `10'.

 -- Resource: maxGlyphs (class MaxGlyphs)
     The maximum number of glyphs to be displayed (default: `10').
     Raising this value causes more glyphs to be allocated, possibly
     wasting resources that are never needed.


File: ddd.info,  Node: Customizing Searching,  Next: Customizing Source Appearance,  Prev: Customizing Glyphs,  Up: Customizing Source

4.4.2 Customizing Searching
---------------------------

Searching in the source text (*note Textual Search::) is controlled by
these resources, changed via the `Source' menu:

 -- Resource: findCaseSensitive (class FindCaseSensitive)
     If this is `on' (default), the `Find' commands are case-sensitive.
     Otherwise, occurrences are found regardless of case.

 -- Resource: findWordsOnly (class FindWordsOnly)
     If this is `on' (default), the `Find' commands find complete words
     only.  Otherwise, arbitrary occurrences are found.


File: ddd.info,  Node: Customizing Source Appearance,  Next: Customizing Source Scrolling,  Prev: Customizing Searching,  Up: Customizing Source

4.4.3 Customizing Source Appearance
-----------------------------------

You can have DDD show line numbers within the source window.  Use `Edit
=> Preferences => Source => Display Source Line Numbers'.

 -- Resource: displayLineNumbers (class DisplayLineNumbers)
     If this is `on', lines in the source text are prefixed with their
     respective line number.  The default is `off'.

   You can instruct DDD to indent the source code, leaving more room
for breakpoints and execution glyphs.  This is done using the `Edit =>
Preferences => Source => Source indentation' slider.  The default value
is `0' for no indentation at all.

 -- Resource: indentSource (class Indent)
     The number of columns to indent the source code, such that there is
     enough place to display breakpoint locations.  Default: `0'.

   By default, DDD uses a minimum indentation for script languages.

 -- Resource: indentScript (class Indent)
     The minimum indentation for script languages, such as Perl,
     Python, and Bash.  Default: `4'.

   The maximum width of line numbers is controlled by this resource.

 -- Resource: lineNumberWidth (class LineNumberWidth)
     The number of columns to use for line numbers (if displaying line
     numbers is enabled).  Line numbers wider than this value extend
     into the breakpoint space.  Default: `4'.

   If your source code uses a tab width different from `8' (the
default), you can set an alternate width using the `Edit => Preferences
=> Source => Tab width' slider.

 -- Resource: tabWidth (class TabWidth)
     The tab width used in the source window (default: `8')


File: ddd.info,  Node: Customizing Source Scrolling,  Next: Customizing Source Lookup,  Prev: Customizing Source Appearance,  Up: Customizing Source

4.4.4 Customizing Source Scrolling
----------------------------------

These resources control when the source window is scrolled:

 -- Resource: linesAboveCursor (class LinesAboveCursor)
     The minimum number of lines to show before the current location.
     Default is `2'.

 -- Resource: linesBelowCursor (class LinesBelowCursor)
     The minimum number of lines to show after the current location.
     Default is `3'.


File: ddd.info,  Node: Customizing Source Lookup,  Next: Customizing File Filtering,  Prev: Customizing Source Scrolling,  Up: Customizing Source

4.4.5 Customizing Source Lookup
-------------------------------

Some DBX and XDB variants do not properly handle paths in source file
specifications.  If you want the inferior debugger to refer to source
locations by source base names only, unset the `Edit => Preferences =>
Source => Refer to Program Sources by full path name' option.

   This is related to the following resource:

 -- Resource: useSourcePath (class UseSourcePath)
     If this is `off' (default), the inferior debugger refers to source
     code locations only by their base names.  If this is `on'
     (default), DDD uses the full source code paths.

   By default, DDD caches source files in memory.  This is convenient
for remote debugging, since remote file access may be slow.  If you
want to reduce memory usage, unset the `Edit => Preferences => Source
=> Cache source files' option.

   This is related to the following resource:

 -- Resource: cacheSourceFiles (class CacheSourceFiles)
     Whether to cache source files (`on', default) or not (`off').
     Caching source files requires more memory, but makes DDD run
     faster.


File: ddd.info,  Node: Customizing File Filtering,  Prev: Customizing Source Lookup,  Up: Customizing Source

4.4.6 Customizing File Filtering
--------------------------------

You can control whether DDD should filter files to be opened.

 -- Resource: filterFiles (class FilterFiles)
     If this is `on' (default), DDD filters files when opening
     execution files, core dumps, or source files, such that the
     selection shows only suitable files.  This requires that DDD opens
     each file, which may take time.  If this is `off', DDD always
     presents all available files.


File: ddd.info,  Node: Stopping,  Next: Running,  Prev: Navigating,  Up: Top

5 Stopping the Program
**********************

The principal purposes of using a debugger are so that you can stop your
program before it terminates; or so that, if your program runs into
trouble, you can investigate and find out why.

   Inside DDD, your program may stop for any of several reasons, such
as a signal, a breakpoint, or reaching a new line after a DDD command
such as `Step'.  You may then examine and change variables, set new
breakpoints or remove old ones, and then continue execution.

   The inferior debuggers supported by DDD support two mechanisms for
stopping a program upon specific events:

   * A "breakpoint" makes your program stop whenever a certain point in
     the program is reached.  For each breakpoint, you can add
     conditions to control in finer detail whether your program stops.
     Typically, breakpoints are set before running the program.

   * A "watchpoint" is a special breakpoint that stops your program when
     the value of an expression changes.

* Menu:

* Breakpoints::                 Stop at a certain point.
* Watchpoints::                 Stop at a certain condition.
* Interrupting::                Stop manually.
* Stopping X Programs::         Take care of grabbed pointers!


File: ddd.info,  Node: Breakpoints,  Next: Watchpoints,  Up: Stopping

5.1 Breakpoints
===============

* Menu:

* Setting Breakpoints::
* Deleting Breakpoints::
* Disabling Breakpoints::
* Temporary Breakpoints::
* Editing Breakpoint Properties::
* Breakpoint Conditions::
* Breakpoint Ignore Counts::
* Breakpoint Commands::
* Moving and Copying Breakpoints::
* Looking up Breakpoints::
* Editing all Breakpoints::
* Hardware-Assisted Breakpoints::


File: ddd.info,  Node: Setting Breakpoints,  Next: Deleting Breakpoints,  Up: Breakpoints

5.1.1 Setting Breakpoints
-------------------------

You can set breakpoints by location or by name.

5.1.1.1 Setting Breakpoints by Location
.......................................

Breakpoints are set at a specific location in the program.

   If the source line is visible, click with _mouse button 1_ on the
left of the source line and then on the `Break' button.

   As a faster alternative, you can simply press _mouse button 3_ on
the left of the source line and select the `Set Breakpoint' item from
the line popup menu.

   As an even faster alternative, you can simply double-click on the
left of the source line to set a breakpoint.

   As yet another alternative, you can select `Source => Breakpoints'.
Click on the `Break' button and enter the location.

   (If you find this number of alternatives confusing, be aware that
DDD users fall into three categories, which must all be supported.
_Novice users_ explore DDD and may prefer to use one single mouse
button.  _Advanced users_ know how to use shortcuts and prefer popup
menus.  _Experienced users_ prefer the command line interface.)

   Breakpoints are indicated by a plain stop sign, or as `#N', where N
is the breakpoint number.  A greyed out stop sign (or `_N_') indicates
a disabled breakpoint.  A stop sign with a question mark (or `?N?')
indicates a conditional breakpoint or a breakpoint with an ignore count
set.

   If you set a breakpoint by mistake, use `Edit => Undo' to delete it
again.

5.1.1.2 Setting Breakpoints by Name
...................................

If the function name is visible, click with _mouse button 1_ on the
function name.  The function name is then copied to the argument field.
Click on the `Break' button to set a breakpoint there.

   As a shorter alternative, you can simply press _mouse button 3_ on
the function name and select the `Break at' item from the popup menu.

   As yet another alternative, you can click on `Break...' from the
Breakpoint editor (invoked through `Source => Breakpoints') and enter
the function name.

5.1.1.3 Setting Regexp Breakpoints
..................................

Using GDB, you can also set a breakpoint on all functions that match a
given string.  `Break => Set Breakpoints at Regexp ()' sets a
breakpoint on all functions whose name matches the _regular expression_
given in `()'.  Here are some examples:

   * To set a breakpoint on every function that starts with `Xm', set
     `()' to `^Xm'.

   * To set a breakpoint on every member of class `Date', set `()' to
     `^Date::'.

   * To set a breakpoint on every function whose name contains `_fun',
     set `()' to `_fun'.

   * To set a breakpoint on every function that ends in `_test', set
     `()' to `_test$'.


File: ddd.info,  Node: Deleting Breakpoints,  Next: Disabling Breakpoints,  Prev: Setting Breakpoints,  Up: Breakpoints

5.1.2 Deleting Breakpoints
--------------------------

To delete a visible breakpoint, click with _mouse button 1_ on the
breakpoint.  The breakpoint location is copied to the argument field.
Click on the `Clear' button to delete all breakpoints there.

   If the function name is visible, click with _mouse button 1_ on the
function name.  The function name is copied to the argument field.
Click on the `Clear' button to clear all breakpoints there.

   As a faster alternative, you can simply press _mouse button 3_ on
the breakpoint and select the `Delete Breakpoint' item from the popup
menu.

   As yet another alternative, you can select the breakpoint and click
on `Delete' in the Breakpoint editor (invoked through `Source =>
Breakpoints').

   As an even faster alternative, you can simply double-click on the
breakpoint while holding <Ctrl>.


File: ddd.info,  Node: Disabling Breakpoints,  Next: Temporary Breakpoints,  Prev: Deleting Breakpoints,  Up: Breakpoints

5.1.3 Disabling Breakpoints
---------------------------

Rather than deleting a breakpoint or watchpoint, you might prefer to
"disable" it.  This makes the breakpoint inoperative as if it had been
deleted, but remembers the information on the breakpoint so that you
can "enable" it again later.(1)

   To disable a breakpoint, press _mouse button 3_ on the breakpoint
symbol and select the `Disable Breakpoint' item from the breakpoint
popup menu.  To enable it again, select `Enable Breakpoint'.

   As an alternative, you can select the breakpoint and click on
`Disable' or `Enable' in the Breakpoint editor (invoked through `Source
=> Breakpoints'.

   Disabled breakpoints are indicated by a grey stop sign, or `_N_',
where N is the breakpoint number.

   The `Disable Breakpoint' item is also accessible via the `Clear'
button.  Just press and hold _mouse button 1_ on the button to get a
popup menu.

   ---------- Footnotes ----------

   (1) JDB does not support breakpoint disabling.


File: ddd.info,  Node: Temporary Breakpoints,  Next: Editing Breakpoint Properties,  Prev: Disabling Breakpoints,  Up: Breakpoints

5.1.4 Temporary Breakpoints
---------------------------

A "temporary breakpoint" is immediately deleted as soon as it is
reached.(1)

   To set a temporary breakpoint, press _mouse button 3_ on the left of
the source line and select the `Set Temporary Breakpoint' item from the
popup menu.

   As a faster alternative, you can simply double-click on the left of
the source line while holding <Ctrl>.

   Temporary breakpoints are convenient to make the program continue up
to a specific location: just set the temporary breakpoint at this
location and continue execution.

   The `Continue Until Here' item from the popup menu sets a temporary
breakpoint on the left of the source line and immediately continues
execution.  Execution stops when the temporary breakpoint is reached.

   The `Set Temporary Breakpoint' and `Continue Until Here' items are
also accessible via the `Break' button.  Just press and hold _mouse
button 1_ on the button to get a popup menu.

   ---------- Footnotes ----------

   (1) JDB does not support temporary breakpoints.


File: ddd.info,  Node: Editing Breakpoint Properties,  Next: Breakpoint Conditions,  Prev: Temporary Breakpoints,  Up: Breakpoints

5.1.5 Editing Breakpoint Properties
-----------------------------------

You can change all properties of a breakpoint by pressing _mouse button
3_ on the breakpoint symbol and select `Properties' from the breakpoint
popup menu.  This will pop up a dialog showing the current properties
of the selected breakpoint.

   As an even faster alternative, you can simply double-click on the
breakpoint.

   * Click on `Lookup' to move the cursor to the breakpoint's location.  

   * Click on `Enable' to enable the breakpoint.  

   * Click on `Disable' to disable the breakpoint.  

   * Click on `Temp' to make the breakpoint temporary.(1) 

   * Click on `Delete' to delete the breakpoint.  

   ---------- Footnotes ----------

   (1) GDB has no way to make a temporary breakpoint non-temporary
again.


File: ddd.info,  Node: Breakpoint Conditions,  Next: Breakpoint Ignore Counts,  Prev: Editing Breakpoint Properties,  Up: Breakpoints

5.1.6 Breakpoint Conditions
---------------------------

The simplest sort of breakpoint breaks every time your program reaches a
specified place.  You can also specify a "condition" for a breakpoint.
A condition is just a Boolean expression in your programming language.
A breakpoint with a condition evaluates the expression each time your
program reaches it, and your program stops only if the condition is
_true_.

   This is the converse of using assertions for program validation; in
that situation, you want to stop when the assertion is violated-that is,
when the condition is false.  In C, if you want to test an assertion
expressed by the condition ASSERTION, you should set the condition
`!ASSERTION' on the appropriate breakpoint.

   Break conditions can have side effects, and may even call functions
in your program.  This can be useful, for example, to activate functions
that log program progress, or to use your own print functions to format
special data structures. The effects are completely predictable unless
there is another enabled breakpoint at the same address.  (In that case,
DDD might see the other breakpoint first and stop your program without
checking the condition of this one.)

   Note that breakpoint commands are usually more convenient and
flexible for the purpose of performing side effects when a breakpoint
is reached.  *Note Breakpoint Commands::, for details.


File: ddd.info,  Node: Breakpoint Ignore Counts,  Next: Breakpoint Commands,  Prev: Breakpoint Conditions,  Up: Breakpoints

5.1.7 Breakpoint Ignore Counts
------------------------------

A special case of a breakpoint condition is to stop only when the
breakpoint has been reached a certain number of times.  This is so
useful that there is a special way to do it, using the "ignore count"
of the breakpoint.  Every breakpoint has an ignore count, which is an
integer.  Most of the time, the ignore count is zero, and therefore has
no effect.  But if your program reaches a breakpoint whose ignore count
is positive, then instead of stopping, it just decrements the ignore
count by one and continues.  As a result, if the ignore count value is
N, the breakpoint does not stop the next N times your program reaches
it.

   In the field `Ignore Count' of the `Breakpoint Properties' panel,
you can specify the breakpoint ignore count.(1)

   If a breakpoint has a positive ignore count and a condition, the
condition is not checked.  Once the ignore count reaches zero, DDD
resumes checking the condition.

   ---------- Footnotes ----------

   (1) JDB, Perl and some DBX variants do not support breakpoint ignore
counts.


File: ddd.info,  Node: Breakpoint Commands,  Next: Moving and Copying Breakpoints,  Prev: Breakpoint Ignore Counts,  Up: Breakpoints

5.1.8 Breakpoint Commands
-------------------------

You can give any breakpoint (or watchpoint) a series of DDD commands to
execute when your program stops due to that breakpoint.  For example,
you might want to print the values of certain expressions, or enable
other breakpoints.(1)

   Using the `Commands' buttons of the `Breakpoint Properties' panel,
you can edit commands to be executed when the breakpoint is hit.

   To edit breakpoint commands, click on `Edit >>' and enter the
commands in the commands editor.  When done with editing, click on
`Edit <<' to close the commands editor.

   Using GDB, you can also "record" a command sequence to be executed.
To record a command sequence, follow these steps:

  1. Click on `Record' to begin the recording of the breakpoint
     commands.  

  2. Now interact with DDD.  While recording, DDD does not execute
     commands, but simply records them to be executed when the
     breakpoint is hit.  The recorded debugger commands are shown in the
     debugger console.

  3. To stop the recording, click on `End' or enter `end' at the GDB
     prompt.  To "cancel" the recording, click on `Interrupt' or press
     <ESC>.  

  4. You can edit the breakpoint commands just recorded using `Edit >>'.  

   ---------- Footnotes ----------

   (1) JDB, PYDB, and some DBX variants do not support breakpoint
commands.


File: ddd.info,  Node: Moving and Copying Breakpoints,  Next: Looking up Breakpoints,  Prev: Breakpoint Commands,  Up: Breakpoints

5.1.9 Moving and Copying Breakpoints
------------------------------------

To move a breakpoint to a different location, press _mouse button 1_ on
the stop sign and drag it to the desired location.(1)  This is
equivalent to deleting the breakpoint at the old location and setting a
breakpoint at the new location.  The new breakpoint inherits all
properties of the old breakpoint, except the breakpoint number.

   To copy a breakpoint to a new location, press <Shift> while dragging.

   ---------- Footnotes ----------

   (1) When glyphs are disabled (*note Customizing Source::),
breakpoints cannot be dragged.  Delete and set breakpoints instead.


File: ddd.info,  Node: Looking up Breakpoints,  Next: Editing all Breakpoints,  Prev: Moving and Copying Breakpoints,  Up: Breakpoints

5.1.10 Looking up Breakpoints
-----------------------------

If you wish to lookup a specific breakpoint, select `Source =>
Breakpoints => Lookup'.  After selecting a breakpoint from the list and
clicking the `Lookup' button, the breakpoint location is displayed.

   As an alternative, you can enter `#N' in the argument field, where N
is the breakpoint number, and click on the `Lookup' button to find its
definition.


File: ddd.info,  Node: Editing all Breakpoints,  Next: Hardware-Assisted Breakpoints,  Prev: Looking up Breakpoints,  Up: Breakpoints

5.1.11 Editing all Breakpoints
------------------------------

To view and edit all breakpoints at once, select `Source =>
Breakpoints'.  This will popup the "Breakpoint Editor" which displays
the state of all breakpoints.

   In the breakpoint editor, you can select individual breakpoints by
clicking on them.  Pressing <Ctrl> while clicking toggles the
selection.  To edit the properties of all selected breakpoints, click on
`Props'.


File: ddd.info,  Node: Hardware-Assisted Breakpoints,  Prev: Editing all Breakpoints,  Up: Breakpoints

5.1.12 Hardware-Assisted Breakpoints
------------------------------------

Using GDB, a few more commands related to breakpoints can be invoked
through the debugger console:

`hbreak POSITION'
     Sets a hardware-assisted breakpoint at POSITION.  This command
     requires hardware support and some target hardware may not have
     this support.  The main purpose of this is EPROM/ROM code
     debugging, so you can set a breakpoint at an instruction without
     changing the instruction.

`thbreak POS'
     Set a temporary hardware-assisted breakpoint at POS.

   *Note Setting breakpoints: (gdb)Setting breakpoints, for details.


File: ddd.info,  Node: Watchpoints,  Next: Interrupting,  Prev: Breakpoints,  Up: Stopping

5.2 Watchpoints
===============

You can make the program stop as soon as some variable value changes, or
when some variable is read or written.  This is called "setting a
watchpoint on a variable".(1)

   Watchpoints have much in common with breakpoints: in particular, you
can enable and disable them.  You can also set conditions, ignore
counts, and commands to be executed when a watched variable changes its
value.

   Please note: on architectures without special watchpoint support,
watchpoints currently make the program execute two orders of magnitude
more slowly.  This is so because the inferior debugger must interrupt
the program after each machine instruction in order to examine whether
the watched value has changed.  However, this delay can be well worth it
to catch errors when you have no clue what part of your program is the
culprit.

* Menu:

* Setting Watchpoints::
* Editing Watchpoint Properties::
* Editing all Watchpoints::
* Deleting Watchpoints::

   ---------- Footnotes ----------

   (1) Watchpoints are available in GDB and some DBX variants only.  In
XDB, a similar feature is available via XDB "assertions"; see the XDB
documentation for details.


File: ddd.info,  Node: Setting Watchpoints,  Next: Editing Watchpoint Properties,  Up: Watchpoints

5.2.1 Setting Watchpoints
-------------------------

If the variable name is visible, click with _mouse button 1_ on the
variable name.  The variable name is copied to the argument field.
Otherwise, enter the variable name in the argument field.  Click on the
`Watch' button to set a watchpoint there.

   Using GDB and JDB 1.2, you can set different types of watchpoints.
Click and hold _mouse button 1_ on the `Watch' button to get a menu.


File: ddd.info,  Node: Editing Watchpoint Properties,  Next: Editing all Watchpoints,  Prev: Setting Watchpoints,  Up: Watchpoints

5.2.2 Editing Watchpoint Properties
-----------------------------------

To change the properties of a watchpoint, enter the name of the watched
variable in the argument field.  Click and hold _mouse button 1_ on the
`Watch' button and select `Watchpoint Properties'.

   The Watchpoint Properties panel has the same functionality as the
Breakpoint Properties panel (*note Editing Breakpoint Properties::).  As
an additional feature, you can click on `Print' to see the current
value of a watched variable.


File: ddd.info,  Node: Editing all Watchpoints,  Next: Deleting Watchpoints,  Prev: Editing Watchpoint Properties,  Up: Watchpoints

5.2.3 Editing all Watchpoints
-----------------------------

To view and edit all watchpoints at once, select `Data => Watchpoints'.
This will popup the "Watchpoint Editor" which displays the state of all
watchpoints.

   The Watchpoint Editor has the same functionality as the Breakpoint
Editor (*note Editing all Breakpoints::).  As an additional feature, you
can click on `Print' to see the current value of a watched variable.


File: ddd.info,  Node: Deleting Watchpoints,  Prev: Editing all Watchpoints,  Up: Watchpoints

5.2.4 Deleting Watchpoints
--------------------------

To delete a watchpoint, enter the name of the watched variable in the
argument field and click the `Unwatch' button.


File: ddd.info,  Node: Interrupting,  Next: Stopping X Programs,  Prev: Watchpoints,  Up: Stopping

5.3 Interrupting
================

If the program is already running (*note Running::), you can interrupt
it any time by clicking the `Interrupt' button or typing <ESC> in a DDD
window.(1)  Using GDB, this is equivalent to sending a `SIGINT'
(Interrupt) signal.

   `Interrupt' and <ESC> also interrupt a running debugger command,
such as printing data.

   ---------- Footnotes ----------

   (1) If <Ctrl+C> is not bound to `Copy' (*note Customizing the Edit
Menu::), you can also use <Ctrl+C> to interrupt the running program.


File: ddd.info,  Node: Stopping X Programs,  Prev: Interrupting,  Up: Stopping

5.4 Stopping X Programs
=======================

If your program is a modal X application, DDD may interrupt it while it
has grabbed the mouse pointer, making further interaction
impossible--your X display will be unresponsive to any user actions.

   By default, DDD will check after each interaction whether the
pointer is grabbed.  If the pointer is grabbed, DDD will continue the
debugged program such that you can continue to use your X display.

   This is how this feature works: When the program stops, DDD checks
for input events such as keyboard or mouse interaction.  If DDD does
not receive any event within the next 5 seconds, DDD checks whether the
mouse pointer is grabbed by attempting to grab and ungrab it.  If this
attempt fails, then DDD considers the pointer grabbed.

   Unfortunately, DDD cannot determine the program that grabbed the
pointer--it may be the debugged program, or another program.
Consequently, you have another 10 seconds to cancel continuation before
DDD continues the program automatically.

   There is one situation where this fails: if you lock your X display
while DDD is running, then DDD will consider a resulting pointer grab
as a result of running the program--and automatically continue
execution of the debugged program.  Consequently, you can turn off this
feature via `Edit => Preferences => General => Continue Automatically
when Mouse Pointer is Frozen'.

* Menu:

* Customizing Grab Checking::


File: ddd.info,  Node: Customizing Grab Checking,  Up: Stopping X Programs

5.4.1 Customizing Grab Checking
-------------------------------

The grab checks are controlled by the following resources:

 -- Resource: checkGrabs (class CheckGrabs)
     If this is `on' (default), DDD will check after each interaction
     whether the pointer is grabbed.  If this is so, DDD will
     automatically continue execution of debugged program.

 -- Resource: checkGrabDelay (class CheckGrabDelay)
     The time to wait (in ms) after a debugger command before checking
     for a grabbed pointer.  If DDD sees some pointer event within this
     delay, the pointer cannot be grabbed and an explicit check for a
     grabbed pointer is unnecessary.  Default is `5000', or 5 seconds.

 -- Resource: grabAction (class grabAction)
     The action to take after having detected a grabbed mouse pointer.
     This is a list of newline-separated commands.  Default is `cont',
     meaning to continue the debuggee.  Other possible choices include
     `kill' (killing the debuggee) or `quit' (exiting DDD).

 -- Resource: grabActionDelay (class grabActionDelay)
     The time to wait (in ms) before taking an action due to having
     detected a grabbed pointer.  During this delay, a working dialog
     pops up telling the user about imminent execution of the grab
     action (see the `grabAction' resource, above).  If the pointer
     grab is released within this delay, the working dialog pops down
     and no action is taken.  This is done to exclude pointer grabs
     from sources other than the debugged program (including DDD).
     Default is `10000', or 10 seconds.


File: ddd.info,  Node: Running,  Next: Examining Data,  Prev: Stopping,  Up: Top

6 Running the Program
*********************

You may start the debugged program with its arguments, if any, in an
environment of your choice.  You may redirect your program's input and
output, debug an already running process, or kill a child process.

* Menu:

* Starting Program Execution::
* Using the Execution Window::
* Attaching to a Process::
* Program Stop::
* Resuming Execution::
* Continuing Somewhere Else::
* Stack::
* Undoing Program Execution::
* Threads::
* Signals::
* Killing the Program::


File: ddd.info,  Node: Starting Program Execution,  Next: Using the Execution Window,  Up: Running

6.1 Starting Program Execution
==============================

To start execution of the debugged program, select `Program => Run'.
You will then be prompted for the arguments to pass to your program.
You can either select from a list of previously used arguments or enter
own arguments in the text field.  Afterwards, press the `Run' button to
start execution with the selected arguments.

   To run your program again, with the same arguments, select `Program
=> Run Again' or press the `Run' button on the command tool.  You may
also enter `run', followed by arguments at the debugger prompt instead.

   When you click on `Run', your program begins to execute immediately.
*Note Stopping::, for a discussion of how to arrange for your program
to stop.  Once your program has stopped, you may call functions in your
program to examine data.  *Note Examining Data::, for details.

   If the modification time of your symbol file has changed since the
last time GDB read its symbols, GDB discards its symbol table, and
reads it again.  When it does this, GDB and DDD try to retain your
current debugger state, such as breakpoints.

* Menu:

* Arguments::                   Your program's arguments.
* Environment::                 Your program's environment.
* Working Directory::           Your program's directory.
* Input/Output::                Your program's I/O.


File: ddd.info,  Node: Arguments,  Next: Environment,  Up: Starting Program Execution

6.1.1 Your Program's Arguments
------------------------------

The arguments to your program are specified by the arguments of the
`run' command, as composed in `Program => Run'.

   In GDB, the arguments are passed to a shell, which expands wildcard
characters and performs redirection of I/O, and thence to your program.
Your `SHELL' environment variable (if it exists) specifies what shell
GDB uses.  If you do not define `SHELL', GDB uses `/bin/sh'.

   If you use another inferior debugger, the exact semantics on how the
arguments are interpreted depend on the inferior debugger you are using.
Normally, the shell is used to pass the arguments, so that you may use
normal conventions (such as wildcard expansion or variable substitution)
in describing the arguments.


File: ddd.info,  Node: Environment,  Next: Working Directory,  Prev: Arguments,  Up: Starting Program Execution

6.1.2 Your Program's Environment
--------------------------------

Your program normally inherits its environment from the inferior
debugger, which again inherits it from DDD, which again inherits it
from its parent process (typically the shell or desktop).

   In GDB, you can use the commands `set environment' and `unset
environment' to change parts of the environment that affect your
program.  *Note Your program's environment: (gdb)Your program's
environment, for details.

   The following environment variables are set by DDD:

`DDD'
     Set to a string indicating the DDD version.  By testing whether
     `DDD' is set, a debuggee (or inferior debugger) can determine
     whether it was invoked by DDD.

`TERM'
     Set to `dumb', the DDD terminal type.  This is set for the
     inferior debugger only.(1)

`TERMCAP'
     Set to `' (none), the DDD terminal capabilities.

`PAGER'
     Set to `cat', the preferred DDD pager.

   The inferior debugger, in turn, might also set or unset some
environment variables.

   ---------- Footnotes ----------

   (1) If the debuggee runs in a separate execution window, the
debuggee's `TERM' value is set according to the `termType' resource;
*Note Customizing the Execution Window::, for details.


File: ddd.info,  Node: Working Directory,  Next: Input/Output,  Prev: Environment,  Up: Starting Program Execution

6.1.3 Your Program's Working Directory
--------------------------------------

Your program normally inherits its working directory from the inferior
debugger, which again inherits it from DDD, which again inherits it
from its parent process (typically the shell or desktop).

   You can change the working directory of the inferior debugger via
`File => Change Directory' or via the `cd' command of the inferior
debugger.


File: ddd.info,  Node: Input/Output,  Prev: Working Directory,  Up: Starting Program Execution

6.1.4 Your Program's Input and Output
-------------------------------------

By default, the program you run under DDD does input and output to the
debugger console.  Normally, you can redirect your program's input
and/or output using "shell redirections" with the arguments--that is,
additional arguments like `< INPUT' or `> OUTPUT'.  You can enter these
shell redirections just like other arguments (*note Arguments::).

   _Warning:_ While input and output redirection work, you cannot use
pipes to pass the output of the program you are debugging to another
program; if you attempt this, DDD may wind up debugging the wrong
program.  *Note Attaching to a Process::, for an alternative.

   If command output is sent to the debugger console, it is impossible
for DDD to distinguish between the output of the debugged program and
the output of the inferior debugger.

   Program output that confuses DDD includes:

   * Primary debugger prompts (e.g. `(gdb) ', `(dbx) ' or `(ladebug) ')

   * Secondary debugger prompts (e.g. `>')

   * Confirmation prompts (e.g. `(y or n) ')

   * Prompts for more output (e.g. `Press RETURN to continue')

   * Display output (e.g. `$pc = 0x1234')

   If your program outputs any of these strings, you may encounter
problems with DDD mistaking them for debugger output.  These problems
can easily be avoided by redirecting program I/O, for instance to the
separate execution window (*note Using the Execution Window::).

   If the inferior debugger changes the default TTY settings, for
instance through a `stty' command in its initialization file, DDD may
also become confused.  The same applies to debugged programs which
change the default TTY settings.

   The behavior of the debugger console can be controlled using the
following resource:

 -- Resource: lineBufferedConsole (class LineBuffered)
     If this is `on' (default), each line from the inferior debugger is
     output on each own, such that the final line is placed at the
     bottom of the debugger console.  If this is `off', all lines are
     output as a whole.  This is faster, but results in a random
     position of the last line.


File: ddd.info,  Node: Using the Execution Window,  Next: Attaching to a Process,  Prev: Starting Program Execution,  Up: Running

6.2 Using the Execution Window
==============================

By default, input and output of your program go to the debugger console.
As an alternative, DDD can also invoke an "execution window", where the
program terminal input and output is shown.(1)

   To activate the execution window, select `Program => Run in
Execution Window'.

   Using the execution window has an important side effect: The output
of your program no longer gets intermixed with the output of the
inferior debugger.  This makes it far easier for DDD to parse the
debugger output correctly.  *Note Debugger Communication::, for details
on the `bufferGDBOutput' resource.

   The execution window is opened automatically as soon as you start the
debugged program.  While the execution window is active, DDD redirects
the standard input, output, and error streams of your program to the
execution window.  Note that the device `/dev/tty' still refers to the
debugger console, _not_ the execution window.

   You can override the DDD stream redirection by giving alternate
redirection operations as arguments.  For instance, to have your program
read from FILE, but to write to the execution window, invoke your
program with `< FILE' as argument.  Likewise, to redirect the standard
error output to the debugger console, use `2> /dev/tty' (assuming the
inferior debugger and/or your UNIX shell support standard error
redirection).

* Menu:

* Customizing the Execution Window::

   ---------- Footnotes ----------

   (1) The execution window is not available in JDB.


File: ddd.info,  Node: Customizing the Execution Window,  Up: Using the Execution Window

6.2.1 Customizing the Execution Window
--------------------------------------

You can customize the DDD execution window and use a different TTY
command.  The command is set by `Edit => Preferences => Helpers =>
Execution Window': 

 -- Resource: termCommand (class TermCommand)
     The command to invoke for the execution window--a TTY emulator
     that shows the input/output of the debugged program.  A Bourne
     shell command to run in the separate TTY is appended to this
     string.  The string `@FONT@' is replaced by the name of the fixed
     width font used by DDD.  A simple value is

          Ddd*termCommand: xterm -fn @FONT@ -e /bin/sh -c
     
   You can also set the terminal type:

 -- Resource: termType (class TermType)
     The terminal type provided by the `termCommand' resource--that is,
     the value of the `TERM' environment variable to be passed to the
     debugged program.  Default: `xterm'.  

   Whether the execution window is active or not, as set by `Program =>
Run in Execution Window', is saved using this resource:

 -- Resource: separateExecWindow (class Separate)
     If `on', the debugged program is executed in a separate execution
     window.  If `off' (default), the debugged program is executed in
     the console window.


File: ddd.info,  Node: Attaching to a Process,  Next: Program Stop,  Prev: Using the Execution Window,  Up: Running

6.3 Attaching to a Running Process
==================================

If the debugged program is already running in some process, you can
"attach" to this process (instead of starting a new one with `Run').(1)

   To attach DDD to a process, select `File => Attach to Process'.  You
can now choose from a list of processes.  Then, press the `Attach'
button to attach to the specified process.

   The first thing DDD does after arranging to debug the specified
process is to stop it. You can examine and modify an attached process
with all the DDD commands that are ordinarily available when you start
processes with `Run'. You can insert breakpoints; you can step and
continue; you can modify storage. If you would rather the process
continue running, you may use `Continue' after attaching DDD to the
process.

   When using `Attach to Process', you should first use `Open Program'
to specify the program running in the process and load its symbol table.

   When you have finished debugging the attached process, you can use
the `File => Detach Process' to release it from DDD control.  Detaching
the process continues its execution.  After `Detach Process', that
process and DDD become completely independent once more, and you are
ready to attach another process or start one with `Run'.

   You can customize the list of processes shown by defining an
alternate command to list processes.  See `Edit => Preferences =>
Helpers => List Processes'; *Note Customizing Attaching to Processes::,
for details.

* Menu:

* Customizing Attaching to Processes::

   ---------- Footnotes ----------

   (1) JDB, PYDB, Perl, and Bash do not support attaching the debugger
to running processes.


File: ddd.info,  Node: Customizing Attaching to Processes,  Up: Attaching to a Process

6.3.1 Customizing Attaching to Processes
----------------------------------------

When attaching to a process (*note Attaching to a Process::), DDD uses
a `ps' command to get the list of processes.  This command is defined
by the `psCommand' resource.

 -- Resource: psCommand (class PsCommand)
     The command to get a list of processes.  Usually `ps'.  Depending
     on your system, useful alternate values include `ps -ef' and `ps
     ux'.  The first line of the output must either contain a `PID'
     title, or each line must begin with a process ID.

     Note that the output of this command is filtered by DDD; a process
     is only shown if it can be attached to.  The DDD process itself as
     well as the process of the inferior debugger are suppressed, too.


File: ddd.info,  Node: Program Stop,  Next: Resuming Execution,  Prev: Attaching to a Process,  Up: Running

6.4 Program Stops
=================

After the program has been started, it runs until one of the following
happens:

   * A breakpoint is reached (*note Breakpoints::).

   * A watched value changes (*note Watchpoints::).

   * The program is interrupted (*note Interrupting::).

   * A signal is received (*note Signals::).

   * Execution completes.

   DDD shows the current program status in the debugger console.  The
current execution position is highlighted by an arrow.

   If `Edit => Preferences => General => Uniconify When Ready' is set,
DDD automatically deiconifies itself when the program stops.  This way,
you can iconify DDD during a lengthy computation and have it uniconify
as soon as the program stops.


File: ddd.info,  Node: Resuming Execution,  Next: Continuing Somewhere Else,  Prev: Program Stop,  Up: Running

6.5 Resuming Execution
======================

6.5.1 Continuing
----------------

To resume execution, at the current execution position, click on the
`Continue' button.  Any breakpoints set at the current execution
position are bypassed.

6.5.2 Stepping one Line
-----------------------

To execute just one source line, click on the `Step' button.  The
program is executed until control reaches a different source line, which
may be in a different function.  Then, the program is stopped and
control returns to DDD.

   _Warning_: If you use the `Step' button while control is within a
function that was compiled without debugging information, execution
proceeds until control reaches a function that does have debugging
information.  Likewise, it will not step into a function which is
compiled without debugging information.  To step through functions
without debugging information, use the `Stepi' button (*note Machine
Code Execution::).

   In GDB, the `Step' button only stops at the first instruction of a
source line.  This prevents the multiple stops that used to occur in
switch statements, for loops, etc.  `Step' continues to stop if a
function that has debugging information is called within the line.

   Also, the `Step' in GDB only enters a subroutine if there is line
number information for the subroutine.  Otherwise it acts like the
`Next' button.

6.5.3 Continuing to the Next Line
---------------------------------

To continue to the next line in the current function, click on the
`Next' button.  This is similar to `Step', but any function calls
appearing within the line of code are executed without stopping.

   Execution stops when control reaches a different line of code at the
original stack level that was executing when you clicked on `Next'.

6.5.4 Continuing Until Here
---------------------------

To continue running until a specific location is reached, use the
`Continue Until Here' facility from the line popup menu.  *Note
Temporary Breakpoints::, for a discussion.

6.5.5 Continuing Until a Greater Line is Reached
------------------------------------------------

To continue until a greater line in the current function is reached,
click on the `Until' button.  This is useful to avoid single stepping
through a loop more than once.

   `Until' is like `Next', except that when `Until' encounters a jump,
it automatically continues execution until the program counter is
greater than the address of the jump.

   This means that when you reach the end of a loop after single
stepping though it, `until' makes your program continue execution until
it exits the loop.  In contrast, clicking on `Next' at the end of a
loop simply steps back to the beginning of the loop, which forces you to
step through the next iteration.

   `Until' always stops your program if it attempts to exit the current
stack frame.

   `Until' works by means of single instruction stepping, and hence is
slower than continuing until a breakpoint is reached.

6.5.6 Continuing Until Function Returns
---------------------------------------

To continue running until the current function returns, use the
`Finish' button.  The returned value (if any) is printed.


File: ddd.info,  Node: Continuing Somewhere Else,  Next: Stack,  Prev: Resuming Execution,  Up: Running

6.6 Continuing at a Different Address
=====================================

Ordinarily, when you continue your program, you do so at the place where
it stopped.  You can instead continue at an address of your own
choosing.

   The most common occasion to use this feature is to back up--perhaps
with more breakpoints set-over a portion of a program that has already
executed, in order to examine its execution in more detail.

   To set the execution position to the current location, use `Set
Execution Position' from the breakpoint popup menu.  This item is also
accessible by pressing and holding the `Break/Clear' button.(1)

   As a quicker alternative, you can also press _mouse button 1_ on the
arrow and drag it to a different location.(2)

   Moving the execution position does not change the current stack
frame, or the stack pointer, or the contents of any memory location or
any register other than the program counter.

   Some inferior debuggers (notably GDB) allow you to set the new
execution position into a different function from the one currently
executing.  This may lead to bizarre results if the two functions
expect different patterns of arguments or of local variables.  For this
reason, moving the execution position requests confirmation if the
specified line is not in the function currently executing.

   After moving the execution position, click on `Continue' to resume
execution.

   ---------- Footnotes ----------

   (1) JDB, PYDB, Perl, and Bash do not support altering the execution
position.

   (2) When glyphs are disabled (*note Customizing Source::), dragging
the execution position is not possible.  Set the execution position
explicitly instead.


File: ddd.info,  Node: Stack,  Next: Undoing Program Execution,  Prev: Continuing Somewhere Else,  Up: Running

6.7 Examining the Stack
=======================

When your program has stopped, the first thing you need to know is
where it stopped and how it got there.

   Each time your program performs a function call, information about
the call is generated.  That information includes the location of the
call in your program, the arguments of the call, and the local
variables of the function being called.  The information is saved in a
block of data called a "stack frame".  The stack frames are allocated
in a region of memory called the "call stack".

   When your program stops, the DDD commands for examining the stack
allow you to see all of this information.

   One of the stack frames is "selected" by DDD and many DDD commands
refer implicitly to the selected frame.  In particular, whenever you
ask DDD for the value of a variable in your program, the value is found
in the selected frame.  There are special DDD commands to select
whichever frame you are interested in.

* Menu:

* Frames::                      Callers and callees.
* Backtraces::                  And you may ask yourself, `how did I get here?'
* Selecting a frame::           Moving up and down.


File: ddd.info,  Node: Frames,  Next: Backtraces,  Up: Stack

6.7.1 Stack Frames
------------------

The call stack is divided up into contiguous pieces called "stack
frames", or "frames" for short; each frame is the data associated with
one call to one function.  The frame contains the arguments given to
the function, the function's local variables, and the address at which
the function is executing.

   When your program is started, the stack has only one frame, that of
the function `main'.  This is called the "initial" frame or the
"outermost" frame.  Each time a function is called, a new frame is
made.  Each time a function returns, the frame for that function
invocation is eliminated.  If a function is recursive, there can be
many frames for the same function.  The frame for the function in which
execution is actually occurring is called the "innermost" frame.  This
is the most recently created of all the stack frames that still exist.

   Inside your program, stack frames are identified by their addresses.
A stack frame consists of many bytes, each of which has its own
address; each kind of computer has a convention for choosing one byte
whose address serves as the address of the frame.  Usually this address
is kept in a register called the "frame pointer register" while
execution is going on in that frame.

   GDB assigns numbers to all existing stack frames, starting with zero
for the innermost frame, one for the frame that called it, and so on
upward.  These numbers do not really exist in your program; they are
assigned by GDB to give you a way of designating stack frames in GDB
commands.


File: ddd.info,  Node: Backtraces,  Next: Selecting a frame,  Prev: Frames,  Up: Stack

6.7.2 Backtraces
----------------

DDD provides a "backtrace window" showing a summary of how your program
got where it is.  It shows one line per frame, for many frames,
starting with the currently executing frame (frame zero), followed by
its caller (frame one), and on up the stack.

   To enable the backtrace window, select `Status => Backtrace'.

   Using GDB, each line in the backtrace shows the frame number and the
function name.  The program counter value is also shown--unless you use
the GDB command `set print address off'.  The backtrace also shows the
source file name and line number, as well as the arguments to the
function.  The program counter value is omitted if it is at the
beginning of the code for that line number.


File: ddd.info,  Node: Selecting a frame,  Prev: Backtraces,  Up: Stack

6.7.3 Selecting a Frame
-----------------------

Most commands for examining the stack and other data in your program
work on whichever stack frame is selected at the moment.  Here are the
commands for selecting a stack frame.(1)

   In the backtrace window, you can _select_ an arbitrary frame to move
from one stack frame to another.  Just click on the desired frame.

   The `Up' button selects the function that called the current
one--that is, it moves one frame up.

   The `Down' button selects the function that was called by the
current one--that is, it moves one frame down.

   You can also directly type the `up' and `down' commands at the
debugger prompt.  Typing <Ctrl+Up> and <Ctrl+Down>, respectively, will
also move you through the stack.

   `Up' and `Down' actions can be undone via `Edit => Undo'.  

   ---------- Footnotes ----------

   (1) Perl does not allow changing the current stack frame.


File: ddd.info,  Node: Undoing Program Execution,  Next: Threads,  Prev: Stack,  Up: Running

6.8 "Undoing" Program Execution
===============================

If you take a look at the `Edit => Undo' menu item after an execution
command, you'll find that DDD offers you to undo execution commands
just as other commands.  Does this mean that DDD allows you to go
backwards in time, undoing program execution as well as undoing any
side-effects of your program?

   Sorry--we must disappoint you.  DDD cannot undo what your program
did.  (After a little bit of thought, you'll find that this would be
impossible in general.)  However, DDD can do something different: it
can show _previously recorded states_ of your program.

   After "undoing" an execution command (via `Edit => Undo', or the
`Undo' button), the execution position moves back to the earlier
position and displayed variables take their earlier values.  Your
program state is in fact unchanged, but DDD gives you a _view_ on the
earlier state as recorded by DDD.

   In this so-called "historic mode", most normal DDD commands that
would query further information from the program are disabled, since
the debugger cannot be queried for the earlier state.  However, you can
examine the current execution position, or the displayed variables.
Using `Undo' and `Redo', you can move back and forward in time to
examine how your program got into the present state.

   To let you know that you are operating in historic mode, the
execution arrow gets a dashed-line appearance (indicating a past
position); variable displays also come with dashed lines.  Furthermore,
the status line informs you that you are seeing an earlier program
state.

   Here's how historic mode works: each time your program stops, DDD
collects the current execution position and the values of displayed
variables.  Backtrace, thread, and register information is also
collected if the corresponding dialogs are open.  When "undoing" an
execution command, DDD updates its view from this collected state
instead of querying the program.

   If you want to collect this information without interrupting your
program--within a loop, for instance--you can place a breakpoint with
an associated `cont' command (*note Breakpoint Commands::).  When the
breakpoint is hit, DDD will stop, collect the data, and execute the
`cont' command, resuming execution.  Using a later `Undo', you can step
back and look at every single loop iteration.

   To leave historic mode, you can use `Redo' until you are back in the
current program state.  However, any DDD command that refers to program
state will also leave historic mode immediately by applying to the
current program state instead.  For instance, `Up' leaves historic mode
immediately and selects an alternate frame in the restored current
program state.

   If you want to see the history of a specific variable, as recorded
during program stops, you can enter the DDD command

     graph history NAME

   This returns a list of all previously recorded values of the variable
NAME, using array syntax.  Note that NAME must have been displayed at
earlier program stops in order to record values.


File: ddd.info,  Node: Threads,  Next: Signals,  Prev: Undoing Program Execution,  Up: Running

6.9 Examining Threads
=====================

In some operating systems, a single program may have more than one
_thread_ of execution.  The precise semantics of threads differ from
one operating system to another, but in general the threads of a single
program are akin to multiple processes--except that they share one
address space (that is, they can all examine and modify the same
variables).  On the other hand, each thread has its own registers and
execution stack, and perhaps private memory.

   For debugging purposes, DDD lets you display the list of threads
currently active in your program and lets you select the _current
thread_--the thread which is the focus of debugging.  DDD shows all
program information from the perspective of the current thread.(1)

   To view all currently active threads in your program, select `Status
=> Threads'.  The current thread is highlighted.  Select any thread to
make it the current thread.

   Using JDB, additional functionality is available:

   * Select a _thread group_ to switch between viewing all threads and
     the threads of the selected thread group;

   * Click on `Suspend' to suspend execution of the selected threads;

   * Click on `Resume' to resume execution of the selected threads.

   For more information on threads, see the JDB and GDB documentation
(*note Debugging programs with multiple threads: (gdb)Threads.).

   ---------- Footnotes ----------

   (1) Currently, threads are supported in GDB and JDB only.


File: ddd.info,  Node: Signals,  Next: Killing the Program,  Prev: Threads,  Up: Running

6.10 Handling Signals
=====================

A signal is an asynchronous event that can happen in a program.  The
operating system defines the possible kinds of signals, and gives each
kind a name and a number.  For example, in UNIX, `SIGINT' is the signal
a program gets when you type an interrupt; `SIGSEGV' is the signal a
program gets from referencing a place in memory far away from all the
areas in use; `SIGALRM' occurs when the alarm clock timer goes off
(which happens only if your program has requested an alarm).

   Some signals, including `SIGALRM', are a normal part of the
functioning of your program.  Others, such as `SIGSEGV', indicate
errors; these signals are _fatal_ (kill your program immediately) if
the program has not specified in advance some other way to handle the
signal.  `SIGINT' does not indicate an error in your program, but it is
normally fatal so it can carry out the purpose of the interrupt: to
kill the program.

   GDB has the ability to detect any occurrence of a signal in your
program.  You can tell GDB in advance what to do for each kind of
signal.

   Normally, DDD is set up to ignore non-erroneous signals like
`SIGALRM' (so as not to interfere with their role in the functioning of
your program) but to stop your program immediately whenever an error
signal happens.  In DDD, you can view and edit these settings via
`Status => Signals'.

   `Status => Signals' pops up a panel showing all the kinds of signals
and how GDB has been told to handle each one.  The settings available
for each signal are:

`Stop'
     If set, GDB should stop your program when this signal happens.
     This also implies `Print' being set.

`Print'
     If set, GDB should print a message when this signal happens.

     If unset, GDB should not mention the occurrence of the signal at
     all.  This also implies `Stop' being unset.

`Pass'
     If set, GDB should allow your program to see this signal; your
     program can handle the signal, or else it may terminate if the
     signal is fatal and not handled.

     If unset, GDB should not allow your program to see this signal.

   The entry `All Signals' is special.  Changing a setting here affects
_all signals at once_--except those used by the debugger, typically
`SIGTRAP' and `SIGINT'.

   To undo any changes, use `Edit => Undo'.  The `Reset' button
restores the saved settings.

   When a signal stops your program, the signal is not visible until you
continue.  Your program sees the signal then, if `Pass' is in effect
for the signal in question _at that time_.  In other words, after GDB
reports a signal, you can change the `Pass' setting in `Status =>
Signals' to control whether your program sees that signal when you
continue.

   You can also cause your program to see a signal it normally would not
see, or to give it any signal at any time.  The `Send' button will
resume execution where your program stopped, but immediately give it the
signal shown.

   On the other hand, you can also prevent your program from seeing a
signal.  For example, if your program stopped due to some sort of memory
reference error, you might store correct values into the erroneous
variables and continue, hoping to see more execution; but your program
would probably terminate immediately as a result of the fatal signal
once it saw the signal.  To prevent this, you can resume execution using
`Commands => Continue Without Signal'.

   Signal settings are not saved across DDD invocations, since changed
signal settings are normally useful within specific projects only.
Instead, signal settings are saved with the current session, using
`File => Save Session As'.


File: ddd.info,  Node: Killing the Program,  Prev: Signals,  Up: Running

6.11 Killing the Program
========================

You can kill the process of the debugged program at any time using the
`Kill' button.  

   Killing the process is useful if you wish to debug a core dump
instead of a running process.  GDB ignores any core dump file while
your program is running.

   The `Kill' button is also useful if you wish to recompile and relink
your program, since on many systems it is impossible to modify an
executable file while it is running in a process.  In this case, when
you next click on `Run', GDB notices that the file has changed, and
reads the symbol table again (while trying to preserve your current
debugger state).


File: ddd.info,  Node: Examining Data,  Next: Machine-Level Debugging,  Prev: Running,  Up: Top

7 Examining Data
****************

DDD provides several means to examine data.

   * The quickest way to examine variables is to move the pointer on an
     occurrence in the source text.  The value is displayed in the
     source line; after a second, a popup window (called "value tip")
     shows the variable value.  This is useful for quick examination of
     several simple values.

   * If you want to refer to variable values at a later time, you can
     "print" the value in the debugger console.  This allows for
     displaying and examining larger data structures.

   * If you want to examine complex data structures, you can "display"
     them graphically in the data window.  Displays remain effective
     until you delete them; they are updated each time the program
     stops.  This is useful for large dynamic structures.

   * If you want to examine arrays of numeric values, you can "plot"
     them graphically in a separate plot window.  The plot is updated
     each time the program stops.  This is useful for large numeric
     arrays.

   * Using GDB or DBX, you can also "examine memory contents" in any of
     several formats, independently of your program's data types.  

* Menu:

* Value Tips::                  Just move the pointer on a variable.
* Printing Values::             Printing a value in the debugger console.
* Displaying Values::           Displaying structures as graphs.
* Plotting Values::             Displaying values as plots.
* Examining Memory::            Low-level memory examination.


File: ddd.info,  Node: Value Tips,  Next: Printing Values,  Up: Examining Data

7.1 Showing Simple Values using Value Tips
==========================================

To display the value of a simple variable, move the mouse pointer on its
name.  After a second, a small window (called "value tip") pops up
showing the value of the variable pointed at.  The window disappears as
soon as you move the mouse pointer away from the variable.  The value is
also shown in the status line.

   You can disable value tips via `Edit => Preferences => General =>
Automatic display of variable values as popup tips'.

   You can disable displaying variable values in the status line via
`Edit => Preferences => General => Automatic display of variable values
in the status line'.

   These customizations are tied to the following resources:

 -- Resource: valueTips (class Tips)
     Whether value tips are enabled (`on', default) or not (`off').
     Value tips affect DDD performance and may be distracting for some
     experienced users.

 -- Resource: valueDocs (class Docs)
     Whether the display of variable values in the status line is
     enabled (`on', default) or not (`off').

   You can turn off value tips via `Edit => Preferences => General =>
Automatic Display of Variable Values'.


File: ddd.info,  Node: Printing Values,  Next: Displaying Values,  Prev: Value Tips,  Up: Examining Data

7.2 Printing Simple Values in the Debugger Console
==================================================

The variable value can also be printed in the debugger console, making
it available for future operations.  To print a variable value, select
the desired variable by clicking _mouse button 1_ on its name.  The
variable name is copied to the argument field.  By clicking the `Print'
button, the value is printed in the debugger console.  The printed
value is also shown in the status line.

   As a shorter alternative, you can simply press _mouse button 3_ on
the variable name and select the `Print' item from the popup menu.

   In GDB, the `Print' button generates a `print' command, which has
several more options.  *Note Examining Data: (gdb)Data, for
GDB-specific expressions, variables, and output formats.


File: ddd.info,  Node: Displaying Values,  Next: Plotting Values,  Prev: Printing Values,  Up: Examining Data

7.3 Displaying Complex Values in the Data Window
================================================

To explore complex data structures, you can "display" them permanently
in the _data window_.  The data window displays selected data of your
program, showing complex data structures graphically.  It is updated
each time the program stops.

* Menu:

* Display Basics::              How to create, manipulate, and delete displays.
* Arrays::                      Special functions for arrays.
* Assignment::                  Setting variable values.
* Examining Structures::        Dereferencing pointers and other references.
* Customizing Displays::        Data Themes.
* Layouting the Graph::         Automatic layout.
* Printing the Graph::          Printing on paper.


File: ddd.info,  Node: Display Basics,  Next: Arrays,  Up: Displaying Values

7.3.1 Display Basics
--------------------

This section discusses how to create, manipulate, and delete displays.
The essentials are:

   * Click on `Display' to display the variable in `()'.

   * Click on a display to select it.

   * Click on `Undisplay' to delete the selected display.  

* Menu:

* Creating Single Displays::
* Selecting Displays::
* Showing and Hiding Details::
* Rotating Displays::
* Displaying Local Variables::
* Displaying Program Status::
* Refreshing the Data Window::
* Placement::
* Clustering::
* Creating Multiple Displays::
* Editing all Displays::
* Deleting Displays::


File: ddd.info,  Node: Creating Single Displays,  Next: Selecting Displays,  Up: Display Basics

7.3.1.1 Creating Single Displays
................................

To create a new display showing a specific variable, select the variable
by clicking _mouse button 1_ on its name.  The variable name is copied
to the argument field.  By clicking the `Display' button, a new display
is created in the data window.  The data window opens automatically as
soon as you create a display.

   As a shorter alternative, you can simply press _mouse button 3_ on
the variable name and select `Display' from the popup menu.

   As an even faster alternative, you can also double-click on the
variable name.

   As another alternative, you may also enter the expression to be
displayed in the argument field and press the `Display' button.

   Finally, you may also type in a command at the debugger prompt:

     graph display EXPR [clustered] [at (X, Y)]
         [dependent on DISPLAY] [[now or] when in SCOPE]

   This command creates a new display showing the value of the
expression EXPR.  The optional parts have the following meaning:

`clustered'
     If given, the new display is created in a cluster.  *Note
     Clustering::, for a discussion.

`at (X, Y)'
     If given, the new display is created at the position (X, Y).
     Otherwise, a default position is assigned.

`dependent on DISPLAY'
     If given, an edge from the display numbered or named _display_ to
     the new display is created.  Otherwise, no edge is created.  *Note
     Dependent Values::, for details.

`when in SCOPE'
`now or when in SCOPE'
     If `when in' is given, the display creation is "deferred" until
     execution reaches the given SCOPE (a function name, as in the
     backtrace output).

     If `now or when in' is given, DDD first attempts to create the
     display immediately.  The display is deferred only if display
     creation fails.

     If neither `when in' suffix nor `now or when in' suffix is given,
     the display is created immediately.


File: ddd.info,  Node: Selecting Displays,  Next: Showing and Hiding Details,  Prev: Creating Single Displays,  Up: Display Basics

7.3.1.2 Selecting Displays
..........................

Each display in the data window has a _title bar_ containing the
_display number_ and the displayed expression (the _display name_).
Below the title, the _display value_ is shown.

   You can select single displays by clicking on them with _mouse
button 1_.

   You can _extend_ an existing selection by pressing the <Shift> key
while selecting.  You can also _toggle_ an existing selection by
pressing the <Shift> key while selecting already selected displays.

   Single displays may also be selected by using the arrow keys <Up>,
<Down>, <Left>, and <Right>.

   _Multiple displays_ are selected by pressing and holding _mouse
button 1_ somewhere on the window background.  By moving the pointer
while holding the button, a selection rectangle is shown; all displays
fitting in the rectangle are selected when mouse button 1 is released.

   If the <Shift> key is pressed while selecting, the existing
selection is _extended_.

   By double-clicking on a display title, the display itself and all
connected displays are automatically selected.


File: ddd.info,  Node: Showing and Hiding Details,  Next: Rotating Displays,  Prev: Selecting Displays,  Up: Display Basics

7.3.1.3 Showing and Hiding Details
..................................

Aggregate values (i.e. records, structs, classes, and arrays) can be
shown _expanded_, that is, displaying all details, or _hidden_, that
is, displayed as `{...}'.

   To show details about an aggregate, select the aggregate by clicking
_mouse button 1_ on its name or value and click on the `Show' button.
Details are shown for the aggregate itself as well as for all contained
sub-aggregates.

   To hide details about an aggregate, select the aggregate by clicking
_mouse button 1_ on its name or value and click on the `Hide' button.

   When pressing and holding _mouse button 1_ on the `Show/Hide'
button, a menu pops up with even more alternatives:

`Show More ()'
     Shows details of all aggregates currently hidden, but not of their
     sub-aggregates.  You can invoke this item several times in a row to
     reveal more and more details of the selected aggregate.

`Show Just ()'
     Shows details of the selected aggregate, but hides all
     sub-aggregates.

`Show All ()'
     Shows all details of the selected aggregate and of its
     sub-aggregates.  This item is equivalent to the `Show' button.

`Hide ()'
     Hide all details of the selected aggregate.  This item is
     equivalent to the `Hide' button.  

   As a faster alternative, you can also press _mouse button 3_ on the
aggregate and select the appropriate menu item.

   As an even faster alternative, you can also double-click _mouse
button 1_ on a value.  If some part of the value is hidden, more details
will be shown; if the entire value is shown, double-clicking will
_hide_ the value instead.  This way, you can double-click on a value
until you get the right amount of details.

   If _all_ details of a display are hidden, the display is called
"disabled"; this is indicated by the string `(Disabled)'.

   Displays can also be disabled or enabled via a DDD command, which
you enter at the debugger prompt:

     graph disable display DISPLAYS...

disables the given displays.

     graph enable display DISPLAYS...

re-enables the given displays.

   In both commands, DISPLAYS... is either
   * a space-separated list of display numbers to disable or enable, or

   * a single display name.  If you specify a display by name, all
     displays with this name will be affected.

   Use `Edit => Undo' to undo disabling or enabling displays.


File: ddd.info,  Node: Rotating Displays,  Next: Displaying Local Variables,  Prev: Showing and Hiding Details,  Up: Display Basics

7.3.1.4 Rotating Displays
.........................

Arrays, structures and lists can be oriented horizontally or vertically.
To change the orientation of a display, select it and then click on the
`Rotate' button.

   As a faster alternative, you can also press _mouse button 3_ on the
array and select `Rotate' from the popup menu.

   If a structure or list is oriented horizontally, DDD automatically
suppresses the member names.  This can be handy for saving space.

   The last chosen display orientation is used for the creation of new
displays.  If you recently rotated an array to horizontal orientation,
the next array you create will also be oriented horizontally.  These
settings are tied to the following resources:

 -- Resource: arrayOrientation (class Orientation)
     How arrays are to be oriented.  Possible values are `XmVERTICAL'
     (default) and `XmHORIZONTAL'.

 -- Resource: showMemberNames (class ShowMemberNames)
     Whether to show struct member names or not.  Default is `on'.

 -- Resource: structOrientation (class Orientation)
     How structs are to be oriented.  Possible values are `XmVERTICAL'
     (default) and `XmHORIZONTAL'.


File: ddd.info,  Node: Displaying Local Variables,  Next: Displaying Program Status,  Prev: Rotating Displays,  Up: Display Basics

7.3.1.5 Displaying Local Variables
..................................

You can display all local variables at once by choosing `Data =>
Display Local Variables'.  When using DBX, XDB, JDB, or Perl, this
displays all local variables, including the arguments of the current
function.  When using GDB or PYDB, function arguments are contained in
a separate display, activated by `Data => Display Arguments'.

   The display showing the local variables can be manipulated just like
any other data display.  Individual variables can be selected and
dereferenced.


File: ddd.info,  Node: Displaying Program Status,  Next: Refreshing the Data Window,  Prev: Displaying Local Variables,  Up: Display Basics

7.3.1.6 Displaying Program Status
.................................

You can create a display from the output of an arbitrary debugger
command.  By entering

     graph display `COMMAND`

the output of COMMAND is turned into a _status display_ updated each
time the program stops.

   For instance, the command

     graph display `where`

creates a status display named `Where' that shows the current backtrace.

   If you are using GDB, DDD provides a panel from which you can choose
useful status displays.  Select `Data => Status Displays' and pick your
choice from the list.

   Refreshing status displays at each stop takes time; you should delete
status displays as soon as you don't need them any more.


File: ddd.info,  Node: Refreshing the Data Window,  Next: Placement,  Prev: Displaying Program Status,  Up: Display Basics

7.3.1.7 Refreshing the Data Window
..................................

The data window is automatically updated or "refreshed" each time the
program stops.  Values that have changed since the last refresh are
highlighted.

   However, there may be situations where you should refresh the data
window explicitly.  This is especially the case whenever you changed
debugger settings that could affect the data format, and want the data
window to reflect these settings.

   You can refresh the data window by selecting `Data => Refresh
Displays'.

   As an alternative, you can press _mouse button 3_ on the background
of the data window and select the `Refresh Displays' item.

   Typing

     graph refresh

at the debugger prompt has the same effect.


File: ddd.info,  Node: Placement,  Next: Clustering,  Prev: Refreshing the Data Window,  Up: Display Basics

7.3.1.8 Display Placement
.........................

By default, displays are created from _top to bottom_--that is, each
new display is placed below the downmost one.  You can change this
setting to _left to right_ via `Edit => Preferences => Data =>
Placement => Left to right'.

   This setting is tied to the following resource:

 -- Resource: displayPlacement (class Orientation)
     If this is `XmVERTICAL' (default), DDD places each new independent
     display below the downmost one.  If this is `XmHORIZONTAL', each
     new independent display is placed on the right of the rightmost
     one.

   Note that changing the placement of new displays also affects the
placement of _dependent displays_ (*note Dependent Values::).  In _top
to bottom_ mode, dependent displays are created on the right of the
originating display; in _left to right_ mode, dependent displays are
created on the below the originating display.


File: ddd.info,  Node: Clustering,  Next: Creating Multiple Displays,  Prev: Placement,  Up: Display Basics

7.3.1.9 Clustering Displays
...........................

If you examine several variables at once, having a separate display for
each of them uses a lot of screen space.  This is why DDD supports
"clusters".  A cluster merges several logical data displays into one
physical display, saving screen space.

   There are two ways to create clusters:
   * You can create clusters _manually_.  This is done by selecting the
     displays to be clustered and choosing `Undisp => Cluster ()'.
     This creates a new cluster from all selected displays.  If an
     already existing cluster is selected, too, the selected displays
     will be clustered into the selected cluster.

   * You can create a cluster _automatically_ for all independent data
     displays, such that all new data displays will automatically be
     clustered, too.  This is achieved by enabling `Edit => Preferences
     => Data => Placement => clustered'.

   Displays in a cluster can be selected and manipulated like parts of
an ordinary display; in particular, you can show and hide details, or
dereference pointers.  However, edges leading to clustered displays can
not be shown, and you must either select one or all clustered displays.

   Disabling a cluster is called _unclustering_, and again, there are
two ways of doing it:

   * You can uncluster displays _manually_, by selecting the cluster
     and choosing `Undisp => Uncluster ()'.

   * You can uncluster all current and future displays by disabling
     `Edit => Preferences => Data => Placement => clustered'.  


File: ddd.info,  Node: Creating Multiple Displays,  Next: Editing all Displays,  Prev: Clustering,  Up: Display Basics

7.3.1.10 Creating Multiple Displays
...................................

To display several successive objects of the same type (a section of an
array, or an array of dynamically determined size), you can use the
notation `FROM..TO' in display expressions.

   FROM and TO are numbers that denote the first and last expression to
display.  Thus,

     graph display argv[0..9]

creates 10 new displays for `argv[0]', `argv[1]', ..., `argv[9]'.  The
displays are clustered automatically (*note Clustering::), such that
you can easily handle the set just like an array.

   The `FROM..TO' notation can also be used multiple times.  For
instance,

     graph display 1..5 * 1..5

creates a handy small multiplication table.

   The `FROM..TO' notation creates several displays, which takes time
to create and update.  If you want to display only a part of an array,
_array slices_ are a more efficient way.  *Note Array Slices::, for a
discussion.


File: ddd.info,  Node: Editing all Displays,  Next: Deleting Displays,  Prev: Creating Multiple Displays,  Up: Display Basics

7.3.1.11 Editing all Displays
.............................

You can view the state of all displays by selecting `Data => Displays'.
This invokes the "Display Editor".

   The Display Editor shows the properties of each display, using the
following fields:

`Num'
     The display number.

`Expression'
     The displayed expression.

`State'
     One of

    `enabled'
          Normal state.

    `disabled'
          Disabled; all details are hidden.  Use `Show' to enable.

    `not active'
          Out of scope.

    `deferred'
          Will be created as soon as its `Scope' is reached (*note
          Creating Single Displays::).

    `clustered'
          Part of a cluster (*note Clustering::).  Use `Undisp =>
          Uncluster' to uncluster.

    `alias of DISPLAY'
          A suppressed alias of display DISPLAY (*note Shared
          Structures::).

`Scope'
     The scope in which the display was created.  For deferred
     displays, this is the scope in which the display will be created.

`Address'
     The address of the displayed expression.  Used for resolving
     aliases (*note Shared Structures::).


File: ddd.info,  Node: Deleting Displays,  Prev: Editing all Displays,  Up: Display Basics

7.3.1.12 Deleting Displays
..........................

To delete a single display, select its title or value and click on the
`Undisp' button.  As an alternative, you can also press _mouse button
3_ on the display and select the `Undisplay' item.

   When a display is deleted, its immediate ancestors and descendants
are automatically selected, so that you can easily delete entire graphs.

   If you have selected only part of a display, clicking on the
`Undisp' button allows you to _suppress_ this part--by applying the
_Suppress Values_ theme on the part.  You'll be asked for confirmation
first.  *Note Using Data Themes::, for details.

   To delete several displays at once, use the `Undisp' button in the
Display Editor (invoked via `Data => Displays').  Select any number of
display items in the usual way and delete them by pressing `Undisp'.

   As an alternative, you can also use a DDD command:

     graph undisplay DISPLAYS...

   Here, DISPLAYS... is either
   * a space-separated list of display numbers to disable or enable, or

   * a single display name.  If you specify a display by name, all
     displays with this name will be affected.

   If you are using stacked windows, deleting the last display from the
data window also automatically closes the data window.  (You can change
this via `Edit => Preferences => Data => Close data window when
deleting last display'.)

   If you deleted a display by mistake, use `Edit => Undo' to re-create
it.

   Finally, you can also cut, copy, and paste displays using the `Cut',
`Copy', and `Paste' items from the `Edit' menu.  The clipboard holds
the _commands_ used to create the displays; `Paste' inserts the display
commands in the debugger console.  This allows you to save displays for
later usage or to copy displays across multiple DDD instances.


File: ddd.info,  Node: Arrays,  Next: Assignment,  Prev: Display Basics,  Up: Displaying Values

7.3.2 Arrays
------------

DDD has some special features that facilitate handling of arrays.

* Menu:

* Array Slices::                Displaying FROM..TO parts of an array
* Repeated Values::             How repeated values are handled.
* Arrays as Tables::            Displaying two-dimensional arrays.


File: ddd.info,  Node: Array Slices,  Next: Repeated Values,  Up: Arrays

7.3.2.1 Array Slices
....................

It is often useful to print out several successive objects of the same
type in memory; a "slice" (section) of an array, or an array of
dynamically determined size for which only a pointer exists in the
program.

   Using DDD, you can display slices using the `FROM..TO' notation
(*note Creating Multiple Displays::).  But this requires that you
already know FROM and TO; it is also inefficient to create several
single displays.  If you use GDB, you have yet another alternative.

   Using GDB, you can display successive objects by referring to a
contiguous span of memory as an "artificial array", using the binary
operator `@'.  The left operand of `@' should be the first element of
the desired array and be an individual object.  The right operand
should be the desired length of the array.  The result is an array
value whose elements are all of the type of the left argument.  The
first element is actually the left argument; the second element comes
from bytes of memory immediately following those that hold the first
element, and so on.

   Here is an example.  If a program says

     int *array = (int *) malloc (len * sizeof (int));

you can print the contents of `array' with

     print array[0]@len

and display the contents with

     graph display array[0]@len

   The general form of displaying an array slice is thus

     graph display ARRAY[FIRST]@NELEMS

where ARRAY is the name of the array to display, FIRST is the index of
the first element, and NELEMS is the number of elements to display.

   The left operand of `@' must reside in memory.  Array values made
with `@' in this way behave just like other arrays in terms of
subscripting, and are coerced to pointers when used in expressions.


File: ddd.info,  Node: Repeated Values,  Next: Arrays as Tables,  Prev: Array Slices,  Up: Arrays

7.3.2.2 Repeated Values
.......................

Using GDB, an array value that is repeated 10 or more times is displayed
only once.  The value is shown with a `<Nx>' postfix added, where N is
the number of times the value is repeated.  Thus, the display `0x0
<30x>' stands for 30 array elements, each with the value `0x0'.  This
saves a lot of display space, especially with homogeneous arrays.

   The default GDB threshold for repeated array values is 10.  You can
change it via `Edit => GDB Settings => Threshold for repeated print
elements'.  Setting the threshold to `0' will cause GDB (and DDD) to
display each array element individually.  Be sure to refresh the data
window via `Data => Refresh Displays' after a change in GDB settings.

   You can also configure DDD to display each array element
individually:

 -- Resource: expandRepeatedValues (class ExpandRepeatedValues)
     GDB can print repeated array elements as `VALUE <repeated N
     times>'.  If `expandRepeatedValues' is `on', DDD will display N
     instances of VALUE instead.  If `expandRepeatedValues' is `off'
     (default), DDD will display VALUE with `<Nx>' appended to indicate
     the repetition.


File: ddd.info,  Node: Arrays as Tables,  Prev: Repeated Values,  Up: Arrays

7.3.2.3 Arrays as Tables
........................

By default, DDD lays out two-dimensional arrays as tables, such that
all array elements are aligned with each other.(1)  To disable this
feature, unset `Edit => Preferences => Data => Display Two-Dimensional
Arrays as Tables'.  This is tied to the following resource:

 -- Resource: align2dArrays (class Align2dArrays)
     If `on' (default), DDD lays out two-dimensional arrays as tables,
     such that all array elements are aligned with each other.  If
     `off', DDD treats a two-dimensional array as an array of
     one-dimensional arrays, each aligned on its own.

   ---------- Footnotes ----------

   (1) This requires that the full array size is known to the debugger.


File: ddd.info,  Node: Assignment,  Next: Examining Structures,  Prev: Arrays,  Up: Displaying Values

7.3.3 Assignment to Variables
-----------------------------

During program execution, you can change the values of arbitrary
variables.(1)

   To change the value of a variable, enter its name in `()'--for
instance, by selecting an occurrence or a display.  Then, click on the
`Set' button.  In a dialog, you can edit the variable value at will;
clicking the `OK' or `Apply' button commits your change and assigns the
new value to the variable.

   To change a displayed value, you can also select `Set Value' menu
from the data popup menu,

   If you made a mistake, you can use `Edit => Undo' to re-set the
variable to its previous value.

   ---------- Footnotes ----------

   (1) JDB 1.1 does not support changing variable values.


File: ddd.info,  Node: Examining Structures,  Next: Customizing Displays,  Prev: Assignment,  Up: Displaying Values

7.3.4 Examining Structures
--------------------------

Besides displaying simple values, DDD can also visualize the
"Dependencies" between values--especially pointers and other references
that make up complex data structures.

* Menu:

* Dependent Values::            Edges from values to values.
* Dereferencing Pointers::      Examining pointer-based data structures.
* Shared Structures::           Multiple pointers to one display.
* Display Shortcuts::           Customize your own menus.


File: ddd.info,  Node: Dependent Values,  Next: Dereferencing Pointers,  Up: Examining Structures

7.3.4.1 Displaying Dependent Values
...................................

Dependent displays are created from an existing display.  The dependency
is indicated by an "edge" leading from the originating display to the
dependent display.

   To create a dependent display, select the originating display or
display part and enter the dependent expression in the `():' argument
field.  Then click on the `Display' button.

   Using dependent displays, you can investigate the data structure of a
tree for example and lay it out according to your intuitive image of the
tree data structure.

   By default, DDD does not recognize shared data structures (i.e. a
data object referenced by multiple other data objects).  *Note Shared
Structures::, for details on how to examine such structures.


File: ddd.info,  Node: Dereferencing Pointers,  Next: Shared Structures,  Prev: Dependent Values,  Up: Examining Structures

7.3.4.2 Dereferencing Pointers
..............................

There are special shortcuts for creating dependent displays showing the
value of a dereferenced pointer.  This allows for rapid examination of
pointer-based data structures.

   To dereference a pointer, select the originating pointer value or
name and click on the `Disp *' button.  A new display showing the
dereferenced pointer value is created.

   As a faster alternative, you can also press _mouse button 3_ on the
originating pointer value or name and select the `Display *' menu item.

   As an even faster alternative, you can also double-click _mouse
button 1_ on the originating pointer value or name.  If you press
<Ctrl> while double-clicking, the display will be dereferenced _in
place_-that is, it will be replaced by the dereferenced display.

   The `Display *()' function is also accessible by pressing and
holding the `Display' button.


File: ddd.info,  Node: Shared Structures,  Next: Display Shortcuts,  Prev: Dereferencing Pointers,  Up: Examining Structures

7.3.4.3 Shared Structures
.........................

By default, DDD does not recognize shared data structures--that is, a
data object referenced by multiple other data objects.  For instance,
if two pointers `p1' and `p2' point at the same data object `d', the
data displays `d', `*p1', and `*p2' will be separate, although they
denote the same object.

   DDD provides a special mode which makes it detect these situations.
DDD recognizes if two or more data displays are stored at the same
physical address, and if this is so, merges all these "aliases" into
one single data display, the _original data display_.  This mode is
called _Alias Detection_; it is enabled via `Data => Detect Aliases'.

   When alias detection is enabled, DDD inquires the memory location
(the _address_) of each data display after each program step.  If two
displays have the same address, they are merged into one.  More
specifically, only the one which has least recently changed remains
(the _original data display_); all other aliases are _suppressed_, i.e.
completely hidden.  The edges leading to the aliases are replaced by
edges leading to the original data display.

   An edge created by alias detection is somewhat special: rather than
connecting two displays directly, it goes through an "edge hint",
describing an arc connecting the two displays and the edge hint.

   Each edge hint is a placeholder for a suppressed alias; selecting an
edge hint is equivalent to selecting the alias.  This way, you can
easily delete display aliases by simply selecting the edge hint and
clicking on `Undisp'.

   To access suppressed display aliases, you can also use the Display
Editor.  Suppressed displays are listed in the Display Editor as
_aliases_ of the original data display.  Via the Display Editor, you
can select, change, and delete suppressed displays.

   Suppressed displays become visible again as soon as

   * alias detection is disabled,

   * their address changes such that they are no more aliases, or

   * the original data display is deleted, such that the least recently
     changed alias becomes the new original data display.

   Please note the following _caveats_ with alias detection:

   * Alias detection requires that the current programming language
     provides a means to determine the address of an arbitrary data
     object.  Currently, only C, C++, and Java are supported.

   * Some inferior debuggers (for instance, SunOS DBX) produce incorrect
     output for address expressions.  Given a pointer P, you may verify
     the correct function of your inferior debugger by comparing the
     values of P and `&P' (unless P actually points to itself).  You
     can also examine the data display addresses, as shown in the
     Display Editor.

   * Alias detection slows down DDD slightly, which is why you can turn
     it off.  You may consider to enable it only at need--for instance,
     while examining some complex data structure--and disable it while
     examining control flow (i.e., stepping through your program).  DDD
     will automatically restore edges and data displays when switching
     modes.

   Alias detection is controlled by the following resources:

 -- Resource: deleteAliasDisplays (class DeleteAliasDisplays)
     If this is `on' (default), the `Undisplay ()' button also deletes
     all aliases of the selected displays.  If this is `off', only the
     selected displays are deleted; the aliases remain, and one of the
     aliases will be unsuppressed.

 -- Resource: detectAliases (class DetectAliases)
     If `on' (default), DDD attempts to recognize shared data
     structures.  If `off', shared data structures are not recognized.

 -- Resource: typedAliases (class TypedAliases)
     If `on' (default), DDD requires structural equivalence in order to
     recognize shared data structures.  If this is `off', two displays
     at the same address are considered aliases, regardless of their
     structure.


File: ddd.info,  Node: Display Shortcuts,  Prev: Shared Structures,  Up: Examining Structures

7.3.4.4 Display Shortcuts
.........................

DDD maintains a _shortcut menu_ of frequently used display expressions.
This menu is activated

   * by pressing and holding the `Display' button, or

   * by pressing _mouse button 3_ on some display and selecting `New
     Display', or

   * by pressing <Shift> and _mouse button 3_ on some display.

   By default, the shortcut menu contains frequently used base
conversions.

   The `Other' entry in the shortcut menu lets you create a new display
that _extends_ the shortcut menu.

   As an example, assume you have selected a display named `date_ptr'.
Selecting `Display => Other' pops up a dialog that allows you to enter
a new expression to be displayed--for instance, you can cast the
display `date_ptr' to a new display `(char *)date_ptr'.  If the
`Include in `New Display' Menu' toggle was activated, the shortcut menu
will then contain a new entry `Display (char *)()' that will cast _any_
selected display DISPLAY to `(char *)DISPLAY'.  Such shortcuts can save
you a lot of time when examining complex data structures.

   You can edit the contents of the `New Display' menu by selecting its
`Edit Menu' item.  This pops up the _Shortcut Editor_ containing all
shortcut expressions, which you can edit at leisure.  Each line
contains the expression for exactly one menu item.  Clicking on `Apply'
re-creates the `New Display' menu from the text.  If the text is empty,
the `New Display' menu will be empty, too.

   DDD also allows you to specify individual labels for user-defined
buttons.  You can write such a label after the expression, separated by
`//'.  This feature is used in the default contents of the GDB `New
Display' menu, where each of the base conversions has a label:

     /t ()   // Convert to Bin
     /d ()   // Convert to Dec
     /x ()   // Convert to Hex
     /o ()   // Convert to Oct

   Feel free to add other conversions here.  DDD supports up to 20 `New
Display' menu items.

   The shortcut menu is controlled by the following resources:

 -- Resource: dbxDisplayShortcuts (class DisplayShortcuts)
     A newline-separated list of display expressions to be included in
     the `New Display' menu for DBX.

     If a line contains a label delimiter(1), the string before the
     delimiter is used as EXPRESSION, and the string after the
     delimiter is used as label.  Otherwise, the label is `Display
     EXPRESSION'.  Upon activation, the string `()' in EXPRESSION is
     replaced by the name of the currently selected display.

 -- Resource: gdbDisplayShortcuts (class DisplayShortcuts)
     A newline-separated list of display expressions to be included in
     the `New Display' menu for GDB.  See the description of
     `dbxDisplayShortcuts', above.

 -- Resource: jdbDisplayShortcuts (class DisplayShortcuts)
     A newline-separated list of display expressions to be included in
     the `New Display' menu for JDB.  See the description of
     `dbxDisplayShortcuts', above.

 -- Resource: perlDisplayShortcuts (class DisplayShortcuts)
     A newline-separated list of display expressions to be included in
     the `New Display' menu for Perl.  See the description of
     `dbxDisplayShortcuts', above.

 -- Resource: bashDisplayShortcuts (class DisplayShortcuts)
     A newline-separated list of display expressions to be included in
     the `New Display' menu for Bash.  See the description of
     `dbxDisplayShortcuts', above.

 -- Resource: pydbDisplayShortcuts (class DisplayShortcuts)
     A newline-separated list of display expressions to be included in
     the `New Display' menu for PYDB.  See the description of
     `dbxDisplayShortcuts', above.

 -- Resource: xdbDisplayShortcuts (class DisplayShortcuts)
     A newline-separated list of display expressions to be included in
     the `New Display' menu for XDB.  See the description of
     `dbxDisplayShortcuts', above.

   ---------- Footnotes ----------

   (1) The string `//'; can be changed via the `labelDelimiter'
resource.  *Note Customizing Buttons::, for details.


File: ddd.info,  Node: Customizing Displays,  Next: Layouting the Graph,  Prev: Examining Structures,  Up: Displaying Values

7.3.5 Customizing Displays
--------------------------

* Menu:

* Using Data Themes::
* Applying Data Themes to Several Values::
* Editing Themes::
* Writing Data Themes::
* Display Resources::
* VSL Resources::


File: ddd.info,  Node: Using Data Themes,  Next: Applying Data Themes to Several Values,  Up: Customizing Displays

7.3.5.1 Using Data Themes
.........................

DDD provides a simple method to customize displays.  DDD comes with a
number of _visual modifiers_, called _data themes_.

   Each theme modifies a particular aspect of a data display.  It can be
applied to individual displays or to a number of displays.  The themes
installed with DDD include:

`Small Titles'
     Apply this theme to show display titles in a smaller font.

`Small Values'
     Apply this theme to display values in a smaller font.

`Tiny Values'
     Apply this theme to display values in a tiny font.

`Suppress Values'
     Apply this theme to display values not at all.

   Each of these themes can be applied for specific displays.

   To apply a theme on a display,
  1. Press _mouse button 3_ on the display.

  2. Select `Theme'

  3. Select the theme to apply.

   For instance, to display the variable `s' in a tiny font, click
_mouse button 3_ on the display of `s', and select `Theme => Tiny
Values => Apply'.

   To unapply a theme, just click on `Undo' (if you just applied it) or
repeat the sequence as above.


File: ddd.info,  Node: Applying Data Themes to Several Values,  Next: Editing Themes,  Prev: Using Data Themes,  Up: Customizing Displays

7.3.5.2 Applying Data Themes to Several Values
..............................................

Whenever you want to apply a theme on a _struct member_ or an _array
element,_ you will be asked whether to

   * apply the theme on the single value only, or

   * apply the theme on all similar values.

   Suppose, for instance, that you don't want to see `vptr' members
anymore.  Then you'd apply the theme _Suppress Values_ on all similar
values.

   On the other hand, if you want to highlight one single value only,
you'd apply the theme _Red Background_ on only one single value.

   If you find this confirmation annoying, you can define a command
button which directly applies the theme.  *Note Defining Commands::,
for details on defining commands.

   Applying and unapplying themes is associated with the following
commands:

     graph apply theme NAME PATTERN
   applies the theme NAME on PATTERN.

     graph unapply theme NAME PATTERN
   unapplies the theme NAME on PATTERN.

     graph toggle theme NAME PATTERN
   applies the theme NAME on PATTERN if it was not already applied, and
unapplies it otherwise.


File: ddd.info,  Node: Editing Themes,  Next: Writing Data Themes,  Prev: Applying Data Themes to Several Values,  Up: Customizing Displays

7.3.5.3 Editing Themes
......................

Each theme can be globally activated or not.  If a theme is activated,
it is applied to all expressions that match its _pattern_.

   Normally, these patterns are automatically maintained by simply
selecting the themes for the individual displays.  However, you can also
edit patterns directly.

   Patterns are separated by `;' and contain shell-like metacharacters:
   * `*' matches any sequence of characters.

   * `?' matches any single character.

   * `[SET]' matches any character in SET.  Character ranges can be
     expressed using FROM-TO: `[0-9a-zA-Z_]' is the set of characters
     allowed in C characters.

   * `[!SET]' matches any character not in SET.

   * To suppress the special syntactic significance of any
     metacharacter\n\ and match the character exactly, precede it with
     `\' (backslash).

   * To suppress the syntactic significance of _all_ metacharacters,\n\
     enclose the pattern in double or single quotes.\n\

   To edit the set of themes, invoke `Data => Themes'.

   To apply changes you made to the themes, click on `Apply'.  To
revert the themes to the last saved, click on `Reset'.


File: ddd.info,  Node: Writing Data Themes,  Next: Display Resources,  Prev: Editing Themes,  Up: Customizing Displays

7.3.5.4 Writing Data Themes
...........................

You can write your own data themes, customizing the display to match
your need.  *Note Top: (ddd-themes)Top, for details.


File: ddd.info,  Node: Display Resources,  Next: VSL Resources,  Prev: Writing Data Themes,  Up: Customizing Displays

7.3.5.5 Display Resources
.........................

You can use these resources to control display appearance:

 -- Resource: autoCloseDataWindow (class AutoClose)
     If this is `on' (default) and DDD is in stacked window mode,
     deleting the last display automatically closes the data window.
     If this is `off', the data window stays open even after deleting
     the last display.

 -- Resource: bumpDisplays (class BumpDisplays)
     If some display D changes size and this resource is `on'
     (default), DDD assigns new positions to displays below and on the
     right of D such that the distance between displays remains
     constant.  If this is `off', other displays are not rearranged.

 -- Resource: clusterDisplays (class ClusterDisplays)
     If `on', new independent data displays will automatically be
     clustered.  Default is `off', meaning to leave new displays
     unclustered.

 -- Resource: hideInactiveDisplays (class HideInactiveDisplays)
     If some display gets out of scope and this resource is `on'
     (default), DDD removes it from the data display.  If this is
     `off', it is simply disabled.

 -- Resource: showBaseDisplayTitles (class ShowDisplayTitles)
     Whether to assign titles to base (independent) displays or not.
     Default is `on'.

 -- Resource: showDependentDisplayTitles (class ShowDisplayTitles)
     Whether to assign titles to dependent displays or not.  Default is
     `off'.

 -- Resource: suppressTheme (class Theme)
     The theme to apply when selecting `Undisp' on a data value.
     Default is `suppress.vsl'.

 -- Resource: themes (class Themes)
     A newline-separated list of themes.  Each theme has the format
     NAME, tabulator character, PATTERN.


File: ddd.info,  Node: VSL Resources,  Prev: Display Resources,  Up: Customizing Displays

7.3.5.6 VSL Resources
.....................

The following resources control the VSL interpreter:

 -- Resource: vslBaseDefs (class VSLDefs)
     A string with additional VSL definitions that are appended to the
     builtin VSL library.  This resource is prepended to the `vslDefs'
     resource below and set in the DDD application defaults file; don't
     change it.

 -- Resource: vslDefs (class VSLDefs)
     A string with additional VSL definitions that are appended to the
     builtin VSL library.  The default value is an empty string.  This
     resource can be used to override specific VSL definitions that
     affect the data display.  The preferred method, though, is to
     write a specific data theme (*note Writing Data Themes::).

 -- Resource: vslLibrary (class VSLLibrary)
     The VSL library to use.  `builtin' (default) means to use the
     built-in library, any other value is used as file name.

 -- Resource: vslPath (class VSLPath)
     A colon-separated list of directories to search for VSL include
     files.  The following directory names are special:
        * The special directory name `user_themes' stands for your
          individual theme directory, typically `~/.ddd/themes/'.

        * The special directory name `ddd_themes' stands for the
          installed theme directory, typically
          `/usr/local/share/ddd-3.3.11/themes/'.
     Default is `user_themes:ddd_themes:.', which means that DDD first
     searches your theme directory, followed by the system directory
     and the current directory.

   If your DDD source distribution is installed in `/opt/src', you can
use the following settings to read the VSL library from
`/home/joe/ddd.vsl':

     Ddd*vslLibrary: /home/joe/ddd.vsl
     Ddd*vslPath:    user_themes:.:/opt/src/ddd/ddd:/opt/src/ddd/vsllib

   VSL include files referenced by `/home/joe/ddd.vsl' are searched
first in the current directory `.', then in your theme directory, then
in `/opt/src/ddd/ddd/', and then in `/opt/src/ddd/vsllib/'.

   Instead of supplying another VSL library, it is often easier to
specify some minor changes to the built-in library (*note Writing Data
Themes::).


File: ddd.info,  Node: Layouting the Graph,  Next: Printing the Graph,  Prev: Customizing Displays,  Up: Displaying Values

7.3.6 Layouting the Graph
-------------------------

If you have several displays at once, you may wish to arrange them
according to your personal preferences.  This section tells you how you
can do this.

* Menu:

* Moving Displays::
* Scrolling Data::
* Aligning Displays::
* Automatic Layout::
* Rotating the Graph::


File: ddd.info,  Node: Moving Displays,  Next: Scrolling Data,  Up: Layouting the Graph

7.3.6.1 Moving Displays
.......................

From time to time, you may wish to move displays at another place in the
data window.  You can move a single display by pressing and holding
_mouse button 1_ on the display title.  Moving the pointer while
holding the button causes all selected displays to move along with the
pointer.

   Edge hints can be selected and moved around like other displays.  If
an arc goes through the edge hint, you can change the shape of the arc
by moving the edge hint around.

   For fine-grain movements, selected displays may also be moved using
the arrow keys.  Pressing <Shift> and an arrow key moves displays by
single pixels.  Pressing <Ctrl> and arrow keys moves displays by grid
positions.


File: ddd.info,  Node: Scrolling Data,  Next: Aligning Displays,  Prev: Moving Displays,  Up: Layouting the Graph

7.3.6.2 Scrolling Data
......................

If the data window becomes too small to hold all displays, scroll bars
are created.  If your DDD is set up to use _panners_ instead, a panner
is created in the lower right edge.  When the panner is moved around,
the window view follows the position of the panner.

   To change from scroll bars to panners, use `Edit => Startup => Data
Scrolling' and choose either `Panner' or `Scrollbars'.  

   This setting is tied to the following resource:

 -- Resource: pannedGraphEditor (class PannedGraphEditor)
     The control to scroll the graph.

        * If this is `on', an Athena panner is used (a kind of
          two-directional scrollbar).

        * If this is `off' (default), two M*tif scrollbars are used.

     *Note Options::, for the `--scrolled-graph-editor' and
     `--panned-graph-editor' options.


File: ddd.info,  Node: Aligning Displays,  Next: Automatic Layout,  Prev: Scrolling Data,  Up: Layouting the Graph

7.3.6.3 Aligning Displays
.........................

You can align all displays on the nearest grid position by selecting
`Data => Align on Grid'.  This is useful for keeping edges strictly
horizontal or vertical.

   You can enforce alignment by selecting `Edit => Preferences => Data
=> Auto-align Displays on Nearest Grid Point'.  If this feature is
enabled, displays can be moved on grid positions only.


File: ddd.info,  Node: Automatic Layout,  Next: Rotating the Graph,  Prev: Aligning Displays,  Up: Layouting the Graph

7.3.6.4 Automatic Layout
........................

You can layout the entire graph as a tree by selecting `Data => Layout
Graph'.  The layout direction is determined from the display placement
(*note Placement::) and from the last rotation (*note Rotating the
Graph::).

   Layouting the graph may introduce "edge hints"; that is, edges are
no more straight lines, but lead to an edge hint and from there to their
destination.  Edge hints can be moved around like arbitrary displays.

   To enable a more compact layout, you can set the `Edit =>
Preferences => Data => Compact Layout' option.  This realizes an
alternate layout algorithm, where successors are placed next to their
parents.  This algorithm is suitable for homogeneous data structures
only.

   You can enforce layout by setting `Edit => Preferences => Data =>
Automatic Layout'.  If automatic layout is enabled, the graph is
layouted after each change.


File: ddd.info,  Node: Rotating the Graph,  Prev: Automatic Layout,  Up: Layouting the Graph

7.3.6.5 Rotating the Graph
..........................

You can rotate the entire graph clockwise by 90 degrees by selecting
`Data => Rotate Graph'.  You may need to layout the graph after
rotating it; *Note Automatic Layout::, for details.


File: ddd.info,  Node: Printing the Graph,  Prev: Layouting the Graph,  Up: Displaying Values

7.3.7 Printing the Graph
------------------------

DDD allows for printing the graph picture on PostScript printers or
into files.  This is useful for documenting program states.

   To print the graph on a PostScript printer, select `File => Print
Graph'.  Enter the printing command in the `Print Command' field.
Click on the `OK' or the `Apply' button to start printing.

   As an alternative, you may also print the graph in a file.  Click on
the `File' button and enter the file name in the `File Name' field.
Click on the `Print' button to create the file.

   When the graph is printed in a file, two formats are available:

   * `PostScript'--suitable for enclosing the graph in another document;

   * `FIG'--suitable for post-processing, using the `xfig' graphic
     editor, or for conversion into other formats (among others, IBMGL,
     TeX, PIC), using the `transfig' or `fig2dev' programs.  

   Please note the following _caveats_ related to printing graphs:

   * If any displays were selected when invoking the `Print' dialog, the
     option `Selected Only' is set.  This makes DDD print only the
     selected displays.

   * The `Color', `Orientation', and `Paper Size' options are
     meaningful for PostScript only.

   These settings are tied to the following resources:

 -- Resource: printCommand (class PrintCommand)
     The command to print a PostScript file.  Usually `lp' or `lpr'.

 -- Resource: paperSize (class PaperSize)
     The paper size used for printing, in format `WIDTH x HEIGHT'.  The
     default is ISO A4 format, or `210mm x 297mm'.


File: ddd.info,  Node: Plotting Values,  Next: Examining Memory,  Prev: Displaying Values,  Up: Examining Data

7.4 Plotting Values
===================

If you have huge amounts of numerical data to examine, a picture often
says more than a thousand numbers.  Therefore, DDD allows you to draw
numerical values in nice 2-D and 3-D plots.

* Menu:

* Plotting Arrays::             Plotting 1-D and 2-D arrays.
* Plot Appearance::             Controlling the appearance.
* Scalars and Composites::      Plotting simple values.
* Plotting Histories::          Plotting the history of a variable.
* Printing Plots::              Printing on paper.
* Entering Plotting Commands::  Raw Gnuplot commands.
* Exporting Plot Data::         Processing data outside of DDD
* Animating Plots::             Visualizing dynamic behaviour.
* Customizing Plots::           All at your leisure.


File: ddd.info,  Node: Plotting Arrays,  Next: Plot Appearance,  Up: Plotting Values

7.4.1 Plotting Arrays
---------------------

Basically, DDD can plot two types of numerical values:

   * One-dimensional arrays.  These are drawn in a 2-D X/Y space, where
     X denotes the array index, and Y the element value.

   * Two-dimensional arrays.  These are drawn in a 3-D X/Y/Z space,
     where X and Y denote the array indexes, and Z the element value.

   To plot a fixed-size array, select its name by clicking _mouse
button 1_ on an occurrence.  The array name is copied to the argument
field.  By clicking the `Plot' button, a new display is created in the
data window, followed by a new top-level window containing the value
plot.

   To plot a dynamically sized array, you must use an array slice
(*note Array Slices::).  In the argument field, enter

     ARRAY[FIRST]@NELEMS

where ARRAY is the name of the array to display, FIRST is the index of
the first element, and NELEMS is the number of elements to display.
Then, click on `Plot' to start the plot.

   To plot a value, you can also enter a command at the debugger prompt:

     graph plot EXPR

works like `graph display EXPR' (and takes the same arguments; *note
Creating Single Displays::), but the value is additionally shown in the
plot window.

   Each time the value changes during program execution, the plot is
updated to reflect the current values.  The plot window remains active
until you close it (via `File => Close') or until the associated
display is deleted.


File: ddd.info,  Node: Plot Appearance,  Next: Scalars and Composites,  Prev: Plotting Arrays,  Up: Plotting Values

7.4.2 Changing the Plot Appearance
----------------------------------

The actual drawing is not done by DDD itself.  Instead, DDD relies on
an external `gnuplot' program to create the drawing.

   DDD adds a menu bar to the Gnuplot plot window that lets you
influence the appearance of the plot:

   * The `View' menu toggles optional parts of the plot, such as border
     lines or a background grid.

   * The `Plot' menu changes the "plotting style".  The `3-D Lines'
     option is useful for plotting two-dimensional arrays.

   * The `Scale' menu allows you to enable logarithmic scaling and to
     enable or disable the scale tics.

   * The `Contour' menu adds contour lines to 3-D plots.  

   In a 3-D plot, you can use the scroll bars to change your view
position.  The horizontal scroll bar rotates the plot around the Z
axis, that is, to the left and right.  The vertical scroll bar rotates
the plot around the Y axis, that is, up and down.

   You can also resize the plot window as desired.


File: ddd.info,  Node: Scalars and Composites,  Next: Plotting Histories,  Prev: Plot Appearance,  Up: Plotting Values

7.4.3 Plotting Scalars and Composites
-------------------------------------

Besides plotting arrays, DDD also allows you to plot scalars (simple
numerical values).  This works just like plotting arrays--you select
the numerical variable, click on `Plot', and here comes the plot.
However, plotting a scalar is not very exciting.  A plot that contains
nothing but a scalar simply draws the scalar's value as a Y
constant--that is, a horizontal line.

   So why care about scalars at all?  DDD allows you to combine
_multiple values into one plot._  The basic idea is: if you want to
plot something that is neither an array nor a scalar, DDD takes all
numerical sub-values it can find and plots them all together in one
window.  For instance, you can plot all local variables by selecting
`Data => Display Local Variables', followed by `Plot'.  This will
create a plot containing all numerical values as found in the current
local variables.  Likewise, you can plot all numeric members contained
in a structure by selecting it, followed by `Plot'.

   If you want more control about what to include in a plot and what
not, you can use _display clusters_ (*note Clustering::).  A common
scenario is to plot a one-dimensional array together with the current
index position.  This is done in three steps:

  1. Display the array and the index, using `Display'.

  2. Cluster both displays: select them and choose `Undisp => Cluster
     ()'.

  3. Plot the cluster by pressing `Plot'.

   Scalars that are displayed together with arrays can be displayed
either as vertical lines or horizontal lines.  By default, scalars are
plotted as horizontal lines.  However, if a scalar is a valid index for
an array that was previously plotted, it is shown as a vertical line.
You can change this initial orientation by selecting the scalar
display, followed by `Rotate'.


File: ddd.info,  Node: Plotting Histories,  Next: Printing Plots,  Prev: Scalars and Composites,  Up: Plotting Values

7.4.4 Plotting Display Histories
--------------------------------

At each program stop, DDD records the values of all displayed
variables, such that you can "undo" program execution (*note Undoing
Program Execution::).  These _display histories_ can be plotted, too.
The menu item `Plot => Plot history of ()' creates a plot that shows
all previously recorded values of the selected display.


File: ddd.info,  Node: Printing Plots,  Next: Entering Plotting Commands,  Prev: Plotting Histories,  Up: Plotting Values

7.4.5 Printing Plots
--------------------

If you want to print the plot, select `File => Print Plot'.  This pops
up the DDD printing dialog, set up for printing plots.  Just as when
printing graphs, you have the choice between printing to a printer or a
file and setting up appropriate options.

   The actual printing is also performed by Gnuplot, using the
appropriate driver.  Please note the following _caveats_ related to
printing:

   * Creating `FIG' files requires an appropriate driver built into
     Gnuplot.  Your Gnuplot program may not contain such a driver.  In
     this case, you will have to recompile Gnuplot, including the line
     `#define FIG' in the Gnuplot `term.h' file.

   * The `Portrait' option generates an EPS file useful for inclusion
     in other documents.  The `Landscape' option makes DDD print the
     plot in the size specified in the `Paper Size' option; this is
     useful for printing on a printer.  In `Portrait' mode, the `Paper
     Size' option is ignored.

   * The Gnuplot device drivers for PostScript and X11 each have their
     own set of colors, such that the printed colors may differ from the
     displayed colors.

   * The `Selected Only' option is set by default, such that only the
     currently selected plot is printed.  (If you select multiple plots
     to be printed, the respective outputs will all be concatenated,
     which may not be what you desire.)  


File: ddd.info,  Node: Entering Plotting Commands,  Next: Exporting Plot Data,  Prev: Printing Plots,  Up: Plotting Values

7.4.6 Entering Plotting Commands
--------------------------------

Via `File => Command', you can enter Gnuplot commands directly.  Each
command entered at the `gnuplot>' prompt is passed to Gnuplot, followed
by a Gnuplot `replot' command to update the view.  This is useful for
advanced Gnuplot tasks.

   Here's a simple example.  The Gnuplot command

     set xrange [XMIN:XMAX]

sets the horizontal range that will be displayed to XMIN...XMAX.  To
plot only the elements 10 to 20, enter:

     gnuplot> set xrange [10:20]
     gnuplot> _

   After each command entered, DDD adds a `replot' command, such that
the plot is updated automatically.

   Here's a more complex example.  The following sequence of Gnuplot
commands saves the plot in TeX format:

     gnuplot> set output "plot.tex" # Set the output filename
     gnuplot> set term latex        # Set the output format
     gnuplot> set term x11          # Show original picture again
     gnuplot> _

   Due to the implicit `replot' command, the output is automatically
written to `plot.tex' after the `set term latex' command.

   The dialog keeps track of the commands entered; use the arrow keys to
restore previous commands.  Gnuplot error messages (if any) are also
shown in the history area.

   The interaction between DDD and Gnuplot is logged in the file
`~/.ddd/log' (*note Logging::).  The DDD `--trace' option logs this
interaction on standard output.


File: ddd.info,  Node: Exporting Plot Data,  Next: Animating Plots,  Prev: Entering Plotting Commands,  Up: Plotting Values

7.4.7 Exporting Plot Data
-------------------------

If you want some external program to process the plot data (a
stand-alone Gnuplot program or the `xmgr' program, for instance), you
can save the plot data in a file, using `File => Save Data As'.  This
pops up a dialog that lets you choose a data file to save the plotted
data in.

   The generated file starts with a few comment lines.  The actual data
follows in X/Y or X/Y/Z format.  It is the same file as processed by
Gnuplot.


File: ddd.info,  Node: Animating Plots,  Next: Customizing Plots,  Prev: Exporting Plot Data,  Up: Plotting Values

7.4.8 Animating Plots
---------------------

If you want to see how your data evolves in time, you can set a
breakpoint whose command sequence ends in a `cont' command (*note
Breakpoint Commands::.  Each time this "continue" breakpoint is
reached, the program stops and DDD updates the displayed values,
including the plots.  Then, DDD executes the breakpoint command
sequence, resuming execution.

   This way, you can set a "continue" breakpoint at some decisive point
within an array-processing algorithm and have DDD display the progress
graphically.  When your program has stopped for good, you can use
`Undo' and `Redo' to redisplay and examine previous program states.
*Note Undoing Program Execution::, for details.


File: ddd.info,  Node: Customizing Plots,  Prev: Animating Plots,  Up: Plotting Values

7.4.9 Customizing Plots
-----------------------

You can customize the Gnuplot program to invoke, as well as a number of
basic settings.

* Menu:

* Gnuplot Invocation::
* Gnuplot Settings::


File: ddd.info,  Node: Gnuplot Invocation,  Next: Gnuplot Settings,  Up: Customizing Plots

7.4.9.1 Gnuplot Invocation
..........................

Using `Edit => Preferences => Helpers => Plot', you can choose the
Gnuplot program to invoke.  This is tied to the following resource:

 -- Resource: plotCommand (class PlotCommand)
     The name of a Gnuplot executable.  Default is `gnuplot', followed
     by some options to set up colors and the initial geometry.

   Using `Edit => Preferences => Helpers => Plot Window', you can
choose whether to use the Gnuplot plot window (`External') or to use
the plot window supplied by DDD (`builtin').  This is tied to the
following resource:

 -- Resource: plotTermType (class PlotTermType)
     The Gnuplot terminal type.  Can have one of two values:
        * If this is `x11', DDD "swallows" the _external_ Gnuplot
          output window into its own user interface.  Some window
          managers, notably `mwm', have trouble with swallowing
          techniques.

        * Setting this resource to `xlib' (default) makes DDD provide a
          _builtin plot window_ instead.  In this mode, plots work well
          with any window manager, but are less customizable (Gnuplot
          resources are not understood).

   You can further control interaction with the external plot window:

 -- Resource: plotWindowClass (class PlotWindowClass)
     The class of the Gnuplot output window.  When invoking Gnuplot,
     DDD waits for a window with this class and incorporates it into
     its own user interface (unless `plotTermType' is `xlib'; see
     above).  Default is `Gnuplot'.

 -- Resource: plotWindowDelay (class WindowDelay)
     The time (in ms) to wait for the creation of the Gnuplot window.
     Before this delay, DDD looks at each newly created window to see
     whether this is the plot window to swallow.  This is cheap, but
     unfortunately, some window managers do not pass the creation event
     to DDD.  If this delay has passed, and DDD has not found the plot
     window, DDD searches _all_ existing windows, which is pretty
     expensive.  Default time is `2000'.


File: ddd.info,  Node: Gnuplot Settings,  Prev: Gnuplot Invocation,  Up: Customizing Plots

7.4.9.2 Gnuplot Settings
........................

To change Gnuplot settings, use these resources:

 -- Resource: plotInitCommands (class PlotInitCommands)
     The initial Gnuplot commands issued by DDD.  Default is:

          set parametric
          set urange [0:1]
          set vrange [0:1]
          set trange [0:1]

     The `parametric' setting is required to make Gnuplot understand the
     data files as generated DDD.  The range commands are used to plot
     scalars.

   See the Gnuplot documentation for additional commands.

 -- Resource: plot2dSettings (class PlotSettings)
     Additional initial settings for 2-D plots.  Default is `set
     noborder'.  Feel free to customize these settings as desired.

 -- Resource: plot3dSettings (class PlotSettings)
     Additional initial settings for 3-D plots.  Default is `set
     border'.  Feel free to customize these settings as desired.



Local Variables:
coding: iso-8859-1
End:
